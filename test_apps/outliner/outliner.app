application outliner

//generic imports
imports widgets/widgets
imports widgets/tree
imports widgets/masterdetail
imports widgets/popup
imports widgets/tabcontrol
imports widgets/dnd
imports widgets/loaddojo
imports widgets/rndButton

//application specific imports
imports data/data
imports data/header
imports data/image
imports data/text
imports data/documentmanagement
imports data/json

imports toolbar

section pages

define page root() {
  var d: Document := null;
  outliner_contents(d)
}

define page outliner(doc: Document) {
  outliner_contents(doc)
}

define no-span outliner_contents(doc: Document) {
  //loadDojo(true, "1.3.2")
  loadDojo(false, "1.3.0")
  loadCSS("outliner.css")
  loadCSS("widgets.css")

  //a hook for the popup windows
  placeholder popup {}
  
  footerLayout("100px")[width:="800px"] with {
    contents() {
    
      collapseUp() {
          toolbar(doc)
      }
      main(doc)
    }
    footer() {
      block[id:= statusBar] { " Loaded." } 
      container[id:= footer] { "application generated by WebDSLx" }
    }
  }
}

define main(doc: Document) {
  if (doc == null) {
    "(No document loaded)" 
  }
  else {
    tabs[height:="400px"] {
      tab(doc.name) {
        masterdetail() with {
          masterview() {
            documentTree(doc)
          }
          detailview() {
            detailView(doc.root)
          }
        }
      }
      lazytab("Print preview") with { contents(){
        printpreview(doc)
      } }
/*      lazytab("JSON tree") {
        documentoutlinehelper(doc)
      } 
*/    }
  }
} 

define template documentTree(doc: Document) {
  Tree(navigate(documentoutline(doc)), doc.root.id.toString())
    [onselect:=selectHeader(null)]
  
  action selectHeader(id: String) {
    var n: HeaderNode := loadHeaderNode(UUIDFromString(id));
    replace(detailView, detailView(n));
  }
}

//dispatch to  proper view
define detailView(item: HeaderNode) {
  dndOnce()
  showPath(item)
  
  spacer
  nodeView(item)
}

define no-span nodeView(item: TreeItem) {
  block[class:=[scopediv, nodeView]] {
         if (item isa HeaderNode) { viewHeader(item as HeaderNode) }
  else { if (item isa TextNode)   { viewText  (item as TextNode) }
  else { if (item isa ImageNode)  { viewImage (item as ImageNode) }
  else { "Error: unsupported node type" }  }  }
  }
}

define showPath(item: HeaderNode) {
  var path: List<HeaderNode> := List<HeaderNode>();
  init {
    var cur: HeaderNode := item;
    while(cur != null) {
      path.add(cur);
      cur := cur.parent as HeaderNode;
    }
  }
  
  for(i: Int from path.length -1 to 0) {
    image("/images/right.png")
    navigate[
      onclick:= loadView(path.get(i))
    ]{ output(path.get(i).caption) }
    
  } 
  image("/images/arrow-right.png")
  output(item.caption)
  
  action loadView(item: HeaderNode) {
    replace (detailView, detailView(item));
  }
}

//not the least trivial solution, but it demonstrates the power of with/require
define printpreview(doc: Document) {
  <b> output(doc.name) </b>
  break
  output(doc.description)
  spacer
  customTree(doc.root) with { 
    treeView(item: TreeItem) {
      if (item isa HeaderNode) {
        <b>
          output((item as HeaderNode).caption)
        </b>
      }
      if (item isa TextNode) {
        output((item as TextNode).contents)
      }
      if (item isa ImageNode) {
        output((item as ImageNode).image)
      }
    }
  }
}

define customTree(item: TreeItem) requires treeView(TreeItem){
  container /*[ an onclick action could be defined here ]*/ {
  /* here could be some +/- sign responsible for collapsing */
    treeView(item)
  }
  break
  container[style:="padding-left: 16px"] {
    for(child: TreeItem in item.children) {
      customTree(child) 
    }
  }
}