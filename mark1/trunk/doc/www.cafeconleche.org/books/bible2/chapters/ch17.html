<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
   <head xmlns:html="http://www.w3.org/1999/xhtml">
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   
      <title>
         XSL Transformations
         
      </title>
   </head>
   <body xmlns:html="http://www.w3.org/1999/xhtml" bgcolor="#FFFFFF" text="#000000">
      <h1>Chapter 
         17
         
         of the <cite>
            XML Bible, Second Edition
            </cite>: 
         
         XSL Transformations
         
      </h1>
      <h2>In This Chapter</h2>
      <ul>
         <li><a href="#d1e495">What Is XSL?</a></li>
         <li><a href="#d1e531">Overview of XSL Transformations</a></li>
         <li><a href="#d1e1349">XSL Templates</a></li>
         <li><a href="#d1e1685">Computing the Value of a Node with xsl:value-of</a></li>
         <li><a href="#d1e2003">Processing Multiple Elements with xsl:for-each</a></li>
         <li><a href="#d1e2090">Patterns for Matching Nodes</a></li>
         <li><a href="#d1e3567">XPath Expressions for Selecting Nodes</a></li>
         <li><a href="#d1e6203">The Default Template Rules</a></li>
         <li><a href="#d1e6328">Deciding What Output to Include</a></li>
         <li><a href="#d1e7170">Copying the Context Node with xsl:copy</a></li>
         <li><a href="#d1e7364">Counting Nodes with xsl:number</a></li>
         <li><a href="#d1e8030">Sorting Output Elements</a></li>
         <li><a href="#d1e8275">Modes</a></li>
         <li><a href="#d1e8497">Defining Constants with xsl:variable</a></li>
         <li><a href="#d1e8598">Named Templates</a></li>
         <li><a href="#d1e8730">Passing Parameters to Templates</a></li>
         <li><a href="#d1e8886">Stripping and Preserving White Space</a></li>
         <li><a href="#d1e9006">Making Choices</a></li>
         <li><a href="#d1e9189">Merging Multiple Style Sheets</a></li>
         <li><a href="#d1e9432">Output Methods</a></li>
      </ul>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <p class="GX">The Extensible Stylesheet Language (XSL) includes both a transformation language and a formatting language. Each of these,
         naturally enough, is an XML application. The transformation language provides elements that define rules for how one XML document
         is transformed into another XML document. The transformed XML document may use the markup and DTD of the original document,
         or it may use a completely different set of elements. In particular, it may use the elements defined by the second part of
         XSL, the formatting objects. This chapter discusses the transformation language half of XSL.
      </p>
      
      <h2><a name="d1e495">What Is XSL?</a></h2>
      
      <p class="GX">The transformation and formatting halves of XSL can function independently of each other. For instance, the transformation
         language can transform an XML document into a well-formed HTML file, and completely ignore XSL formatting objects. This is
         the style of XSL previewed in Chapter 5 and emphasized in this chapter. Furthermore, it's not absolutely required that a document
         written in XSL formatting objects be produced by using the transformation part of XSL on another XML document. For example,
         it's easy to imagine a converter written in Java that reads TeX or PDF files and translates them into XSL formatting objects
         (though no such converters exist as of early 2001).
      </p>
      
      <p class="GX">In essence, XSL is two languages, not one. The first language is a transformation language, the second a formatting language.
         The transformation language is useful independent of the formatting language. Its ability to move data from one XML representation
         to another makes it an important component of XML-based electronic commerce, electronic data interchange, metadata exchange,
         and any application that needs to convert between different XML representations of the same data. These uses are also united
         by their lack of concern with rendering data on a display for humans to read. They are purely about moving data from one computer
         system or program to another.
      </p>
      
      <p class="GX">Consequently, many early implementations of XSL focus exclusively on the transformation part and ignore the formatting objects.
         These are incomplete implementations, but nonetheless useful. Not all data must ultimately be rendered on a computer monitor
         or printed on paper.
      </p>
      
      <p class="SBT" style="font-weight: bold; margin-left: 0.5in; margin-right: 0.5in;        font-family: Arial, Helvetica, sans; color: #0000ff">Cross-Reference</p>
      
      <p class="SBT" style="font-family: Arial, Helvetica, sans;        margin-left: 0.5in; margin-right: 0.5in">Chapter 18<span class="italic"> </span>discusses the XSL formatting language.
      </p>
      
      <p class="SBT" style="font-weight: bold; text-align: center;         font-family: Arial, Helvetica, sans">A Word of Caution about XSL</p>
      
      <p class="SBT" style="font-family: Arial, Helvetica, sans;        margin-left: 0.5in; margin-right: 0.5in">XSL is still under development. The language has changed radically in the past, and will almost certainly change again in
         the future. This chapter is based on the November 16, 1999 XSLT 1.0 Recommendation. Because XSLT is now an official Recommendation
         of the World Wide Web Consortium (W3C), I'm hopeful that any changes that do occur will simply add to the existing syntax
         without invalidating style sheets that adhere to the 1.0 spec. Indeed the W3C has just begun work on XSLT 1.1 and 2.0, and
         it does seem likely that all legal XSLT 1.0 documents will still be legal XSLT 1.1 and 2.0 documents.
      </p>
      
      <p class="SBT" style="font-family: Arial, Helvetica, sans;        margin-left: 0.5in; margin-right: 0.5in">Not all software has caught up to the 1.0 Recommendation, however. In particular, Version 5.5 and earlier of Internet Explorer
         only implement a very old working draft of XSLT that looks almost nothing like the finished standard. You should not expect
         most of the examples in this chapter to work with IE, even after substantial tweaking. Conversely, the language that IE does
         implement is not XSLT; and any book or person that tells you otherwise is telling you an untruth. Both Microsoft's live presentations
         and the written documentation it posts on its Web site are notorious for teaching nonstandard Microsoft versions of XSLT (and
         other languages) without clearly distinguishing which parts are real XSLT and which are Microsoft extensions to (some would
         say perversions of) standard XSLT.
      </p>
      
      <p class="SBT" style="font-family: Arial, Helvetica, sans;        margin-left: 0.5in; margin-right: 0.5in">In November 2000 Microsoft released MSXML 3.0, an XML parser/XSLT processor for IE that does come much closer to supporting
         XSLT 1.0. You can download it from <code>http://msdn.microsoft.com/xml/general/xmlparser.asp</code>. However, there are still some bugs and areas where Microsoft did not follow the specification, so this is not quite a complete
         implementation of XSLT 1.0. More importantly, MSXML 3.0 is not bundled with IE5.5; and even if you install it, it does not
         automatically replace the earlier, non-standard-compliant version of MSXML that is bundled. To replace the old version, you
         have to download and run a separate program called xmlinst.exe, which you can get from the same page where you found MSXML
         3.0.
      </p>
      
      <h2><a name="d1e531">Overview of XSL Transformations</a></h2>
      
      <p class="GX">In an XSL transformation, an XSLT processor reads both an XML document and an XSLT style sheet. Based on the instructions
         the processor finds in the XSLT style sheet, it outputs a new XML document or fragment thereof. There's also special support
         for outputting HTML. With some effort most XSLT processors can also be made to output essentially arbitrary text, though XSLT
         is designed primarily for XML-to-XML and XML-to-HTML transformations.
      </p>
      
      <h3>Trees</h3>
      
      <p class="GX">As you learned in Chapter 6, every well-formed XML document is a tree. A tree is a data structure composed of connected nodes
         beginning with a top node called the root. The root is connected to its child nodes, each of which is connected to zero or
         more children of its own, and so forth. Nodes that have no children of their own are called <span class="italic">leaves</span>. A diagram of a tree looks much like a genealogical descendant chart that lists the descendants of a single ancestor. The
         most useful property of a tree is that each node and its children also form a tree. Thus, a tree is a hierarchical structure
         of trees in which each tree is built out of smaller trees.
      </p>
      
      <p class="GX">For the purposes of XSLT, elements, attributes, namespaces, processing instructions, and comments are counted as nodes. Furthermore,
         the root of the document must be distinguished from the root element. Thus, XSLT processors model an XML document as a tree
         that contains seven kinds of nodes:
      </p>
      
      <ul>
         <li>The root</li>
         <li>Elements</li>
         <li>Text</li>
         <li>Attributes</li>
         <li>Namespaces</li>
         <li>Processing instructions</li>
         <li>Comments</li>
      </ul>
      
      
      
      
      
      
      
      <p class="GX">The Document Type Definition (DTD) and document type declaration are specifically not included in this tree. However, a DTD
         may add default attribute values to some elements, which then become additional attribute nodes in the tree.
      </p>
      
      <p class="GX">For example, consider the XML document in Listing 17-1. This shows part of the periodic table of the elements. I&#8217;ll be using
         this as an example in this chapter.
      </p>
      
      <p class="SBT" style="font-weight: bold; margin-left: 0.5in; margin-right: 0.5in;        font-family: Arial, Helvetica, sans; color: #0000ff">On the CD-ROM</p>
      
      <p class="SBT" style="font-family: Arial, Helvetica, sans;        margin-left: 0.5in; margin-right: 0.5in">The complete periodic table appears on the CD-ROM in the file allelements.xml in the examples/periodic_table directory.</p>
      
      <p class="GX">The root <code>PERIODIC_TABLE</code> element contains <code>ATOM</code> child elements. Each <code>ATOM</code> element contains several child elements providing the atomic number, atomic weight, symbol, boiling point, and so forth.
         A <code>UNITS</code> attribute specifies the units for those elements that have units.
      </p>
      
      <p class="SBT" style="font-weight: bold; margin-left: 0.5in; margin-right: 0.5in;        font-family: Arial, Helvetica, sans; color: #0000ff">Note</p>
      
      <p class="SBT" style="font-family: Arial, Helvetica, sans;        margin-left: 0.5in; margin-right: 0.5in"><code>ELEMENT</code> would be a more appropriate name here than <code>ATOM</code>. However, writing about <code>ELEMENT</code> elements and trying to distinguish between chemical elements and XML elements might create confusion. Thus, at least for
         the purposes of this chapter, <code>ATOM</code> seemed like the more legible option.
      </p>
      
      <p style="font-weight: bold">Listing 17-1: 
         An XML periodic table with two atoms: hydrogen and helium
      </p>
      
      <pre><code>&lt;?xml version="1.0"?&gt;
&lt;?xml-stylesheet type="text/xml" href="17-2.xsl"?&gt;
&lt;PERIODIC_TABLE&gt;
  &lt;ATOM STATE="GAS"&gt;
    &lt;NAME&gt;Hydrogen&lt;/NAME&gt;
    &lt;SYMBOL&gt;H&lt;/SYMBOL&gt;
    &lt;ATOMIC_NUMBER&gt;1&lt;/ATOMIC_NUMBER&gt;
    &lt;ATOMIC_WEIGHT&gt;1.00794&lt;/ATOMIC_WEIGHT&gt;
    &lt;BOILING_POINT UNITS="Kelvin"&gt;20.28&lt;/BOILING_POINT&gt;
    &lt;MELTING_POINT UNITS="Kelvin"&gt;13.81&lt;/MELTING_POINT&gt;
    &lt;DENSITY UNITS="grams/cubic centimeter"&gt;
      &lt;!-- At 300K, 1 atm --&gt;
      0.0000899
    &lt;/DENSITY&gt;
  &lt;/ATOM&gt;
  &lt;ATOM STATE="GAS"&gt;
    &lt;NAME&gt;Helium&lt;/NAME&gt;
    &lt;SYMBOL&gt;He&lt;/SYMBOL&gt;
    &lt;ATOMIC_NUMBER&gt;2&lt;/ATOMIC_NUMBER&gt;
    &lt;ATOMIC_WEIGHT&gt;4.0026&lt;/ATOMIC_WEIGHT&gt;
    &lt;BOILING_POINT UNITS="Kelvin"&gt;4.216&lt;/BOILING_POINT&gt;
    &lt;MELTING_POINT UNITS="Kelvin"&gt;0.95&lt;/MELTING_POINT&gt;
    &lt;DENSITY UNITS="grams/cubic centimeter"&gt;&lt;!-- At 300K --&gt;
      0.0001785
    &lt;/DENSITY&gt;
  &lt;/ATOM&gt;
&lt;/PERIODIC_TABLE&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <p class="GX">Figure 17-1 displays a tree diagram of this document. It begins at the top with the root node (not the same as the root element!)
         which contains two child nodes, the <code>xml-stylesheet</code> processing instruction and the root element <code>PERIODIC_TABLE</code>. (The XML declaration is not visible to the XSLT processor and is not included in the tree the XSLT processor operates on.)
         The <code>PERIODIC_TABLE</code> element contains two child nodes, both <code>ATOM</code> elements. Each <code>ATOM</code> element has an attribute node for its <code>STATE</code> attribute, and a variety of child element nodes. Each child element contains a node for its contents, as well as nodes for
         any attributes, comments and processing instructions it possesses. Notice in particular that many nodes are something other
         than elements. There are nodes for text, attributes, comments, namespaces and processing instructions. Unlike CSS, XSL is
         not limited to working only with whole elements. It has a much more granular view of a document that enables you to base styles
         on comments, attributes, processing instructions, element content, and more.
      </p>
      
      <p class="SBT" style="font-weight: bold; margin-left: 0.5in; margin-right: 0.5in;        font-family: Arial, Helvetica, sans; color: #0000ff">Note</p>
      
      <p class="SBT" style="font-family: Arial, Helvetica, sans;        margin-left: 0.5in; margin-right: 0.5in">Like the XML declaration, an internal DTD subset or DOCTYPE declaration is not part of the tree. However, it may have the
         effect of adding attribute nodes to some elements through <code>&lt;!ATTLIST&gt;</code> declarations that use <code>#FIXED</code> or default attribute values.
      </p>
      
      <div align="center"><img src="17/picture1.jpg" width="299" height="118" alt="Image: 17/picture1.jpg"></div>
      
      
      
      <p style="font-weight: bold">Figure 17-1: 
         Listing 17-1 as a tree diagram
      </p>
      
      
      <p class="GX">XSLT operates by transforming one XML tree into another XML tree. More precisely, an XSLT processor accepts as input a tree
         represented as an XML document and produces as output a new tree, also represented as an XML document. Consequently, the transformation
         part of XSL is also called the tree construction part. The XSL transformation language contains operators for selecting nodes
         from the tree, reordering the nodes, and outputting nodes. If one of these nodes is an element node, then it may be an entire
         tree itself. Remember that all these operators, both for input and output, are designed for operation on a tree.
      </p>
      
      <p class="GX">The input must be an XML document. You cannot use XSLT to transform from non-XML formats such as PDF, TeX, Microsoft Word,
         PostScript, MIDI, or others. HTML and SGML are borderline cases because they're so close to XML. XSLT can work with HTML and
         SGML documents that satisfy XML's well-formedness rules. However, XSLT cannot handle the wide variety of non-well-formed HTML
         and SGML that you encounter on most Web sites and document production systems. XSLT is not a general-purpose regular expression
         language for transforming arbitrary data.
      </p>
      
      <p class="GX">Most of the time the output of an XSLT transformation is also an XML document. However, it can also be a result tree fragment
         that could be used as an external parsed entity in another XML document. (That is, it would be a well-formed XML document
         if it were enclosed in a single root element.) In other words, the output may not necessarily be a well-formed XML document,
         but it will at least be a plausible part of a well-formed XML document. An XSLT transformation cannot output text that is
         malformed XML such as
      </p>
      <pre><code>&lt;B&gt;&lt;I&gt;Tag Mismatch!&lt;/B&gt;&lt;/I&gt;
</code></pre>
      <p class="SBT" style="font-weight: bold; margin-left: 0.5in; margin-right: 0.5in;        font-family: Arial, Helvetica, sans; color: #0000ff">Tip</p>
      
      <p class="SBT" style="font-family: Arial, Helvetica, sans;        margin-left: 0.5in; margin-right: 0.5in">The <code>xsl:output</code> element and <code>disable-output-escaping</code> attribute discussed below loosen this restriction somewhat.
      </p>
      
      <p class="GX">Most XSLT processors also support output as HTML and/or raw text, although the standard does not require them to do so. To
         some extent this allows you to transform to non-XML formats like TeX, RTF, or PostScript. However XSLT is not designed to
         make these transformations easy. It is designed for XML-to-XML transformations. If you need a non-XML output format, it will
         probably be easier to use XSLT to transform the XML to an intermediate format like TeXML (<code>http://www.alphaworks.ibm.com/tech/texml</code>), and then use additional, non-XSLT software to transform that into the format you want.
      </p>
      
      <h3>XSLT style sheet documents</h3>
      
      <p class="GX">An XSLT document contains template rules. A template rule has a pattern specifying the nodes it matches and a template to
         be instantiated and output when the pattern is matched. When an XSLT processor transforms an XML document using an XSL style
         sheet, it walks the XML document tree, looking at each node in turn. As each node in the XML document is read, the processor
         compares it with the pattern of each template rule in the style sheet. When the processor finds a node that matches a template
         rule's pattern, it outputs the rule's template. This template generally includes some markup, some new data, and some data
         copied out of the source XML document.
      </p>
      
      <p class="GX">XSLT uses XML to describe these rules, templates, and patterns. The root element of the XSLT document is either a <code>stylesheet</code> or a <code>transform</code> element in the <code>http://www.w3.org/1999/XSL/Transform</code> namespace. By convention this namespace is mapped to the <code>xsl</code> prefix, but you're free to pick another prefix if you prefer. In this chapter, I always use the <code>xsl</code> prefix. From this point forward it should be understood that the prefix <code>xsl</code> is mapped to the <code>http://www.w3.org/1999/XSL/Transform</code> namespace.
      </p>
      
      <p class="SBT" style="font-weight: bold; margin-left: 0.5in; margin-right: 0.5in;        font-family: Arial, Helvetica, sans; color: #0000ff">Tip</p>
      
      <p class="SBT" style="font-family: Arial, Helvetica, sans;        margin-left: 0.5in; margin-right: 0.5in">If you get the namespace URI wrong, either by using a URI from an older draft of the specification, such as <code>http://www.w3.org/TR/WD-xsl</code>, or simply by making a typo in the normal URI, the XSLT processor will output the style sheet document itself instead of
         the transformed input document. This is the result of the interaction between several obscure sections of the XSLT 1.0 specification.
         The details aren&#8217;t important. What is important is that this very unusual behavior looks very much like a bug in the processor
         if you aren&#8217;t familiar with it. If you are familiar with it, fixing it is trivial; just correct the namespace URI to <code>http://www.w3.org/1999/XSL/Transform</code>.
      </p>
      
      <p class="GX">Each template rule is an <code>xsl:template</code> element. The pattern of the rule is placed in the <code>match</code> attribute of the <code>xsl:template</code> element. The output template is the content of the <code>xsl:template</code> element. All instructions in the template for doing things such as selecting parts of the input tree to include in the output
         tree are performed by one or another XSLT elements. These are identified by the <code>xsl:</code> prefix on the element names. Elements that do not have an <code>xsl:</code> prefix are part of the result tree.
      </p>
      
      <p class="GX">Listing 17-2 shows a very simple XSLT style sheet with two template rules. The first template rule matches the root element
         <code>PERIODIC_TABLE</code>. It replaces this element with an <code>html</code> element. The contents of the <code>html</code> element are the results of applying the other templates in the document to the contents of the <code>PERIODIC_TABLE</code> element.
      </p>
      
      <p class="GX">The second template matches <code>ATOM</code> elements. It replaces each <code>ATOM</code> element in the input document with a <code>P</code> element in the output document. The <code>xsl:apply-templates</code> rule inserts the text of the matched source element into the output document. Thus, the contents of a <code>P</code> element will be the text (but not the markup) contained in the corresponding <code>ATOM</code> element.
      </p>
      
      <p class="GX">The <code>xsl:stylesheet</code> root element has two required attributes, <code>version</code> and <code>xmlns:xsl</code>, each of which must have exactly the values shown here (<code>1.0</code> for <code>version</code> and <code>http://www.w3.org/1999/XSL/Transform</code> for <code>xmlns:xsl</code>). I'll discuss the exact syntax of all these elements and attributes below.
      </p>
      
      <p style="font-weight: bold">Listing 17-2: 
         An XSLT style sheet for the periodic table with two template rules
      </p>
      
      <pre><code>&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" 
          xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:template match="PERIODIC_TABLE"&gt;
    &lt;html&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/html&gt;
  &lt;/xsl:template&gt;
  &lt;xsl:template match="ATOM"&gt;
    &lt;P&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/P&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      
      
      <p class="GX">The <code>xsl:transform</code> element can be used in place of <code>xsl:stylesheet</code> if you prefer. This is an exact synonym with the same syntax, semantics, and attributes. For example,
      </p>
      <pre><code>&lt;?xml version="1.0"?&gt;
&lt;xsl:transform version="1.0" 
         xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;!-- templates go here --&gt;
&lt;/xsl:transform&gt;
</code></pre>
      
      
      
      
      <p class="GX">In this book, I will stick to <code>xsl:stylesheet</code>.
      </p>
      
      <h3>Where does the XML transformation happen?</h3>
      
      <p class="GX">There are three primary ways to transform XML documents into other formats, such as HTML, with an XSLT style sheet:</p>
      
      <ul>
         <li>&nbsp;1.&nbsp;The XML document and associated style sheet are both served to the client (Web browser), which then transforms the document
            as specified by the style sheet and presents it to the user.
         </li>
         <li>&nbsp;2.&nbsp;The server applies an XSLT style sheet to an XML document to transform it to some other format (generally HTML) and sends
            the transformed document to the client (Web browser).
         </li>
         <li>&nbsp;3.&nbsp;A third program transforms the original XML document into some other format (often HTML) before the document is placed
            on the server. Both server and client only deal with the transformed document.
         </li>
      </ul>
      
      
      
      <p class="GX">Each of these three approaches uses different software, although they all use the same XML documents and XSLT style sheets.
         An ordinary Web server sending XML documents to Internet Explorer is an example of the first approach. A servlet-compatible
         Web server using the IBM alphaWorks' XML Enabler (<code>http://www.alphaworks.ibm.com/tech/xmlenabler</code>) is an example of the second approach. A human using Michael Kay's command line SAXON program (<code>http://users.iclway.co.uk/mhkay/saxon/</code>) to transform XML documents to HTML documents, then placing the HTML documents on a Web server is an example of the third
         approach. However, these all use (at least in theory) the same XSLT language.
      </p>
      
      <p class="GX">In this chapter, I emphasize the third approach, primarily because at the time of this writing, specialized converter programs
         such as Michael Kay's SAXON and the XML Apache Project's Xalan (<code>http://xml.apache.org/xalan/</code>) provide the most complete and accurate implementations of the XSLT specification. Furthermore, this approach offers the
         broadest compatibility with legacy Web browsers and servers, whereas the first approach requires a more recent browser than
         most users use, and the second approach requires special Web server software. In practice, though, requiring a different server
         is not nearly as onerous as requiring a particular client. You, yourself, can install your own special server software; but
         you cannot rely on your visitors to install particular client software.
      </p>
      
      <p class="SBT" style="font-weight: bold; margin-left: 0.5in; margin-right: 0.5in;        font-family: Arial, Helvetica, sans; color: #0000ff">On the CD-ROM</p>
      
      <p class="SBT" style="font-family: Arial, Helvetica, sans;        margin-left: 0.5in; margin-right: 0.5in">Xalan is on the CD-ROM in the directory utilities/xalan. SAXON is on the CD-ROM in the directory utilities/saxon.</p>
      
      <h3>How to use Xalan</h3>
      
      <p class="GX">Xalan is a Java 1.1 character mode application. To use it, you'll need a Java 1.1-compatible virtual machine such as Sun's
         Java Development Kit (JDK), or Java Runtime Environment (JRE), Apple's Macintosh Runtime for Java 2.2 (MRJ), or Microsoft's
         virtual machine. You'll need to set your <code>CLASSPATH</code> environment variable to include both the xalan.jar and xerces.jar files (both included in the Xalan distribution). On Unix/Linux
         you can set this in your .cshrc file if you use csh or tcsh or in your .profile file if you use sh, ksh or bash. On Windows
         95/98 you can set it in AUTOEXEC.BAT. In Windows NT/2000, set it with the System Control Panel Environment tab.
      </p>
      
      <p class="SBT" style="font-weight: bold; margin-left: 0.5in; margin-right: 0.5in;        font-family: Arial, Helvetica, sans; color: #0000ff">Tip</p>
      
      <p class="SBT" style="font-family: Arial, Helvetica, sans;        margin-left: 0.5in; margin-right: 0.5in">If you're using the JRE 1.2 or later, you can just put the xalan.jar and xerces.jar files in your jre/lib/ext directory instead
         of mucking around with the <code>CLASSPATH</code> environment variable. If you've installed the JDK instead of the JRE on Windows, you may have two jre/lib/ext directories,
         one somewhere like C:\jdk1.3\jre\lib\ext and the other somewhere like C:\Program Files\Javasoft\jre\1.3\lib\ext. You need
         to copy the jar archive into both ext directories. Putting one copy in one directory and an alias into the other directory
         does not work. You must place complete, actual copies into each ext directory.
      </p>
      
      <p class="SBT" style="font-weight: bold; margin-left: 0.5in; margin-right: 0.5in;        font-family: Arial, Helvetica, sans; color: #0000ff">Note</p>
      
      <p class="SBT" style="font-family: Arial, Helvetica, sans;        margin-left: 0.5in; margin-right: 0.5in">Although I primarily use Xalan in this chapter, the examples should work with SAXON or any other XSLT processor that implements
         the November 16, 1999 XSLT 1.0 recommendation.
      </p>
      
      <p class="GX">The Java class containing the main method for Xalan is <code>org.apache.xalan.xslt.Process</code>. You can run Xalan by typing the following at the shell prompt or in a DOS window:
      </p>
      <pre><code>C:\&gt; java org.apache.xalan.xslt.Process -in 17-1.xml -xsl 17-2.xsl -out 17-3.html
</code></pre>
      <p class="GX">This line runs the <code>java</code> interpreter on the Java class containing the Xalan program's <code>main()</code> method, <code>org.apache.xalan.xslt.Process</code>. The source XML document following the -in flag is 17-1.xml. The XSLT style sheet follows the -xsl flag and is 17-2.xsl here;
         and the output HTML file follows the -out argument and is named 17-3.html. If the -out argument is omitted, the transformed
         document will be printed on the console. If the -xsl argument is omitted, Xalan will attempt to use the style sheet named
         by the <code>xml-stylesheet</code> processing instruction in the prolog of the input XML document.
      </p>
      
      <p class="GX">Listing 17-2 transforms input documents to well-formed HTML files as discussed in Chapter 6. However, you can transform from
         any XML application to any other as long as you can write a style sheet to support the transformation. For example, you can
         imagine a style sheet that transforms from Vector Markup Language (VML) documents to Scalable Vector Graphics (SVG) documents:
      </p>
      <pre><code>% java org.apache.xalan.xslt.Process -in pinktriangle.vml
  -xsl VmlToSVG.xsl -out pinktriangle.svg
</code></pre>
      
      <p class="GX">Most other command line XSLT processors behave similarly, though of course they'll have different command line arguments and
         options. They may prove slightly easier to use if they're not written in Java since there won't be any need to configure the
         <code>CLASSPATH</code>.
      </p>
      
      <p class="SBT" style="font-weight: bold; margin-left: 0.5in; margin-right: 0.5in;        font-family: Arial, Helvetica, sans; color: #0000ff">Tip</p>
      
      <p class="SBT" style="font-family: Arial, Helvetica, sans;        margin-left: 0.5in; margin-right: 0.5in">If you're using Windows, you can use a stand-alone executable version of SAXON called Instant SAXON (<code>http://users.iclway.co.uk/mhkay/saxon/instant.html</code>) instead. This is a little easier to use because it doesn't require you to mess around with <code>CLASSPATH</code> environment variables. To transform a document with this program, simply place the saxon.exe file in your path and type:
      </p>
      
      <p class="icon-code">C:\&gt; saxon -o 17-3.html 17-1.xml 17-2.xsl</p>
      
      <p class="GX">Listing 17-3 shows the output of running Listing 17-1 through Xalan with the XSLT style sheet in Listing 17-2. Notice that
         Xalan does not attempt to clean up the HTML it generates, which has a lot of white space. This is not important since ultimately
         you want to view the file in a Web browser that trims white space. Figure 17-2 shows Listing 17-3 loaded into Netscape Navigator
         4.6. Because Listing 17-3 is standard HTML, you don't need an XML-capable browser to view it.
      </p>
      
      <p style="font-weight: bold">Listing 17-3: 
         The HTML produced by applying the style sheet in Listing 17-2 to the XML in Listing 17-1
      </p>
      
      <pre><code>&lt;html&gt;
  &lt;P&gt;
    Hydrogen
    H
    1
    1.00794
    20.28
    13.81
      0.0000899
  &lt;/P&gt;
  &lt;P&gt;
    Helium
    He
    2
    4.0026
    4.216
    0.95
      0.0001785
  &lt;/P&gt;
&lt;/html&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <div align="center"><img src="17/picture3.jpg" width="335" height="173" alt="Image: 17/picture3.jpg"></div>
      
      
      <p style="font-weight: bold">Figure 17-2: 
         The page produced by applying the style sheet in Listing 17-2 to the XML document in Listing 17-1.
      </p>
      
      
      <h3>Direct display of XML files with XSLT style sheets</h3>
      
      <p class="GX">Instead of preprocessing the XML file, you can send the client both the XML file and the XSLT file that describes how to render
         it. The client is responsible for applying the style sheet to the document and rendering it accordingly. This is more work
         for the client, but places much less load on the server. In this case, the XSLT style sheet must transform the document into
         an XML application the client understands. HTML is a likely choice, though in the future some browsers may understand XSL
         formatting objects as well.
      </p>
      
      <p class="GX">Attaching an XSLT style sheet to an XML document is easy. Simply insert an <code>xml-stylesheet</code> processing instruction in the prolog immediately after the XML declaration. This processing instruction should have a <code>type</code> attribute with the value <code>text/xml</code> and an <code>href</code> attribute whose value is a URL pointing to the style sheet. For example:
      </p>
      <pre><code>&lt;?xml version="1.0"?&gt;
&lt;?xml-stylesheet type="text/xml" href="17-2.xsl"?&gt;
</code></pre>
      
      <p class="GX">This is also how you attach a CSS style sheet to a document. The only difference here is that the <code>type</code> attribute has the value <code>text/xml</code> instead of <code>text/css</code>.
      </p>
      
      <p class="SBT" style="font-weight: bold; margin-left: 0.5in; margin-right: 0.5in;        font-family: Arial, Helvetica, sans; color: #0000ff">Note</p>
      
      <p class="SBT" style="font-family: Arial, Helvetica, sans;        margin-left: 0.5in; margin-right: 0.5in">In the future the more specific MIME media type <code>application/xslt+xml</code> will be available to distinguish XSLT documents from all other XML documents. Once XSLT processors are revised to support
         this, you will be able to write the <code>xml-stylesheet</code> processing instruction like this instead:
      </p>
      
      <p class="icon-code">&lt;?xml-stylesheet type="application/xslt+xml" href="17-2.xsl"?&gt;</p>
      
      <p class="GX">Internet Explorer 5.0 and 5.5's XSLT support differs from the November 16, 1999 recommendation in several ways. First, it
         expects that XSLT elements live in the <code>http://www.w3.org/TR/WD-xsl</code> namespace instead of the <code>http://www.w3.org/1999/XSL/Transform</code> namespace, although the <code>xsl</code> prefix is still used. Second, it expects the non-standard MIME type <code>text/xsl</code> in the <code>xml-stylesheet</code> processing instruction rather than <code>text/xml</code>. Finally, it does not implement the default rules for elements that match no template. Consequently, you need to provide
         a template for each element in the hierarchy starting from the root before trying to view a document in Internet Explorer.
         Listing 17-4 demonstrates. The three rules match the root node, the root element <code>PERIODIC_TABLE</code>, and the <code>ATOM</code> elements in that order. Figure 17-3 shows the XML document in Listing 17-1 loaded into Internet Explorer 5.5 with this style
         sheet.
      </p>
      
      <p style="font-weight: bold">Listing 17-4: 
         The style sheet of Listing 17-2 adjusted to work with Internet Explorer 5.0 and 5.5
      </p>
      
      <pre><code>&lt;?xml version="1.0"?&gt;
&lt;!-- This is a non-standard style sheet designed just for
     Internet Explorer. It will not work with any standards
     compliant XSLT processor. --&gt;
&lt;xsl:stylesheet version="1.0" 
  xmlns:xsl="http://www.w3.org/TR/WD-xsl"&gt;
  &lt;xsl:template match="/"&gt;
    &lt;html&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/html&gt;
  &lt;/xsl:template&gt;
  &lt;xsl:template match="PERIODIC_TABLE"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:template&gt;
  &lt;xsl:template match="ATOM"&gt;
    &lt;P&gt;
      &lt;xsl:value-of select="."/&gt;
    &lt;/P&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <p class="SBT" style="font-weight: bold; margin-left: 0.5in; margin-right: 0.5in;        font-family: Arial, Helvetica, sans; color: #0000ff">Caution</p>
      
      <p class="SBT" style="font-family: Arial, Helvetica, sans;        margin-left: 0.5in; margin-right: 0.5in">Ideally, you would use the same XML document both for direct display and for prerendering to HTML. Unfortunately, that would
         require Microsoft to actually support the real XSLT specification. Microsoft has repeatedly promised to support this, and
         they have just as repeatedly reneged on those promises.
      </p>
      
      <div align="center"><img src="17/picture5.jpg" width="335" height="178" alt="Image: 17/picture5.jpg"></div>
      
      
      <p style="font-weight: bold">Figure 17-3: 
         The page produced in Internet Explorer 5.5 by applying the style sheet in Listing 17-4 to the XML document in Listing 17-1.
      </p>
      
      
      <p class="GX">Internet Explorer also fails to support many other parts of standard XSLT, while offering a number of nonstandard extensions.
         If you've successfully installed MSXML3 in replace mode, then IE5 can handle most of XSLT 1.0 including the <code>http://www.w3.org/1999/XSL/Transform</code> namespace. However, even this version still has a few bugs, including expecting the text/xsl MIME type instead of text/xml.
         In the rest of this chapter, I use only standard XSLT and simply prerender the file in HTML before loading it into a Web browser.
         If you find something in this chapter doesn&#8217;t work in Internet Explorer, please complain to Microsoft, not to me.
      </p>
      
      <h2><a name="d1e1349">XSL Templates</a></h2>
      
      <p class="GX">Template rules defined by <code>xsl:template</code> elements are the most important part of an XSLT style sheet. These associate particular output with particular input. Each
         <code>xsl:template</code> element has a <code>match</code> attribute that specifies which nodes of the input document the template is instantiated for.
      </p>
      
      <p class="GX">The content of the <code>xsl:template</code> element is the actual template to be instantiated. A template may contain both text that will appear literally in the output
         document and XSLT instructions that copy data from the input XML document to the result. Because all XSLT instructions are
         in the <code>http://www.w3.org/1999/XSL/Transform</code> namespace, it's easy to distinguish between the elements that are literal data to be copied to the output and instructions.
         For example, here is a template that is applied to the root node of the input tree:
      </p>
      <pre><code>&lt;xsl:template match="/"&gt;
  &lt;html&gt;
    &lt;head&gt;
    &lt;/head&gt;
    &lt;body&gt;
    &lt;/body&gt;
  &lt;/html&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      
      
      
      
      
      <p class="GX">When the XSLT processor reads the input document, the first node it sees is the root. This rule matches that root node, and
         tells the XSLT processor to emit this text:
      </p>
      <pre><code>&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
      
      
      
      
      
      <p class="GX">This text is well-formed HTML. Because the XSLT document is itself an XML document, its contents &#8212; templates included &#8212; must
         be well-formed XML.
      </p>
      
      <p class="GX">If you were to use the above rule, and only the above rule, in an XSLT style sheet, the output would be limited to the above
         six tags. That's because no instructions in the rule tell the formatter to move down the tree and look for further matches
         against the templates in the style sheet.
      </p>
      
      <h3>The xsl:apply-templates element</h3>
      
      <p class="GX">To get beyond the root, you have to tell the formatting engine to process the children of the root. In general, to include
         content in the child nodes, you have to recursively process the nodes through the XML document. The element that does this
         is <code>xsl:apply-templates</code>. By including <code>xsl:apply-templates</code> in the output template, you tell the formatter to compare each child element of the matched source element against the templates
         in the style sheet, and, if a match is found, output the template for the matched node. The template for the matched node
         may itself contain <code>xsl:apply-templates</code> elements to search for matches for its children. When the formatting engine processes a node, the node is treated as a complete
         tree. This is the advantage of the tree structure. Each part can be treated the same way as the whole. For example, Listing
         17-5 is an XSLT style sheet that uses the <code>xsl:apply templates</code> element to process the child nodes.
      </p>
      
      <p style="font-weight: bold">Listing 17-5: 
         An XSLT style sheet that recursively processes the children of the root
      </p>
      
      <pre><code>&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:template match="/"&gt;
    &lt;html&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/html&gt;
  &lt;/xsl:template&gt;
  &lt;xsl:template match="PERIODIC_TABLE"&gt;
    &lt;body&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/body&gt;
  &lt;/xsl:template&gt;
  &lt;xsl:template match="ATOM"&gt;
    An Atom
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <p class="GX">When this style sheet is applied to Listing 17-1, here's what happens:</p>
      
      <ul>
         <li>&nbsp;1.&nbsp;The root node is compared with all template rules in the style sheet. It matches the first one.</li>
         <li>&nbsp;2.&nbsp;The <code>&lt;html&gt;</code> tag is written out.
         </li>
         <li>&nbsp;3.&nbsp;The <code>xsl:apply-templates</code> element causes the formatting engine to process the child nodes of the root node of the input document.
         </li>
      </ul>
      
      
      
      <p class="NL2">&nbsp;A.&nbsp;The first child of the root, the <code>xml-stylesheet</code> processing instruction, is compared with the template rules. It doesn't match any of them, so no output is generated.
      </p>
      
      <p class="NL2">&nbsp;B.&nbsp;The second child of the root node of the input document, the root element <code>PERIODIC_TABLE</code>, is compared with the template rules. It matches the second template rule.
      </p>
      
      <p class="NL2">&nbsp;C.&nbsp;The <code>&lt;body&gt;</code> tag is written out.
      </p>
      
      <p class="NL2">&nbsp;D.&nbsp;The <code>xsl:apply-templates</code> element in the <code>body</code> element causes the formatting engine to process the child nodes of <code>PERIODIC_TABLE</code>.
      </p>
      
      
      <p class="BL2">a.&nbsp;The first child of the <code>PERIODIC_TABLE</code> element, that is the Hydrogen <code>ATOM</code> element, is compared with the template rules. It matches the third template rule.
      </p>
      
      <p class="BL2">b.&nbsp;The text "An Atom" is output.</p>
      
      <p class="BL2">c.&nbsp;The second child of the <code>PERIODIC_TABLE</code> element, that is the Helium <code>ATOM</code> element, is compared with the template rules. It matches the third template rule.
      </p>
      
      <p class="BL2">d.&nbsp;The text "An Atom" is output.</p>
      
      <p class="NL2">&nbsp;E.&nbsp;The <code>&lt;/body&gt;</code> tag is written out.
      </p>
      
      <ul>
         <li>&nbsp;4.&nbsp;The <code>&lt;/html&gt;</code> tag is written out.
         </li>
         <li>&nbsp;5.&nbsp;Processing is complete.</li>
      </ul>
      
      
      <p class="GX">The end result is:</p>
      <pre><code>&lt;html&gt;
&lt;body&gt;
    An Atom
    An Atom
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
      
      
      
      
      
      <h3>The select attribute</h3>
      
      <p class="GX">To replace the text "An Atom" with the name of the <code>ATOM</code> element as given by its <code>NAME</code> child, you need to specify that templates should be applied to the <code>NAME</code> children of the <code>ATOM</code> element. To choose a particular set of children instead of all children you supply <code>xsl:apply-templates</code> with a <code>select</code> attribute designating the children to be selected. For example:
      </p>
      <pre><code>&lt;xsl:template match="ATOM"&gt;
  &lt;xsl:apply-templates select="NAME"/&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      <p class="GX">The <code>select</code> attribute uses the same kind of patterns as the <code>match</code> attribute of the <code>xsl:template</code> element. For now, I'll stick to simple names of elements; but in the section on patterns for matching and selecting later
         in this chapter, you'll see many more possibilities for both <code>select</code> and <code>match</code>. If no <code>select</code> attribute is present, all child element, text, comment, and processing instruction nodes are selected. (Attribute and namespace
         nodes are not selected.)
      </p>
      
      <p class="GX">The result of adding this rule to the style sheet of Listing 17-5 and applying it to Listing 17-1 is this:</p>
      <pre><code>&lt;html&gt;
&lt;body&gt;
  Hydrogen
  Helium
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
      
      
      
      
      
      <h2><a name="d1e1685">Computing the Value of a Node with xsl:value-of</a></h2>
      
      <p class="GX">The <code>xsl:value-of</code> element computes the value of something (most of the time, though not always, something in the input document) and copies
         it into the output document. The <code>select</code> attribute of the <code>xsl:value-of</code> element specifies exactly which something's value is being computed.
      </p>
      
      <p class="GX">For example, suppose you want to replace the literal text <code>An Atom</code> with the name of the <code>ATOM</code> element as given by the contents of its <code>NAME</code> child. You can replace <code>An Atom</code> with <code>&lt;xsl:value-of select="NAME"/&gt;</code> like this:
      </p>
      <pre><code>&lt;xsl:template match="ATOM"&gt;
  &lt;xsl:value-of select="NAME"/&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      <p class="GX">Then, when you apply the style sheet to Listing 17-1, this text is generated:</p>
      <pre><code>&lt;html&gt;
&lt;body&gt;
  Hydrogen
  Helium
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
      
      
      
      
      
      <p class="GX">The item whose value is selected, the <code>NAME</code> element in this example, is relative to the current node. The current node is the item matched by the template, the particular
         <code>ATOM</code> element in this example. Thus, when the Hydrogen <code>ATOM</code> is matched by <code>&lt;xsl:template match="ATOM"&gt;</code>, the Hydrogen <code>ATOM</code>'s <code>NAME</code> is selected by <code>xsl:value-of</code>. When the Helium <code>ATOM</code> is matched by <code>&lt;xsl:template match="ATOM"&gt;</code>, the Helium <code>ATOM</code>'s <code>NAME</code> is selected by <code>xsl:value-of</code>.
      </p>
      
      <p class="GX">The value of a node is always a string, possibly an empty string. The exact contents of this string depend on the type of
         the node. The most common type of node is element, and the value of an element node is particularly simple. It's the concatenation
         of all the character data (but not markup!) between the element's start tag and end tag. For example, the first <code>ATOM</code> element in Listing 17-1 is as follows:
      </p>
      <pre><code>  &lt;ATOM STATE="GAS"&gt;
    &lt;NAME&gt;Hydrogen&lt;/NAME&gt;
    &lt;SYMBOL&gt;H&lt;/SYMBOL&gt;
    &lt;ATOMIC_NUMBER&gt;1&lt;/ATOMIC_NUMBER&gt;
    &lt;ATOMIC_WEIGHT&gt;1.00794&lt;/ATOMIC_WEIGHT&gt;
    &lt;BOILING_POINT UNITS="Kelvin"&gt;20.28&lt;/BOILING_POINT&gt;
    &lt;MELTING_POINT UNITS="Kelvin"&gt;13.81&lt;/MELTING_POINT&gt;
    &lt;DENSITY UNITS="grams/cubic centimeter"&gt;
      &lt;!-- At 300K, 1 atm --&gt;
      0.0000899
    &lt;/DENSITY&gt;
  &lt;/ATOM&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      <p class="GX">The value of this element is shown below:</p>
      <pre><code>  Hydrogen
  H
  1
  1.00794
  1
  20.28
  13.81
    0.0000899
</code></pre>
      
      
      
      
      
      
      
      <p class="GX">I calculated this value by stripping out all the tags and comments. Everything else including white space was left intact.
         The values of the other six node types are calculated similarly, mostly in obvious ways. Table 17-1 summarizes.
      </p>
      
      <p style="font-weight: bold; text-align: center; font-family: Arial, Helvetica, sans">Table 17-1: 
         Values of Nodes
      </p>
      
      
      <table border="1" summary="(unspecified contents)">
         
         <colgroup span="1">
            <col width="112" span="1">
            <col width="324" span="1">
         </colgroup>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p style="font-weight: bold; font-family: Arial, Helvetica, sans">Node Type: 
                  
               </p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p style="font-weight: bold; font-family: Arial, Helvetica, sans">Value: 
                  
               </p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Root</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">The value of the root element</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Element</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">The concatenation of all parsed character data contained in the element, including character data in any of the descendants
                  of the element
               </p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Text</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">The text of the node; essentially the node itself</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Attribute</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">The normalized attribute value as specified by Section 3.3.3 of the XML 1.0 recommendation; basically the attribute value
                  after entities are resolved and leading and trailing white space is stripped; does not include the name of the attribute,
                  the equals sign, or the quotation marks
               </p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Namespace</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">The URI of the namespace</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Processing instruction</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">The data in the processing instruction; does not include the processing instruction , <code>&lt;?</code> or <code>?&gt;</code></p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Comment</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">The text of the comment, <code>&lt;!--</code> and <code>--&gt;</code> not included
               </p>
               
            </td>
            
         </tr>
         
      </table>
      
      <h2><a name="d1e2003">Processing Multiple Elements with xsl:for-each</a></h2>
      
      <p class="GX">The <code>xsl:value-of</code> element should only be used in contexts where it is obvious which node's value is being taken. If there are multiple possible
         items that could be selected, then only the first one will be chosen. For instance, this is a poor rule because a typical
         <code>PERIODIC_TABLE</code> element contains more than one <code>ATOM</code>:
      </p>
      <pre><code>&lt;xsl:template match="PERIODIC_TABLE"&gt;
  &lt;xsl:value-of select="ATOM"/&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      <p class="GX">There are two ways of processing multiple elements in turn. The first method you've already seen. Simply use <code>xsl:apply-templates</code> with a <code>select</code> attribute that chooses the particular elements that you want to include, like this:
      </p>
      <pre><code>  &lt;xsl:template match="PERIODIC_TABLE"&gt;
    &lt;xsl:apply-templates select="ATOM"/&gt;
  &lt;/xsl:template&gt;
  &lt;xsl:template match="ATOM"&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:template&gt;
</code></pre>
      
      
      
      
      
      <p class="GX">The <code>select="."</code> in the second template tells the formatter to take the value of the matched element, <code>ATOM</code> in this example.
      </p>
      
      <p class="GX">The second option is <code>xsl:for-each</code>. The <code>xsl:for-each</code> element processes each element chosen by its <code>select</code> attribute in turn. However, no additional template is required. For example:
      </p>
      <pre><code>&lt;xsl:template match="PERIODIC_TABLE"&gt;
  &lt;xsl:for-each select="ATOM"&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      
      
      <h2><a name="d1e2090">Patterns for Matching Nodes</a></h2>
      
      <p class="GX">The <code>match</code> attribute of the <code>xsl:template</code> element supports a complex syntax that allows you to express exactly which nodes you do and do not want to match. The <code>select</code> attribute of <code>xsl:apply-templates</code>, <code>xsl:value-of</code>, <code>xsl:for-each</code>, <code>xsl:copy-of</code>, and <code>xsl:sort</code> supports an even more powerful superset of this syntax called Xpath that allows you to express exactly which nodes you do
         and do not want to select. Various patterns for matching and selecting nodes are discussed below.
      </p>
      
      <h3>Matching the root node</h3>
      
      <p class="GX">In order that the output document be well-formed, the first thing output from an XSL transformation should be the output document's
         root element. Consequently, XSLT style sheets generally start with a rule that applies to the root node. To specify the root
         node in a rule, you give its <code>match</code> attribute the value <code>"/"</code>. For example:
      </p>
      <pre><code>&lt;xsl:template match="/"&gt;
  &lt;DOCUMENT&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/DOCUMENT&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      
      
      <p class="GX">This rule applies to the root node and only the root node of the input tree. When the root node is read, the tag <code>&lt;DOCUMENT&gt;</code> is output, the children of the root node are processed, then the <code>&lt;/DOCUMENT&gt;</code> tag is output. This rule overrides the default rule for the root node. Listing 17-6 shows a style sheet with a single rule
         that applies to the root node.
      </p>
      
      <p style="font-weight: bold">Listing 17-6: 
         An XSLT style sheet with one rule for the root node
      </p>
      
      <pre><code>&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
    &lt;xsl:template match="/"&gt;
      &lt;html&gt;
        &lt;head&gt;
          &lt;title&gt;Atomic Number vs. Atomic Weight&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
          &lt;table&gt;
            Atom data will go here
          &lt;/table&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <p class="GX">Because this style sheet only provides a rule for the root node, and because that rule's template does not specify any further
         processing of child nodes, only literal output that's included in the template is inserted in the resulting document. In other
         words, the result of applying the style sheet in Listing 17-6 to Listing 17-1 (or any other well-formed XML document) is this:
      </p>
      <pre><code>&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Atomic Number vs. Atomic Weight&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;table&gt;
            Atom data will go here
          &lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      <h3>Matching element names</h3>
      
      <p class="GX">As previously mentioned, the most basic pattern contains a single element name that matches all elements with that name. For
         example, this template matches <code>ATOM</code> elements and makes their <code>ATOMIC_NUMBER</code> children bold:
      </p>
      <pre><code>&lt;xsl:template match="ATOM"&gt;
  &lt;b&gt;&lt;xsl:value-of select="ATOMIC_NUMBER"/&gt;&lt;/b&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      <p class="GX">Listing 17-7 demonstrates a style sheet that expands on Listing 17-6. First, an <code>xsl:apply-templates</code> element is included in the template rule for the root node. This rule uses a <code>select</code> attribute to ensure that only <code>PERIODIC_TABLE</code> elements are processed.
      </p>
      
      <p class="GX">Second, a rule that only applies to <code>PERIODIC_TABLE</code> elements is created using <code>match="PERIODIC_TABLE"</code>. This rule sets up the header for the table, and then applies templates to form the body of the table from <code>ATOM</code> elements.
      </p>
      
      <p class="GX">Finally, the <code>ATOM</code> rule specifically selects the <code>ATOM</code> element's <code>NAME</code>, <code>ATOMIC_NUMBER</code>, and <code>ATOMIC_WEIGHT</code> child elements with <code>&lt;xsl:value-of select="NAME"/&gt;</code>, <code>&lt;xsl:value-of select="ATOMIC_NUMBER"/&gt;</code>, and <code>&lt;xsl:value-of select="ATOMIC_WEIGHT"/&gt;</code>. These are wrapped up inside HTML's <code>tr</code> and <code>td</code> elements, so that the end result is a table of atomic numbers matched to atomic weights. Figure 17-4 shows the output of
         applying the style sheet in Listing 17-7 to the complete periodic table document displayed in Netscape Navigator.
      </p>
      
      <p class="GX">One thing you may wish to note about this style sheet: The exact order of the <code>NAME</code>, <code>ATOMIC_NUMBER,</code> and <code>ATOMIC_WEIGHT</code> elements in the input document is irrelevant. They appear in the output in the order they were selected; that is, first number,
         then weight. Conversely, the individual atoms are sorted in alphabetical order as they appear in the input document. Later,
         you'll see how to use an <code>xsl:sort</code> element to change that so you can arrange the atoms in the more conventional atomic number order.
      </p>
      
      <p style="font-weight: bold">Listing 17-7: 
         Templates applied to specific classes of element with select
      </p>
      
      <pre><code>&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
    &lt;xsl:template match="/"&gt;
      &lt;html&gt;
        &lt;head&gt;
          &lt;title&gt;Atomic Number vs. Atomic Weight&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
          &lt;xsl:apply-templates select="PERIODIC_TABLE"/&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    &lt;/xsl:template&gt;
    &lt;xsl:template match="PERIODIC_TABLE"&gt;
      &lt;h1&gt;Atomic Number vs. Atomic Weight&lt;/h1&gt;
      &lt;table&gt;
        &lt;th&gt;Element&lt;/th&gt;
        &lt;th&gt;Atomic Number&lt;/th&gt;
        &lt;th&gt;Atomic Weight&lt;/th&gt;
          &lt;xsl:apply-templates select="ATOM"/&gt;
      &lt;/table&gt;
    &lt;/xsl:template&gt;
    &lt;xsl:template match="ATOM"&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;xsl:value-of select="NAME"/&gt;&lt;/td&gt;
        &lt;td&gt;&lt;xsl:value-of select="ATOMIC_NUMBER"/&gt;&lt;/td&gt;
        &lt;td&gt;&lt;xsl:value-of select="ATOMIC_WEIGHT"/&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <div align="center"><img src="17/picture7.jpg" width="335" height="333" alt="Image: 17/picture7.jpg"></div>
      
      
      <p style="font-weight: bold">Figure 17-4: 
         A table showing atomic number versus atomic weight in Netscape Navigator
      </p>
      
      
      <h3>Wild cards</h3>
      
      <p class="GX">Sometimes you want a single template to apply to more than one element. You can indicate that a template matches all elements
         by using the asterisk wildcard (<code>*</code>) in place of an element name in the <code>match</code> attribute. For example this template says that all elements should be wrapped in a <code>P</code> element:
      </p>
      <pre><code>    &lt;xsl:template match="*"&gt;
      &lt;P&gt;
        &lt;xsl:value-of select="."/&gt;
      &lt;/P&gt;
    &lt;/xsl:template&gt;
</code></pre>
      
      
      
      
      <p class="GX">Of course this is probably more than you want. You&#8217;d like to use the template rules already defined for <code>PERIODIC_TABLE</code> and <code>ATOM</code> elements as well as the root node and only use this rule for the other elements. Fortunately you can. In the event that two
         rules both match a single node, then by default the more specific one takes precedence. In this case that means that <code>ATOM</code> elements will use the template with <code>match="ATOM"</code> instead of a template that merely has <code>match="*"</code>. However, <code>NAME</code>, <code>BOILING_POINT</code>, <code>ATOMIC_NUMBER</code> and other elements that don&#8217;t match a more specific template will cause the <code>match="*"</code> template to activate.
      </p>
      
      <p class="GX">You can place a namespace prefix in front of the asterisk to indicate that only elements in a particular namespace should
         be matched. For example this template matches all SVG elements, presuming that the prefix <code>svg</code> is mapped to the normal SVG URI <code>http://www.w3.org/2000/svg</code> in the style sheet.
      </p>
      <pre><code>    &lt;xsl:template match="svg:*"&gt;
      &lt;DIV&gt;
        &lt;xsl:value-of select="."/&gt;
      &lt;/DIV&gt;
    &lt;/xsl:template&gt;
</code></pre>
      
      
      
      
      <p class="GX">Of course in Listing 17-1, there aren't any elements from this namespace, so this template wouldn&#8217;t produce any output. However,
         it might when applied to a different document that did include some SVG.
      </p>
      
      <h3>Matching children with /</h3>
      
      <p class="GX">You're not limited to the children of the current node in <code>match</code> attributes. You can use the <code>/</code> symbol to match specified hierarchies of elements. Used alone, the <code>/</code> symbol refers to the root node. However, you can use it between two names to indicate that the second is the child of the
         first. For example, <code>ATOM/NAME</code> refers to <code>NAME</code> elements that are children of <code>ATOM</code> elements.
      </p>
      
      <p class="GX">In <code>xsl:template</code> elements, this enables you to match only some of the elements of a given kind. For example, this template rule marks <code>SYMBOL</code> elements that are children of <code>ATOM</code> elements strong. It does nothing to <code>SYMBOL</code> elements that are not direct children of <code>ATOM</code> elements.
      </p>
      <pre><code>&lt;xsl:template match="ATOM/SYMBOL"&gt;
  &lt;strong&gt;&lt;xsl:value-of select="."/&gt;&lt;/strong&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      <p class="SBT" style="font-weight: bold; margin-left: 0.5in; margin-right: 0.5in;        font-family: Arial, Helvetica, sans; color: #0000ff">Caution</p>
      
      <p class="SBT" style="font-family: Arial, Helvetica, sans;        margin-left: 0.5in; margin-right: 0.5in">Remember that this rule selects <code>SYMBOL</code> elements that are children of <code>ATOM</code> elements, not <code>ATOM</code> elements that have <code>SYMBOL</code> children. In other words, the <code>.</code> in <code>&lt;xsl:value-of select="."/&gt;</code> refers to the <code>SYMBOL</code> and not to the <code>ATOM</code>.
      </p>
      
      <p class="GX">You can specify deeper matches by stringing patterns together. For example, <code>PERIODIC_TABLE/ATOM/NAME</code> selects <code>NAME</code> elements whose parent is an <code>ATOM </code>element whose parent is a <code>PERIODIC_TABLE</code> element.
      </p>
      
      <p class="GX">You can also use the <code>*</code> wild card to substitute for an arbitrary element name in a hierarchy. For example, this template rule applies to all <code>SYMBOL</code> elements that are grandchildren of a <code>PERIODIC_TABLE</code> element.
      </p>
      <pre><code>&lt;xsl:template match="PERIODIC_TABLE/*/SYMBOL"&gt;
  &lt;strong&gt;&lt;xsl:value-of select="."/&gt;&lt;/strong&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      <p class="GX">Finally, as you saw above, a <code>/</code> by itself selects the root node of the document. For example, this rule applies to all <code>PERIODIC_TABLE</code> elements that are root elements of the document:
      </p>
      <pre><code>&lt;xsl:template match="/PERIODIC_TABLE"&gt;
  &lt;html&gt;&lt;xsl:apply-templates/&gt;&lt;/html&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      <p class="GX">While <code>/</code> refers to the root node, <code>/*</code> refers to the root element, whatever it is. For example, this template doesn't care whether the root element is <code>PERIODIC_TABLE</code>, <code>DOCUMENT</code>, or <code>SCHENECTADY</code>. It produces the same output in all cases.
      </p>
      <pre><code>&lt;xsl:template match="/*"&gt;
  &lt;html&gt;
    &lt;head&gt;
      &lt;title&gt;Atomic Number vs. Atomic Weight&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/body&gt;
  &lt;/html&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      <h3>Matching descendants with //</h3>
      
      <p class="GX">Sometimes, especially with an uneven hierarchy, you may find it easier to bypass intermediate nodes and simply select all
         the elements of a given type, whether they're immediate children, grandchildren, great-grandchildren, or what have you. The
         double slash, <code>//</code>, refers to a descendant element at an arbitrary level. For example, this template rule applies to all <code>NAME</code> descendants of <code>PERIODIC_TABLE</code>, no matter how deep:
      </p>
      <pre><code>&lt;xsl:template match="PERIODIC_TABLE//NAME"&gt;
  &lt;i&gt;&lt;xsl:value-of select="."/&gt;&lt;/i&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      <p class="GX">The periodic table example is fairly shallow, but this trick becomes more important in deeper hierarchies, especially when
         an element can contain other elements of its type (for example, an <code>ATOM</code> contains an <code>ATOM</code>).
      </p>
      
      <p class="GX">The <code>//</code> operator at the beginning of a pattern selects any descendant of the root node. For example, this template rule processes
         all <code>ATOMIC_NUMBER</code> elements while completely ignoring their location:
      </p>
      <pre><code>&lt;xsl:template match="//ATOMIC_NUMBER"&gt;
  &lt;i&gt;&lt;xsl:value-of select="."/&gt;&lt;/i&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      <h3>Matching by ID</h3>
      
      <p class="GX">You may want to apply a particular style to a particular single element without changing all other elements of that type.
         The simplest way to do that in XSLT is to attach a style to the element's ID type attribute. This is done with the <code>id()</code> selector, which contains the ID value in single quotes. For example, this rule makes the element with the ID <code>e47</code> bold:
      </p>
      <pre><code>&lt;xsl:template match="id('e47')"&gt;
  &lt;b&gt;&lt;xsl:value-of select="."/&gt;&lt;/b&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      <p class="GX">This assumes, of course, that the elements that you want to select in this fashion have an attribute declared as type <code>ID</code> in the source document's DTD. This may not be the case, however. For one thing, many documents do not have DTDs. They're
         merely well-formed, not valid. And even if they have a DTD, there's no guarantee that any element has an <code>ID</code> type attribute.
      </p>
      
      <p class="SBT" style="font-weight: bold; margin-left: 0.5in; margin-right: 0.5in;        font-family: Arial, Helvetica, sans; color: #0000ff">Cross-Reference</p>
      
      <p class="SBT" style="font-family: Arial, Helvetica, sans;        margin-left: 0.5in; margin-right: 0.5in">ID-type attributes are not simply attributes with the name <code>ID</code>. ID type attributes are discussed in Chapter 11.
      </p>
      
      <h3>Matching attributes with @</h3>
      
      <p class="GX">As you saw in Chapter 5, the <code>@</code> sign matches against attributes and selects nodes according to attribute names. Simply prefix the name of the attribute that
         you want to select with the <code>@</code> sign. For example, this template rule matches <code>UNITS</code> attributes, and wraps them in an <code>I</code> element.
      </p>
      <pre><code>    &lt;xsl:template match="@UNITS"&gt;
      &lt;I&gt;&lt;xsl:value-of select="."/&gt;&lt;/I&gt;
    &lt;/xsl:template&gt;
</code></pre>
      
      
      <p class="GX">However, merely adding this rule to the style sheet will not automatically produce italicized units in the output because
         attributes are not children of the elements that contain them. Therefore by default when an XSLT processor is walking the
         tree it does not see attribute nodes. You have to explicitly process them using <code>xsl:apply-templates</code> with an appropriate <code>select</code> attribute. Listing 17-8 demonstrates with a style sheet that outputs a table of atomic numbers versus melting points. Not
         only is the value of the <code>MELTING_POINT</code> element written out, so is the value of its <code>UNITS</code> attribute. This is selected by <code>&lt;xsl:apply-templates select="@UNITS"/&gt;</code> in the template rule for <code>MELTING_POINT</code> elements.
      </p>
      
      <p style="font-weight: bold">Listing 17-8: 
         An XSLT style sheet that selects the UNITS attribute with @
      </p>
      
      <pre><code>&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
    &lt;xsl:template match="/PERIODIC_TABLE"&gt;
      &lt;html&gt;
        &lt;body&gt;
          &lt;h1&gt;Atomic Number vs. Melting Point&lt;/h1&gt;
          &lt;table&gt;
            &lt;th&gt;Element&lt;/th&gt;
            &lt;th&gt;Atomic Number&lt;/th&gt;
            &lt;th&gt;Melting Point&lt;/th&gt;
            &lt;xsl:apply-templates/&gt;
          &lt;/table&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    &lt;/xsl:template&gt;
    &lt;xsl:template match="ATOM"&gt;
       &lt;tr&gt;
        &lt;td&gt;&lt;xsl:value-of select="NAME"/&gt;&lt;/td&gt;
        &lt;td&gt;&lt;xsl:value-of select="ATOMIC_NUMBER"/&gt;&lt;/td&gt;
        &lt;td&gt;&lt;xsl:apply-templates select="MELTING_POINT"/&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/xsl:template&gt;
    &lt;xsl:template match="MELTING_POINT"&gt;
      &lt;xsl:value-of select="."/&gt;
      &lt;xsl:apply-templates select="@UNITS"/&gt;
    &lt;/xsl:template&gt;
    &lt;xsl:template match="@UNITS"&gt;
      &lt;I&gt;&lt;xsl:value-of select="."/&gt;&lt;/I&gt;
    &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <p class="GX">Recall that the value of an attribute node is simply the normalized string value of the attribute. Once you apply the style
         sheet in Listing 17-8, <code>ATOM</code> elements come out formatted like this:
      </p>
      <pre><code>  &lt;tr&gt;
&lt;td&gt;Hydrogen&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;13.81&lt;I&gt;Kelvin&lt;/I&gt;&lt;/td&gt;
&lt;/tr&gt;
  &lt;tr&gt;
&lt;td&gt;Helium&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;0.95&lt;I&gt;Kelvin&lt;/I&gt;&lt;/td&gt;
&lt;/tr&gt;
</code></pre>
      
      
      
      
      
      <p class="GX">You can combine attributes with elements using the various hierarchy operators. For example, the pattern <code>BOILING_POINT/@UNITS</code> refers to the <code>UNITS</code> attribute of a <code>BOILING_POINT</code> element. <code>ATOM/*/@UNITS</code> matches any <code>UNITS</code> attribute of a child element of an <code>ATOM</code> element. This is especially helpful when matching against attributes in template rules. You must remember that what's being
         matched is the attribute node, not the element that contains it. It's a very common mistake to implicitly confuse the attribute
         node with the element node that contains it. For example, consider this rule, which attempts to apply templates to all child
         elements that have <code>UNITS</code> attributes:
      </p>
      <pre><code>&lt;xsl:template match="ATOM"&gt;
  &lt;xsl:apply-templates select="@UNITS"/&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      <p class="GX">What it actually does is apply templates to the nonexistent <code>UNITS</code> attributes of <code>ATOM</code> elements.
      </p>
      
      <p class="GX">You can also use the <code>@*</code> wild card to match all attributes of an element, for example <code>BOILING_POINT/@*</code> to match all attributes of <code>BOILING_POINT</code> elements. You can also add a namespace prefix after the <code>@</code> to match all attributes in a declared namespace. For instance, <code>@xlink:*</code> matches all the XLink attributes, such as <code>xlink:show</code>, <code>xlink:type</code>, and <code>xlink:href</code>, assuming the <code>xlink</code> prefix is mapped to the <code>http://www.w3.org/1999/xlink</code> XLink namespace URI.
      </p>
      
      <h3>Matching comments with comment()</h3>
      
      <p class="GX">Most of the time you should simply ignore comments in XML documents. Making comments an essential part of a document is a
         very bad idea. Nonetheless, XSLT does provide a means to match a comment if you absolutely have to.
      </p>
      
      <p class="GX">To match a comment, use the <code>comment()</code> pattern. Although this pattern has function-like parentheses, it never actually takes any arguments. For example, this template
         rule italicizes all comments:
      </p>
      <pre><code>    &lt;xsl:template match="comment()"&gt;
      &lt;i&gt;&lt;xsl:value-of select="."/&gt;&lt;/i&gt;
    &lt;/xsl:template&gt;
</code></pre>
      
      
      <p class="GX">To distinguish between different comments, you have to look at the comments' parent and ancestors. For example, recall that
         a <code>DENSITY</code> element looks like this:
      </p>
      <pre><code>    &lt;DENSITY UNITS="grams/cubic centimeter"&gt;
      &lt;!-- At 300K, 1 atm --&gt;
      0.0000899
    &lt;/DENSITY&gt;
</code></pre>
      
      
      
      <p class="GX">You can use the hierarchy operators to select particular comments. For example, this rule only matches comments that occur
         inside <code>DENSITY</code> elements:
      </p>
      <pre><code>&lt;xsl:template match="DENSITY/comment()"&gt;
  &lt;i&gt;&lt;xsl:value-of select="."/&gt;&lt;/i&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      <p class="GX">The only reason Listing 17-1 uses a comment to specify conditions instead of an attribute or element is precisely for this
         example. In practice, you should never put important information in comments. The real reason XSLT allows you to select comments
         is so that a style sheet can transform from one XML application to another while leaving the comments intact. Any other use
         indicates a poorly designed original document. The following rule matches all comments, and copies them back out again using
         the <code>xsl:comment</code> element.
      </p>
      <pre><code>&lt;xsl:template match="comment()"&gt;
  &lt;xsl:comment&gt;&lt;xsl:value-of select="."/&gt;&lt;/xsl:comment&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      <h3>Matching processing instructions with processing-instruction()</h3>
      
      <p class="GX">When it comes to writing structured, intelligible, maintainable XML, processing instructions aren't much better than comments.
         However, there are occasional genuine needs for them, including attaching style sheets to documents.
      </p>
      
      <p class="GX">The <code>processing-instruction()</code> function matches processing instructions. The argument to <code>processing-instruction()</code> is a quoted string giving the target of the processing instruction to select. If you do not include an argument, the first
         processing instruction child of the current node is matched. For example, this rule matches the processing instruction children
         of the root node (most likely the <code>xml-stylesheet</code> processing instruction). The <code>xsl:processing-instruction</code> element inserts a processing instruction with the specified name and value in the output document.
      </p>
      <pre><code>&lt;xsl:template match="/processing-instruction()"&gt;
  &lt;xsl:processing-instruction name="xml-stylesheet"&gt;
    type="text/xml" value="auto.xsl"
  &lt;/xsl:processing-instruction&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      
      
      <p class="GX">This rule also matches the <code>xml-stylesheet</code> processing instruction, but by its name:
      </p>
      <pre><code>&lt;xsl:template
  match="processing-instruction('xml-stylesheet')"&gt;
  &lt;xsl:processing-instruction name="xml-stylesheet"&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:processing-instruction&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      
      
      
      <p class="GX">In fact, one of the primary reasons for distinguishing between the root element and the root node is so that processing instructions
         from the prolog can be read and processed. Although the <code>xml-stylesheet</code> processing instruction uses a name = value syntax, XSL does not consider these to be attributes because processing instructions
         are not elements. The value of a processing instruction is simply everything between the white space following its name and
         the closing <code>?&gt;</code>.
      </p>
      
      <h3>Matching text nodes with text()</h3>
      
      <p class="GX">Text nodes are generally ignored as nodes, although their values are included as part of the value of a selected element.
         However, the <code>text()</code> operator does enable you to specifically select the text child of an element. Despite the parentheses, this operator takes
         no arguments. For example, this rule emboldens all text:
      </p>
      <pre><code>&lt;xsl:template match="text()"&gt;
  &lt;b&gt;&lt;xsl:value-of select="."/&gt;&lt;/b&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      <p class="GX">The main reason this operator exists is for the default rules. XSLT processors must provide the following default rule whether
         the author specifies it or not:
      </p>
      <pre><code>&lt;xsl:template match="text()"&gt;
  &lt;xsl:value-of select="."/&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      <p class="GX">This means that whenever a template is applied to a text node, the text of the node is output. If you do not want the default
         behavior, you can override it. For example, including the following empty template rule in your style sheet will prevent text
         nodes from being output unless specifically matched by another rule.
      </p>
      <pre><code>&lt;xsl:template match="text()"&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      <h3>Using the or operator |</h3>
      
      <p class="GX">The vertical bar (<code>|</code>)allows a template rule to match multiple patterns. If a node matches one pattern or the other, it will activate the template.
         For example, this template rule matches both <code>ATOMIC_NUMBER</code> and <code>ATOMIC_WEIGHT</code> elements:
      </p>
      <pre><code>&lt;xsl:template match="ATOMIC_NUMBER|ATOMIC_WEIGHT"&gt;
  &lt;B&gt;&lt;xsl:apply-templates/&gt;&lt;/B&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      <p class="GX">You can include white space around the <code>|</code> if that makes the code clearer. For example,
      </p>
      <pre><code>&lt;xsl:template match="ATOMIC_NUMBER | ATOMIC_WEIGHT"&gt;
  &lt;B&gt;&lt;xsl:apply-templates/&gt;&lt;/B&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      <p class="GX">You can also use more than two patterns in sequence. For example, this template rule applies to <code>ATOMIC_NUMBER</code>, <code>ATOMIC_WEIGHT</code>, and <code>SYMBOL</code> elements (that is, it matches <code>ATOMIC_NUMBER</code>, <code>ATOMIC_WEIGHT</code> and <code>SYMBOL</code> elements):
      </p>
      <pre><code>&lt;xsl:template match="ATOMIC_NUMBER | ATOMIC_WEIGHT | SYMBOL"&gt;
  &lt;B&gt;&lt;xsl:apply-templates/&gt;&lt;/B&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      <p class="GX">The <code>/</code> operator is evaluated before the <code>|</code> operator. Thus, the following template rule matches an <code>ATOMIC_NUMBER</code> child of an <code>ATOM</code>, or an <code>ATOMIC_WEIGHT</code> of unspecified parentage, not an <code>ATOMIC_NUMBER</code> child of an <code>ATOM</code> or an <code>ATOMIC_WEIGHT</code> child of an <code>ATOM</code>.
      </p>
      <pre><code>&lt;xsl:template match="ATOM/ATOMIC_NUMBER|ATOMIC_WEIGHT"&gt;
  &lt;B&gt;&lt;xsl:apply-templates/&gt;&lt;/B&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      <h3>Testing with [ ]</h3>
      
      <p class="GX">So far, I've merely tested for the presence of various nodes. However, you can test for more details about the nodes that
         match a pattern using <code>[]</code>. You can perform many different tests including:
      </p>
      
      <ul>
         <li>Whether an element contains a given child, attribute, or other node</li>
         <li>Whether the value of an attribute is a certain string</li>
         <li>Whether the value of an element matches a string</li>
         <li>What position a given node occupies in the hierarchy</li>
      </ul>
      
      
      
      
      <p class="GX">For example, seaborgium, element 106, has only been created in microscopic quantities. Even its most long-lived isotope has
         a half-life of only 30 seconds. With such a hard-to-create, short-lived element, it's virtually impossible to measure the
         density, melting point, and other bulk properties. Consequently, the periodic table document omits the elements describing
         the bulk properties of seaborgium and similar atoms because the data simply doesn&#8217;t exist. If you want to create a table of
         atomic number versus melting point, you should omit those elements with unknown melting points. To do this, you can provide
         one template for <code>ATOM</code> elements that have <code>MELTING_POINT</code> children and another one for elements that don't, like this:
      </p>
      <pre><code>&lt;!-- Include nothing for arbitrary atoms --&gt;
&lt;xsl:template match="ATOM" /&gt;
&lt;!-- Include a table row for atoms that do have 
     melting points. This rule will override the 
     previous one for those atoms that do have 
     melting points. --&gt;
&lt;xsl:template match="ATOM[MELTING_POINT]"&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;xsl:value-of select="NAME"/&gt;&lt;/td&gt;
    &lt;td&gt;&lt;xsl:value-of select="MELTING_POINT"/&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      <p class="GX">Note here, that it is the <code>ATOM</code> element being matched, not the <code>MELTING_POINT</code> element as in the case of <code>ATOM/MELTING_POINT</code>.
      </p>
      
      <p class="GX">The test brackets can contain more than simply a child-element name. In fact, they can contain any XPath expression. (XPath
         expressions are a superset of match patterns that are discussed in the next section.) If the specified element has a child
         matching that expression, it is considered to match the total pattern. For example, this template rule matches <code>ATOM</code> elements with <code>NAME</code> or <code>SYMBOL</code> children.
      </p>
      <pre><code>&lt;xsl:template match="ATOM[NAME | SYMBOL]"&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      <p class="GX">This template rule matches <code>ATOM</code> elements with a <code>DENSITY</code> child element that has a <code>UNITS</code> attribute:
      </p>
      <pre><code>&lt;xsl:template match="ATOM[DENSITY/@UNITS]"&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      <p class="GX">To revisit an earlier example, to correctly find all child elements that have <code>UNITS</code> attributes, use <code>*</code> to find all elements and <code>[@UNITS]</code> to winnow those down to the ones with <code>UNITS</code> attributes, like this:
      </p>
      <pre><code>&lt;xsl:template match="ATOM"&gt;
  &lt;xsl:apply-templates select="*[@UNITS]"/&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      <p class="GX">One type of pattern testing that proves especially useful is string equality. An equals sign (<code>=</code>) can test whether the value of a node identically matches a given string. For example, this template finds the <code>ATOM</code> element that contains an <code>ATOMIC_NUMBER</code> element whose content is the string <code>10</code> (Neon).
      </p>
      <pre><code>&lt;xsl:template match="ATOM[ATOMIC_NUMBER='10']"&gt;
  This is Neon!
&lt;/xsl:template&gt;
</code></pre>
      
      
      <p class="GX">Testing against element content may seem extremely tricky because of the need to get the value exactly right, including white
         space. You may find it easier to test against attribute values since those are less likely to contain insignificant white
         space. For example, the style sheet in Listing 17-9 applies templates only to those <code>ATOM</code> elements whose <code>STATE</code> attribute value is the three letters <code>GAS</code>.
      </p>
      
      <p style="font-weight: bold">Listing 17-9: 
         An XSLT style sheet that selects only those ATOM elements whose STATE attribute has the value GAS
      </p>
      
      <pre><code>&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:template match="PERIODIC_TABLE"&gt;
    &lt;html&gt;
      &lt;head&gt;&lt;title&gt;Gases&lt;/title&gt;&lt;/head&gt;
      &lt;body&gt;
        &lt;xsl:apply-templates/&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  &lt;/xsl:template&gt;
  &lt;xsl:template match="ATOM"/&gt;
  &lt;xsl:template match="ATOM[@STATE='GAS']"&gt;
    &lt;P&gt;&lt;xsl:value-of select="."/&gt;&lt;/P&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <p class="GX">You can use other XPath expressions for more complex matches. For example, you can select all elements whose names begin with
         "A" or all elements with an atomic number less than 100.
      </p>
      
      <h2><a name="d1e3567">XPath Expressions for Selecting Nodes</a></h2>
      
      <p class="GX">The <code>select</code> attribute is used in <code>xsl:apply-templates</code>, <code>xsl:value-of</code>, <code>xsl:for-each</code>, <code>xsl:copy-of</code>, <code>xsl:variable</code>, <code>xsl:param</code>, and <code>xsl:sort</code> to specify exactly which nodes are operated on. The value of this attribute is an <span class="italic">expression</span> written in the XPath language. The XPath language provides a means of identifying a particular element, group of elements,
         text fragment, or other part of an XML document. The XPath syntax is used both for XSLT and XPointer.
      </p>
      
      <p class="SBT" style="font-weight: bold; margin-left: 0.5in; margin-right: 0.5in;        font-family: Arial, Helvetica, sans; color: #0000ff">Cross-reference</p>
      
      <p class="SBT" style="font-family: Arial, Helvetica, sans;        margin-left: 0.5in; margin-right: 0.5in">XPointers are discussed in Chapter 20. XPath is discussed further in that chapter as well.</p>
      
      <p class="GX">Expressions are a superset of the match patterns discussed in the last section. That is, all match patterns are expressions,
         but not all expressions are match patterns. Recall that match patterns enable you to match nodes by element name, child elements,
         descendants, and attributes, as well as by making simple tests on these items. XPath expressions allow you to select nodes
         through all these criteria but also by referring to ancestor nodes, parent nodes, sibling nodes, preceding nodes, and following
         nodes. Furthermore, expressions aren't limited to producing merely a list of nodes, but can also produce booleans, numbers,
         and strings.
      </p>
      
      <h3>Node axes</h3>
      
      <p class="GX">Expressions are not limited to specifying the children and descendants of the current node. XPath provides a number of axes
         that you can use to select from different parts of the tree relative to some particular node in the tree called the context
         node. In XSLT, the context node is normally initialized to the current node that the template matches, though there are ways
         to change this. Table 17-2 summarizes the axes and their meanings.
      </p>
      
      <p style="font-weight: bold; text-align: center; font-family: Arial, Helvetica, sans">Table 17-2: 
         Expression Axes
      </p>
      
      
      <table border="1" summary="(unspecified contents)">
         
         <colgroup span="1">
            <col width="103" span="1">
            <col width="333" span="1">
         </colgroup>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p style="font-weight: bold; font-family: Arial, Helvetica, sans">Axis: 
                  
               </p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p style="font-weight: bold; font-family: Arial, Helvetica, sans">Selects From: 
                  
               </p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>ancestor</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">The parent of the context node, the parent of the parent of the context node, the parent of the parent of the parent of the
                  context node, and so forth back to the root node
               </p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>ancestor-or-self</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">The ancestors of the context node and the context node itself</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>attribute</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">The attributes of the context node</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>child</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">The immediate children of the context node</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>descendant</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">The children of the context node, the children of the children of the context node, and so forth</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>descendant-or-self</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">The context node itself and its descendants</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>following</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">All nodes that start after the end of the context node, excluding attribute and namespace nodes</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>following-sibling</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">All nodes that start after the end of the context node and have the same parent as the context node</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>namespace</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">The namespace of the context node</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>parent</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">The unique parent node of the context node</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>preceding</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">All nodes that finish before the beginning of the context node, excluding attribute and namespace nodes </p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>preceding-sibling</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">All nodes that start before the beginning of the context node and have the same parent as the context node</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>self</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">The context node</p>
               
            </td>
            
         </tr>
         
      </table>
      
      <p class="GX">Choosing an axis limits the expression so that it only selects from the set of nodes indicated in the second column of Table
         17-2. The axis is generally followed by a double colon (<code>::</code>) and a node test that further winnows down this node set. For example, a node test may contain the name of the element to
         be selected as in the following template rule:
      </p>
      <pre><code>&lt;xsl:template match="ATOM"&gt;
  &lt;tr&gt;
    &lt;td&gt;
      &lt;xsl:value-of select="child::NAME"/&gt;
    &lt;/td&gt;
    &lt;td&gt;
      &lt;xsl:value-of select="child::ATOMIC_NUMBER"/&gt;
    &lt;/td&gt;
    &lt;td&gt;
      &lt;xsl:value-of select="child::ATOMIC_WEIGHT"/&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      
      <p class="GX">The template rule matches <code>ATOM</code> elements. When an <code>ATOM</code> element is matched, that element becomes the context node. A <code>NAME</code> element, an <code>ATOMIC_NUMBER</code> element, and an <code>ATOMIC_WEIGHT</code> element are all selected from the children of that matched <code>ATOM</code> element and output as table cells. (If there's one more than one of these desired elements &#8212; for example, three <code>NAME</code> elements &#8212; then all are selected but only the value of the first one is taken.)
      </p>
      
      <p class="GX">The <code>child</code> axis doesn't let you do anything that you can't do with element names alone. In fact <code>select="ATOMIC_WEIGHT"</code> is just an abbreviated form of <code>select="child::ATOMIC_WEIGHT"</code>. However, the other axes are a little more interesting.
      </p>
      
      <p class="GX">Referring to the parent element is illegal in match patterns, but not in expressions. To refer to the parent, you use the
         <code>parent</code> axis. For example, this template matches <code>BOILING_POINT</code> elements but outputs the value of the parent <code>ATOM</code> element:
      </p>
      <pre><code>&lt;xsl:template match="BOILING_POINT"&gt;
  &lt;P&gt;&lt;xsl:value-of select="parent::ATOM"/&gt;&lt;/P&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      <p class="GX">Some radioactive atoms such as polonium have half-lives so short that bulk properties such as the boiling point and melting
         point can't be measured. Therefore, not all <code>ATOM</code> elements necessarily have <code>BOILING_POINT</code> child elements. The above rule enables you to write a template that only outputs those elements that actually have boiling
         points. Expanding on this example, Listing 17-10 matches the <code>MELTING_POINT</code> elements but actually outputs the parent <code>ATOM</code> element using <code>parent::ATOM</code>.
      </p>
      
      <p style="font-weight: bold">Listing 17-10: 
         A style sheet that outputs only those elements with known melting points
      </p>
      
      <pre><code>&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
    &lt;xsl:template match="/"&gt;
      &lt;html&gt;
        &lt;body&gt;
          &lt;xsl:apply-templates select="PERIODIC_TABLE"/&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    &lt;/xsl:template&gt;
    &lt;xsl:template match="PERIODIC_TABLE"&gt;
      &lt;h1&gt;Elements with known Melting Points&lt;/h1&gt;
      &lt;xsl:apply-templates select=".//MELTING_POINT"/&gt;
    &lt;/xsl:template&gt;
    &lt;xsl:template match="MELTING_POINT"&gt;
      &lt;p&gt;
        &lt;xsl:value-of select="parent::ATOM"/&gt;
      &lt;/p&gt;
    &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <p class="GX">Once in awhile, you may need to select the nearest ancestor of an element with a given type. The <code>ancestor</code> axis does this. For example, this rule inserts the value of the nearest <code>PERIODIC_TABLE</code> element that contains the matched <code>SYMBOL</code> element.
      </p>
      <pre><code>&lt;xsl:template match="SYMBOL"&gt;
  &lt;xsl:value-of select="ancestor::PERIODIC_TABLE"/&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      <p class="GX">The <code>ancestor-or-self</code> axis behaves like the <code>ancestor</code> axis except that if the context node passes the node test, then it will be returned as well. For example, this rule matches
         all elements. If the matched element is a <code>PERIODIC_TABLE</code>, then that very <code>PERIODIC_TABLE</code> is selected in <code>xsl:value-of</code>.
      </p>
      <pre><code>&lt;xsl:template match="*"&gt;
  &lt;xsl:value-of select="ancestor-or-self::PERIODIC_TABLE"/&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      <h4>Node tests</h4>
      
      <p class="GX">Instead of the name of a node, the axis may be followed by one of these four node-type functions:</p>
      
      <ul>
         <li><code>comment()</code></li>
         <li><code>text()</code></li>
         <li><code>processing-instruction()</code></li>
         <li><code>node()</code></li>
      </ul>
      
      
      
      
      <p class="GX">The <code>comment()</code> function selects a comment node. The <code>text()</code> function selects a text node. The <code>processing-instruction()</code> function selects a processing instruction node, and the <code>node()</code> function selects any type of node. (The <code>*</code> wild card only selects element nodes.) The <code>processing-instruction()</code> node type can also contain an optional argument specifying the name of the processing instruction to select.
      </p>
      
      <h4>Hierarchy operators</h4>
      
      <p class="GX">You can use the <code>/</code> and <code>//</code> operators to string expressions together. For example, Listing 17-11 prints a table of element names, atomic numbers, and
         melting points for only those elements that have melting points. It does this by selecting the parent of the <code>MELTING_POINT</code> element, then finding that parent's <code>NAME</code> and <code>ATOMIC_NUMBER</code> children with <code>select="parent::*/child::NAME)"</code>.
      </p>
      
      <p style="font-weight: bold">Listing 17-11: 
         A table of melting point versus atomic number
      </p>
      
      <pre><code>&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
    &lt;xsl:template match="/PERIODIC_TABLE"&gt;
      &lt;html&gt;
        &lt;body&gt;
          &lt;h1&gt;Atomic Number vs. Melting Point&lt;/h1&gt;
          &lt;table&gt;
            &lt;th&gt;Element&lt;/th&gt;
            &lt;th&gt;Atomic Number&lt;/th&gt;
            &lt;th&gt;Melting Point&lt;/th&gt;
            &lt;xsl:apply-templates select="child::ATOM"/&gt;
          &lt;/table&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    &lt;/xsl:template&gt;
    &lt;xsl:template match="ATOM"&gt;
      &lt;xsl:apply-templates
       select="child::MELTING_POINT"/&gt;
    &lt;/xsl:template&gt;
    &lt;xsl:template match="MELTING_POINT"&gt;
       &lt;tr&gt;
        &lt;td&gt;
          &lt;xsl:value-of select="parent::*/child::NAME"/&gt;
        &lt;/td&gt;
        &lt;td&gt;
          &lt;xsl:value-of
         select="parent::*/child::ATOMIC_NUMBER"/&gt;
        &lt;/td&gt;
        &lt;td&gt;
          &lt;xsl:value-of select="self::*"/&gt;
          &lt;xsl:value-of select="attribute::UNITS"/&gt;
        &lt;/td&gt;
      &lt;/tr&gt;
   &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <p class="GX">This is not the only way to solve the problem. Another possibility is to use the <code>preceding-sibling</code> and <code>following-sibling</code> axes, or both if the relative location (preceding or following) is uncertain. The necessary template rule for the <code>MELTING_POINT</code> element looks like this:
      </p>
      <pre><code> &lt;xsl:template match="MELTING_POINT"&gt;
    &lt;tr&gt;
     &lt;td&gt;
       &lt;xsl:value-of
        select="preceding-sibling::NAME
              | following-sibling::NAME"/&gt;
     &lt;/td&gt;
     &lt;td&gt;
       &lt;xsl:value-of
        select="preceding-sibling::ATOMIC_NUMBER
              | following-sibling::ATOMIC_NUMBER"/&gt;
     &lt;/td&gt;
     &lt;td&gt;
       &lt;xsl:value-of select="self::*"/&gt;
       &lt;xsl:value-of select="attribute::UNITS"/&gt;
     &lt;/td&gt;
   &lt;/tr&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <h4>Abbreviated syntax</h4>
      
      <p class="GX">The various axes in Table 17-2 are a bit too wordy for comfortable typing. XPath also defines an abbreviated syntax that can
         substitute for the most common of these axes and is more used in practice. Table 17-3 shows the full and abbreviated equivalents.
      </p>
      
      <p style="font-weight: bold; text-align: center; font-family: Arial, Helvetica, sans">Table 17-3: 
         Abbreviated Syntax for XPath Expressions
      </p>
      
      
      <table border="1" summary="(unspecified contents)">
         
         <colgroup span="1">
            <col width="117" span="1">
            <col width="320" span="1">
         </colgroup>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p style="font-weight: bold; font-family: Arial, Helvetica, sans">Abbreviation: 
                  
               </p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p style="font-weight: bold; font-family: Arial, Helvetica, sans">Full: 
                  
               </p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">.</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">self::node()</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">..</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">parent::node()</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><span class="italic">name</span></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">child::<span class="italic">name</span></p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">@<span class="italic">name</span></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">attribute::<span class="italic">name</span></p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">//</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">/descendant-or-self::node()/</p>
               
            </td>
            
         </tr>
         
      </table>
      
      <p class="GX">Listing 17-12 demonstrates by rewriting Listing 17-11 using the abbreviated syntax. The output produced by the two style sheets
         is exactly the same, however.
      </p>
      
      <p style="font-weight: bold">Listing 17-12: 
         A table of melting point versus atomic number using the abbreviated syntax
      </p>
      
      <pre><code>&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
    &lt;xsl:template match="/PERIODIC_TABLE"&gt;
      &lt;html&gt;
        &lt;body&gt;
          &lt;h1&gt;Atomic Number vs. Melting Point&lt;/h1&gt;
          &lt;table&gt;
            &lt;th&gt;Element&lt;/th&gt;
            &lt;th&gt;Atomic Number&lt;/th&gt;
            &lt;th&gt;Melting Point&lt;/th&gt;
            &lt;xsl:apply-templates select="ATOM"/&gt;
          &lt;/table&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    &lt;/xsl:template&gt;
    &lt;xsl:template match="ATOM"&gt;
      &lt;xsl:apply-templates
       select="MELTING_POINT"/&gt;
    &lt;/xsl:template&gt;
    &lt;xsl:template match="MELTING_POINT"&gt;
       &lt;tr&gt;
        &lt;td&gt;
          &lt;xsl:value-of
           select="../NAME"/&gt;
        &lt;/td&gt;
        &lt;td&gt;
          &lt;xsl:value-of
         select="../ATOMIC_NUMBER"/&gt;
        &lt;/td&gt;
        &lt;td&gt;
          &lt;xsl:value-of select="."/&gt;
          &lt;xsl:value-of select="@UNITS"/&gt;
        &lt;/td&gt;
      &lt;/tr&gt;
   &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <p class="GX">Match patterns can only use the abbreviated syntax and the <code>child</code> and <code>attribute</code> axes. The full syntax using the axes of Table 17-2 is restricted to expressions.
      </p>
      
      <h3>Expression types</h3>
      
      <p class="GX">Every expression evaluates to a single value. For example, the expression <code>3 + 2</code> evaluates to the value <code>5</code>. The expressions used so far have all evaluated to node sets. However, there are five types of expressions in XSLT:
      </p>
      
      <ul>
         <li>Node sets</li>
         <li>Booleans</li>
         <li>Numbers</li>
         <li>Strings</li>
         <li>Result tree fragments</li>
      </ul>
      
      
      
      
      
      <h4>Node sets</h4>
      
      <p class="GX">A node set is an unordered group of nodes from the input document. The axes in Table 17-2 all return a node set containing
         the nodes they match. Which nodes are in the node set depends on the context node, the node test, and the axis.
      </p>
      
      <p class="GX">For example, when the context node is the <code>PERIODIC_TABLE</code> element of Listing 17-1, the XPath expression <code>select="child::ATOM"</code> returns a node set that contains both <code>ATOM</code> elements in that document. The XPath expression <code>select="child::ATOM/child::NAME"</code> returns a node set containing the two element nodes <code>&lt;NAME&gt;Hydrogen&lt;/NAME&gt;</code> and <code>&lt;NAME&gt;Helium&lt;/NAME&gt;</code> when the context node is the <code>PERIODIC_TABLE</code> element of Listing 17-1.
      </p>
      
      <p class="GX">The context node is a member of the <span class="italic">context node list</span>. The context node list is that group of elements that all match the same rule at the same time, generally as a result of
         one <code>xsl:apply-templates</code> or <code>xsl:for-each</code> call. For instance, when Listing 17-12 is applied to Listing 17-1, the <code>ATOM</code> template is invoked twice, first for the hydrogen atom, then for the helium atom. The first time it's invoked, the context
         node is the hydrogen <code>ATOM</code> element. The second time it's invoked, the context node is the helium <code>ATOM</code> element. However, both times the context node list is the set containing both the helium and hydrogen <code>ATOM</code> elements.
      </p>
      
      <p class="GX">Table 17-4 lists a number of functions that operate on node sets, either as arguments or as the context node.</p>
      
      <p style="font-weight: bold; text-align: center; font-family: Arial, Helvetica, sans">Table 17-4: 
         Functions That Operate on or Return Node Sets
      </p>
      
      
      <table border="1" summary="(unspecified contents)">
         
         <colgroup span="1">
            <col width="108" span="1">
            <col width="76" span="1">
            <col width="252" span="1">
         </colgroup>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p style="font-weight: bold; font-family: Arial, Helvetica, sans">Function: 
                  
               </p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p style="font-weight: bold; font-family: Arial, Helvetica, sans">Return Type: 
                  
               </p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p style="font-weight: bold; font-family: Arial, Helvetica, sans">Returns: 
                  
               </p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>position()</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">number</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">The position of the context node in the context node list; the first node in the list has position 1</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>last()</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">number</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">The number of nodes in the context node list; this is the same as the position of the last node in the list</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>count(</code><span class="italic"><code>node-set</code></span><code>)</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">number</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">The number of nodes in <span class="italic"><code>node-set</code></span>.
               </p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>id(</code><span class="italic"><code>string1 string2 string3&#8230;</code></span><code>)</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">node set</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">A node set containing all the elements anywhere in the same document that have an ID named in the argument list; the empty
                  set if no element has the specified ID.
               </p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>key(</code><span class="italic"><code>string name</code></span><code>, </code><span class="italic"><code>Object value</code></span><code>)</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">node set</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">A node set containing all nodes in this document that have a key with the specified value. Keys are set with the top-level
                  <code>xsl:key</code> element.
               </p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>document(</code><span class="italic"><code>string URI, string base</code></span><code>)</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">node set</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">A node set in the document referred to by the URI; the nodes are chosen from the named anchor or XPointer used by the URI.
                  If there is no named anchor or XPointer, then the root element of the named document is the node set. Relative URIs are relative
                  to the base URI given in the second argument. If the second argument is omitted, then relative URIs are relative to the URI
                  of the style sheet (not the source document!).
               </p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>local-name(</code><span class="italic"><code>node set</code></span><code>)</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">string</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">The local name (everything after the namespace prefix) of the first node in the <span class="italic"><code>node set</code></span> argument; can be used without any arguments to get the local name of the context node.
               </p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>namespace-uri(</code><span class="italic"><code>node set</code></span><code>)</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">string</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">The URI of the namespace of the first node in the node set; can be used without any arguments to get the URI of the namespace
                  of the context node; returns an empty string if the node is not in a namespace.
               </p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>name(</code><span class="italic"><code>node set</code></span><code>)</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">string</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">The qualified name (both prefix and local part) of the first node in the <span class="italic"><code>node set</code></span> argument; can be used without an argument to get the qualified name of the context node.
               </p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>generate-id(</code><span class="italic"><code>node set</code></span><code>)</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">string</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">A unique identifier for the first node in the argument <span class="italic"><code>node set</code></span>; can be used without any argument to generate an ID for the context node.
               </p>
               
            </td>
            
         </tr>
         
      </table>
      
      <p class="GX">If an argument of the wrong type is passed to one of these functions, then XSLT will attempt to convert that argument to the
         correct type; for instance, by converting the number 12 to the string "12". However, no arguments may be converted to node
         sets.
      </p>
      
      <p class="GX">The <code>position()</code> function can be used to determine an element's position within a node set. Listing 17-13 is a style sheet that prefixes the
         name of each atom's name with its position in the document using <code>&lt;xsl:value-of select="position()"/&gt;</code>.
      </p>
      
      <p style="font-weight: bold">Listing 17-13: 
         A style sheet that numbers the atoms in the order they appear in the document
      </p>
      
      <pre><code>&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:template match="/PERIODIC_TABLE"&gt;
    &lt;HTML&gt;
      &lt;HEAD&gt;&lt;TITLE&gt;The Elements&lt;/TITLE&gt;&lt;/HEAD&gt;
      &lt;BODY&gt;
        &lt;xsl:apply-templates select="ATOM"/&gt;
      &lt;/BODY&gt;
    &lt;/HTML&gt;
  &lt;/xsl:template&gt;
  &lt;xsl:template match="ATOM"&gt;
    &lt;P&gt;
      &lt;xsl:value-of select="position()"/&gt;.
      &lt;xsl:value-of select="NAME"/&gt;
    &lt;/P&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <p class="GX">When this style sheet is applied to Listing 17-1, the output is this:</p>
      <pre><code>&lt;HTML&gt;
&lt;HEAD&gt;
&lt;TITLE&gt;The Elements&lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;P&gt;1.
      Hydrogen&lt;/P&gt;
&lt;P&gt;2.
      Helium&lt;/P&gt;
&lt;/BODY&gt;
&lt;/HTML&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      <h4>Booleans</h4>
      
      <p class="GX">A boolean has one of two values: true or false. XSLT allows any kind of data to be transformed into a boolean. This is often
         done implicitly when a string or a number or a node set is used where a boolean is expected, as in the <code>test</code> attribute of an <code>xsl:if</code> element. These conversions can also be performed by the <code>boolean()</code> function which converts an argument of any type to a boolean according to these rules:
      </p>
      
      <ul>
         <li>A number is false if it's zero or NaN (a special symbol meaning Not a Number, used for the result of dividing by zero and
            similar illegal operations); true otherwise.
         </li>
         <li>An empty node set is false. All other node sets are true.</li>
         <li>An empty result tree fragment is false. All other result tree fragments are true.</li>
         <li>A zero length string is false. All other strings are true.</li>
      </ul>
      
      
      
      
      <p class="GX">Booleans are also produced as the result of expressions involving these operators:</p>
      
      <ul>
         <li><code>=</code>&nbsp;equal to
         </li>
         <li>!<code>=</code>&nbsp;not equal to
         </li>
         <li><code>&lt;</code>&nbsp;less than (really <code>&amp;lt;</code>)
         </li>
         <li><code>&gt;</code>&nbsp;greater than
         </li>
         <li><code>&lt;=</code>&nbsp;less than or equal to (really <code>&amp;lt;=</code>)
         </li>
         <li><code>&gt;=</code>&nbsp;greater than or equal to
         </li>
      </ul>
      
      
      
      
      
      
      <p class="SBT" style="font-weight: bold; margin-left: 0.5in; margin-right: 0.5in;        font-family: Arial, Helvetica, sans; color: #0000ff">Caution</p>
      
      <p class="SBT" style="font-family: Arial, Helvetica, sans;        margin-left: 0.5in; margin-right: 0.5in">The <code>&lt;</code> sign is illegal in attribute values. Consequently, it must be replaced by <code>&amp;lt;</code> even when used as the less-than operator.
      </p>
      
      <p class="GX">These operators are most commonly used in predicate tests to determine whether a rule should be invoked. An XPath expression
         can contain not only a pattern that selects certain nodes, but also a predicate that further filters the set of nodes selected.
         For example, <code>child::ATOM</code> selects all the <code>ATOM</code> children of the context node. However, <code>child::ATOM[position()=1]</code> selects only the first <code>ATOM</code> child of the context node. <code>[position()=1]</code> is a predicate on the node test <code>ATOM</code> that returns a boolean result: True if the position of the <code>ATOM</code> is equal to one; false otherwise. Each node test can have any number of predicates. However, more than one is unusual.
      </p>
      
      <p class="GX">For example, this template rule applies to the first <code>ATOM</code> element in the periodic table, but not to subsequent ones, by testing whether or not the position of the element equals 1.
      </p>
      <pre><code>&lt;xsl:template match="PERIODIC_TABLE/ATOM[position()=1]"&gt;
  &lt;xsl:value-of select="."/&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      <p class="GX">This template rule applies to all <code>ATOM</code> elements that are not the first child element of the <code>PERIODIC_TABLE</code> by testing whether the position is greater than 1:
      </p>
      <pre><code>&lt;xsl:template match="PERIODIC_TABLE/ATOM[position()&gt;1]"&gt;
  &lt;xsl:value-of select="."/&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      <p class="GX">The keywords <code>and</code> and <code>or</code> logically combine two boolean expressions according to the normal rules of logic. For example, suppose you want a template
         that matches an <code>ATOMIC_NUMBER</code> element that is both the first and last child of its parent element; that is, it is the only element of its parent. This
         template rule uses <code>and</code> to accomplish that:
      </p>
      <pre><code>&lt;xsl:template
 match="ATOMIC_NUMBER[position()=1 and position()=last()]"&gt;
  &lt;xsl:value-of select="."/&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      
      <p class="GX">If the first condition is false, then the complete <code>and</code> expression is guaranteed to be false. Consequently, the second condition won't be checked.
      </p>
      
      <p class="GX">This template matches both the first and last <code>ATOM</code> elements in their parent by matching when the position is 1 or when the position is equal to the number of elements in the
         set:
      </p>
      <pre><code>&lt;xsl:template match="ATOM[position()=1 or position()=last()]"&gt;
  &lt;xsl:value-of select="."/&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      <p class="GX">This is logical <code>or</code>, so it will also match if both conditions are true. That is, it will match an <code>ATOM</code> that is both the first and last child of its parent. If the first condition is true, then the complete <code>or</code> expression is guaranteed to be true. Consequently, the second condition won't be checked.
      </p>
      
      <p class="GX">The <code>not()</code> function reverses the result of an operation. For example, this template rule matches all <code>ATOM</code> elements that are not the first child of their parents:
      </p>
      <pre><code>&lt;xsl:template match="ATOM[not(position()=1)]"&gt;
  &lt;xsl:value-of select="."/&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      <p class="GX">The same template rule could be written using the not equal operator <code>!=</code> instead:
      </p>
      <pre><code>&lt;xsl:template match="ATOM[position()!=1]"&gt;
  &lt;xsl:value-of select="."/&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      <p class="GX">This template rule matches all <code>ATOM</code> elements that are neither the first nor last <code>ATOM</code> child of their parent:
      </p>
      <pre><code>&lt;xsl:template match =
 "ATOM[not(position()=1 or position()=last())]"&gt;
  &lt;xsl:value-of select="."/&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      
      <p class="GX">XSLT does not have an exclusive <code>or</code> operator. However, one can be formed by judicious use of <code>not()</code>, <code>and</code>, and <code>or</code>. For example, this rule selects those <code>ATOM</code> elements that are either the first or last child, but not both:
      </p>
      <pre><code>&lt;xsl:template
 match="ATOM[(position()=1 or position()=last())
              and not(position()=1 and position()=last())]"&gt;
  &lt;xsl:value-of select="."/&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      
      
      <p class="GX">There are three remaining functions that return booleans:</p>
      
      <ul>
         <li><span style="{font-family: Arial}"><span class="bold"></span></span><code>true()</code> always returns true
         </li>
         <li><code>false()</code> always returns false
         </li>
         <li><code>lang(</code><span class="italic"><code>code</code></span><code>)</code> returns true if the current node has the same language (as given by the <code>xml:lang</code> attribute) as the <span class="italic"><code>code</code></span> argument.
         </li>
      </ul>
      
      
      
      <h4>Numbers</h4>
      
      <p class="GX">XPath numbers are 64-bit IEEE 754 floating-point doubles. Even numbers like 42 or -7000 that look like integers are stored
         as doubles. Nonnumber values such as strings and booleans are converted to numbers automatically as necessary, or at user
         request through the <code>number()</code> function using these rules:
      </p>
      
      <ul>
         <li>Booleans are 1 if true; 0 if false.</li>
         <li>A string is trimmed of leading and trailing white space, then converted to a number in the fashion you would expect; for example,
            the string "12" is converted to the number 12. If the string cannot be interpreted as a number, then it is converted to the
            special symbol NaN, which stands for Not a Number.
         </li>
         <li>Node sets and result tree fragments are converted to strings; the string is then converted to a number.</li>
      </ul>
      
      
      
      <p class="GX">For example, this template only outputs the nonnaturally occurring transuranium elements; that is, those elements with atomic
         numbers greater than 92 (the atomic number of uranium). The node set produced by <code>ATOMIC_NUMBER</code> is implicitly converted to the string value of the current <code>ATOMIC_NUMBER</code> node. This string is then converted into a number.
      </p>
      <pre><code>&lt;xsl:template match="/PERIODIC_TABLE"&gt;
  &lt;HTML&gt;
    &lt;HEAD&gt;&lt;TITLE&gt;The Transuranium Elements&lt;/TITLE&gt;&lt;/HEAD&gt;
    &lt;BODY&gt;
      &lt;xsl:apply-templates select="ATOM[ATOMIC_NUMBER&gt;92]"/&gt;
    &lt;/BODY&gt;
  &lt;/HTML&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      
      
      
      
      
      <p class="GX">XPath provides the standard four arithmetic operators:</p>
      
      <ul>
         <li><code>+</code> for addition
         </li>
         <li><code>-</code> for subtraction
         </li>
         <li><code>*</code> for multiplication
         </li>
         <li><code>div</code> for division (the more common <code>/</code> is already used for other purposes in XPath)
         </li>
      </ul>
      
      
      
      
      <p class="GX">For example, <code>&lt;xsl:value-of select="2+2"/&gt;</code> inserts the string "4" into the output document. These operations are more commonly used as part of a test. For example,
         this rule selects those elements whose atomic weight is more than twice their atomic number:
      </p>
      <pre><code>&lt;xsl:template match="/PERIODIC_TABLE"&gt;
  &lt;HTML&gt;
    &lt;BODY&gt;
      &lt;H1&gt;High Atomic Weight to Atomic Number Ratios&lt;/H1&gt;
      &lt;xsl:apply-templates
        select="ATOM[ATOMIC_WEIGHT &gt; 2 * ATOMIC_NUMBER]"/&gt;
    &lt;/BODY&gt;
  &lt;/HTML&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      
      
      
      
      
      
      <p class="GX">This template actually prints the ratio of atomic weight to atomic number:</p>
      <pre><code>&lt;xsl:template match="ATOM"&gt;
  &lt;p&gt;
    &lt;xsl:value-of select="NAME"/&gt;
    &lt;xsl:value-of select="ATOMIC_WEIGHT div ATOMIC_NUMBER"/&gt;
  &lt;/p&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      
      
      
      <p class="GX">XPath also provides the less-familiar <code>mod</code> binary operator, which takes the remainder of two numbers. When used in conjunction with <code>position()</code> this operator lets you perform tasks such as outputting every second <code>ATOM</code> or alternating colors between rows in a table. Just define templates that apply different styles when the position mod two
         is one and when it's zero. For example, these two rules use different colors for alternate rows of a table:
      </p>
      <pre><code>   &lt;xsl:template match="ATOM[position() mod 2 = 1]"&gt;
       &lt;tr&gt;
        &lt;td&gt;&lt;xsl:value-of select="NAME"/&gt;&lt;/td&gt;
        &lt;td&gt;&lt;xsl:value-of select="ATOMIC_NUMBER"/&gt;&lt;/td&gt;
        &lt;td&gt;&lt;xsl:apply-templates select="MELTING_POINT"/&gt;&lt;/td&gt;
      &lt;/tr&gt;
   &lt;/xsl:template&gt;
   &lt;xsl:template match="ATOM[position() mod 2 = 0]"&gt;
       &lt;tr style="color: #666666"&gt;
        &lt;td&gt;&lt;xsl:value-of select="NAME"/&gt;&lt;/td&gt;
        &lt;td&gt;&lt;xsl:value-of select="ATOMIC_NUMBER"/&gt;&lt;/td&gt;
        &lt;td&gt;&lt;xsl:apply-templates select="MELTING_POINT"/&gt;&lt;/td&gt;
      &lt;/tr&gt;
   &lt;/xsl:template&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      
      
      <p class="GX">You can change the divisor to 3 to apply different styles to every third element, to 4 to apply different styles to every
         fourth element, and so forth.
      </p>
      
      <p class="GX">Finally, XPath includes four functions that operate on numbers:</p>
      
      <ul>
         <li><code>floor()</code> returns the greatest integer less than or equal to the number
         </li>
         <li><code>ceiling()</code> returns the smallest integer greater than or equal to the number
         </li>
         <li><code>round()</code> rounds the number to the nearest integer
         </li>
         <li><code>sum()</code> returns the sum of its arguments
         </li>
      </ul>
      
      
      
      
      <p class="GX">For example, this template rule estimates the number of neutrons in an atom by subtracting the atomic number (the number of
         protons) from the atomic weight (the weighted average over the natural distribution of isotopes of the number of neutrons
         plus the number of protons) and rounding to the nearest integer:
      </p>
      <pre><code>&lt;xsl:template match="ATOM"&gt;
  &lt;p&gt;
    &lt;xsl:value-of select="NAME"/&gt;
    &lt;xsl:value-of
     select="round(ATOMIC_WEIGHT - ATOMIC_NUMBER)"/&gt;
  &lt;/p&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      
      
      
      
      <p class="GX">This rule calculates the average atomic weight of all the atoms in the table by adding all the atomic weights, and then dividing
         by the number of atoms:
      </p>
      <pre><code>&lt;xsl:template match="/PERIODIC_TABLE"&gt;
  &lt;HTML&gt;
    &lt;BODY&gt;
    &lt;H1&gt;Average Atomic Weight&lt;/H1&gt;
      &lt;xsl:value-of
       select="sum(descendant::ATOMIC_WEIGHT)
               div count(descendant::ATOMIC_WEIGHT)"/&gt;
    &lt;/BODY&gt;
  &lt;/HTML&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      <h4>Strings</h4>
      
      <p class="GX">A string is a sequence of Unicode characters. Other data types can be converted to strings using the <code>string()</code> function according to these rules:
      </p>
      
      <ul>
         <li>Node sets are converted to strings by using the value of the first node in the set as calculated by the <code>xsl:value-of</code> element according to the rules given in Table 17-1.
         </li>
         <li>Result tree fragments are converted by acting as if they're contained in a single element, and then taking the value of that
            imaginary element. Again, the value of this element is calculated by the <code>xsl:value-of</code> element according to the rules given in Table 17-1. That is, all the result tree fragment's text (but not markup) is concatenated.
         </li>
         <li>A number is converted to a European-style number string like -12 or 3.1415292.</li>
         <li>Boolean false is converted to the English word false. Boolean true is converted to the English word true.</li>
      </ul>
      
      
      
      
      <p class="GX">Besides <code>string()</code>, XSLT contains 10 functions that manipulate strings. These are summarized in Table 17-5.
      </p>
      
      <p style="font-weight: bold; text-align: center; font-family: Arial, Helvetica, sans">Table 17-5: 
         XPath String Functions
      </p>
      
      
      <table border="1" summary="(unspecified contents)">
         
         <colgroup span="1">
            <col width="142" span="1">
            <col width="78" span="1">
            <col width="216" span="1">
         </colgroup>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p style="font-weight: bold; font-family: Arial, Helvetica, sans">Function: 
                  
               </p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p style="font-weight: bold; font-family: Arial, Helvetica, sans">Return Type: 
                  
               </p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p style="font-weight: bold; font-family: Arial, Helvetica, sans">Returns: 
                  
               </p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>starts-with(</code><span class="italic"><code>main_string</code></span><code>, </code><span class="italic"><code>prefix_string</code></span><code>)</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Boolean</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">True if <span class="italic"><code>main_string</code></span> starts with <span class="italic"><code>prefix_string</code></span>; false otherwise
               </p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>contains(</code><span class="italic"><code>containing_string</code></span><code>, </code><span class="italic"><code>contained_string</code></span><code>)</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Boolean</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">True if the <span class="italic"><code>contained_string</code></span> is part of the <span class="italic"><code>containing_string</code></span>; false otherwise
               </p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>substring(</code><span class="italic"><code>string</code></span><code>, </code><span class="italic"><code>offset, length</code></span><code>)</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">String</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><span class="italic"><code>length</code></span> characters from the specified <span class="italic"><code>offset</code></span> in <span class="italic"><code>string</code></span>; or all characters from the <span class="italic"><code>offset</code></span> to the end of the <span class="italic"><code>string</code></span> if <span class="italic"><code>length</code></span> is omitted; <span class="italic"><code>length</code></span> and <span class="italic"><code>offset</code></span> are rounded to the nearest integer if necessary
               </p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>substring-before(</code><span class="italic"><code>string</code></span><code>, </code><span class="italic"><code>marker-string</code></span><code>)</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">String</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">The part of the <span class="italic"><code>string</code></span> from the first character up to (but not including) the first occurrence of <span class="italic"><code>marker-string</code></span></p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>substring-after(</code><span class="italic"><code>string</code></span><code>, </code><span class="italic"><code>marker-string</code></span><code>)</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">String</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">The part of the <span class="italic"><code>string</code></span> from the end of the first occurrence of <span class="italic"><code>marker-string</code></span> to the end of <span class="italic"><code>string</code></span>; the first character in the string is at offset 1
               </p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>string-length(</code><span class="italic"><code>string</code></span><code>)</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Number</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">The number of characters in <span class="italic"><code>string</code></span></p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>normalize-space(</code><span class="italic"><code>string</code></span><code>)</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">String</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">The <span class="italic"><code>string</code></span> after leading and trailing white space is stripped and runs of white space are replaced with a single space; if the argument
                  is omitted the string value of the context node is normalized
               </p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>translate(</code><span class="italic"><code>string</code></span><code>, </code><span class="italic"><code>replaced_text</code></span><code>, </code><span class="italic"><code>replacement_text</code></span><code>)</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">String</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Returns <span class="italic"><code>string</code></span> with occurrences of characters in <span class="italic"><code>replaced_text</code></span> replaced by the corresponding characters from <span class="italic"><code>replacement_text</code></span></p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>concat(</code><span class="italic"><code>string1, string2, . . . </code></span><code>)</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">String</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Returns the concatenation of as many strings as are passed as arguments in the order they were passed</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>format-number(</code><span class="italic"><code>number</code></span><code>, </code><span class="italic"><code>format-string</code></span><code>, </code><span class="italic"><code>locale-string</code></span><code>)</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">String</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Returns the string form of <span class="italic"><code>number</code></span> formatted according to the specified <span class="italic"><code>format-string</code></span> as if by Java 1.1's<span class="italic"><code> </code></span><code>java.text.DecimalFormat</code> class (see <code>http://java.sun.com/products/jdk/1.1/docs/api/java.text.DecimalFormat.html</code>); the <span class="italic"><code>locale-string</code></span> is an optional argument that provides the name of the <code>xsl:decimal-format</code> element used to interpret the <span class="italic"><code>format-string</code></span></p>
               
            </td>
            
         </tr>
         
      </table>
      
      <h4>Result tree fragments</h4>
      
      <p class="GX">A result tree fragment is a portion of an XML document that is not a complete node or set of nodes. For instance, using the
         <code>document()</code> function with a URI that points into the middle of an element might produce a result tree fragment. Result tree fragments
         may also be returned by some extension functions (functions unique to a particular XSLT implementation or installation).
      </p>
      
      <p class="GX">Because result tree fragments aren't well-formed XML, you can't do much with them. In fact, the only allowed operations are
         to convert them to a string or a boolean using <code>string()</code> and <code>boolean()</code>, respectively.
      </p>
      
      <h2><a name="d1e6203">The Default Template Rules</a></h2>
      
      <p class="GX">Having to carefully map the hierarchy of an XML document in an XSLT style sheet may be inconvenient. This is especially true
         if the document does not follow a stable, predictable order like the periodic table, but rather throws elements together willy-nilly
         like many Web pages. In those cases, you should have general rules that can find an element and apply templates to it regardless
         of where it appears in the source document.
      </p>
      
      <p class="GX">To make this process easier, XSLT defines several default template rules that are implicitly included in all style sheets.
         The first default rule matches root and element nodes, and applies templates to all child nodes. The second default rule matches
         text nodes and attributes, copying their values onto the output stream. Together these two rules mean that even a blank XSLT
         style sheet with just one empty <code>xsl:stylesheet</code> element will still produce the raw character data of the input XML document as output.
      </p>
      
      <h3>The default rule for elements</h3>
      
      <p class="GX">The first default rule applies to element nodes and the root node:</p>
      <pre><code>&lt;xsl:template match="*|/"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      <p class="GX"><code>*|/</code> is XPath shorthand for "any element node or the root node." The purpose of this rule is to ensure that all elements are recursively
         processed even if they aren't reached by following the explicit rules. That is, unless another rule overrides this one (especially
         for the root element), all element nodes will be processed.
      </p>
      
      <p class="GX">However, once an explicit rule for any parent of an element is present, this rule will not be activated for the child elements
         unless the template rule for the parent has an <code>xsl:apply-templates</code> child. For instance, you can stop all processing by matching the root element and neither applying templates nor using <code>xsl:for-each</code> to process the children like this:
      </p>
      <pre><code>&lt;xsl:template match="/"&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      <h3>The default rule for text nodes and attributes</h3>
      
      <p class="GX">Exceptionally observant readers may have noted several of the examples seem to have output the contents of some elements without
         actually taking the value of the element they were outputting! These contents were provided by XSLT's default rule for text
         and attribute nodes. This rule is:
      </p>
      <pre><code>&lt;xsl:template match="text()|@*"&gt;
  &lt;xsl:value-of select="."/&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      <p class="GX">This rule matches all text and attribute nodes (<code>match="text()</code>|<code>@*"</code>) and outputs the value of the node (<code>&lt;xsl:value-of select="."/&gt;</code>). In other words, it copies the text from the input to the output. This rule ensures that at the very least an element's
         text is output, even if no rule specifically matches it. Another rule can override this one for specific elements where you
         want either more or less than the text content of an element.
      </p>
      
      <p class="GX">This rule also copies attribute values (but not names). However, they turn from attributes in the input to simple text in
         the output. Because there's no default rule that ever applies templates to attributes, this rule won't be activated for attributes
         unless you specifically add a nondefault rule somewhere in the style sheet that does apply templates to attributes of one
         or more elements.
      </p>
      
      <h3>The default rule for processing instructions and comments</h3>
      
      <p class="GX">There's also a default rule for processing instructions and comments. It simply says to do nothing; that is, drop the processing
         instructions and comments from the output as if they didn't exist. It looks like this:
      </p>
      <pre><code>&lt;xsl:template match="processing-instruction()|comment()"/&gt;
</code></pre>
      <p class="GX">You can, of course, replace this with your own rule for handling processing instructions and comments if you want to.</p>
      
      <h3>Implications of the default rules</h3>
      
      <p class="GX">Together, the default rules imply that applying an empty style sheet with only an <code>xsl:stylesheet</code> or <code>xsl:transform</code> element but no children (such as Listing 17-14) to an XML document copies all the <code>#PCDATA</code> out of the elements in the input to the output. However, this method produces no markup. These are, however, extremely low
         priority rules. Consequently, any other matches take precedence over the default rules.
      </p>
      
      <p style="font-weight: bold">Listing 17-14: 
         An empty XML style sheet
      </p>
      
      <pre><code>&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
&lt;/xsl:stylesheet&gt;
</code></pre>
      
      
      <p class="SBT" style="font-weight: bold; margin-left: 0.5in; margin-right: 0.5in;        font-family: Arial, Helvetica, sans; color: #0000ff">Caution</p>
      
      <p class="SBT" style="font-family: Arial, Helvetica, sans;        margin-left: 0.5in; margin-right: 0.5in">One of the most common sources of confusion about XSLT in Internet Explorer 5.5 and earlier is that IE does not provide any
         of these default rules. You have to make sure that you explicitly match any node whose contents (including descendants) you
         want to output.
      </p>
      
      <h2><a name="d1e6328">Deciding What Output to Include</a></h2>
      
      <p class="GX">It's often necessary to defer decisions about what markup to emit until the input document has been read. For instance, you
         may want to change the contents of a <code>FILENAME</code> element into the <code>HREF</code> attribute of an <code>A</code> element, or replace one element type in the input with several different element types in the output depending on the value
         of an attribute. This is accomplished with <code>xsl:element</code>, <code>xsl:attribute</code>, <code>xsl:processing-instruction</code>, <code>xsl:comment</code>, and <code>xsl:text</code> elements. XSLT instructions are used in the contents of these elements and attribute value templates are used in the attribute
         values of these elements to vary their output.
      </p>
      
      <h3>Attribute value templates</h3>
      
      <p class="GX">Attribute value templates copy data from the input document to attribute values in the output. For example, suppose you want
         to convert the periodic table into empty <code>ATOM</code> elements with this attribute-based form:
      </p>
      <pre><code>&lt;ATOM NAME="Vanadium"
  ATOMIC_WEIGHT="50.9415"
  ATOMIC_NUMBER="23"
/&gt;
</code></pre>
      
      
      
      <p class="GX">To do this, you need to extract the contents of elements in the input document and place those in attribute values in the
         output document. The first thing you're likely to attempt is something similar to this:
      </p>
      <pre><code>&lt;xsl:template match="ATOM"&gt;
  &lt;ATOM NAME="&lt;xsl:value-of select='NAME'/&gt;"
    ATOMIC_WEIGHT="&lt;xsl:value-of select='ATOMIC_WEIGHT'/&gt;"
    ATOMIC_NUMBER="&lt;xsl:value-of select='ATOMIC_NUMBER'/&gt;"
  /&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      
      
      
      <p class="GX">But this is malformed XML. You can't use the <code>&lt;</code> character inside an attribute value. Furthermore, it's extremely difficult to write software that can parse this in its most
         general case.
      </p>
      
      <p class="GX">Instead, inside attribute values, data enclosed in curly braces <code>{}</code> takes the place of the <code>xsl:value-of</code> element. The correct way to write the above template is like this:
      </p>
      <pre><code>&lt;xsl:template match="ATOM"&gt;
  &lt;ATOM NAME="{NAME}"/&gt;
    ATOMIC_WEIGHT="{ATOMIC_WEIGHT}"
    ATOMIC_NUMBER="{ATOMIC_NUMBER}"
  /&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      
      
      
      <p class="GX">In the output, <code>{NAME}</code> is replaced by the value of the <code>NAME</code> child element of the matched <code>ATOM</code>. <code>{ATOMIC_WEIGHT}</code> is replaced by the value of the <code>ATOMIC_WEIGHT</code> child element of the matched <code>ATOM</code>. <code>{ATOMIC_NUMBER}</code> is replaced by the value of the <code>ATOMIC_NUMBER</code> child element, and so on.
      </p>
      
      <p class="GX">Attribute value templates can have more complicated patterns than merely an element name. In fact, you can use any XPath expression
         in an attribute value template. For example, this template rule selects <code>DENSITY</code> elements in the form used in Listing 17-1.
      </p>
      <pre><code>&lt;xsl:template match="DENSITY"&gt;
  &lt;BULK_PROPERTY
    NAME="DENSITY"
    ATOM="{../NAME}"
    VALUE="{normalize-space(.)}"
    UNITS="{@UNITS}"
  /&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      
      
      
      
      
      <p class="GX">It converts them into <code>BULK_PROPERTY</code> elements that look like this:
      </p>
      <pre><code>&lt;BULK_PROPERTY NAME="DENSITY" ATOM="Helium"
  VALUE="0.0001785" UNITS="grams/cubic centimeter"/&gt;
</code></pre>
      
      <p class="GX">Attribute values are not limited to a single attribute value template. You can combine an attribute value template with literal
         data or with other attribute value templates. For example, this template rule matches <code>ATOM</code> elements and replaces them with their name formatted as a link to a file in the format H.html, He.html, and so on. The filename
         is derived from the attribute value template <code>{SYMBOL}</code>, while the literal data provides the period and extension.
      </p>
      <pre><code>&lt;xsl:template match="ATOM"&gt;
  &lt;A HREF="{SYMBOL}.html"&gt;
    &lt;xsl:value-of select="NAME"/&gt;
  &lt;/A&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      
      
      <p class="GX">More than one attribute value template can be included in an attribute value. For example, this template rule includes the
         density units as part of the <code>VALUE</code> attribute rather than making them a separate attribute:
      </p>
      <pre><code>&lt;xsl:template match="DENSITY"&gt;
  &lt;BULK_PROPERTY
    NAME="DENSITY"
    ATOM="{../NAME}"
    VALUE="{normalize-space(.)} {@UNITS}"
  /&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      
      
      
      
      <p class="GX">You can use attribute value templates in many attributes in an XSLT style sheet. This is particularly important in <code>xsl:element</code>, <code>xsl:attribute</code>, and <code>xsl:processing-instruction</code> elements where attribute value templates allow the designer to defer the decision about exactly what element, attribute,
         or processing instruction appears in the output until the input document is read. You cannot use attribute value templates
         as the value of a <code>select</code> or <code>match</code> attribute, an <code>xmlns</code> attribute, an attribute that provides the name of another XSLT instruction element, or an attribute of a top-level element
         (one that's an immediate child of <code>xsl:stylesheet</code>).
      </p>
      
      <h3>Inserting elements into the output with xsl:element</h3>
      
      <p class="GX">Elements are usually included in the output document simply by including the literal start and end tags in template content.
         For instance, to insert a <code>P</code> element you merely type <code>&lt;P&gt;</code> and <code>&lt;/P&gt;</code> at the appropriate points in the style sheet. However, occasionally you need to use details from the input document to determine
         which element to place in the output document. This might happen, for example, when making a transformation from a source
         vocabulary that uses attributes for information to an output vocabulary that uses elements for the same information.
      </p>
      
      <p class="GX">The <code>xsl:element</code> element inserts an element into the output document. The name of the element is given by an attribute value template in the
         <code>name</code> attribute of <code>xsl:element</code>. The content of the element derives from the content of the <code>xsl:element</code> element, which may include <code>xsl:attribute</code>, <code>xsl:processing-instruction,</code> and <code>xsl:comment</code> instructions (all discussed below) to insert these items.
      </p>
      
      <p class="GX">For example, suppose you want to replace the <code>ATOM</code> elements with <code>GAS</code>, <code>LIQUID</code>, and <code>SOLID</code> elements, depending on the value of the <code>STATE</code> attribute. Using <code>xsl:element</code>, a single rule can do this by converting the value of the <code>STATE</code> attribute to an element name. This is how it works:
      </p>
      <pre><code>&lt;xsl:template match="ATOM"&gt;
  &lt;xsl:element name="{@STATE}"&gt;
    &lt;NAME&gt;&lt;xsl:value-of select="NAME"/&gt;&lt;/NAME&gt;
    &lt;!-- rules for other children --&gt;
  &lt;/xsl:element&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      
      
      
      <p class="GX">By using more complicated attribute value templates, you can perform most of the calculations that you might need.</p>
      
      <h3>Inserting attributes into the output with xsl:attribute</h3>
      
      <p class="GX">You can include attributes in the output document simply by typing the literal attributes themselves. For instance, to insert
         a <code>DIV</code> element with an <code>ALIGN</code> attribute bearing the value <code>CENTER</code>, you merely type <code>&lt;DIV ALIGN="CENTER"&gt;</code> and <code>&lt;/DIV&gt;</code> at the appropriate points in the style sheet. However, you frequently have to rely on data that you read from the input document
         to determine an attribute value and sometimes even to determine the attribute name.
      </p>
      
      <p class="GX">For example, suppose you want a style sheet that selects atom names and formats them as links to files named H.html, He.html,
         Li.html, and so forth like this:
      </p>
      <pre><code>&lt;LI&gt;&lt;A HREF="H.html"&gt;Hydrogen&lt;/A&gt;&lt;/LI&gt;
&lt;LI&gt;&lt;A HREF="He.html"&gt;Helium&lt;/A&gt;&lt;/LI&gt;
&lt;LI&gt;&lt;A HREF="Li.html"&gt;Lithium&lt;/A&gt;&lt;/LI&gt;
</code></pre>
      
      
      <p class="GX">Each different element in the input will have a different value for the <code>HREF</code> attribute. The <code>xsl:attribute</code> element calculates an attribute name and value and inserts it into the output. Each <code>xsl:attribute</code> element is a child of either an <code>xsl:element</code> element or a literal element. The attribute calculated by <code>xsl:attribute</code> will be attached to the element calculated by its parent in the output. The name of the attribute is specified by the <code>name</code> attribute of the <code>xsl:attribute</code> element. The value of the attribute is given by the contents of the <code>xsl:attribute</code> element. For example, this template rule produces the output shown above:
      </p>
      <pre><code>&lt;xsl:template match="ATOM"&gt;
  &lt;LI&gt;&lt;A&gt;
    &lt;xsl:attribute name="HREF"&gt;
      &lt;xsl:value-of select="SYMBOL"/&gt;.html
    &lt;/xsl:attribute&gt;
    &lt;xsl:value-of select="NAME"/&gt;
  &lt;/A&gt;&lt;/LI&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      
      
      
      
      
      <p class="GX">All <code>xsl:attribute</code> elements must come before any other content of their parent element. You can't add an attribute to an element after you've
         already started writing out its content. For example, this template is illegal:
      </p>
      <pre><code>&lt;xsl:template match="ATOM"&gt;
  &lt;LI&gt;&lt;A&gt;
    &lt;xsl:value-of select="NAME"/&gt;
    &lt;xsl:attribute name="HREF"&gt;
      &lt;xsl:value-of select="SYMBOL"/&gt;.html
    &lt;/xsl:attribute&gt;
  &lt;/A&gt;&lt;/LI&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      
      
      
      
      
      <h3>Defining attribute sets</h3>
      
      <p class="GX">You often need to apply the same group of attributes to many different elements, of either the same or different classes.
         For instance, you might want to apply a <code>style</code> attribute to each cell in an HTML table. To make this simpler, you can define one or more attributes as members of an attribute
         set at the top level of the style sheet with <code>xsl:attribute-set</code>, and then include that attribute set in an element with an <code>xsl:use-attribute-sets</code> attribute.
      </p>
      
      <p class="GX">For example, this <code>xsl:attribute-set</code> element defines an element named <code>cellstyle</code> with a <code>font-family</code> attribute of <code>New York</code>, <code>Times</code> <code>New Roman</code>, <code>Times</code>, <code>serif</code> and a <code>font-size</code> attribute of <code>12pt</code>.
      </p>
      <pre><code>&lt;xsl:attribute-set name="cellstyle"&gt;
  &lt;xsl:attribute name="font-family"&gt;
    New York, Times New Roman, Times, serif
  &lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="font-size"&gt;12pt&lt;/xsl:attribute&gt;
&lt;/xsl:attribute-set&gt;
</code></pre>
      
      
      
      
      
      <p class="GX">This template rule then applies those attributes to <code>td</code> elements in the output.
      </p>
      <pre><code>&lt;xsl:template match="ATOM"&gt;
  &lt;tr&gt;
    &lt;td xsl:use-attribute-sets="cellstyle"&gt;
      &lt;xsl:value-of select="NAME"/&gt;
    &lt;/td&gt;
    &lt;td xsl:use-attribute-sets="cellstyle"&gt;
      &lt;xsl:value-of select="ATOMIC_NUMBER"/&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      <p class="GX">An element can use more than one attribute set by specifying the names of the all the sets in a white space separated list
         in the value of the <code>xsl:use-attribute-sets</code> attribute. All attributes from all the sets are applied to the element. For example, this <code>td</code> element possesses attributes from both the <code>cellstyle</code> and the <code>numberstyle</code> attribute sets.
      </p>
      <pre><code>    &lt;td xsl:use-attribute-sets="cellstyle numberstyle"&gt;
      &lt;xsl:value-of select="ATOMIC_NUMBER"/&gt;
    &lt;/td&gt;
</code></pre>
      
      
      <p class="GX">If more than one attribute set defines the same attribute, then the last attribute set mentioned is used. If there is more
         than one attribute set with the same name (as may happen when one style sheet imports another) then the attributes in the
         sets are merged. If the identically named attribute sets define the same attribute, then the value from the set with higher
         importance is chosen. A style sheet in which multiple attribute sets of the same importance with the same name define the
         same attribute is in error.
      </p>
      
      <p class="GX">You can also include attribute sets in particular elements by adding a <code>use-attribute-sets</code> element to an <code>xsl:element</code>, <code>xsl:copy</code>, or <code>xsl:attribute-set</code> element. For example,
      </p>
      <pre><code>    &lt;xsl:element name="td" use-attribute-sets="cellstyle"&gt;
      &lt;xsl:value-of select="ATOMIC_NUMBER"/&gt;
    &lt;/xsl:element&gt;
</code></pre>
      
      
      <p class="GX">The <code>xsl:</code> prefix is unnecessary (and in fact prohibited) when <code>use-attribute-sets</code> is an attribute of an XSLT element rather than an element from the result set.
      </p>
      
      <h3>Generating processing instructions with xsl:processing-instruction</h3>
      
      <p class="GX">The <code>xsl:processing-instruction</code> element places a processing instruction in the output document. The target of the processing instruction is specified by
         a required <code>name</code> attribute. The contents of the <code>xsl:processing-instruction</code> element become the contents of the processing instruction. For example, this rule replaces <code>PROGRAM</code> elements with a <code>gcc</code> processing instruction:
      </p>
      <pre><code>&lt;xsl:template match="PROGRAM"&gt;
  &lt;xsl:processing-instruction name="gcc"&gt; -O4
  &lt;/xsl:processing-instruction&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      
      <p class="GX"><code>PROGRAM</code> elements in the input are replaced by this processing instruction in the output:
      </p>
      <pre><code>&lt;?gcc -O4
  ?&gt;
</code></pre>
      
      <p class="GX">The contents of the <code>xsl:processing-instruction</code> element can include <code>xsl:value-of</code> elements and <code>xsl:apply-templates</code> elements provided the result of these instructions is pure text. For example,
      </p>
      <pre><code>&lt;xsl:template match="PROGRAM"&gt;
  &lt;xsl:processing-instruction name="gcc"&gt;-O4 
    &lt;xsl:value-of select="NAME"/&gt;
  &lt;/xsl:processing-instruction&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      
      
      <p class="GX">The <code>xsl:processing-instruction</code> element may not contain <code>xsl:element</code> and other instructions that produce elements and attributes in the result. Furthermore, <code>xsl:processing-instruction</code> may not include any instructions or literal text that insert a <code>?&gt;</code> in the output because that would prematurely end the processing instruction.
      </p>
      
      <h3>Generating comments with xsl:comment</h3>
      
      <p class="GX">The <code>xsl:comment</code> element inserts a comment in the output document. It has no attributes. Its contents are the text of the comment. For example,
      </p>
      <pre><code>&lt;xsl:template match="ATOM"&gt;
  &lt;xsl:comment&gt;There was an atom here once.&lt;/xsl:comment&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      <p class="GX">This rule replaces <code>ATOM</code> nodes with this comment:
      </p>
      <pre><code>&lt;!--There was an atom here once.--&gt;
</code></pre>
      <p class="GX">The contents of the <code>xsl:comment</code> element can include <code>xsl:value-of</code> elements and <code>xsl:apply-templates</code> elements provided the results of these instructions are pure text. It may not contain <code>xsl:element</code> and other instructions that produce elements and attributes in the result. Furthermore, <code>xsl:comment</code> may not include any instructions or literal text that inserts a double hyphen in the comment. This would result in a malformed
         comment in the output.
      </p>
      
      <h3>Generating text with xsl:text</h3>
      
      <p class="GX">The <code>xsl:text</code> element inserts its contents into the output document as literal text. For example, this rule replaces each <code>ATOM</code> element with the string "There was an atom here once."
      </p>
      <pre><code>&lt;xsl:template match="ATOM"&gt;
  &lt;xsl:text&gt;There was an atom here once.&lt;/xsl:text&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      <p class="GX">The <code>xsl:text</code> element isn't much used because most of the time it's easier to simply type the text. However, <code>xsl:text</code> does have a couple of advantages. The first is that it preserves white space exactly, even if the node contains nothing but
         white space. By default, XSLT processors delete all text nodes from the style sheet that contain only white space. This is
         useful when dealing with poetry, computer source code, or other text in which white space is significant.
      </p>
      
      <p class="GX">The second advantage is that it enables you to insert unescaped <code>&lt;</code> and <code>&amp;</code> into your output document that are not converted to <code>&amp;lt;</code> and <code>&amp;amp;</code>. To do this, place the general entity reference for the symbol (<code>&amp;lt;</code> or <code>&amp;amp;</code>) in an <code>xsl:text</code> element; then set the <code>xsl:text</code> element's <code>disable-output-escaping</code> attribute to <code>yes</code>. This can be useful when you need to include JavaScript source code in the output document. For example,
      </p>
      <pre><code>&lt;xsl:template match="SCRIPT"&gt;
  &lt;script language="javascript"&gt;
    &lt;xsl:text disable-output-escaping="yes"&gt;
      &amp;lt;!-- if (
         location.host.tolowercase().indexof("ibiblio")
         &amp;lt; 0) {
           location.href="http://www.cafeconleche.org/";
        }
      } // --&amp;gt;
    &lt;/xsl:text&gt;
  &lt;/script&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      <p class="GX">This may produce output that is not well-formed XML. (Indeed that's the case here.) However, if you're trying to write a non-XML
         format such as HTML or TeX this may be what you want. Note, however, that the style sheet and the input document are both
         still well-formed XML.
      </p>
      
      <h2><a name="d1e7170">Copying the Context Node with xsl:copy</a></h2>
      
      <p class="GX">The <code>xsl:copy</code> element copies the source node into the output tree. Child elements, attributes, and other content are not automatically
         copied. However, the contents of the <code>xsl:copy</code> element are an <code>xsl:template</code> element that can select these things to be copied as well. This is often useful when transforming a document from one markup
         vocabulary to the same or a closely related markup vocabulary. For example, this template rule strips the attributes and child
         elements off an <code>ATOM</code> and replaces it with the value of its contents enclosed in a <code>b</code> element:
      </p>
      <pre><code>&lt;xsl:template match="ATOM"&gt;
   &lt;xsl:copy&gt;
     &lt;b&gt;&lt;xsl:value-of select="."/&gt;&lt;/b&gt;
   &lt;/xsl:copy&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      
      
      <p class="GX">One useful template <code>xsl:copy</code> makes possible is the identity transformation; that is, a transformation from a document into itself. Such a transformation
         looks like this:
      </p>
      <pre><code>&lt;xsl:template 
  match="*|@*|comment()|processing-instruction()|text()"&gt;
  &lt;xsl:copy&gt;
    &lt;xsl:apply-templates
     select="*|@*|comment()|processing-instruction()|text()"/&gt;
  &lt;/xsl:copy&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      
      
      
      
      <p class="GX">You can adjust the identity transformation a little to produce similar documents. For example, Listing 17-15 is a style sheet
         that strips comments from a document, leaving the document otherwise untouched. It resulted from leaving the <code>comment()</code> node out of the <code>match</code> and <code>select</code> attribute values in the identity transformation.
      </p>
      
      <p style="font-weight: bold">Listing 17-15: 
         An XSLT style sheet that strips comments from a document
      </p>
      
      <pre><code>&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:template 
     match="*|@*|processing-instruction()|text()"&gt;
    &lt;xsl:copy&gt;
      &lt;xsl:apply-templates
        select="*|@*|processing-instruction()|text()"/&gt;
    &lt;/xsl:copy&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      <p class="GX"><code>xsl:copy</code> only copies the source node. You can copy other nodes, possibly more than one of them, using <code>xsl:copy-of</code>. The <code>select</code> attribute of <code>xsl:copy-of</code> chooses the nodes to be copied. For example, Listing 17-16 is a style sheet that uses <code>xsl:copy-of</code> to strip out elements without melting points from the periodic table by copying only <code>ATOM</code> elements that have <code>MELTING_POINT</code> children.
      </p>
      
      <p style="font-weight: bold">Listing 17-16: 
         A style sheet that copies only ATOM elements that have MELTING_POINT children
      </p>
      
      <pre><code>&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
    &lt;xsl:template match="/PERIODIC_TABLE"&gt;
      &lt;PERIODIC_TABLE&gt;
        &lt;xsl:apply-templates select="ATOM"/&gt;
      &lt;/PERIODIC_TABLE&gt;
    &lt;/xsl:template&gt;
    &lt;xsl:template match="ATOM"&gt;
      &lt;xsl:apply-templates select="MELTING_POINT"/&gt;
    &lt;/xsl:template&gt;
   &lt;xsl:template match="MELTING_POINT"&gt;
     &lt;xsl:copy-of select=".."/&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <p class="SBT" style="font-weight: bold; margin-left: 0.5in; margin-right: 0.5in;        font-family: Arial, Helvetica, sans; color: #0000ff">Note</p>
      
      <p class="SBT" style="font-family: Arial, Helvetica, sans;        margin-left: 0.5in; margin-right: 0.5in">Listings 17-15 and 17-16 are examples of XSL transformations from a source vocabulary to the same vocabulary. Unlike most
         of the examples in this chapter, they do not transform to well-formed HTML.
      </p>
      
      <h2><a name="d1e7364">Counting Nodes with xsl:number</a></h2>
      
      <p class="GX">The <code>xsl:number</code> element inserts a formatted integer into the output document. The value of the integer is given by the <code>value</code> attribute. This contains a number, which is rounded to the nearest integer, then formatted according to the value of the
         <code>format</code> attribute. Reasonable defaults are provided for both these attributes. For example, consider the style sheet for the <code>ATOM</code> elements in Listing 17-17.
      </p>
      
      <p style="font-weight: bold">Listing 17-17: 
         An XSLT style sheet that counts atoms
      </p>
      
      <pre><code>&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
    &lt;xsl:template match="PERIODIC_TABLE"&gt;
      &lt;html&gt;
        &lt;head&gt;&lt;title&gt;The Elements&lt;/title&gt;&lt;/head&gt;
        &lt;body&gt;
          &lt;table&gt;
            &lt;tr&gt;&lt;xsl:apply-templates select="ATOM"/&gt;&lt;/tr&gt;
          &lt;/table&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    &lt;/xsl:template&gt;
    &lt;xsl:template match="ATOM"&gt;
      &lt;td&gt;&lt;xsl:number value="ATOMIC_NUMBER"/&gt;&lt;/td&gt;    
      &lt;td&gt;&lt;xsl:value-of select="NAME"/&gt;&lt;/td&gt;
    &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <p class="GX">When this style sheet is applied to Listing 17-1, the output appears like this:</p>
      <pre><code>&lt;html&gt;
&lt;head&gt;
&lt;title&gt;The Elements&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;&lt;td&gt;Hydrogen&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;Helium&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      <p class="GX">Each element is matched with its atomic number. The <code>value</code> attribute can contain any data that XPath knows how to convert to a number. In this case, the <code>ATOMIC_NUMBER</code> child element of the matched <code>ATOM</code> is converted.
      </p>
      
      <h3>Default numbers</h3>
      
      <p class="GX">If you use the <code>value</code> attribute to calculate the number, that's all you need. However, if the <code>value</code> attribute is omitted, then the position of the current node in the source tree is used as the number. For example, consider
         Listing 17-18, which produces a table of atoms that have boiling points less than or equal to the boiling point of nitrogen.
      </p>
      
      <p style="font-weight: bold">Listing 17-18: 
         An XSLT style sheet that counts atoms
      </p>
      
      <pre><code>&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
    &lt;xsl:template match="PERIODIC_TABLE"&gt;
      &lt;html&gt;
        &lt;head&gt;&lt;title&gt;The Elements&lt;/title&gt;&lt;/head&gt;
        &lt;body&gt;
          &lt;table&gt;
            &lt;tr&gt;
              &lt;td&gt;Name&lt;/td&gt;
              &lt;td&gt;Position&lt;/td&gt;
              &lt;td&gt;Default Number&lt;/td&gt;
              &lt;td&gt;Boiling Point&lt;/td&gt;
            &lt;/tr&gt;
            &lt;xsl:apply-templates 
              select="ATOM[BOILING_POINT &amp;lt;= 77.344]"/&gt;
          &lt;/table&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    &lt;/xsl:template&gt;
    &lt;xsl:template match="ATOM"&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;xsl:value-of select="NAME"/&gt;&lt;/td&gt;
        &lt;td&gt;&lt;xsl:number value="position()"/&gt;&lt;/td&gt;
        &lt;td&gt;&lt;xsl:number/&gt;&lt;/td&gt;
        &lt;td&gt;&lt;xsl:number value="BOILING_POINT"/&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <p class="GX">Figure 17-5 shows the finished table produced by applying this stylesheet to the complete periodic table. This shows that
         the default value calculated by <code>xsl:number</code> is the position of the node among other sibling nodes of the same type (<code>ATOM</code> elements in this case) . This is not the same as the number returned by the <code>position()</code> function, which only calculates position relative to other nodes in the context node list (the nodes which the template matched
         &#8212; hydrogen, helium, nitrogen, and neon in this example). You can change what <code>xsl:number</code> counts using these three attributes:
      </p>
      
      <ul>
         <li><code>level</code></li>
         <li><code>count</code></li>
         <li><code>from</code></li>
      </ul>
      
      
      
      <div align="center"><img src="17/picture9.jpg" width="240" height="145" alt="Image: 17/picture9.jpg"></div>
      
      
      <p style="font-weight: bold">Figure 17-5: 
         Atoms with boiling points less than or equal to nitrogen's
      </p>
      
      
      <h4>The level attribute</h4>
      
      <p class="GX">By default, with no <code>value</code> attribute, <code>xsl:number</code> counts siblings of the source node with the same type. For instance, if the <code>ATOMIC_NUMBER</code> elements were numbered instead of <code>ATOM</code> elements, none would have a number higher than 1 because an <code>ATOM</code> never has more than one <code>ATOMIC_NUMBER</code> child. Although the document contains more than one <code>ATOMIC_NUMBER</code> element, these are not siblings.
      </p>
      
      <p class="GX">Setting the <code>level</code> attribute of <code>xsl:number</code> to <code>any</code> counts all of the elements of the same kind as the current node in the document. This includes not just the ones in the current
         node list, but all nodes of the same type. Even if you select only the atomic numbers of the gases, for example, the solids
         and liquids would still count, even if they weren't output. Consider these rules:
      </p>
      <pre><code>&lt;xsl:template match="ATOM"&gt;
  &lt;tr&gt;&lt;xsl:apply-templates select="NAME"/&gt;&lt;/tr&gt;
&lt;/xsl:template&gt;
&lt;xsl:template match="NAME"&gt;
  &lt;td&gt;&lt;xsl:number level="any"/&gt;&lt;/td&gt;
  &lt;td&gt;&lt;xsl:value-of select="."/&gt;&lt;/td&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      
      
      
      
      <p class="GX">Because <code>level</code> is set to <code>any</code>, these templates produce output like this that doesn't start from 1 with each new <code>NAME</code> element:
      </p>
      <pre><code>&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;&lt;td&gt;Hydrogen&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;&lt;td&gt;Helium&lt;/td&gt;
&lt;/tr&gt;
</code></pre>
      
      
      
      
      
      <p class="GX">If you remove the <code>level</code> attribute or set it to its default value of <code>single</code>, then the output looks like this:
      </p>
      <pre><code>&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;&lt;td&gt;Hydrogen&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;&lt;td&gt;Helium&lt;/td&gt;
&lt;/tr&gt;
</code></pre>
      
      
      
      
      
      <p class="GX">A slightly less useful option sets the <code>level</code> attribute of <code>xsl:number</code> to <code>multiple</code> to specify that both the siblings of the current node and its ancestors (but not their children that aren't siblings of the
         current node) should be counted.
      </p>
      
      <h4>The count attribute</h4>
      
      <p class="GX">By default, with no <code>value</code> attribute, only elements of the same type as the element of the current node get counted. However, you can set the <code>count</code> attribute of <code>xsl:number</code> to an expression that specifies what to count. For instance, this rule matches all the child elements of an <code>ATOM</code>. It places a number in front of each one that represents its position among all the children of that <code>ATOM</code>.
      </p>
      <pre><code>&lt;xsl:template match="ATOM/*"&gt;
  &lt;td&gt;&lt;xsl:number count="*"/&gt;&lt;/td&gt;
  &lt;td&gt;&lt;xsl:value-of select="."/&gt;&lt;/td&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      
      <p class="GX">The output from this template looks like this:</p>
      <pre><code>    &lt;td&gt;1&lt;/td&gt;&lt;td&gt;Hydrogen&lt;/td&gt;
    &lt;td&gt;2&lt;/td&gt;&lt;td&gt;H&lt;/td&gt;
    &lt;td&gt;3&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;
    &lt;td&gt;4&lt;/td&gt;&lt;td&gt;1.00794&lt;/td&gt;
    &lt;td&gt;5&lt;/td&gt;&lt;td&gt;20.28&lt;/td&gt;
    &lt;td&gt;6&lt;/td&gt;&lt;td&gt;13.81&lt;/td&gt;
    &lt;td&gt;7&lt;/td&gt;&lt;td&gt;
      0.0000899
    &lt;/td&gt;
    &lt;td&gt;1&lt;/td&gt;&lt;td&gt;Helium&lt;/td&gt;
    &lt;td&gt;2&lt;/td&gt;&lt;td&gt;He&lt;/td&gt;
    &lt;td&gt;3&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;
    &lt;td&gt;4&lt;/td&gt;&lt;td&gt;4.0026&lt;/td&gt;
    &lt;td&gt;5&lt;/td&gt;&lt;td&gt;4.216&lt;/td&gt;
    &lt;td&gt;6&lt;/td&gt;&lt;td&gt;0.95&lt;/td&gt;
    &lt;td&gt;7&lt;/td&gt;&lt;td&gt;
      0.0001785
    &lt;/td&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <h4>The from attribute</h4>
      
      <p class="GX">The <code>from</code> attribute contains an XPath expression that specifies which element the counting begins with in the input tree. However,
         the counting still begins from 1, not 2 or 10 or some other number. The <code>from</code> attribute only changes which element is considered to be the first element. This attribute is only considered when <code>level="any"</code>. Other times it has no effect.
      </p>
      
      <h3>Number to string conversion</h3>
      
      <p class="GX">Until now, I've implicitly assumed that numbers looked like 1, 2, 3, and so on; that is, a European numeral starting from
         1 and counting by 1. However, that's not the only possibility. For instance, the page numbers in the preface and other front
         matter of books often appear in small Roman numerals like i, ii, iii, iv, and so on. And different countries use different
         conventions to group the digits, separate the integer and fractional parts of a real number, and represent the symbols for
         the various digits. These are all adjustable through four attributes of <code>xsl:number</code>:
      </p>
      
      <ul>
         <li><code>format</code></li>
         <li><code>letter-value</code></li>
         <li><code>grouping-separator</code></li>
         <li><code>grouping-size</code></li>
      </ul>
      
      
      
      
      <h4>The format attribute</h4>
      
      <p class="GX">You can adjust the numbering style used by <code>xsl:number</code> using the <code>format</code> attribute. This attribute generally has one of the following values:
      </p>
      
      <ul>
         <li><code>i</code>: the lowercase Roman numerals i, ii, iii, iv, v, vi, . . .
         </li>
         <li><code>I</code>: the uppercase Roman numerals I, II, III, IV, V, VI, . . .
         </li>
         <li><code>a</code>: the lowercase letters a, b, c, d, e, f, . . .
         </li>
         <li><code>A</code>: the uppercase letters A, B, C, D, E, F, . . .
         </li>
      </ul>
      
      
      
      
      <p class="GX">For example, this rule numbers the atoms with capital Roman numerals:</p>
      <pre><code>&lt;xsl:template match="ATOM"&gt;
  &lt;P&gt;
    &lt;xsl:number value="position()" format="I"/&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/P&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      
      
      
      <p class="GX">You can specify decimal numbering with leading zeroes by including the number of leading zeroes you want in the <code>format</code> attribute. For instance, setting <code>format="01"</code>, produces the sequence 01, 02, 03, 04, 05, 06, 07, 08, 09, 10, 11, 12, . . . . You might find this useful when lining numbers
         up in columns.
      </p>
      
      <h4>The letter-value attribute</h4>
      
      <p class="GX">The <code>letter-value</code> attribute distinguishes between letters interpreted as numbers and letters interpreted as letters. For instance, if you want
         to use <code>format="I"</code> to start the sequence I, J, K, L, M, N, . . . instead of I, II, III, IV, V, VI, . . . you would set the <code>letter-value</code> attribute to the keyword <code>alphabetic</code>. The keyword <code>traditional</code> specifies a numeric sequence. For example,
      </p>
      <pre><code>&lt;xsl:template match="ATOM"&gt;
  &lt;P&gt;
   &lt;xsl:number value="position()"
               format="I" letter-value="alphabetic"/&gt;
   &lt;xsl:value-of select="."/&gt;
  &lt;/P&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      
      
      
      
      <h4>Grouping attributes</h4>
      
      <p class="GX">In the United States, we tend to write large numbers with commas grouping every three digits; for example, 4,567,302,000.
         However, in many languages and countries, a period or a space separates the groups instead; for instance, 4.567.302.000 or
         4 567 302 000. Furthermore, in some countries it's customary to group large numbers every four digits instead of every three;
         for example, 4,5673,0000. If you're dealing with very long lists that may contain a thousand or more items, you need to worry
         about these issues.
      </p>
      
      <p class="GX">The <code>grouping-separator</code> attribute specifies the grouping separator used between groups of digits. The <code>grouping-size</code> attribute specifies the number of digits used in a group. Generally, you'd make these attributes contingent on the language.
         For example,
      </p>
      <pre><code>&lt;xsl:number grouping-separator=" " grouping-size="3"/&gt;
</code></pre>
      <h2><a name="d1e8030">Sorting Output Elements</a></h2>
      
      <p class="GX">The <code>xsl:sort</code> element sorts the output elements into a different order than they appear in the input. An <code>xsl:sort</code> element appears as a child of an <code>xsl:apply-templates</code> element or <code>xsl:for-each</code> element. The <code>select</code> attribute of the <code>xsl:sort</code> element defines the key used to sort the element's output by <code>xsl:apply-templates</code> or <code>xsl:for-each</code>.
      </p>
      
      <p class="GX">By default, sorting is performed in alphabetical order of the keys. If more than one <code>xsl:sort</code> element is present in a given <code>xsl:apply-templates</code> or <code>xsl:for-each</code> element, then the elements are sorted first by the first key, then by the second key, and so on. If any elements still compare
         equally, they are output in the order they appear in the source document.
      </p>
      
      <p class="GX">For example, suppose you have a file full of <code>ATOM</code> elements arranged alphabetically. To sort by atomic number, you can use the style sheet in Listing 17-19.
      </p>
      
      <p style="font-weight: bold">Listing 17-19: 
         An XSLT style sheet that sorts by atomic number
      </p>
      
      <pre><code>&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
    &lt;xsl:template match="PERIODIC_TABLE"&gt;
      &lt;html&gt;
        &lt;head&gt;
          &lt;title&gt;Atomic Number vs. Atomic Weight&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
          &lt;h1&gt;Atomic Number vs. Atomic Weight&lt;/h1&gt;
          &lt;table&gt;
            &lt;th&gt;Element&lt;/th&gt;
            &lt;th&gt;Atomic Number&lt;/th&gt;
            &lt;th&gt;Atomic Weight&lt;/th&gt;
            &lt;xsl:apply-templates&gt;
              &lt;xsl:sort select="ATOMIC_NUMBER"/&gt;
            &lt;/xsl:apply-templates&gt;
          &lt;/table&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    &lt;/xsl:template&gt;
    &lt;xsl:template match="ATOM"&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;xsl:apply-templates select="NAME"/&gt;&lt;/td&gt;
        &lt;td&gt;&lt;xsl:apply-templates select="ATOMIC_NUMBER"/&gt;&lt;/td&gt;
        &lt;td&gt;&lt;xsl:apply-templates select="ATOMIC_WEIGHT"/&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <p class="GX">Figure 17-6 shows the limits of alphabetical sorting. Hydrogen, atomic number 1, is the first element. However, the second
         element is not helium, atomic number 2, but rather neon, atomic number 10. Although 10 sorts after 9 numerically, alphabetically
         10 falls before 2.
      </p>
      
      <div align="center"><img src="17/picture11.jpg" width="335" height="333" alt="Image: 17/picture11.jpg"></div>
      
      
      <p style="font-weight: bold">Figure 17-6: 
         Atoms alphabetically sorted by atomic number
      </p>
      
      
      <p class="GX">You can, however, adjust the order of the sort by setting the optional <code>data-type</code> attribute to the value <code>number</code>. For example,
      </p>
      <pre><code>&lt;xsl:sort data-type="number" select="ATOMIC_NUMBER"/&gt;
</code></pre>
      <p class="GX">Figure 17-7 shows the elements sorted properly.</p>
      
      <div align="center"><img src="17/picture13.jpg" width="335" height="333" alt="Image: 17/picture13.jpg"></div>
      
      
      <p style="font-weight: bold">Figure 17-7: 
         Atoms numerically sorted by atomic number
      </p>
      
      
      <p class="GX">You can change the order of the sort from the default ascending order to descending by setting the <code>order</code> attribute to <code>descending</code> like this:
      </p>
      <pre><code>&lt;xsl:sort order="descending"
          data-type="number"
          select="ATOMIC_NUMBER"/&gt;
</code></pre>
      
      
      <p class="GX">This sorts the elements from the largest atomic number to the smallest so that hydrogen now appears last in the list.</p>
      
      <p class="GX">Alphabetical sorting naturally depends on the alphabet. The <code>lang</code> attribute can set the language of the keys. The value of this attribute should be an ISO 639 language code such as <code>en</code> for English. However, processors are not required to know how to sort in all the different languages that might be encountered
         in XML. While English sorting is fairly straight-forward, many other languages require much more complicated algorithms. Indeed
         a few languages actually have multiple standard ways of sorting based on different criteria. The <code>lang</code> attribute is ignored if <code>data-type</code> is <code>number</code>.
      </p>
      
      <p class="SBT" style="font-weight: bold; margin-left: 0.5in; margin-right: 0.5in;        font-family: Arial, Helvetica, sans; color: #0000ff">Cross-Reference</p>
      
      <p class="SBT" style="font-family: Arial, Helvetica, sans;        margin-left: 0.5in; margin-right: 0.5in">These are the same values supported by the <code>xml:lang</code> attribute discussed in Chapter 11.
      </p>
      
      <p class="GX">Finally, you can set the <code>case-order</code> attribute to one of the two values <code>upper-first</code> or <code>lower-first</code> to specify whether uppercase letters sort before lowercase letters or vice versa. The default depends on the language.
      </p>
      
      <h2><a name="d1e8275">Modes</a></h2>
      
      <p class="GX">Sometimes you want to include the same content from the source document in the output document multiple times. That's easy
         to do simply by applying templates multiple times, once in each place where you want the data to appear. However, suppose
         you want the data to be formatted differently in different locations? That's a little trickier.
      </p>
      
      <p class="GX">For example, suppose you want the output of processing the periodic table to be a series of 100 links to more detailed descriptions
         of the individual atoms. In this case, the output document would start like this:
      </p>
      <pre><code>&lt;UL&gt;
&lt;LI&gt;&lt;A HREF="#Ac"&gt;Actinium&lt;/A&gt;&lt;/LI&gt;
&lt;LI&gt;&lt;A HREF="#Al"&gt;Aluminum&lt;/A&gt;&lt;/LI&gt;
&lt;LI&gt;&lt;A HREF="#Am"&gt;Americium&lt;/A&gt;&lt;/LI&gt;
&lt;LI&gt;&lt;A HREF="#Sb"&gt;Antimony&lt;/A&gt;&lt;/LI&gt;
&lt;LI&gt;&lt;A HREF="#Ar"&gt;Argon&lt;/A&gt;&lt;/LI&gt;
. . .
</code></pre>
      
      
      
      
      
      
      <p class="GX">Later in the document, the actual atom descriptions would appear, formatted like this:</p>
      <pre><code>&lt;H3&gt;
&lt;A NAME="H"&gt;Hydrogen&lt;/A&gt;
&lt;/H3&gt;
&lt;P&gt;
    Hydrogen
    H
    1
    1.00794
    20.28
    13.81
      0.0000899
  &lt;/P&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      <p class="GX">This sort of application is common anytime you automatically generate a table of contents or an index. The <code>NAME</code> of the atom must be formatted differently in the table of contents than in the body of the document. You need two different
         rules that both apply to the <code>ATOM</code> element at different places in the document. The solution is to give each of the different rules a <code>mode</code> attribute. Then you can choose which template to apply by setting the <code>mode</code> attribute of the <code>xsl:apply-templates</code> element. Listing 17-20 demonstrates.
      </p>
      
      <p style="font-weight: bold">Listing 17-20: 
         An XSLT style sheet that uses modes to format the same data differently in two different places
      </p>
      
      <pre><code>&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:template match="/PERIODIC_TABLE"&gt;
    &lt;HTML&gt;
      &lt;HEAD&gt;&lt;TITLE&gt;The Elements&lt;/TITLE&gt;&lt;/HEAD&gt;
      &lt;BODY&gt;
        &lt;H2&gt;Table of Contents&lt;/H2&gt;
        &lt;UL&gt;
          &lt;xsl:apply-templates select="ATOM" mode="toc"/&gt;
        &lt;/UL&gt;
        &lt;H2&gt;The Elements&lt;/H2&gt;
        &lt;xsl:apply-templates select="ATOM" mode="full"/&gt;
      &lt;/BODY&gt;
    &lt;/HTML&gt;
  &lt;/xsl:template&gt;
  &lt;xsl:template match="ATOM" mode="toc"&gt;
    &lt;LI&gt;&lt;A&gt;
      &lt;xsl:attribute name="HREF"&gt;#&lt;xsl:value-of
        select="SYMBOL"/&gt;&lt;/xsl:attribute&gt;
      &lt;xsl:value-of select="NAME"/&gt;
    &lt;/A&gt;&lt;/LI&gt;
  &lt;/xsl:template&gt;
  &lt;xsl:template match="ATOM" mode="full"&gt;
    &lt;H3&gt;&lt;A&gt;
      &lt;xsl:attribute name="NAME"&gt;
        &lt;xsl:value-of select="SYMBOL"/&gt;
      &lt;/xsl:attribute&gt;
      &lt;xsl:value-of select="NAME"/&gt;
    &lt;/A&gt;&lt;/H3&gt;
      &lt;P&gt;
        &lt;xsl:value-of select="."/&gt;
      &lt;/P&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <p class="GX">The default template rule for nodes preserves modes. That is, for every mode <span class="italic">n</span> you declare in your style sheet, the XSLT processor adds one template rule that applies specifically to that mode and looks
         like this:
      </p>
      <pre><code>&lt;xsl:template match="*|/" mode="<span class="italic">n</span>"&gt;
  &lt;xsl:apply-templates mode="<span class="italic">n</span>"/&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      <p class="GX">As usual, you are free to override this default rule with one of your own design.</p>
      
      <h2><a name="d1e8497">Defining Constants with xsl:variable</a></h2>
      
      <p class="GX">Named constants help clean up code. They can replace commonly used boilerplate text with a simple name and reference. They
         can also make it easy to adjust boilerplate text that appears in multiple locations by simply changing the constant definition.
      </p>
      
      <p class="GX">The <code>xsl:variable</code> element defines a named string for use elsewhere in the style sheet via an attribute value template. It has a single attribute,
         <code>name,</code> which provides a name by which the variable can be referred to. The contents of the <code>xsl:variable</code> element provide the replacement text. For example, this <code>xsl:variable</code> element defines a variable with the name <code>copy01</code> and the value <code>Copyright 2001 Elliotte Rusty Harold</code>:
      </p>
      <pre><code>&lt;xsl:variable name="copy01"&gt;
  Copyright 2001 Elliotte Rusty Harold
&lt;/xsl:variable&gt;
</code></pre>
      
      
      <p class="GX">To access the value of this variable, you prefix a dollar sign to the name of the variable. To insert this in an attribute,
         use an attribute value template. For example:
      </p>
      <pre><code>&lt;BLOCK COPYRIGHT="{$copy01}"&gt;
&lt;/BLOCK&gt;
</code></pre>
      
      <p class="GX">You can use <code>xsl:value-of</code> to insert the variable's replacement text into the output document as text:
      </p>
      <pre><code>&lt;xsl:value-of select="$copy01"/&gt;
</code></pre>
      <p class="GX">The contents of the <code>xsl:variable</code> can contain markup including other XSLT instructions. This means that you can calculate the value of a variable based on
         other information, including the value of other variables. However, a variable may not refer to itself recursively, either
         directly or indirectly. For instance, the following example is in error:
      </p>
      <pre><code>&lt;xsl:variable name="GNU"&gt;
  &lt;xsl:value-of select="$GNU"/&gt;'s not Unix
&lt;/xsl:variable&gt;
</code></pre>
      
      
      <p class="GX">Similarly, two variables may not refer to each other in a circular fashion like this:</p>
      <pre><code>&lt;xsl:variable name="Thing1"&gt;
  Thing1 loves &lt;xsl:value-of select="$Thing2"/&gt;
&lt;/xsl:variable&gt;
&lt;xsl:variable name="Thing2"&gt;
  Thing2 loves &lt;xsl:value-of select="$Thing1"/&gt;
&lt;/xsl:variable&gt;
</code></pre>
      
      
      
      
      
      <p class="GX"><code>xsl:variable</code> elements can either be top-level children of the <code>xsl:stylesheet</code> root element or they can be included inside template rules. A variable present at the top level of a style sheet can be accessed
         anywhere in the style sheet. It&#8217;s a global variable. By contrast, a variable that&#8217;s declared inside a template rule is only
         accessible by its following sibling elements and their descendants (the <span class="italic">scope</span> of the variable). It&#8217;s a local variable. Local variables override global variables with the same name. Local variables can
         also override other local variables. In the event of a conflict between two variables with the same name, the closest local
         variable with the same name is used.
      </p>
      
      <h2><a name="d1e8598">Named Templates</a></h2>
      
      <p class="GX">Variables are limited to basic text and markup. XSLT provides a more powerful macro facility that can wrap standard markup
         and text around changing data. For example, suppose you want an atom's atomic number, atomic weight, and other key values
         formatted as a table cell in small, bold Times in blue. In other words, you want the output to look like this:
      </p>
      <pre><code>&lt;td&gt;
  &lt;font face="Times, serif" color="blue" size="2"&gt;
    &lt;b&gt;52&lt;/b&gt;
  &lt;/font&gt;
&lt;/td&gt;
</code></pre>
      
      
      
      
      <p class="GX">You can certainly include all that in a template rule like this:</p>
      <pre><code>&lt;xsl:template match="ATOMIC_NUMBER"&gt;
  &lt;td&gt;
    &lt;font face="Times, serif" color="blue" size="2"&gt;
      &lt;b&gt;
        &lt;xsl:value-of select="."/&gt;
      &lt;/b&gt;
    &lt;/font&gt;
  &lt;/td&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      
      
      
      
      
      
      <p class="GX">This markup can be repeated inside other template rules. When the detailed markup grows more complex, and when it appears
         in several different places in a style sheet, you may elect to turn it into a named template. Named templates resemble variables.
         However, they enable you to include data from the place where the template is applied, rather than merely inserting fixed
         text.
      </p>
      
      <p class="GX">The <code>xsl:template</code> element can have a <code>name</code> attribute by which it can be explicitly invoked, even when it isn't applied indirectly. For example, this shows a sample
         named template for the above pattern:
      </p>
      <pre><code>&lt;xsl:template name="ATOM_CELL"&gt;
  &lt;td&gt;
    &lt;font face="Times, serif" color="blue" size="2"&gt;
      &lt;b&gt;
        &lt;xsl:value-of select="."/&gt;
      &lt;/b&gt;
    &lt;/font&gt;
  &lt;/td&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      
      
      
      
      
      
      <p class="GX">The <code>&lt;xsl:value-of select="."/&gt;</code> element in the middle of the named template will be replaced by the contents of the current node from which this template
         was called.
      </p>
      
      <p class="GX">The <code>xsl:call-template</code> element appears in the contents of a template rule. It has a required <code>name</code> argument that names the template it will call. When processed, the <code>xsl:call-template</code> element is replaced by the contents of the <code>xsl:template</code> element it names. For example, you can now rewrite the <code>ATOMIC_NUMBER</code> rule like this by using the <code>xsl:call-template</code> element to call the <code>ATOM_CELL</code> named template:
      </p>
      <pre><code>&lt;xsl:template match="ATOMIC_NUMBER"&gt;
  &lt;xsl:call-template name="ATOM_CELL"/&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      <p class="GX">This fairly simple example only saves a few lines of code, but the more complicated the template, and the more times it's
         reused, the greater the reduction in complexity of the style sheet. Named templates also have the advantage, like variables,
         of factoring out common patterns in the style sheet so that you can edit them as one. For instance, if you decide to change
         the color of atomic number, atomic weight, and other key values from blue to red, you only need to change it once in the named
         template. You do not have to change it in each separate template rule. This facilitates greater consistency of style.
      </p>
      
      <h2><a name="d1e8730">Passing Parameters to Templates</a></h2>
      
      <p class="GX">Each separate invocation of a template can pass parameters to the template to customize its output. This is done the same
         way for named templates and unnamed templates. In the <code>xsl:template</code> element, the parameters are represented as <code>xsl:param</code> child elements. In <code>xsl:call-template</code> or <code>xsl:apply-templates</code> elements, parameters are represented as <code>xsl:with-param</code> child elements.
      </p>
      
      <p class="GX">For example, suppose you want to also include a link to a particular file for each atom cell. The output should look something
         like this:
      </p>
      <pre><code>&lt;td&gt;
  &lt;font face="Times, serif" color="blue" size="2"&gt;
    &lt;b&gt;
      &lt;a href="atomic_number.html"&gt;52&lt;/a&gt;
    &lt;/b&gt;
  &lt;/font&gt;
&lt;/td&gt;
</code></pre>
      
      
      
      
      
      
      <p class="GX">The trick is that the value of the <code>href</code> attribute has to be passed in from the point where the template is invoked because it changes for each separate invocation
         of the template. For example, atomic weights will have to be formatted like this:
      </p>
      <pre><code>&lt;td&gt;
  &lt;font face="Times, serif" color="blue" size="2"&gt;
    &lt;b&gt;
      &lt;a href="atomic_weight.html"&gt;4.0026&lt;/a&gt;
    &lt;/b&gt;
  &lt;/font&gt;
&lt;/td&gt;
</code></pre>
      
      
      
      
      
      
      <p class="GX">The template that supports this looks like this:</p>
      <pre><code>&lt;xsl:template name="ATOM_CELL"&gt;
  &lt;xsl:param name="file"&gt;index.html&lt;/xsl:param&gt;
  &lt;td&gt;
    &lt;font face="Times, serif" color="blue" size="2"&gt;
      &lt;b&gt;
        &lt;a href="{$file}"&gt;&lt;xsl:value-of select="."/&gt;&lt;/a&gt;
      &lt;/b&gt;
    &lt;/font&gt;
  &lt;/td&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      <p class="GX">The <code>name</code> attribute of the <code>xsl:param</code> element gives the parameter a name (important if there are multiple arguments) and the contents of the <code>xsl:param</code> element supplies a default value for this parameter to be used if the invocation doesn't provide a value. (This can also
         be given as a string expression by using a <code>select</code> attribute.)
      </p>
      
      <p class="GX">When this template is called, an <code>xsl:with-param</code> child of the <code>xsl:call-template</code> element provides the value of the parameter using its <code>name</code> attribute to identify the parameter and its contents to provide a value for the parameter. For example:
      </p>
      <pre><code>&lt;xsl:template match="ATOMIC_NUMBER"&gt;
  &lt;xsl:call-template name="ATOM_CELL"&gt;
    &lt;xsl:with-param 
                name="file"&gt;atomic_number.html&lt;/xsl:with-param&gt;
  &lt;/xsl:call-template&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      
      
      
      
      <p class="GX">Again, this is a simple example. However, much more complex named templates exist. For instance, you could define header and
         footer templates for pages on a Web site for importing by many different style sheets, each of which would only have to change
         a few parameters for the name of the page author, the title of the page, and the copyright date.
      </p>
      
      <h2><a name="d1e8886">Stripping and Preserving White Space</a></h2>
      
      <p class="GX">You may have noticed that most of the examples of output have been formatted a little strangely. The reason the examples appeared
         strange is that the source document needed to break long elements across multiple lines to fit between the margins of this
         book. Unfortunately, the extra white space added to the input document carried over into the output document. For a computer,
         the details of insignificant white space aren't important, but for a person they can be distracting.
      </p>
      
      <p class="GX">The default behavior for text nodes read from the input document, such as the content of an <code>ATOMIC_NUMBER</code> or <code>DENSITY</code> element, is to preserve all white space. A typical <code>DENSITY</code> element looks like this:
      </p>
      <pre><code>    &lt;DENSITY UNITS="grams/cubic centimeter"&gt;
      &lt;!-- At 300K, 1 atm --&gt;
      0.0000899
    &lt;/DENSITY&gt;
</code></pre>
      
      
      
      <p class="GX">When its value is taken the leading and trailing white space is included, like this, even though it's really only there to
         help fit on this printed page and isn't at all significant:
      </p>
      <pre><code>      0.0000899
</code></pre>
      <p class="GX">You can use the <code>normalize-space()</code> function to strip the leading and trailing white space from this or any other string. For example, instead of writing <code>&lt;xsl:value-of select="DENSITY"/&gt;</code>, you would write <code>&lt;xsl:value-of select="normalize-space(DENSITY)"/&gt;</code>.
      </p>
      
      <p class="GX">You can also automatically delete white-space only nodes in the input document by using <code>xsl:strip-space</code>. The <code>elements</code> attribute of this top-level element contains a list of elements from which text nodes that contain nothing but white space
         should be deleted. For example, this element says that nodes containing only white space should be stripped from <code>DENSITY</code>, <code>NAME</code>, <code>SYMBOL</code>, and <code>BOILING_POINT</code> elements:
      </p>
      <pre><code>&lt;xsl:strip-space elements="DENSITY NAME SYMBOL BOILING_POINT"/&gt;
</code></pre>
      <p class="GX">You can strip space-only nodes in all elements by using the <code>*</code> wildcard, like this:
      </p>
      <pre><code>&lt;xsl:strip-space elements="*"/&gt;
</code></pre>
      <p class="GX">There's also an <code>xsl:preserve-space</code> element with a similar syntax but opposite meaning. However, since preserving space is the default, this element isn&#8217;t much
         used. Its main purpose is to override <code>xsl:strip-space</code> elements imported from other style sheets or to specify a few elements where space is preserved when the default has been
         reset to stripping by <code>&lt;xsl:strip-space elements="*"/&gt;</code>.
      </p>
      
      <p class="GX">White space only text nodes in the style sheet, as opposed to the input document, are another matter. They are stripped by
         default. If you want to preserve one, you attach an <code>xml:space</code> attribute with the value <code>preserve</code> to its parent element or to another one of its ancestors.
      </p>
      
      <p class="SBT" style="font-weight: bold; margin-left: 0.5in; margin-right: 0.5in;        font-family: Arial, Helvetica, sans; color: #0000ff">Cross-Reference</p>
      
      <p class="SBT" style="font-family: Arial, Helvetica, sans;        margin-left: 0.5in; margin-right: 0.5in">The <code>xml:space</code> attribute was discussed in Chapter 11.
      </p>
      
      <p class="GX">Sometimes the easiest way to include significant white space in a style sheet is to wrap it in an <code>xsl:text</code> element. Space inside an <code>xsl:text</code> element is treated literally and never stripped.
      </p>
      
      <h2><a name="d1e9006">Making Choices</a></h2>
      
      <p class="GX">XSLT provides two elements that allow you to change the output based on the input. The <code>xsl:if</code> element either does or does not output a given fragment of XML depending on what patterns are present in the input. The <code>xsl:choose</code> element picks one of several possible XML fragments, depending on what patterns are present in the input. Most of what you
         can do with <code>xsl:if</code> and <code>xsl:choose</code> can also be done by a suitable application of templates. However, sometimes the solution with <code>xsl:if</code> or <code>xsl:choose</code> is simpler and more obvious.
      </p>
      
      <h3>xsl:if</h3>
      
      <p class="GX">The <code>xsl:if</code> element provides a simple facility for changing the output based on a pattern. The <code>test</code> attribute of <code>xsl:if</code> contains an expression that evaluates to a boolean. If the expression is true, the contents of the <code>xsl:if</code> element are output. Otherwise, they're not. For example, this template writes out the names of all <code>ATOM</code> elements. A comma and a space is added after all except the last element in the list.
      </p>
      <pre><code>&lt;xsl:template match="ATOM"&gt;
  &lt;xsl:value-of select="NAME"/&gt;
  &lt;xsl:if test="position()!=last()"&gt;, &lt;/xsl:if&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      
      <p class="GX">This ensures that the list looks like "Hydrogen, Helium" and not "Hydrogen, Helium, ".</p>
      
      <p class="GX">There are no <code>xsl:else</code> or <code>xsl:else-if</code> elements. The <code>xsl:choose</code> element provides this functionality.
      </p>
      
      <h3>xsl:choose</h3>
      
      <p class="GX">The <code>xsl:choose</code> element selects one of several possible outputs depending on several possible conditions. Each condition and its associated
         output template is provided by an <code>xsl:when</code> child element. The <code>test</code> attribute of the <code>xsl:when</code> element is an XPath expression with a boolean value. If multiple conditions are true, only the first true one is instantiated.
         If none of the <code>xsl:when</code> elements are true, the <code>xsl:otherwise</code> child element is instantiated. For example, this rule changes the color of the output based on whether the <code>STATE</code> attribute of the <code>ATOM</code> element is <code>SOLID</code>, <code>LIQUID</code>, or <code>GAS</code>:
      </p>
      <pre><code>&lt;xsl:template match="ATOM"&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test="@STATE='SOLID'"&gt;
      &lt;P style="color: black"&gt;
        &lt;xsl:value-of select="."/&gt;
      &lt;/P&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:when test="@STATE='LIQUID'"&gt;
      &lt;P style="color: blue"&gt;
        &lt;xsl:value-of select="."/&gt;
      &lt;/P&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:when test="@STATE='GAS'"&gt;
      &lt;P style="color: red"&gt;
        &lt;xsl:value-of select="."/&gt;
      &lt;/P&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;P style="color: green"&gt;
        &lt;xsl:value-of select="."/&gt;
      &lt;/P&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/xsl:template&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <h2><a name="d1e9189">Merging Multiple Style Sheets</a></h2>
      
      <p class="GX">A single XML document may use many different markup vocabularies described in many different DTDs. You may wish to use different
         standard style sheets for those different vocabularies. However, you'll also want style rules for particular documents as
         well. The <code>xsl:import</code> and <code>xsl:include</code> elements enable you to merge multiple style sheets so that you can organize and reuse style sheets for different vocabularies
         and purposes.
      </p>
      
      <h3>Importing with xsl:import</h3>
      
      <p class="GX">The <code>xsl:import</code> element is a top-level element whose <code>href</code> attribute provides the URI of a style sheet to import. All <code>xsl:import</code> elements must appear before any other top-level element in the <code>xsl:stylesheet</code> root element. For example, these <code>xsl:import</code> elements import the style sheets genealogy.xsl and standards.xsl.
      </p>
      <pre><code>&lt;xsl:stylesheet version="1.0" 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:import href="genealogy.xsl"/&gt;
  &lt;xsl:import href="standards.xsl"/&gt;
  &lt;!-- other child elements follow --&gt;
&lt;/xsl:stylesheet&gt;
</code></pre>
      
      
      
      
      
      <p class="GX">Rules in the imported style sheets may conflict with rules in the importing style sheet. If so, rules in the importing style
         sheet take precedence. If two rules in different imported style sheets conflict, then the rule in the last style sheet imported
         (standards.xsl above) takes precedence.
      </p>
      
      <p class="GX">The <code>xsl:apply-imports</code> element is a slight variant of <code>xsl:apply-templates</code> that only uses imported rules. It does not use any rules from the importing style sheet. This allows access to imported rules
         that would otherwise be overridden by rules in the importing style sheet. Other than the name, it has identical syntax to
         <code>xsl:apply-templates</code>. The only behavioral difference is that it only matches template rules in imported style sheets.
      </p>
      
      <h3>Inclusion with xsl:include</h3>
      
      <p class="GX">The <code>xsl:include</code> element is a top-level element that copies another style sheet into the current style sheet at the point where it occurs.
         (More precisely, it copies the contents of the <code>xsl-stylesheet</code> or <code>xsl:transform</code> element in the remote document into the current document.) Its <code>href</code> attribute provides the URI of the style sheet to include. An <code>xsl:include</code> element can occur anywhere at the top level after the last <code>xsl:import</code> element.
      </p>
      
      <p class="GX">Unlike rules included by <code>xsl:import</code> elements, rules included by <code>xsl:include</code> elements have the same precedence in the including style sheet that they would have if they were copied and pasted from one
         style sheet to the other. As far as the XSLT processor is concerned, there is no difference between an included rule and a
         rule that's physically present.
      </p>
      
      <h3>Embedding with xsl:stylesheet</h3>
      
      <p class="GX">You can directly include an XSLT style sheet in the XML document it applies to. I don't recommend this in practice, and browsers
         and XSLT processors are not required to support it. Nonetheless, a few do. To use this, the <code>xsl:stylesheet</code> element must appear as a child of the document element, rather than as a root element itself. It would have an <code>id</code> attribute giving it a unique name, and this <code>id</code> attribute would appear as the value of the <code>href</code> attribute in the <code>xml-stylesheet</code> processing instruction, following the fragment identifier separator <code>#</code>. Listing 17-21 demonstrates.
      </p>
      
      <p style="font-weight: bold">Listing 17-21: 
         An XSLT style sheet embedded in an XML document
      </p>
      
      <pre><code>&lt;?xml version="1.0"?&gt;
&lt;?xml-stylesheet type="text/xml" href="#mystyle"?&gt;
&lt;PERIODIC_TABLE&gt;
  &lt;xsl:stylesheet version="1.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    id="mystyle"&gt;
    &lt;xsl:template match="/"&gt;
      &lt;html&gt;
        &lt;xsl:apply-templates/&gt;
      &lt;/html&gt;
    &lt;/xsl:template&gt;
    &lt;xsl:template match="PERIODIC_TABLE"&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/xsl:template&gt;
    &lt;xsl:template match="ATOM"&gt;
      &lt;P&gt;
        &lt;xsl:value-of select="."/&gt;
      &lt;/P&gt;
    &lt;/xsl:template&gt;
    &lt;!--Don't display the style sheet itself
       or its descendants--&gt;
    &lt;xsl:template match="xsl:stylesheet"/&gt;
  &lt;/xsl:stylesheet&gt;
  &lt;ATOM&gt;
    &lt;NAME&gt;Actinium&lt;/NAME&gt;
    &lt;ATOMIC_WEIGHT&gt;227&lt;/ATOMIC_WEIGHT&gt;
    &lt;ATOMIC_NUMBER&gt;89&lt;/ATOMIC_NUMBER&gt;
    &lt;OXIDATION_STATES&gt;3&lt;/OXIDATION_STATES&gt;
    &lt;BOILING_POINT UNITS="Kelvin"&gt;3470&lt;/BOILING_POINT&gt;
    &lt;MELTING_POINT UNITS="Kelvin"&gt;1324&lt;/MELTING_POINT&gt;
    &lt;SYMBOL&gt;Ac&lt;/SYMBOL&gt;
    &lt;DENSITY UNITS="grams/cubic centimeter"&gt;&lt;!-- At 300K --&gt;
      10.07
    &lt;/DENSITY&gt;
    &lt;ELECTRONEGATIVITY&gt;1.1&lt;/ELECTRONEGATIVITY&gt;
    &lt;ATOMIC_RADIUS UNITS="Angstroms"&gt;1.88&lt;/ATOMIC_RADIUS&gt;
  &lt;/ATOM&gt;
&lt;/PERIODIC_TABLE&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <h2><a name="d1e9432">Output Methods</a></h2>
      
      <p class="GX">Most of the examples in this chapter have focused on transforming XML into well-formed HTML. However, most XSLT processors
         actually support three different output methods:
      </p>
      
      <ul>
         <li>XML</li>
         <li>HTML</li>
         <li>Text</li>
      </ul>
      
      
      
      <p class="GX">The XSLT processor behaves differently depending on which of these output methods it uses. The XML format is the default and
         in many ways the simplest. The output is mostly exactly what you request in your style sheet. Because well-formed XML does
         not permit raw less-than signs and ampersands, if you use a character reference such as <code>&amp;#60;</code> or the entity reference <code>&amp;lt;</code> to insert the <code>&lt;</code> character, the formatter will output <code>&amp;lt;</code> or perhaps <code>&amp;#60;</code>. If you use a character reference such as <code>&amp;#38;</code> or the entity reference <code>&amp;amp;</code> to insert the <code>&amp;</code> character, the formatter will insert <code>&amp;amp;</code> or perhaps <code>&amp;#38;</code>. There are ways to disable this escaping, though, as you'll see later.
      </p>
      
      <p class="GX">The HTML output method is designed to output standard HTML 4.0. This is not the well-formed HTML used in this book, but rather
         traditional HTML in which empty tags look like <code>&lt;HR&gt;</code> and <code>&lt;IMG&gt;</code> instead of <code>&lt;HR/&gt;</code> and <code>&lt;IMG/&gt;</code>, processing instructions are terminated with a <code>&gt;</code> instead of <code>?&gt;</code>, and <code>&lt;</code> signs used in JavaScript are not converted to <code>&amp;lt;</code>. This makes it much easier to output HTML that works across many browsers and platforms without odd effects such as double
         lines where a single line is expected or other detritus caused by forcing HTML into the XML mold. The HTML output method is
         automatically selected when the formatter notices that the root output element is <code>html</code>, <code>HTML</code>, <code>HtMl</code>, or any other combination of case that still spells Hypertext Markup Language.
      </p>
      
      <p class="GX">The final output method is pure text. The text output method operates by first forming a full result tree as per the XML output
         method, but then only outputting the string value of that tree. This is useful for transforming to non-XML formats such as
         RTF or TeX. The primary benefit of the text output format is that less than signs are not converted to <code>&amp;lt;</code> or <code>&amp;#60;</code> and ampersands are not converted to <code>&amp;amp;</code> or <code>&amp;#38;</code>. This allows you to output effectively arbitrary text.
      </p>
      
      <h3>xsl:output</h3>
      
      <p class="GX">By default an XSLT processor will use the XML output method, unless it recognizes the output root element as <code>HTML</code>, in which case it uses the HTML output method. You can change this by using a top-level <code>xsl:output</code> element. The <code>method</code> attribute of the <code>xsl:output</code> element specifies which output method to use and normally has one of these three values:
      </p>
      
      <ul>
         <li><code>xml</code></li>
         <li><code>htm</code>l
         </li>
         <li><code>text</code></li>
      </ul>
      
      
      
      <p class="GX">Formatting engines may support other values as well, but so far none do. For example, to specify that you want pure well-formed
         HTML as output, with all the empty tags properly indicated, all less than signs escaped, and so forth, you would use this
         <code>xsl:output</code> element at the top level of your style sheet:
      </p>
      <pre><code>&lt;xsl:output method="xml"/&gt;
</code></pre>
      <p class="GX">To indicate that you want regular HTML output even though you aren't using an <code>html</code> root element, you'd put this <code>xsl:output</code> element at the top level of your style sheet:
      </p>
      <pre><code>&lt;xsl:output method="html"/&gt;
</code></pre>
      <p class="GX">The <code>xsl:output</code> element also has a number of other allowed attributes that modify how XML is output. These allow you to change the prolog
         of the document, how the output is indented with insignificant white space, and which elements use <code>CDATA</code> sections rather than escaping <code>&lt;</code> and <code>&amp;</code> characters.
      </p>
      
      <h3>XML Declaration</h3>
      
      <p class="GX">Four attributes of <code>xsl:output</code> format the XML declaration used in your document. This assumes the output method is xml. These attributes are:
      </p>
      
      <ul>
         <li><code>omit-xml-declaration</code></li>
         <li><code>version</code></li>
         <li><code>encoding</code></li>
         <li><code>standalone</code></li>
      </ul>
      
      
      
      
      <p class="GX">The <code>omit-xml-declaration</code> attribute has the value <code>yes</code> or <code>no</code>. If <code>yes</code>, then an XML declaration is not included in the output document. If <code>no</code>, then it is. For example, to insert a very basic <code>&lt;?xml version="1.0"?&gt;</code> XML declaration in the output document you would use this <code>xsl:output</code> element at the top level of your style sheet:
      </p>
      <pre><code>&lt;xsl:output method="xml" omit-xml-declaration="no"/&gt;
</code></pre>
      <p class="GX">You could also include it as two separate <code>xsl:output</code> elements like this:
      </p>
      <pre><code>&lt;xsl:output method="xml"/&gt;
&lt;xsl:output omit-xml-declaration="no"/&gt;
</code></pre>
      
      <p class="GX">The default value of the <code>version</code> attribute of the XML declaration is 1.0. Currently, that's the only value allowed. If at some point in the future that changes,
         then the <code>version</code> attribute of <code>xsl:output</code> will allow you to change the version used in the XML declaration. For example,
      </p>
      <pre><code>&lt;xsl:output version="1.1"/&gt;
</code></pre>
      <p class="GX">You can set the <code>standalone</code> attribute of the XML declaration to the value <code>yes</code> or <code>no</code> using the <code>standalone</code> attribute of the <code>xsl:output</code> element. For example, this <code>xsl:output</code> element would insert the XML declaration <code>&lt;?xml version="1.0" standalone="yes"?&gt;</code>:
      </p>
      <pre><code>&lt;xsl:output method="xml"
            omit-xml-declaration="no" standalone="yes"/&gt;
</code></pre>
      
      <p class="GX">The final possible piece of an XML declaration is the <code>encoding</code> declaration. As you probably guessed this can be set with the encoding attribute of the <code>xsl:output</code> element. The value can be any legal encoding name registered with the Internet Assigned Numbers Authority as discussed in
         Chapter 7. For example, to insert the XML declaration <code>&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;</code>, you'd use this <code>xsl:output</code> element:
      </p>
      <pre><code>&lt;xsl:output method="xml"
          omit-xml-declaration="no" encoding="ISO-8859-1"/&gt;
</code></pre>
      
      <p class="GX">This also changes the encoding the XSLT processor uses for the output document from its default UTF-8. However, not all processors
         support all possible encodings. Those written in Java are likely to support the most encodings because Java's rich class library
         makes it almost trivial to support several dozen popular encodings.
      </p>
      
      <h3>Document type declaration</h3>
      
      <p class="GX">XSLT does not provide any elements for building an internal DTD subset for the output document with <code>&lt;!ELEMENT&gt;</code>, <code>&lt;!ATTLIST&gt;</code>, <code>&lt;!ENTITY&gt;</code>, and <code>&lt;!NOTATION&gt;</code> declarations. However, it does provide two attributes of the <code>xsl:output</code> element you can use to include a <code>DOCTYPE</code> declaration that points to an external DTD. These are <code>doctype-system</code> and <code>doctype-public</code>. The first inserts a <code>SYSTEM</code> identifier for the DTD; the second a <code>PUBLIC</code> identifier. For example, suppose you want this <code>DOCTYPE</code> declaration in your output document:
      </p>
      <pre><code>&lt;!DOCTYPE PERIODIC_TABLE SYSTEM "chemistry.dtd"&gt;
</code></pre>
      <p class="GX">Then you would use this <code>xsl:output</code> element at the top level of your style sheet:
      </p>
      <pre><code>&lt;xsl:output doctype-system="chemistry.dtd"/&gt;
</code></pre>
      <p class="GX">The XSLT processor determines the proper root element for the document type declaration by looking at the root element of
         the output tree. Using a full URL instead of a relative URL is equally easy:
      </p>
      <pre><code>&lt;xsl:output
  doctype-system="http://www.mysite.com/chemistry.dtd"/&gt;
</code></pre>
      
      <p class="GX">On the other hand, suppose you want this <code>DOCTYPE</code> declaration in your output document:
      </p>
      <pre><code>&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
         "http://www.w3.org/TR/REC-html40/loose.dtd"&gt;
</code></pre>
      
      <p class="GX">Then you would use both <code>doctype-system</code> and <code>doctype-public</code> attributes so your <code>DOCTYPE</code> declaration will have both a <code>PUBLIC</code> and a <code>SYSTEM</code> identifier. For example,
      </p>
      <pre><code>&lt;xsl:output
  doctype-system="http://www.w3.org/TR/REC-html40/loose.dtd"
  doctype-public="-//W3C//DTD HTML 4.0 Transitional//EN"/&gt;
</code></pre>
      
      
      <h3>Indentation</h3>
      
      <p class="GX">The indentation of most of the output examples in this chapter has been more than a little flaky. It's certainly not as neat
         as the carefully hand-coded indentation of the input documents. However, if white space isn't particularly significant in
         your output document, you can change this and ask the formatter for "pretty printed" XML with the nesting of different elements
         indicated by the indentation. This is accomplished by the <code>indent</code> attribute of the <code>xsl:output</code> element. If this attribute has the value <code>yes</code> (the default is <code>no</code>), then the processor is allowed (but not required) to insert (but not remove) extra white space into the output to try to
         "pretty print" the output. This may include indentation and line breaks. For example,
      </p>
      <pre><code>&lt;xsl:output indent="yes"/&gt;
</code></pre>
      <p class="GX">You cannot, however, specify how much you want each level indented (for example, by two spaces or one tab). That's up to the
         formatter. Together, the <code>xsl:strip-space</code> and the <code>indent</code> attribute of the <code>xsl:output</code> element allow you to produce output that's almost as attractive as the most painstakingly hand-crafted XML.
      </p>
      
      <h3>CDATA sections</h3>
      
      <p class="GX">Standard XSLT does not allow you to insert CDATA sections at arbitrary locations in XML documents produced by XSL transformations.
         However, you can specify that the text contents of a particular element be placed in a <code>CDATA</code> section. In this case the <code>&lt;</code> and <code>&amp;</code> symbols are not encoded as <code>&amp;lt;</code> and <code>&amp;amp;</code> as they would normally be. To do this, place the name of the element whose text contents should be wrapped in CDATA delimiters
         in the <code>cdata-section-elements</code> attribute of the <code>xsl:output</code> element. For example, this <code>xsl:output</code> element says that the contents of the <code>SCRIPT</code> element should be wrapped in a CDATA section:
      </p>
      <pre><code>&lt;xsl:output cdata-section-elements="SCRIPT"/&gt;
</code></pre>
      <p class="GX">You can enclose multiple names of elements whose text contents should be wrapped in CDATA delimiters in one <code>cdata-section-elements</code> attribute simply by separating the names with white space. For example, this <code>xsl:output</code> element says that the contents of both the <code>SCRIPT</code> and <code>CODE</code> elements should be wrapped in a CDATA section:
      </p>
      <pre><code>&lt;xsl:output cdata-section-elements="SCRIPT CODE"/&gt;
</code></pre>
      <p class="GX">Alternately, you can just use multiple <code>xsl:output</code> elements, each naming one element. For example:
      </p>
      <pre><code>&lt;xsl:output cdata-section-elements="SCRIPT"/&gt;
&lt;xsl:output cdata-section-elements="CODE"/&gt;
</code></pre>
      
      <h3>Media type</h3>
      
      <p class="GX">One final <code>xsl:output</code> attribute specifies the MIME media type of the output document. This is <code>media-type</code>. Mostly this will have the value <code>text/xml</code>, but it might be <code>text/html</code> for the HTML output method, <code>text/plain</code> for the text output method, or even something else such as <code>text/rtf</code>. You should not specify a charset parameter for the media type. The formatting engine should determine this from the <code>encoding</code> attribute of the <code>xsl:output</code> element. For example, this <code>xsl:output</code> element specifies that the output encoding uses the text/rtf MIME type:
      </p>
      <pre><code>&lt;xsl:output media-type="text/rtf"/&gt;
</code></pre>
      <p class="GX">Depending on external context, this may determine the filename extension, the icon of the file, how an HTTP server handles
         the file, or something else. Then again, it might have no effect at all. The XSLT processor might ignore this request and
         output the same byte stream or XML tree regardless of media type. This is something that's important to the environment in
         which the XML document exists, but not so important to the XML document itself.
      </p>
      
      <h2 class="sum-H">Summary</h2>
      
      <p class="sum-X">In this chapter, you learned about XSL transformations. In particular, you learned that:</p>
      
      <ul>
         <li>The Extensible Stylesheet Language (XSL) comprises two separate XML applications for transforming and formatting XML documents.</li>
         <li>An XSL transformation applies rules to a tree read from an XML document to transform it into an output tree written out as
            an XML document.
         </li>
         <li>An XSL template rule is an <code>xsl:template</code> element with a <code>match</code> attribute. Nodes in the input tree are compared against the patterns of the <code>match</code> attributes of the different template elements. When a match is found, the contents of the template are output.
         </li>
         <li>The value of a node is a pure text (no markup) string containing the contents of the node. This can be calculated by the <code>xsl:value-of</code> element.
         </li>
         <li>You can process multiple elements in two ways: the <code>xsl:apply-templates</code> element and the <code>xsl:for each</code> element.
         </li>
         <li>The value of the <code>match</code> attribute of the <code>xsl:template</code> element is a match pattern specifying which nodes the template matches.
         </li>
         <li>XPath expressions (or simply expressions) are a superset of match patterns used by the <code>select</code> attribute of <code>xsl:apply-templates</code>, <code>xsl:value-of</code>, <code>xsl:for-each</code>, <code>xsl:copy-of</code>, <code>xsl:variable</code>, <code>xsl:param</code>, <code>xsl:with-param</code>, and <code>xsl:sort</code> elements.
         </li>
         <li>Default rules apply templates to element nodes and take the value of text nodes and attributes.</li>
         <li>The <code>xsl:element</code>, <code>xsl:attribute</code>, <code>xsl:processing-instruction</code>, <code>xsl:comment</code>, and <code>xsl:text</code> elements output elements, attributes, processing instructions, comments, and text calculated from data in the input document.
         </li>
         <li>The <code>xsl:attribute-set</code> element defines a common group of attributes that can be applied to multiple elements in different templates with the <code>xsl:use-attribute-sets</code>.
         </li>
         <li>The <code>xsl:copy</code> element copies the current node from the input into the output.
         </li>
         <li>The <code>xsl:number</code> element inserts the number specified by its <code>value</code> attribute into the output using a specified number format given by the <code>format</code> attribute.
         </li>
         <li>The <code>xsl:sort</code> element can reorder the input nodes before copying them to the output.
         </li>
         <li>Modes can apply different templates to the same element from different locations in the style sheet.</li>
         <li>The <code>xsl:variable</code> element defines named constants that can clarify your code.
         </li>
         <li>Named templates help you reuse common template code.</li>
         <li>White space is maintained by default unless an <code>xsl:strip-space</code> element or <code>xml:space</code> attribute says otherwise.
         </li>
         <li>The <code>xsl:if</code> element produces output if, and only if, its <code>test</code> attribute is true.
         </li>
         <li>The <code>xsl:choose</code> element outputs the template of the first one of its <code>xsl:when</code> children whose <code>test</code> attribute is true, or the template of its <code>xsl:otherwise</code> element if no <code>xsl:when</code> element has a <code>true</code> <code>test</code> attribute.
         </li>
         <li>The <code>xsl:import</code> and <code>xsl:include</code> elements merge rules from different style sheets.
         </li>
         <li>The <code>xsl:stylesheet</code> element allows you to include a style sheet directly in the document it applies to.
         </li>
         <li>Various attributes of the <code>xsl:output</code> element allow you to specify the output document's format, XML declaration, <a id="s" name="s" shape="rect"></a>document type declaration, indentation, encoding and MIME type.
         </li>
      </ul>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <p class="sum-X">The next chapter takes up the second half of XSL: the formatting objects vocabulary. Formatting objects is an extremely powerful
         way of specifying the precise layout you want your pages to have. XSL transformations are used to transform an XML document
         into an XSL formatting object document.
      </p>
      
      <hr>
      <div style="text-align: center">
         [ <a href="../../index.html">Cafe con Leche</a> 
         | <a href="../index.html">XML Bible Home Page</a>
         | Order from <a href="http://www.amazon.com/exec/obidos/ASIN/0764547607/ref=nosim/cafeaulaitA/">amazon.com</a> ]
         
      </div>
      <hr>
      Copyright 2001, 2002 <a href="http://www.elharo.com/">Elliotte Rusty Harold</a><br /><a href="mailto:elharo@metalab.unc.edu">elharo@metalab.unc.edu</a><br />
      Last Modified December 31, 2002  
      
   </body>
</html>
