<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
   <head xmlns:html="http://www.w3.org/1999/xhtml">
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   
      <title>
         Schemas
         
      </title>
   </head>
   <body xmlns:html="http://www.w3.org/1999/xhtml" bgcolor="#FFFFFF" text="#000000">
      <h1>Chapter 
         24
         
         of the <cite>
            XML Bible, Second Edition
            </cite>: 
         
         Schemas
         
      </h1>
      <h2>In This Chapter</h2>
      <ul>
         <li><a href="#d1e500">What's Wrong with DTDs?</a></li>
         <li><a href="#d1e584">What is a Schema?</a></li>
         <li><a href="#d1e700">The W3C XML Schema Language</a></li>
         <li><a href="#d1e712">Hello Schemas</a></li>
         <li><a href="#d1e1063">Complex Types</a></li>
         <li><a href="#d1e2436">Grouping</a></li>
         <li><a href="#d1e2925">Simple Types</a></li>
         <li><a href="#d1e4741">Deriving Simple Types</a></li>
         <li><a href="#d1e7792">Empty Elements</a></li>
         <li><a href="#d1e7840">Attributes</a></li>
         <li><a href="#d1e8500">Namespaces</a></li>
         <li><a href="#d1e9286">Annotations</a></li>
      </ul>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <h2><a name="d1e500">What's Wrong with DTDs?</a></h2>
      
      <p class="GX">Document Type Definitions (DTDs) are an outgrowth of XML's heritage in the Standardized General Markup Language (SGML). SGML
         was always intended for narrative-style documents: books, reports, technical manuals, brochures, Web pages, and the like.
         DTDs were designed to serve the needs of these sorts of documents, and indeed they serve them very well. DTDs let you state
         very simply and straightforwardly that every book must have one or more authors, that every song has exactly one title, that
         every <code>PERSON</code> element has an <code>ID</code> attribute, and so forth. Indeed for narrative documents that are intended for human beings to read from start to finish,
         that are more or less composed of words in a row, there's really no need for anything beyond a DTD. However, XML has gone
         well beyond the uses envisioned for SGML. XML is being used for object serialization, stock trading, remote procedure calls,
         vector graphics, and many more things that look nothing like traditional narrative documents; and it is in these new arenas
         that DTDs are showing some limits.
      </p>
      
      <p class="GX">The limitation most developers notice first is the almost complete lack of data typing, especially for element content. DTDs
         can't say that a <code>PRICE</code> element must contain a number, much less a number that's greater than zero with two decimal digits of precision and a dollar
         sign. There's no way to say that a <code>MONTH</code> element must be an integer between 1 and 12. There's no way to indicate that a <code>TITLE</code> must contain between 1 and 255 characters. None of these are particularly important things to do for the narrative documents
         SGML was aimed at; but they're very common things to want to do with data formats intended for computer-to-computer exchange
         of information rather than computer-to-human communication. Humans are very good at handling fuzzy systems where expected
         data is missing, or perhaps in not quite the right format; computers are not. Computers need to know that when they expect
         an element to contain an integer between 1 and 12, the element really contains an integer in that range and nothing else.
      </p>
      
      <p class="GX">The second problem is that DTDs have an unusual non-XML syntax. You actually need separate parsers and APIs to handle DTDs
         than you do to handle XML documents themselves. For instance, consider this common element declaration:
      </p>
      <pre><code>&lt;!ELEMENT TITLE (#PCDATA)&gt;
</code></pre>
      <p class="GX">This is not a legal XML element. You can&#8217;t begin an element name with an exclamation point. <code>TITLE</code> is not an attribute. Neither is <code>(#PCDATA)</code>. This is a very different way of describing information than is used in XML document instances. One would expect that if
         XML were really powerful enough to live up to all its hype then it would be powerful enough to describe itself. You shouldn&#8217;t
         need two different syntaxes: one for the information and one for the meta-information detailing the structure of the information.
         XML element and attribute syntax should suffice for both info and meta-info.
      </p>
      
      <p class="GX">The third problem is that DTDs are only marginally extensible and don&#8217;t scale very well. It's difficult to combine independent
         DTDs together in a sensible way. You can do this with parameter entity references. Indeed, SMIL 2.0 and modular XHTML are
         based on this idea. However, the modularized DTDs are very messy and very hard to follow. The largest DTDs in use today are
         in the ballpark of 10,000 lines of code, and it's questionable whether much larger XML applications can be defined before
         the entire DTD becomes completely unmanageable and incomprehensible. By contrast, the largest computer programs in existence
         today, which are much more intrinsically complex than even the most ambitious DTDs, easily reach sizes of 1,000,000 lines
         of code and more; sometimes even 10,000,000 lines of code or more.
      </p>
      
      <p class="GX">Perhaps most annoyingly, DTDs are only marginally compatible with namespaces. The first principle of namespaces is that only
         the URI matters. The prefix does not. The prefix can change as long as the URI remains the same. However, validation of documents
         that use namespace prefixes works only if the DTD declares the prefixed names. You cannot use namespace URIs in a DTD. You
         must use the actual prefixes. If you change the prefixes in the document but don&#8217;t change the DTD, then the document immediately
         ceases to be valid. There are some tricks that you can perform with parameter entity references to make DTDs less dependent
         on the actual prefix, but they're complicated and not well understood in the XML community. And even when they are understood,
         these tricks simply feel far too much like a dirty hack rather than a clean, maintainable solution.
      </p>
      
      <p class="GX">Finally, there are a number of annoying minor limitations where DTDs don&#8217;t allow you to do things that it really feels like
         you ought to be able to do. For instance, DTDs cannot enforce the order or number of child elements in mixed content. That
         is, you can't make statements such as each <code>PARAGRAPH</code> element must begin with exactly one <code>SUMMARY</code> element that is followed by plain text. Similarly you can&#8217;t enforce the number of child elements without also enforcing their
         order. For instance, you cannot easily say that a <code>PERSON</code> element must contain a <code>FIRST_NAME</code> child, a <code>MIDDLE_NAME</code> child, and a <code>LAST_NAME</code> child, but that you don&#8217;t care what order they appear in. Again, there are workarounds; but they grow combinatorially complex
         with the number of possible child elements.
      </p>
      
      <p class="GX">Schemas are an attempt to solve all these problems by defining a new XML-based syntax for describing the permissible contents
         of XML documents that includes:
      </p>
      
      <ul>
         <li>Powerful data typing including range checking</li>
         <li>Namespace-aware validation based on namespace URIs rather than on prefixes</li>
         <li>Extensibility and scalability</li>
      </ul>
      
      
      
      <p class="GX">However, schemas are not a be-all and end-all solution. In particular, <span class="italic">schemas do not replace DTDs!</span> You can use both schemas and DTDs in the same document. DTDs can do several things that schemas cannot do, most importantly
         declaring entities. And of course, DTDs still work very well for the classic sort of narrative documents they were originally
         designed for. Indeed, for these types of documents, a DTD is often considerably easier to write than an equivalent schema.
         Parsers and other software will continue to support DTDs for as long as they support XML.
      </p>
      
      <h2><a name="d1e584">What is a Schema?</a></h2>
      
      
      <p class="GX">The word <span class="italic">schema</span> derives from the Greek word <span class="italic"><span style="{font-family: Times New Roman Greek}">&#963;&#967;&#951;&#956;&#945;</span></span>, meaning form or shape. It was first popularized in the Western world by Immanuel Kant in the late 1700s. According to the
         1933 edition of the <span class="italic">Oxford English Dictionary</span>, Kant used the word <span class="italic">schema</span> to mean, "Any one of certain forms or rules of the &#8216;productive imagination&#8217; through which the understanding is able to apply
         its &#8216;categories&#8217; to the manifold of sense-perception in the process of realizing knowledge or experience." (And you thought
         computer science was full of unintelligible technical jargon!)
      </p>
      
      <p class="GX">Schemas remained the province of philosophers for the next 200 years until, the word <span class="italic">schema</span> entered computer science, probably through database theory. Here, <span class="italic">schema</span> originally meant any document that described the permissible content of a database. More specifically, a schema was a description
         of all the tables in a database and the fields in the table. A schema also described what type of data each field could contain:
         CHAR, INT, CHAR[32], BLOB, DATE, and so on.
      </p>
      
      <p class="GX">The word <span class="italic">schema</span> has grown from that source definition to a more generic meaning of any document that describes the permissible contents of
         other documents, especially if data typing is involved. Thus, you'll hear about different kinds of schemas from different
         technologies, including vocabulary schemas, RDF schemas, organizational schemas, X.500 schemas and, of course, XML schemas.
      </p>
      
      
      <p class="SBT" style="font-weight: bold; text-align: center;         font-family: Arial, Helvetica, sans">You say schemas, I say schemata</p>
      
      <p class="SBT" style="font-family: Arial, Helvetica, sans;        margin-left: 0.5in; margin-right: 0.5in">Probably no single topic has been more controversial in the schema world than the proper plural form of the word <span class="italic">schema</span>. The original Greek plural is <span class="italic"><span style="{font-family: Arial Greek}">&#963;&#967;&#951;&#956;&#945;&#964;&#945;</span></span>, <span class="italic">schemata</span> in Latin transliteration; and this is the form which Kant used and which you'll find in most dictionaries. This was fine
         for the 200 years when only people with PhDs in philosophy actually used the word. However, as often happens when words from
         other languages are adopted into popular English, its plural changed to something that sounds more natural to an Anglophone
         ear. In this case, the plural form <span class="italic">schemata</span> seems to be rapidly dying out in favor of the simpler <span class="italic">schemas</span>. In fact, the three World Wide Web Consortium (W3C) schema specifications all use the plural form <span class="italic">schemas</span>. I follow this convention in this book.
      </p>
      
      <p class="GX">Since schemas is such a generic term, it shouldn't come as any surprise to you that there's more than one schema language
         for XML. In fact there are many, each with its own unique advantages and disadvantages. These include Murata Makoto's Relax
         (<code>http://www.xml.gr.jp/relax/</code>), Rick Jelliffe's Schematron (<code>http://www.ascc.net/xml/resource/schematron/schematron.html</code>), James Clark's TREX - Tree Regular Expressions for XML (<code>http://www.thaiopensource.com/trex/</code>), the Document Definition Markup Language (DDML, also known as XSchema, <code>http://purl.oclc.org/NET/ddml</code>), and the W3C's misleadingly, generically titled <span class="upCastTextColor-1">XML Schema language</span>. In addition, traditional XML DTDs can be considered to be yet another schema language.
      </p>
      
      <p class="GX">There are also a number of dead XML schema languages that have been abandoned by their manufacturers in favor of other languages.
         These include Document Content Description (DCD), Commerce One's Schema for Object-Oriented XML (SOX), and Microsoft's XML-Data
         Reduced (XDR). None of these are worth your time or investment at this point. They never achieved broad adoption, and their
         vendors are now moving to the W3C XML Schema language instead.
      </p>
      
      <p class="GX">This chapter focuses almost exclusively on the W3C XML Schema language. Nonetheless, TREX, Relax, and Schematron are definitely
         worthy of your attention as well. In particular, if you find W3C schemas to be excessively complex (and many people do so
         find them) and if you want a simpler schema language that still offers a complete set of extensible data types, you should
         consider Relax. Relax adopts the less controversial data types half of the W3C XML Schema recommendation, but replaces the
         much more complex and much less popular structures half with a much simpler language. Relax also has the advantage of being
         an official JIS and ISO standard.
      </p>
      
      <p class="GX">Most schema languages, including W3C schemas, Relax, TREX, DDML, and DTDs, take the approach that you must carefully specify
         what is allowed in the document. They are conservative: Everything not permitted is forbidden. If, on the other hand, you're
         looking for a less-restrictive schema language in which everything not forbidden is permitted, you should consider Schematron.
         Schematron is based on XPath, which allows it to make statements none of the other major schema languages can, such as "An
         <code>a</code> element cannot have another <code>a</code> element as a descendant, even though an <code>a</code> element can contain a <code>strong</code> element which can contain an <code>a</code> element if it itself is not a descendant of an <code>a</code> element." This isn&#8217;t a theoretical example. This is a real restriction in XHTML that has to be made in the prose of the specification
         because neither DTDs nor schemas are powerful enough to say it. What it means is that links can&#8217;t nest; that is, a link cannot
         contain another link.
      </p>
      
      <p class="GX">From this point forward, I will use the unqualified word <span class="italic">schema</span> to refer to the W3C's XML schema language; but please keep in mind that alternatives that are equally deserving of the appellation
         do exist.
      </p>
      
      <h2><a name="d1e700">The W3C XML Schema Language</a></h2>
      
      <p class="GX">The W3C XML Schema language was created by the W3C XML Schema Working Group based on many different submissions from a variety
         of companies and individuals. It is a very large specification designed to handle a broad range of use cases. In fact, the
         schema specification is considerably larger and more complex than the XML 1.0 specification. It is an open standard, free
         to be implemented by any interested party. There are no known patent, trademark, or other intellectual property restrictions
         that would prevent you from doing anything you might reasonably want to do with schemas. (which unfortunately is not quite
         the same thing as saying that there are no known patent, trademark, or other intellectual property restrictions that would
         prevent you from doing anything you might reasonably want to do. The U.S. Patent Office has been a little out of control lately,
         granting patents left and right for inventions that really don&#8217;t deserve it, including a lot of software and business processes.
         I would not be surprised to learn of an as yet unnoticed patent that at least claims to cover some or all of the W3C XML Schema
         language.)
      </p>
      
      <p class="SBT" style="font-weight: bold; margin-left: 0.5in; margin-right: 0.5in;        font-family: Arial, Helvetica, sans; color: #0000ff">Caution</p>
      
      <p class="SBT" style="font-family: Arial, Helvetica, sans;        margin-left: 0.5in; margin-right: 0.5in">This chapter is based on the May 2, 2001 Recommendation of XML Schemas. At the time of this writing, (June 2001) no software
         yet implements all of the final Recommendation. In fact, only one parser, Xerces-J, currently supports most of the W3C XML
         Schema language. Eventually, of course, this should be less of an issue as the standard evolves toward its final incarnation
         and more vendors implement the full schema language described here. In the meantime, if you do encounter something that doesn&#8217;t
         seem to work quite right, please report the problem to your parser vendor, not to me.
      </p>
      
      <h2><a name="d1e712">Hello Schemas</a></h2>
      
      <p class="GX">Let's begin our exploration of schemas with the ubiquitous Hello World example. Recall, once again, Listing 3-2 (greeting.xml)
         from Chapter 3. It is shown below:
      </p>
      
      <p style="font-weight: bold">Listing 3-2: 
         greeting.xml
      </p>
      
      <pre><code>&lt;?xml version="1.0"?&gt;
&lt;GREETING&gt;
Hello XML!
&lt;/GREETING&gt;
</code></pre>
      
      
      
      <p class="GX">This XML document contains a single element, <code>GREETING</code>. (Remember that <code>&lt;?xml version="1.0"?&gt;</code> is the XML declaration, not an element.) This element contains parsed character data. A schema for this document has to declare
         the <code>GREETING</code> element. It may declare other elements too, including ones that aren&#8217;t present in this particular document, but it must at
         least declare the <code>GREETING</code> element.
      </p>
      
      <h3>The greeting schema</h3>
      
      <p class="GX">Listing 24-1 is a very simple schema for <code>GREETING</code> elements. By convention it would be stored in a file with the three-letter extension .xsd, greeting.xsd for example, but
         that's not required. It is an XML document so it has an XML declaration. It can be written and saved in any text editor that
         knows how to save Unicode files. As always, you can use a different character set if you declare it in an encoding declaration.
         Schema documents are XML documents and have all the privileges and responsibilities of other XML documents. They can even
         have DTDs, <code>DOCTYPE</code> declarations, and style sheets if that seems useful to you, although in practice most do not.
      </p>
      
      <p style="font-weight: bold">Listing 24-1: 
         greeting.xsd
      </p>
      
      <pre><code>&lt;?xml version="1.0"?&gt;
&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;xsd:element name="GREETING" type="xsd:string"/&gt;
&lt;/xsd:schema&gt;
</code></pre>
      
      
      
      <p class="GX">The root element of this and all other schemas is <code>schema</code>. This must be in the <code>http://www.w3.org/2001/XMLSchema</code> namespace. Normally, this namespace is bound to the prefix <code>xsd</code> or <code>xs</code>, although this can change as long as the URI stays the same. The other common approach is to make this URI the default namespace,
         although that generally requires a few extra attributes to help separate out the names from the XML application the schema
         describes from the names of the schema elements themselves. You'll see this when namespaces are discussed at the end of this
         chapter.
      </p>
      
      <p class="GX">Elements are declared using <code>xsd:element</code> elements. Listing 24-1 includes a single such element declaring the <code>GREETING</code> element. The <code>name</code> attribute specifies which element is being declared, <code>GREETING</code> in this example. This <code>xsd:element</code> element also has a <code>type</code> attribute whose value is the data type of the element. In this case the type is <code>xsd:string</code>, a standard type for elements that can contain any amount of text in any form but not child elements. It's equivalent to
         a DTD content model of <code>#PCDATA</code>. That is, this <code>xsd:element</code> says that a valid <code>GREETING</code> element must look like this:
      </p>
      <pre><code>&lt;GREETING&gt;
  various random text but no markup
&lt;/GREETING&gt;
</code></pre>
      
      
      <p class="GX">There's no restriction on what text the element can contain. It can be zero or more Unicode characters with any meaning. Thus
         a <code>GREETING</code> element can also look like this:
      </p>
      <pre><code>&lt;GREETING&gt;Hello!&lt;/GREETING&gt;
</code></pre>
      <p class="GX">Or even this:</p>
      <pre><code>&lt;GREETING&gt;&lt;/GREETING&gt;
</code></pre>
      <p class="GX">However, a valid <code>GREETING</code> element may not look like this:
      </p>
      <pre><code>&lt;GREETING&gt;
  &lt;SOME_TAG&gt;various random text&lt;/SOME_TAG&gt;
  &lt;SOME_EMPTY_TAG/&gt;
&lt;/GREETING&gt;
</code></pre>
      
      
      
      <p class="GX">Nor may it look like this:</p>
      <pre><code>&lt;GREETING&gt;
  &lt;GREETING&gt;various random text&lt;/GREETING&gt;
&lt;/GREETING&gt;
</code></pre>
      
      
      <p class="GX">Each <code>GREETING</code> element must consist of nothing more and nothing less than parsed character data between an opening <code>&lt;GREETING&gt;</code> tag and a closing <code>&lt;/GREETING&gt;</code> tag.
      </p>
      
      <h3>Validating the document against the schema</h3>
      
      <p class="GX">Before a document can be validated against a DTD, the document itself must contain a document type declaration pointing to
         the DTD it should be validated against. You cannot easily receive a document from a third party and validate it against your
         own DTD. You have to validate it against the DTD that the document's author specified. This is excessively limiting.
      </p>
      
      <p class="GX">For example, imagine you're running an e-commerce business that accepts orders for products using SOAP or XML-RPC. Each order
         comes to you over the Internet as an XML document. Before accepting that order the first thing you want to do is check that
         it's valid against a DTD you've defined to make sure that it contains all the necessary information. However, if DTDs are
         all you have to validate with, then there's nothing to prevent a hacker sending you a document whose <code>DOCTYPE</code> declaration points to a different DTD. Then your system may report that the document is valid according to the hacked DTD,
         even though it would be invalid when compared to the correct DTD. If your system accepts the invalid document, it could introduce
         corrupt data that crashes the system or lets the hacker order goods they haven&#8217;t paid for, all because the person authoring
         the document got to choose which DTD to validate against rather than the person validating the document.
      </p>
      
      <p class="GX">Schemas are more flexible. The schema specification specifically allows for a variety of different means for associating documents
         with schemas. For instance, one possibility is that both the name of the document to validate and the name of the schema to
         validate it against could be passed to the validator program on the command line like this:
      </p>
      <pre><code>C:\&gt;validator greeting.xml greeting.xsd
</code></pre>
      <p class="GX">Parsers could also let you choose the schema by setting a SAX property or an environment variable. Many other schemes are
         possible. The schema specification does not mandate any one way of doing this. However, it does define one particular way
         to associate a document with a schema. As with <code>DOCTYPE</code> declarations and DTDs, this requires modifying the instance document to point to the schema. The difference is that with
         schemas, unlike with DTDs, this is not the only way to do it. Parser vendors are free to develop other mechanisms if they
         want to.
      </p>
      
      <p class="GX">To attach a schema to a document, add an <code>xsi:noNamespaceSchemaLocation</code> attribute to the document's root element. (You can also add it to the first element in the document that the schema applies
         to, but most of the time adding it to the root element is simplest.) The <code>xsi</code> prefix is mapped to the <code>http://www.w3.org/2001/XMLSchema-instance</code> URI. As always, the prefix can change as long as the URI stays the same. Listing 24-2 demonstrates.
      </p>
      
      <p style="font-weight: bold">Listing 24-2: 
         valid_greeting.xml
      </p>
      
      <pre><code>&lt;?xml version="1.0"?&gt;
&lt;GREETING xsi:noNamespaceSchemaLocation="greeting.xsd"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
Hello XML!
&lt;/GREETING&gt;
</code></pre>
      
      
      
      
      <p class="GX">You can now run the document through any parser that supports schema validation. One such parser is Xerces Java 1.4.0 from
         the XML Apache Project. In fact, you can use the same SAXCount program you learned about in Chapter 8 to validate against
         schemas as well as DTDs. When you set the <code>-v</code> flag, SAXCount validates the documents it parses against a DTD if it sees a <code>DOCTYPE</code> declaration and against a schema if it finds an <code>xsi:noNamespaceSchemaLocation</code> attribute. Assuming SAXCount finds no errors, it simply returns the amount of time that was required to parse the document:
      </p>
      <pre><code>C:\XML&gt;java sax.SAXCount -v valid_greeting.xml
valid_greeting.xml: 701 ms (1 elems, 1 attrs, 0 spaces, 12
chars)
</code></pre>
      
      
      <p class="SBT" style="font-weight: bold; margin-left: 0.5in; margin-right: 0.5in;        font-family: Arial, Helvetica, sans; color: #0000ff">Note</p>
      
      <p class="SBT" style="font-family: Arial, Helvetica, sans;        margin-left: 0.5in; margin-right: 0.5in">This chapter uses Xerces Java 1.4.0, which provides partial support for the May 2, 2001 Recommendation of XML Schema. At the
         time of this writing Xerces C++ has no schema support at all. Furthermore, earlier versions of Xerces Java support earlier
         drafts of the W3C XML Schema language that use different namespace URIs. In particular, they support the <code>http://www.w3.org/2000/10/XMLSchema-</code>and <code>http://www.w3.org/1999/XMLSchema</code> namespaces. You can download the latest version of Xerces from <code>http://xml.apache.org/xerces-j/</code>.
      </p>
      
      <p class="GX">Now let's suppose you have a document that's not valid, such as Listing 24-3. This document uses a <code>P</code> element that hasn't been declared in the schema.
      </p>
      
      <p style="font-weight: bold">Listing 24-3: 
         invalid_greeting.xml
      </p>
      
      <pre><code>&lt;?xml version="1.0"?&gt;
&lt;GREETING
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:noNamespaceSchemaLocation="greeting.xsd"&gt;
  &lt;P&gt;Hello XML!&lt;/P&gt;
&lt;/GREETING&gt;
</code></pre>
      
      
      
      
      
      <p class="GX">Running it through sax.SAXCount, you now get this output showing you what the problems are:</p>
      <pre><code>C:\XML&gt;java sax.SAXCount -v invalid_greeting.xml
[Error] invalid_greeting.xml:5:6: Element type "P" must be
declared.
[Error] invalid_greeting.xml:6:13: Datatype error: In element
'GREETING' : Can not have element children within a simple type
content.
invalid_greeting.xml: 1292 ms (2 elems, 2 attrs, 0 spaces, 14
chars)
</code></pre>
      
      
      
      
      
      
      
      <p class="GX">The validator found two problems. The first is that the <code>P</code> element is used but is not, itself, declared. The second is that the <code>GREETING</code> element is declared to have type <code>xsd:string</code>, one of several "simple" types that cannot have any child elements. However, in this case, the <code>GREETING</code> element does contain a child element: the <code>P</code> element.
      </p>
      
      <h2><a name="d1e1063">Complex Types</a></h2>
      
      <p class="GX">The W3C XML Schema language divides elements into complex and simple types. A simple type element is one like <code>GREETING</code> that can only contain text and does not have any attributes. It cannot contain any child elements. It may, however, be more
         limited in the kind of text it can contain. For instance, a schema can say that a simple element contains an integer, a date,
         or a decimal value between 3.76 and 98.24. Complex elements can have attributes and can have child elements.
      </p>
      
      <p class="GX">Most documents need a mix of both complex and simple elements. For example, consider Listing 24-4. This document describes
         the song <span class="italic">Yes I Am</span> by Melissa Etheridge. The root element is <code>SONG</code>. This element has a number of child elements giving the title of the song, the composer, the producer, the publisher, the
         duration of the song, the year it was released, the price, and the artist who sang it. Except for <code>SONG</code> itself, these are all simple elements that can have type <code>xsd:string</code>. You might see documents like this used in CD databases, MP3 players, Gnutella clients, or anything else that needs to store
         information about songs.
      </p>
      
      <p style="font-weight: bold">Listing 24-4: 
         yesiam.xml
      </p>
      
      <pre><code>&lt;?xml version="1.0"?&gt;
&lt;SONG xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:noNamespaceSchemaLocation="song.xsd"&gt;
  &lt;TITLE&gt;Yes I Am&lt;/TITLE&gt;
  &lt;COMPOSER&gt;Melissa Etheridge&lt;/COMPOSER&gt;
  &lt;PRODUCER&gt;Hugh Padgham&lt;/PRODUCER&gt;
  &lt;PUBLISHER&gt;Island Records&lt;/PUBLISHER&gt;
  &lt;LENGTH&gt;4:24&lt;/LENGTH&gt;
  &lt;YEAR&gt;1993&lt;/YEAR&gt;
  &lt;ARTIST&gt;Melissa Etheridge&lt;/ARTIST&gt;
  &lt;PRICE&gt;$1.25&lt;/PRICE&gt;
&lt;/SONG&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      <p class="GX">Now you need a schema that describes this and all other reasonable song documents. Listing 24-5 is the first attempt at such
         a schema.
      </p>
      
      <p style="font-weight: bold">Listing 24-5: 
         song.xsd
      </p>
      
      <pre><code>&lt;?xml version="1.0"?&gt;
&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;xsd:element name="SONG" type="SongType"/&gt;
  &lt;xsd:complexType name="SongType"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="TITLE"     type="xsd:string"/&gt;
      &lt;xsd:element name="COMPOSER"  type="xsd:string"/&gt;
      &lt;xsd:element name="PRODUCER"  type="xsd:string"/&gt;
      &lt;xsd:element name="PUBLISHER" type="xsd:string"/&gt;
      &lt;xsd:element name="LENGTH"    type="xsd:string"/&gt;
      &lt;xsd:element name="YEAR"      type="xsd:string"/&gt;
      &lt;xsd:element name="ARTIST"    type="xsd:string"/&gt;
      &lt;xsd:element name="PRICE"     type="xsd:string"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;
&lt;/xsd:schema&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <p class="GX">The root element of this schema is once again <code>xsd:schema</code>, and once again the prefix <code>xsd</code> is mapped to the namespace URI <code>http://www.w3.org/2001/XMLSchema</code>. This will be the case for all schemas in this chapter, and indeed all schemas that you write. I won&#8217;t note it again.
      </p>
      
      <p class="GX">This schema declares a single <span class="italic">top-level element</span>. That is, there is exactly one element declared in an <code>xsd:element</code> declaration that is an immediate child of the root <code>xsd:schema</code> element. This is the <code>SONG</code> element. Only top-level elements can be the root elements of documents described by this schema, though in general they do
         not have to be the root element.
      </p>
      
      <p class="GX">The <code>SONG</code> element is declared to have type <code>SongType</code>. The W3C Schema Working Group wasn't prescient. They built a lot of common types into the language, but they didn&#8217;t know
         that I was going to need a song type, and they didn&#8217;t provide one. Indeed, they could not reasonably have been expected to
         predict and provide for the numerous types that schema designers around the world were ever going to need. Instead, they provided
         facilities to allow users to define their own types. <code>SongType</code> is one such user-defined type. In fact, you can tell it's not a built-in type because it doesn&#8217;t begin with the prefix <code>xsd</code>. All built-in types are in the <code>http://www.w3.org/2001/XMLSchema</code> namespace.
      </p>
      
      <p class="GX">The <code>xsd:complexType</code> element defines a new type. The <code>name</code> attribute of this element names the type being defined. Here that name is <code>SongType</code>, which matches the type previously assigned to the <code>SONG</code> element. Forward references (for example, <code>xsd:element</code> using the <code>SongType</code> type before it's been defined) are perfectly acceptable in schemas. Circular references are okay, too. Type A can depend
         on type B which depends on type A. Schema processors sort all this out without any difficulty.
      </p>
      
      <p class="GX">The contents of the <code>xsd:complexType</code> element specify what content a <code>SongType</code> element must contain. In this example, the schema says that every <code>SongType</code> element contains a sequence of eight child elements: <code>TITLE</code>, <code>COMPOSER</code>, <code>PRODUCER</code>, <code>PUBLISHER</code>, <code>LENGTH</code>, <code>YEAR</code>, <code>PRICE</code>, and <code>ARTIST</code>. Each of these is declared to have the built-in type <code>xsd:string</code>. Each <code>SongType</code> element must contain exactly one of each of these in exactly that order. The only other content it may contain is insignificant
         white space between the tags.
      </p>
      
      <h3>minOccurs and maxOccurs</h3>
      
      <p class="GX">You can validate Listing 24-4, yesiam.xml, against the song schema, and it does, indeed, prove valid. Are you done? Is song.xsd
         now an adequate description of legal song documents? Suppose you instead wanted to validate Listing 24-6, a song document
         that describes <span class="italic">Hot Cop</span> by the Village People. Is it valid according to the schema in Listing 24-5?
      </p>
      
      <p style="font-weight: bold">Listing 24-6: 
         hotcop.xml
      </p>
      
      <pre><code>&lt;?xml version="1.0"?&gt;
&lt;SONG xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:noNamespaceSchemaLocation="song.xsd"&gt;
  &lt;TITLE&gt;Hot Cop&lt;/TITLE&gt;
  &lt;COMPOSER&gt;Jacques Morali&lt;/COMPOSER&gt;
  &lt;COMPOSER&gt;Henri Belolo&lt;/COMPOSER&gt;
  &lt;COMPOSER&gt;Victor Willis&lt;/COMPOSER&gt;
  &lt;PRODUCER&gt;Jacques Morali&lt;/PRODUCER&gt;
  &lt;PUBLISHER&gt;PolyGram Records&lt;/PUBLISHER&gt;
  &lt;LENGTH&gt;6:20&lt;/LENGTH&gt;
  &lt;YEAR&gt;1978&lt;/YEAR&gt;
  &lt;ARTIST&gt;Village People&lt;/ARTIST&gt;
&lt;/SONG&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      
      <p class="GX">The answer is no, it is not. The reason is that this song was a collaboration between three different composers and the existing
         schema only allows a single composer. Furthermore, the price is missing. If you looked at other songs, you'd find similar
         problems with the other child elements. <span class="italic">Under Pressure</span> has two artists, David Bowie and Queen. <span class="italic">We Are the World</span> has dozens of artists. Many songs have multiple producers. A garage band without a publisher might record a song and post
         it on Napster in the hope of finding one.
      </p>
      
      <p class="GX">The song schema needs to be adjusted to allow for varying numbers of particular elements. This is done by attaching <code>minOccurs</code> and <code>maxOccurs</code> attributes to each <code>xsd:element</code> element. These attributes specify the minimum and maximum number of instances of the element that may appear at that point
         in the document. The value of each attribute is an integer greater than or equal to zero. The <code>maxOccurs</code> attribute may also have the value <code>unbounded</code> to indicate that an unlimited number of the particular element may appear. Listing 24-7 demonstrates.
      </p>
      
      <p style="font-weight: bold">Listing 24-7: 
         minOccurs and maxOccurs
      </p>
      
      <pre><code>&lt;?xml version="1.0"?&gt;
&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;xsd:element name="SONG" type="SongType"/&gt;
  &lt;xsd:complexType name="SongType"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="TITLE"     type="xsd:string"
                   minOccurs="1"    maxOccurs="1"/&gt;
      &lt;xsd:element name="COMPOSER"  type="xsd:string"
                   minOccurs="1"    maxOccurs="unbounded"/&gt;
      &lt;xsd:element name="PRODUCER"  type="xsd:string"
                   minOccurs="0"    maxOccurs="unbounded"/&gt;
      &lt;xsd:element name="PUBLISHER" type="xsd:string"
                   minOccurs="0"    maxOccurs="1"/&gt;
      &lt;xsd:element name="LENGTH"    type="xsd:string"
                   minOccurs="1"    maxOccurs="1"/&gt;
      &lt;xsd:element name="YEAR"      type="xsd:string"
                   minOccurs="1"    maxOccurs="1"/&gt;
      &lt;xsd:element name="ARTIST"    type="xsd:string"
                   minOccurs="1"    maxOccurs="unbounded"/&gt;
      &lt;xsd:element name="PRICE"     type="xsd:string"
                   minOccurs="0"    maxOccurs="1"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;
&lt;/xsd:schema&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <p class="GX">This schema says that every <code>SongType</code> element must have, in order,
      </p>
      
      <ul>
         <li>Exactly one <code>TITLE</code> (<code>minOccurs="1" maxOccurs="1"</code>)
         </li>
         <li>At least one, and possibly a great many, <code>COMPOSER</code>s (<code>minOccurs="1" maxOccurs="unbounded"</code>)
         </li>
         <li>Any number of <code>PRODUCER</code>s, although possibly no producer at all (<code>minOccurs="0" maxOccurs="unbounded"</code>)
         </li>
         <li>Either one <code>PUBLISHER</code> or no <code>PUBLISHER</code> at all (<code>minOccurs="0" maxOccurs="1"</code>)
         </li>
         <li>Exactly one <code>LENGTH</code> (<code>minOccurs="1" maxOccurs="1"</code>)
         </li>
         <li>Exactly one <code>YEAR</code> (<code>minOccurs="1" maxOccurs="1"</code>)
         </li>
         <li>At least one <code>ARTIST</code>, possibly more (<code>minOccurs="1" maxOccurs="unbounded"</code>)
         </li>
         <li>An optional <code>PRICE</code>, (<code>minOccurs="0" maxOccurs="1"</code>)
         </li>
      </ul>
      
      
      
      
      
      
      
      
      <p class="GX">This is much more flexible and easier to use than the limited <code>?</code>, <code>*</code>, and <code>+</code> that are available in DTDs. It is very straightforward to say, for example, that you want between 4 and 7 of a given element.
         Just set <code>minOccurs</code> to 4 and <code>maxOccurs</code> to 7.
      </p>
      
      <p class="GX">If <code>minOccurs</code> and <code>maxOccurs</code> are not present, then the default value of each is 1. Taking advantage of this, the song schema can be written a little more
         compactly as shown in Listing 24-8.
      </p>
      
      <p style="font-weight: bold">Listing 24-8: 
         Taking advantage of the default values of minOccurs and maxOccurs
      </p>
      
      <pre><code>&lt;?xml version="1.0"?&gt;
&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;xsd:element name="SONG" type="SongType"/&gt;
  &lt;xsd:complexType name="SongType"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="TITLE"     type="xsd:string"/&gt;
      &lt;xsd:element name="COMPOSER"  type="xsd:string"
                   maxOccurs="unbounded"/&gt;
      &lt;xsd:element name="PRODUCER"  type="xsd:string"
                   minOccurs="0"    maxOccurs="unbounded"/&gt;
      &lt;xsd:element name="PUBLISHER" type="xsd:string"
                   minOccurs="0"/&gt;
      &lt;xsd:element name="LENGTH"    type="xsd:string"/&gt;
      &lt;xsd:element name="YEAR"      type="xsd:string"/&gt;
      &lt;xsd:element name="ARTIST"    type="xsd:string"
                   maxOccurs="unbounded"/&gt;
      &lt;xsd:element name="PRICE"     type="xsd:string"
                   minOccurs="0"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;
&lt;/xsd:schema&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <h3>Element content</h3>
      
      <p class="GX">The examples so far have all been relatively flat. That is, a <code>SONG</code> element contained other elements; but those elements only contained parsed character data, not child elements of their own.
         Suppose, however, that some child elements do contain other elements, as in Listing 24-9. Here the <code>COMPOSER</code> and <code>PRODUCER</code> elements each contain <code>NAME</code> elements.
      </p>
      
      <p style="font-weight: bold">Listing 24-9: 
         A deeper hierarchy
      </p>
      
      <pre><code>&lt;?xml version="1.0"?&gt;
&lt;SONG xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:noNamespaceSchemaLocation="24-10.xsd"&gt;
  &lt;TITLE&gt;Hot Cop&lt;/TITLE&gt;
  &lt;COMPOSER&gt;
    &lt;NAME&gt;Jacques Morali&lt;/NAME&gt;
  &lt;/COMPOSER&gt;
  &lt;COMPOSER&gt;
    &lt;NAME&gt;Henri Belolo&lt;/NAME&gt;
  &lt;/COMPOSER&gt;
  &lt;COMPOSER&gt;
    &lt;NAME&gt;Victor Willis&lt;/NAME&gt;
  &lt;/COMPOSER&gt;
  &lt;PRODUCER&gt;
    &lt;NAME&gt;Jacques Morali&lt;/NAME&gt;
  &lt;/PRODUCER&gt;
  &lt;PUBLISHER&gt;PolyGram Records&lt;/PUBLISHER&gt;
  &lt;LENGTH&gt;6:20&lt;/LENGTH&gt;
  &lt;YEAR&gt;1978&lt;/YEAR&gt;
  &lt;ARTIST&gt;Village People&lt;/ARTIST&gt;
&lt;/SONG&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <p class="GX">Because the <code>COMPOSER</code> and <code>PRODUCER</code> elements now have complex content, you can no longer use one of the built-in types such as <code>xsd:string</code> to declare them. Instead you have to define a new <code>ComposerType</code> and <code>ProducerType</code> using top-level <code>xsd:complexType</code> elements. Listing 24-10 demonstrates.
      </p>
      
      <p style="font-weight: bold">Listing 24-10: 
         Defining separate ComposerType and ProducerType types
      </p>
      
      <pre><code>&lt;?xml version="1.0"?&gt;
&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;xsd:element name="SONG" type="SongType"/&gt;
  &lt;xsd:complexType name="ComposerType"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="NAME" type="xsd:string"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;
  &lt;xsd:complexType name="ProducerType"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="NAME" type="xsd:string"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;
  &lt;xsd:complexType name="SongType"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="TITLE"     type="xsd:string"/&gt;
      &lt;xsd:element name="COMPOSER"  type="ComposerType"
                   maxOccurs="unbounded"/&gt;
      &lt;xsd:element name="PRODUCER"  type="ProducerType"
                   minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;xsd:element name="PUBLISHER" type="xsd:string"
                   minOccurs="0"/&gt;
      &lt;xsd:element name="LENGTH" type="xsd:string"/&gt;
      &lt;xsd:element name="YEAR"   type="xsd:string"/&gt;
      &lt;xsd:element name="ARTIST" type="xsd:string"
                   maxOccurs="unbounded"/&gt;
      &lt;xsd:element name="PRICE" type="xsd:string"
                   minOccurs="0"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;
&lt;/xsd:schema&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <h3>Sharing content models</h3>
      
      <p class="GX">You may have noticed that <code>PRODUCER</code> and <code>COMPOSER</code> are very similar. Each contains a single <code>NAME</code> child element and nothing else. In a DTD you'd take advantage of this shared content model via a parameter entity reference.
         In a schema, it's much easier. Simply given them the same type. While you could declare that the <code>PRODUCER </code>has <code>ComposerType</code> or vice versa, it's better to declare that both have a more generic <code>PersonType</code>. Listing 24-11 demonstrates.
      </p>
      
      <p style="font-weight: bold">Listing 24-11: 
         Using a single PersonType for both COMPOSER and PRODUCER
      </p>
      
      <pre><code>&lt;?xml version="1.0"?&gt;
&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;xsd:element name="SONG" type="SongType"/&gt;
  &lt;xsd:complexType name="PersonType"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="NAME" type="xsd:string"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;
  &lt;xsd:complexType name="SongType"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="TITLE"     type="xsd:string"/&gt;
      &lt;xsd:element name="COMPOSER"  type="PersonType"
                   maxOccurs="unbounded"/&gt;
      &lt;xsd:element name="PRODUCER"  type="PersonType"
                   minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;xsd:element name="PUBLISHER" type="xsd:string"
                   minOccurs="0"/&gt;
      &lt;xsd:element name="LENGTH" type="xsd:string"/&gt;
      &lt;xsd:element name="YEAR"   type="xsd:string"/&gt;
      &lt;xsd:element name="ARTIST" type="xsd:string"
                   maxOccurs="unbounded"/&gt;
      &lt;xsd:element name="PRICE" type="xsd:string"
                   minOccurs="0"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;
&lt;/xsd:schema&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <h3>Anonymous types</h3>
      
      <p class="GX">Suppose you wanted to divide the <code>NAME</code> elements into separate <code>GIVEN</code> and <code>FAMILY</code> elements like this:
      </p>
      <pre><code>&lt;NAME&gt;
  &lt;GIVEN&gt;Victor&lt;/GIVEN&gt;
  &lt;FAMILY&gt;Willis&lt;/FAMILY&gt;
&lt;/NAME&gt;
&lt;NAME&gt;
  &lt;GIVEN&gt;Jacques&lt;/GIVEN&gt;
  &lt;FAMILY&gt;Morali&lt;/FAMILY&gt;
&lt;/NAME&gt;
</code></pre>
      
      
      
      
      
      
      
      <p class="GX">To declare this, you could use an <code>xsd:complexType</code> element to define a new <code>NameType</code> element like this:
      </p>
      <pre><code>  &lt;xsd:complexType name="NameType"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="GIVEN"  type="xsd:string"/&gt;
      &lt;xsd:element name="FAMILY" type="xsd:string"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;
</code></pre>
      
      
      
      
      
      <p class="GX">Then the <code>PersonType</code> would be defined like this:
      </p>
      <pre><code>  &lt;xsd:complexType name="PersonType"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="NAME" type="NameType"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;
</code></pre>
      
      
      
      
      <p class="GX">However, the <code>NAME</code> element is only used inside <code>PersonType</code> elements. Perhaps it shouldn't be a top-level definition. For instance, you may not want to allow <code>NAME</code> elements to be used as root elements, or to be children of things that aren&#8217;t <code>PersonType</code> elements. You can prevent this by defining a name with an <span class="italic">anonymous type</span>. To do this, instead of assigning the <code>NAME</code> element a type with a <code>type</code> attribute on the corresponding <code>xsd:element</code> element, you give it an <code>xsd:complexType</code> child element to define its type. Listing 24-12 demonstrates.
      </p>
      
      <p style="font-weight: bold">Listing 24-12: 
         Anonymous types
      </p>
      
      <pre><code>&lt;?xml version="1.0"?&gt;
&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;xsd:element name="SONG" type="SongType"/&gt;
  &lt;xsd:complexType name="PersonType"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="NAME"&gt;
        &lt;xsd:complexType&gt;
          &lt;xsd:sequence&gt;
            &lt;xsd:element name="GIVEN"  type="xsd:string"/&gt;
            &lt;xsd:element name="FAMILY" type="xsd:string"/&gt;
          &lt;/xsd:sequence&gt;
        &lt;/xsd:complexType&gt;
      &lt;/xsd:element&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;
  &lt;xsd:complexType name="SongType"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="TITLE"     type="xsd:string"/&gt;
      &lt;xsd:element name="COMPOSER"  type="PersonType"
                   maxOccurs="unbounded"/&gt;
      &lt;xsd:element name="PRODUCER"  type="PersonType"
                   minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;xsd:element name="PUBLISHER" type="xsd:string"
                   minOccurs="0"/&gt;
      &lt;xsd:element name="LENGTH" type="xsd:string"/&gt;
      &lt;xsd:element name="YEAR"   type="xsd:string"/&gt;
      &lt;xsd:element name="ARTIST" type="xsd:string"
                   maxOccurs="unbounded"/&gt;
      &lt;xsd:element name="PRICE" type="xsd:string"
                   minOccurs="0"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;
&lt;/xsd:schema&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <p class="GX">Defining the element types inside the <code>xsd:element</code> elements that are themselves children of <code>xsd:complexType</code> elements is a very powerful technique. Among other things, it enables you to give elements with the same name different types
         when used in different elements. For example, you can say that the <code>NAME</code> of a <code>PERSON</code> contains <code>GIVEN</code> and <code>FAMILY</code> child elements while the <code>NAME</code> of a <code>MOVIE</code> contains an <code>xsd:string</code> and the <code>NAME</code> of a <code>VARIABLE</code> contains a string containing only alphanumeric characters from the ASCII character set.
      </p>
      
      <h3>Mixed content</h3>
      
      <p class="GX">Schemas offer much greater control over mixed content than DTDs do. In particular, schemas let you enforce the order and number
         of elements appearing in mixed content. For example, suppose you wanted to allow extra text to be mixed in with the names
         to provide middle initials, titles, and the like as shown in Listing 24-13.
      </p>
      
      <p class="SBT" style="font-weight: bold; margin-left: 0.5in; margin-right: 0.5in;        font-family: Arial, Helvetica, sans; color: #0000ff">Caution</p>
      
      <p class="SBT" style="font-family: Arial, Helvetica, sans;        margin-left: 0.5in; margin-right: 0.5in">The format used here is purely for illustrative purposes. In practice, I'd recommend that you make the middle names and titles
         separate elements as well.
      </p>
      
      <p style="font-weight: bold">Listing 24-13: 
         Mixed content
      </p>
      
      <pre><code>&lt;?xml version="1.0"?&gt;
&lt;SONG xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:noNamespaceSchemaLocation="24-14.xsd"&gt;
  &lt;TITLE&gt;Hot Cop&lt;/TITLE&gt;
  &lt;COMPOSER&gt;
    &lt;NAME&gt;
      Mr. &lt;GIVEN&gt;Jacques&lt;/GIVEN&gt; &lt;FAMILY&gt;Morali&lt;/FAMILY&gt; Esq.
    &lt;/NAME&gt;
  &lt;/COMPOSER&gt;
  &lt;COMPOSER&gt;
    &lt;NAME&gt;
      Mr. &lt;GIVEN&gt;Henri&lt;/GIVEN&gt; L. &lt;FAMILY&gt;Belolo&lt;/FAMILY&gt;, M.D.
    &lt;/NAME&gt;
  &lt;/COMPOSER&gt;
  &lt;COMPOSER&gt;
    &lt;NAME&gt;
      Mr. &lt;GIVEN&gt;Victor&lt;/GIVEN&gt; C. &lt;FAMILY&gt;Willis&lt;/FAMILY&gt;
    &lt;/NAME&gt;
  &lt;/COMPOSER&gt;
  &lt;PRODUCER&gt;
    &lt;NAME&gt;
      Mr. &lt;GIVEN&gt;Jacques&lt;/GIVEN&gt; S. &lt;FAMILY&gt;Morali&lt;/FAMILY&gt;
    &lt;/NAME&gt;
  &lt;/PRODUCER&gt;
  &lt;PUBLISHER&gt;PolyGram Records&lt;/PUBLISHER&gt;
  &lt;LENGTH&gt;6:20&lt;/LENGTH&gt;
  &lt;YEAR&gt;1978&lt;/YEAR&gt;
  &lt;ARTIST&gt;Village People&lt;/ARTIST&gt;
&lt;/SONG&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <p class="GX">It's very easy to declare that an element has mixed content in schemas. First, set up the <code>xsd:complexType</code> exactly as you would if the element only contained child elements. Then add a <code>mixed</code> attribute to it with the value <code>true</code>. Listing 24-14 demonstrates. It is almost identical to Listing 24-12 except for the addition of the <code>mixed="true"</code> attribute.
      </p>
      
      <p style="font-weight: bold">Listing 24-14: 
         Declaring mixed content in a schema
      </p>
      
      <pre><code>&lt;?xml version="1.0"?&gt;
&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;xsd:element name="SONG" type="SongType"/&gt;
  &lt;xsd:complexType name="PersonType"&gt;
    &lt;xsd:sequence&gt;
         &lt;xsd:element name="NAME"&gt;
           &lt;xsd:complexType mixed="true"&gt;
&nbsp;&nbsp;  &lt;xsd:sequence&gt;
            &lt;xsd:element name="GIVEN"  type="xsd:string"/&gt;
        &nbsp;    &lt;xsd:element name="FAMILY" type="xsd:string"/&gt;
&nbsp;&nbsp;  &lt;/xsd:sequence&gt;
      &nbsp;&lt;/xsd:complexType&gt;
      &lt;/xsd:element&gt;
&nbsp; &lt;/xsd:sequence&gt;
&lt;/xsd:complexType&gt;
  &lt;xsd:complexType name="SongType"&gt;
    &lt;xsd:sequence&gt;
   &lt;xsd:element name="TITLE"     type="xsd:string"/&gt;
      &lt;xsd:element name="COMPOSER"  type="PersonType"
                   maxOccurs="unbounded"/&gt;
      &lt;xsd:element name="PRODUCER"  type="PersonType"
                   minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;xsd:element name="PUBLISHER" type="xsd:string"
                   minOccurs="0"/&gt;
      &lt;xsd:element name="LENGTH" type="xsd:string"/&gt;
      &lt;xsd:element name="YEAR"   type="xsd:string"/&gt;
      &lt;xsd:element name="ARTIST" type="xsd:string"/&gt;
                   maxOccurs<span class="annotation-reference"><span style="{font-size: 8pt}"><span class="upCastTextColor-6"><span style="{font-family: Times New Roman}">
                  </span></span></span>="unbounded"/&gt;</span>
<span class="annotation-reference">      &lt;xsd:element name="PRICE" type="xsd:string"</span>
                   minOccurs="0"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;
&lt;/xsd:schema&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <h2><a name="d1e2436">Grouping</a></h2>
      
      <p class="GX">So far, all the schemas you've seen have held that order mattered; for example, that it would be wrong to put the <code>COMPOSER</code> before the <code>TITLE</code> or the <code>PRODUCER</code> after the <code>ARTIST</code>. Given these schemas, the document shown below in Listing 24-15 is clearly invalid. But should it be? Element order often
         does matter in narrative documents such as books and Web pages. However, it's not nearly as important in data-centric documents
         like the examples in this chapter. Do you really care whether the <code>TITLE</code> comes first or not, as long as there is a <code>TITLE</code>? After all, if the document's going to be shown to a human being, it will probably first be transformed with an XSLT style
         sheet that can easily place the contents in any order it likes.
      </p>
      
      <p style="font-weight: bold">Listing 24-15: 
         A song document that places the elements in a different order
      </p>
      
      <pre><code>&lt;?xml version="1.0"?&gt;
&lt;SONG xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:noNamespaceSchemaLocation="song.xsd"&gt;
  &lt;ARTIST&gt;Village People&lt;/ARTIST&gt;
  &lt;TITLE&gt;Hot Cop&lt;/TITLE&gt;
  &lt;COMPOSER&gt;
    &lt;NAME&gt;&lt;GIVEN&gt;Jacques&lt;/GIVEN&gt; &lt;FAMILY&gt;Morali&lt;/FAMILY&gt;&lt;/NAME&gt;
  &lt;/COMPOSER&gt;
  &lt;PUBLISHER&gt;PolyGram Records&lt;/PUBLISHER&gt;
  &lt;COMPOSER&gt;
    &lt;NAME&gt;&lt;FAMILY&gt;Belolo&lt;/FAMILY&gt; &lt;GIVEN&gt;Henri&lt;/GIVEN&gt;&lt;/NAME&gt;
  &lt;/COMPOSER&gt;
  &lt;YEAR&gt;1978&lt;/YEAR&gt;
  &lt;COMPOSER&gt;
    &lt;NAME&gt;&lt;FAMILY&gt;Willis&lt;/FAMILY&gt; &lt;GIVEN&gt;Victor&lt;/GIVEN&gt;&lt;/NAME&gt;
  &lt;/COMPOSER&gt;
  &lt;PRODUCER&gt;
    &lt;NAME&gt;&lt;GIVEN&gt;Jacques&lt;/GIVEN&gt; &lt;FAMILY&gt;Morali&lt;/FAMILY&gt;&lt;/NAME&gt;
  &lt;/PRODUCER&gt;
  &lt;PRICE&gt;$1.25&lt;/PRICE&gt;
&lt;/SONG&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <p class="GX">The W3C XML Schema language provides three grouping constructs that specify whether and how ordering of individual elements
         is important. These are:
      </p>
      
      <ul>
         <li>The <code>xsd:all</code> group requires that each element in the group must occur at most once, but that order is not important.
         </li>
         <li>The <code>xsd:choice</code> group specifies that any one element from the group should appear. It can also be used to say that between N and M elements
            from the group should appear in any order.
         </li>
         <li>The <code>xsd:sequence</code> group requires that each element in the group appear exactly once, in the specified order.
         </li>
      </ul>
      
      
      
      <p class="GX">Unfortunately, these constructs are not everything you might desire. In particular, you can&#8217;t specify constraints such as
         those that would be required to really handle Listing 24-14. In particular, you can&#8217;t specify that you want a <code>SONG</code> to have exactly one <code>TITLE</code>, one or more <code>COMPOSER</code>s, zero or more <code>PRODUCER</code>s, one or more <code>ARTIST</code>s, but that you don&#8217;t care in what order the individual elements occur.
      </p>
      
      <h3>The xsd:all Group</h3>
      
      <p class="GX">You can specify that you want each <code>NAME</code> element to have exactly one <code>GIVEN</code> child and one <code>FAMILY</code> child, but that you don&#8217;t care what order they appear in. The <code>xsd:all</code> group accomplishes this. For example,
      </p>
      <pre><code>&lt;xsd:complexType name="PersonType"&gt;
  &lt;xsd:sequence&gt;
    &lt;xsd:element name="NAME"&gt;
      &lt;xsd:complexType&gt;
        &lt;xsd:all&gt;
          &lt;xsd:element name="GIVEN" type="xsd:string"
                       minOccurs="1" maxOccurs="1"/&gt;
          &lt;xsd:element name="FAMILY" type="xsd:string"
                       minOccurs="1" maxOccurs="1"/&gt;
        &lt;/xsd:all&gt;
      &lt;/xsd:complexType&gt;
    &lt;/xsd:element&gt;
  &lt;/xsd:sequence&gt;
&lt;/xsd:complexType&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      
      
      <p class="GX">The extension to handle what you want for Listing 24-15 seems obvious. It would look like this:</p>
      <pre><code>&lt;xsd:complexType name="SongType"&gt;
  &lt;xsd:all&gt;
    &lt;xsd:element name="TITLE" type="xsd:string"
                 minOccurs="1" maxOccurs="1"/&gt;
    &lt;xsd:element name="COMPOSER" type="PersonType"
                 minOccurs="1" maxOccurs="unbounded"/&gt;
    &lt;xsd:element name="PRODUCER" type="PersonType"
                 minOccurs="0" maxOccurs="unbounded"/&gt;
    &lt;xsd:element name="PUBLISHER" type="xsd:string"
                 minOccurs="0" maxOccurs="1"/&gt;
    &lt;xsd:element name="LENGTH" type="xsd:string"
                 minOccurs="1" maxOccurs="1"/&gt;
    &lt;xsd:element name="YEAR" type="xsd:string"
                 minOccurs="1" maxOccurs="1"/&gt;
    &lt;xsd:element name="ARTIST" type="xsd:string"
                 minOccurs="1" maxOccurs="unbounded"/&gt;
    &lt;xsd:element name="PRICE" type="xsd:string" minOccurs="0"/&gt;
  &lt;/xsd:all&gt;
&lt;/xsd:complexType&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <p class="GX">Unfortunately, the W3C XML Schema language restricts the use of <code>minOccurs</code> and <code>maxOccurs</code> inside <code>xsd:all</code> elements. In particular, each one's value must be <code>0</code> or <code>1</code>. You cannot set it to <code>4</code> or <code>7</code> or <code>unbounded</code>. Therefore the above type definition is invalid. Furthermore, <code>xsd:all</code> can only contain individual element declarations. It cannot contain <code>xsd:choice</code> or <code>xsd:sequence</code> elements. <code>xsd:all</code> offers somewhat more expressivity than DTDs do, but probably not as much as you want.
      </p>
      
      <h3>Choices</h3>
      
      <p class="GX">The <code>xsd:choice</code> element is the schema equivalent of the <code>|</code> in DTDs. When <code>xsd:element</code> elements are combined inside an <code>xsd:choice</code>, then exactly one of those elements must appear in instance documents. For example, the choice in this <code>xsd:complexType</code> requires either a <code>PRODUCER</code> or a <code>COMPOSER</code>, but not both.
      </p>
      <pre><code>&lt;xsd:complexType name="SongType"&gt;
  &lt;xsd:sequence&gt;
    &lt;xsd:element name="TITLE" type="xsd:string"/&gt;
    &lt;xsd:choice&gt;
      &lt;xsd:element name="COMPOSER" type="PersonType"/&gt;
      &lt;xsd:element name="PRODUCER" type="PersonType"/&gt;
    &lt;/xsd:choice&gt;
    &lt;xsd:element name="PUBLISHER" type="xsd:string"
                 minOccurs="0"/&gt;
    &lt;xsd:element name="LENGTH" type="xsd:string"/&gt;
    &lt;xsd:element name="YEAR"   type="xsd:string"/&gt;
    &lt;xsd:element name="ARTIST" type="xsd:string"
                 maxOccurs="unbounded"/&gt;
    &lt;xsd:element name="PRICE" type="xsd:string" minOccurs="0"/&gt;
  &lt;/xsd:sequence&gt;
&lt;/xsd:complexType&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <p class="GX">The <code>xsd:choice</code> element itself can have <code>minOccurs</code> and <code>maxOccurs</code> attributes that establish exactly how many selections may be made from the choice. For example, setting <code>minOccurs</code> to 1 and <code>maxOccurs</code> to 6 would indicate that between one and six elements listed in the <code>xsd:choice</code> should appear. Each of these can be any of the elements in the <code>xsd:choice</code>. For example, you could have six different elements, three of the same element and three of another, or up to six of the
         same element. This next <code>xsd:choice</code> allows for any number of artists, composers, and producers. However, in order to require that there be at least one <code>ARTIST</code> element and at least one <code>COMPOSER</code> element, rather than allowing all spaces to be filled by <code>PRODUCER</code> elements, it's necessary to place <code>xsd:element</code> declarations for these two outside the choice. This has the unfortunate side-effect of locking in more order than is really
         needed.
      </p>
      <pre><code>&lt;xsd:complexType name="SongType"&gt;
  &lt;xsd:sequence&gt;
    &lt;xsd:element name="TITLE" type="xsd:string"/&gt;
    &lt;xsd:element name="COMPOSER" type="PersonType"/&gt;
    &lt;xsd:choice minOccurs="0" maxOccurs="unbounded"&gt;
      &lt;xsd:element name="PRODUCER" type="PersonType"/&gt;
      &lt;xsd:element name="COMPOSER" type="PersonType"/&gt;
      &lt;xsd:element name="ARTIST"   type="xsd:string"/&gt;
    &lt;/xsd:choice&gt;
    &lt;xsd:element name="ARTIST" type="xsd:string"/&gt;
    &lt;xsd:element name="PUBLISHER" type="xsd:string"
                 minOccurs="0"/&gt;
    &lt;xsd:element name="LENGTH" type="xsd:string"/&gt;
    &lt;xsd:element name="YEAR"   type="xsd:string"/&gt;
    &lt;xsd:element name="PRICE" type="xsd:string" minOccurs="0"/&gt;
  &lt;/xsd:sequence&gt;
&lt;/xsd:complexType&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <h3>Sequences</h3>
      
      <p class="GX">An <code>xsd:sequence</code> element requires each member of the sequence to appear in the same order in the instance document as in the <code>xsd:sequence</code> element. I've used this frequently as the basic group for <code>xsd:complexType</code> elements in this chapter so far. The number of times each element is allowed to appear can be controlled by the <code>xsd:element</code>'s <code>minOccurs</code> and <code>maxOccurs</code> attributes. You can add <code>minOccurs</code> and <code>maxOccurs</code> attributes to the <code>xsd:sequence</code> element to specify the number of times the sequence should repeat.
      </p>
      
      <h2><a name="d1e2925">Simple Types</a></h2>
      
      <p class="GX">Until now I've focused on writing schemas that validate the element structures in an XML document. However, there's also a
         lot of non-XML structure in the song documents. The <code>YEAR</code> element isn't just a string. It's an integer, and maybe not just any integer either, but a positive integer with four digits.
         The <code>PRICE</code> element is some sort of money. The <code>LENGTH</code> element is a duration of time. DTDs have absolutely nothing to say about such non-XML structures that are inside the parsed
         character data content of elements and attributes. Schemas, however, do let you make all sorts of statements about what forms
         the text inside elements may take and what it means. Schemas provide much more sophisticated semantics for documents than
         DTDs do.
      </p>
      
      <p class="GX">Listing 24-16 is a new schema for song documents. It's based on Listing 24-8, but read closely and you should notice that
         a few things have changed.
      </p>
      
      <p style="font-weight: bold">Listing 24-16: 
         A schema with simple data types
      </p>
      
      <pre><code>&lt;?xml version="1.0"?&gt;
&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;xsd:element name="SONG" type="SongType"/&gt;
  &lt;xsd:complexType name="SongType"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="TITLE"     type="xsd:string"/&gt;
      &lt;xsd:element name="COMPOSER"  type="xsd:string"
                   maxOccurs="unbounded"/&gt;
      &lt;xsd:element name="PRODUCER"  type="xsd:string"
                   minOccurs="0"    maxOccurs="unbounded"/&gt;
      &lt;xsd:element name="PUBLISHER" type="xsd:string"
                   minOccurs="0"/&gt;
      &lt;xsd:element name="LENGTH"    type="xsd:duration"/&gt;
      &lt;xsd:element name="YEAR"      type="xsd:gYear"/&gt;
      &lt;xsd:element name="ARTIST"    type="xsd:string"
                   maxOccurs="unbounded"/&gt;
      &lt;xsd:element name="PRICE"     type="xsd:string"
                   minOccurs="0"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;
&lt;/xsd:schema&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <p class="GX">Did you spot the changes? The values of the <code>type</code> attributes of the <code>LENGTH</code> and <code>YEAR</code> declarations are no longer <code>xsd:string</code>. Instead, <code>LENGTH</code> has the type <code>xsd:duration</code> and <code>YEAR</code> has the type <code>xsd:gYear</code>. These declarations say that it's no longer okay for the <code>YEAR</code> and <code>LENGTH</code> elements to contain just any old string of text. Instead they must contain strings in particular formats. In particular,
         the <code>YEAR</code> element must contain a year; and the <code>LENGTH</code> element must contain a recognizable length of time. When you check a document against this schema, the validator will check
         that these elements contain the proper data. It's not just looking at the elements. It's looking at the content inside the
         elements!
      </p>
      
      <p class="GX">Let's actually validate hotcop.xml against this schema and see what we get:</p>
      <pre><code>C:\XML&gt;java sax.SAXCount -v hotcop.xml
[Error] hotcop.xml:10:25: Datatype error: In element 'LENGTH' :
Value '6:20' is not legal value for current datatype.
hotcop.xml: 1783 ms (10 elems, 2 attrs, 28 spaces, 98 chars)
</code></pre>
      
      
      
      <p class="GX">That's unexpected! The problem is that 6:20 is not in the proper format for time durations, at least not the format that the
         W3C XML Schema language uses and that schema validators know how to check. Schema validators expect that time types are expressed
         in the format defined in ISO standard 8601, <span class="italic">Representations of dates and times</span> (<code>http://www.iso.ch/markete/8601.pdf</code>). This standard says that time durations should have the form PnYnMnDTnHnMdS, where <span class="italic">n</span> is an integer and <span class="italic">d</span> is a decimal number. <span class="italic">P</span> stands for "Period". <span class="italic">nY</span> gives the number of years; the first <span class="italic">nM</span> gives the number of months; and <span class="italic">nD</span> gives the number of days. <span class="italic">T</span> separates the date from the time. Following the T, <span class="italic">nH</span> gives the number of hours; the second <span class="italic">nM</span> gives the number of minutes; and <span class="italic">dS</span> gives the number of seconds. If <span class="italic">d</span> has a fraction part, then the duration can be specified to an arbitrary level of precision.
      </p>
      
      <p class="GX">In this format, a duration of 6 minutes and 20 seconds should be written as P0Y0M0DT0H6M20S. If you prefer, the zero pieces
         can be left out, so you can write this more compactly as PT6M20S. Listing 24-17 shows the fixed version of hotcop.xml with
         the <code>LENGTH</code> in the right format.
      </p>
      
      <p style="font-weight: bold">Listing 24-17: 
         fixed hotcop.xml
      </p>
      
      <pre><code>&lt;?xml version="1.0"?&gt;
&lt;SONG xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:noNamespaceSchemaLocation="24-16.xsd"&gt;
  &lt;TITLE&gt;Hot Cop&lt;/TITLE&gt;
  &lt;COMPOSER&gt;Jacques Morali&lt;/COMPOSER&gt;
  &lt;COMPOSER&gt;Henri Belolo&lt;/COMPOSER&gt;
  &lt;COMPOSER&gt;Victor Willis&lt;/COMPOSER&gt;
  &lt;PRODUCER&gt;Jacques Morali&lt;/PRODUCER&gt;
  &lt;PUBLISHER&gt;PolyGram Records&lt;/PUBLISHER&gt;
  &lt;LENGTH&gt;P0YT6M20S&lt;/LENGTH&gt;
  &lt;YEAR&gt;1978&lt;/YEAR&gt;
  &lt;ARTIST&gt;Village People&lt;/ARTIST&gt;
&lt;/SONG&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      
      <p class="GX">Admittedly the ISO 8601 format for time durations is a little obtuse, if precise. You may well be asking whether there's a
         type that you can specify for the <code>LENGTH</code> that would make lengths such as 6:20 and 4:24 legal. In fact, there's no such type built-in to the W3C XML Schema language;
         but you can define one yourself. You'll learn how to do that soon, but first let's explore some of the other data types that
         are built-in to the W3C XML Schema language.
      </p>
      
      <p class="GX">There are 44 built-in simple types in the W3C XML Schema language. These can be unofficially divided into seven groups:</p>
      
      <ul>
         <li>Numeric types</li>
         <li>Time types</li>
         <li>XML types</li>
         <li>String types</li>
         <li>The boolean type</li>
         <li>The URI reference type</li>
         <li>The binary types</li>
      </ul>
      
      
      
      
      
      
      
      <h3>Numeric data types</h3>
      
      <p class="GX">The most obvious data types, and the ones most familiar to programmers, are the numeric data types. Among computer scientists,
         there's quite a bit of disagreement about how numbers should be represented in computer systems. The W3C XML Schema language
         tries to make everyone happy by providing almost every numeric type imaginable including:
      </p>
      
      <ul>
         <li>Integer and floating point numbers</li>
         <li>Finite size numbers similar to those in Java and C and infinitely precise, unlimited-size numbers similar to those in Eiffel
            and Java's <code>java.math</code> package
         </li>
         <li>Signed and unsigned numbers</li>
      </ul>
      
      
      
      <p class="GX">You'll probably only use a subset of these. For instance, you wouldn&#8217;t use both the arbitrarily large <code>xsd:integer</code> type and the four-byte limited <code>xsd:int</code> type. Table 24-1 summarizes the different numeric types.
      </p>
      
      <p style="font-weight: bold; text-align: center; font-family: Arial, Helvetica, sans">Table 24-1: 
         Schema Numeric Types
      </p>
      
      
      <table border="1" summary="(unspecified contents)">
         
         <colgroup span="1">
            <col width="120" span="1">
            <col width="122" span="1">
            <col width="180" span="1">
         </colgroup>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p style="font-weight: bold; font-family: Arial, Helvetica, sans">Name: 
                  
               </p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p style="font-weight: bold; font-family: Arial, Helvetica, sans">Type: 
                  
               </p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p style="font-weight: bold; font-family: Arial, Helvetica, sans">Examples: 
                  
               </p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>xsd:float</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">IEEE 754 32-bit floating point number, or as close as you can get using a base 10 representation; same as Java's <code>float</code> type
               </p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">-INF, -1E4, -0, 0, 12.78E-2, 12, INF, NaN</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>xsd:double</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">IEEE 754 64-bit floating point number, or as close as you can get using a base 10 representation; same as Java's <code>double</code> type
               </p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">-INF, 1.401E-90, -1E4, -0, 0, 12.78E-2, 12, INF, NaN, 3.4E42</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>xsd:decimal</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Arbitrary precision, decimal numbers; same as <code>java.math.BigDecimal</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">-2.7E400, 5.7E-444, -3.1415292, 0, 7.8, 90200.76, 3.4E1024</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>xsd:integer</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">An arbitrarily large or small integer; same as <code>java.math.BigInteger</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">-500000000000000000000000, -9223372036854775809, -126789, -1, 0, 1, 5, 23, 42, 126789, 9223372036854775808, 4567349873249832649873624958</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>xsd:nonPositiveInteger</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">An integer less than or equal to zero</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">0, -1, -2, -3, -4, -5, -6, -7, -8, -9, . . .<span style="{font-size: 8pt}"><span class="upCastTextColor-6"><span class="annotation-reference">
                           </span></span></span></p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>xsd:negativeInteger</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">An integer strictly less than zero</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">-1, -2, -3, -4, -5, -6, -7, -8, -9, . . .</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>xsd:long</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">An eight-byte two's complement integer such as Java's <code>long</code> type
               </p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">-9223372036854775808, -9223372036854775807, . . . -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
                  . . ., 2147483645, 2147483646, 2147483647, 2147483648, . . .9223372036854775806, 9223372036854775807
               </p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>xsd:int</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">An integer that can be represented as a four-byte, two's complement number such as Java's <code>int</code> type
               </p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">-2147483648, -2147483647, -2147483646, 2147483645, . . . -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,
                  13, 14, . . ., 2147483645, 2147483646, 2147483647 
               </p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>xsd:short</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">An integer that can be represented as a two-byte, two's complement number such as Java's <code>short</code> type
               </p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">-32768, -32767, -32766, . . ., -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,  . . . 32765,
                  32766, 32767
               </p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>xsd:byte</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">An integer that can be represented as a one-byte, two's complement number such as Java's <code>byte</code> type
               </p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">-128, -127, -126, -125, . . ., -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, . . .121, 122, 123, 124,
                  125, 126, 127 
               </p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>xsd:nonNegativeInteger</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">An integer greater than or equal to zero</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, . . .. . .</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>xsd:unsignedLong</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">An eight-byte unsigned integer</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, . . .18446744073709551614, 18446744073709551615</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>xsd:unsignedInt</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">A four-byte unsigned integer</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">0, 1, 2, 3, 4, 5, . . .4294967294, 4294967295 </p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>xsd:unsignedShort</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">A two-byte unsigned integer</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, . . .65533, 65534, 65535</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>xsd:unsignedByte</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">A one-byte unsigned integer</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, . . . 252, 253, 254, 255</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>xsd:positiveInteger</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">An integer strictly greater than zero</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, . . .</p>
               
            </td>
            
         </tr>
         
      </table>
      
      <h3>Time data types</h3>
      
      <p class="GX">The next set of simple types the W3C XML Schema language provides are more familiar to database designers than to procedural
         programmers; these are the time types. These can represent times of day, dates, or durations of time. The formats, shown in
         Table 24-2, are all based on the ISO standard 8601, <span class="italic">Representations of dates and times</span> (<code>http://www.iso.ch/markete/8601.pdf</code>). Time zones are given as offsets from Coordinated Universal Time (Greenwich Mean Time to laypeople) or as the letter Z to
         indicate Coordinated Universal Time.
      </p>
      
      <p style="font-weight: bold; text-align: center; font-family: Arial, Helvetica, sans">Table 24-2: 
         XML Schema Time Types
      </p>
      
      
      <table border="1" summary="(unspecified contents)">
         
         <colgroup span="1">
            <col width="94" span="1">
            <col width="159" span="1">
            <col width="183" span="1">
         </colgroup>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p style="font-weight: bold; font-family: Arial, Helvetica, sans">Name: 
                  
               </p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p style="font-weight: bold; font-family: Arial, Helvetica, sans">Type: 
                  
               </p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p style="font-weight: bold; font-family: Arial, Helvetica, sans">Examples: 
                  
               </p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>xsd:dateTime</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">A particular moment in Coordinated Universal Time, up to an arbitrarily small fraction of a second</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">1999-05-31T13:20:00.000-05:00, 1999-05-31T18:20:00.000Z, 1999-05-31T13:20:00.000, 1999-05-31T13:20:00.000-05:00.321 </p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>xsd:date</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">A specific day in history</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">-0044-03-15, 0001-01-01, 1969-06-27, 2000-10-31, 2001-11-17</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>xsd:time</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">A specific time of day that recurs every day</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">14:30:00.000, 09:30:00.000-05:00, 14:30:00.000Z</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>xsd:gDay</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">A day in no particular month, or rather in every month</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">--01, --02, . . . &#8211;09, --10, --11, --12, . . ., --28, --29, --30, --31</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>xsd:gMonth</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">A month in no particular year</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">--01--,  --02--,  --03--, ---04--, . . . --09--, --10--,  --11--, --12--</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>xsd:gYear</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">A given year</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">. . . -0002, -0001, 0001, 0002, 0003, . . .1998, 1999, 2000, 2001, 2002, . . .9997, 9998, 9999</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>xsd:gYearMonth</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">A specific month in a specific year </p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">1999-12, 2001-04, 1968-07</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>xsd:gMonthDay</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">A date in no particular year, or rather in every year</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">--10-31, --02-28, --02-29</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>xsd:duration</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">A length of time, without fixed endpoints, to an arbitrary fraction of a second</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">P2000Y10M31DT09H32M7.4312S</p>
               
            </td>
            
         </tr>
         
      </table>
      
      <p class="GX">Notice in particular that in all the date formats the year comes first, followed by the month, then the day, then the hour,
         and so on. The largest unit of time is on the left and the smallest unit is on the right. This helps avoid questions such
         as whether 2001&#8211;02&#8211;11 is February 11, 2000 or November 2, 2001.
      </p>
      
      <h3>XML data types</h3>
      
      <p class="GX">The next batch of schema data types should be quite familiar. These are the types related to XML constructs themselves. Most
         of these types match attribute types in DTDs such as <code>NMTOKENS</code> or <code>IDREF</code>. The difference is that with schemas these types can be applied to both elements and attributes. These also include four
         new types related to other XML constructs: <code>xsd:language</code>, <code>xsd:Name</code>, <code>xsd:QName</code>, and <code>xsd:NCName</code>. Table 24-3 summarizes the different types.
      </p>
      
      <p style="font-weight: bold; text-align: center; font-family: Arial, Helvetica, sans">Table 24-3: 
         XML Schema XML Types
      </p>
      
      
      <table border="1" summary="(unspecified contents)">
         
         <colgroup span="1">
            <col width="94" span="1">
            <col width="166" span="1">
            <col width="176" span="1">
         </colgroup>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p style="font-weight: bold; font-family: Arial, Helvetica, sans">Name: 
                  
               </p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p style="font-weight: bold; font-family: Arial, Helvetica, sans">Type: 
                  
               </p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p style="font-weight: bold; font-family: Arial, Helvetica, sans">Examples: 
                  
               </p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>xsd:ID</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">XML 1.0 <code>ID</code> attribute type; any XML name that's unique among ID type attributes and elements
               </p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>p1</code>, <code>p2</code>, <code>ss124-45-6789</code>, <code>_92</code>, <code>red</code>, <code>green</code>, <code>NT-Decl</code>, <code>seventeen</code></p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>xsd:IDREF</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">XML 1.0 <code>IDREF</code> attribute type; any XML name that's used as the value of an ID type attribute or element elsewhere in the document
               </p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>p1</code>, <code>p2</code>, <code>ss124-45-6789</code>, <code>_92</code>, <code>p1</code>, <code>p2</code>, <code>red</code>, <code>green</code>, <code>NT-Decl</code>, <code>seventeen</code></p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>xsd:ENTITY</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">XML 1.0 <code>ENTITY</code> attribute type; any XML name that's declared as an unparsed entity in the DTD
               </p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>PIC1</code>, <code>PIC2</code>, <code>PIC3</code>, <code>cow_movie</code>, <code>MonaLisa</code>, <code>Warhol</code></p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>xsd:NOTATION</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">XML 1.0 <code>NOTATION</code> attribute type; any XML name that's declared as a notation name in the schema using <code>xsd:notation</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"> <code>GIF</code>, <code>jpeg</code>, <code>TIF</code>, <code>pdf</code>, <code>TeX</code></p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>xsd:IDREFS</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">XML 1.0 <code>IDREFS</code> attribute type; a white space-separated list of XML names that are used as values of ID type attributes or elements elsewhere
                  in the document
               </p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>p1 p2</code>, <code>ss124-45-6789</code> <code>_92</code>, <code>red green NT-Decl seventeen</code></p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>xsd:ENTITIES</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">XML 1.0 <code>ENTITIES</code> attribute type; a white space-separated list of <code>ENTITY</code> names
               </p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>PIC1 PIC2 PIC3</code></p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>xsd:NMTOKEN</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">XML 1.0 <code>NMTOKEN</code> attribute type
               </p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>12</code> <code>are</code> <code>you</code> <code>ready</code> <code>199</code></p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>xsd:NMTOKENS</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">XML 1.0 <code>NMTOKENS</code> attribute type, a white space-separated list of name tokens
               </p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>MI NY LA CA</code></p>
               
               <p class="TX"><code>p1 p2 p3 p4 p5 p6</code></p>
               
               <p class="TX"><code>1 2 3 4 5 6</code></p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>xsd:language</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Valid values for <code>xml:lang</code> as defined in XML 1.0
               </p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>en</code>, <code>en-GB</code>, <code>en-US</code>, <code>fr</code>, <code>i-lux</code>, <code>ama</code>, <code>ara</code>, <code>ara-EG, x-choctaw</code></p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>xsd:Name</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">An XML 1.0 Name, with or without colons</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>set</code>, <code>title</code>, <code>rdf</code>, <code>math</code>, <code>math123</code>, <code>xlink:href</code>, <code>song:title</code></p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>xsd:QName</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">a prefixed name</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>song:title</code>, <code>math:set</code>, <code>xsd:element</code></p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>xsd:NCName</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">a local name without any colons</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>set</code>, <code>title</code>, <code>rdf</code>, <code>math</code>, <code>tei.2</code>, <code>href</code></p>
               
            </td>
            
         </tr>
         
      </table>
      
      <p class="SBT" style="font-weight: bold; margin-left: 0.5in; margin-right: 0.5in;        font-family: Arial, Helvetica, sans; color: #0000ff">Cross-Reference</p>
      
      <p class="SBT" style="font-family: Arial, Helvetica, sans;        margin-left: 0.5in; margin-right: 0.5in">For more details on the permissible values for elements and attributes declared to have these types, see Chapter 11.</p>
      
      <h3>String data types</h3>
      
      <p class="GX">You've already encountered the <code>xsd:string</code> type. It's the most generic simple type. It requires a sequence of Unicode characters of any length, but this is what all
         XML element content and attribute values are. There are also two very closely related types: <code>xsd:token</code> and <code>xsd:CDATA</code>. These are the same as <code>xsd:string</code> except that they limit the amount, location, and type of white space that can be used. Table 24-4 summarizes the string data
         types.
      </p>
      
      <p style="font-weight: bold; text-align: center; font-family: Arial, Helvetica, sans">Table 24-4: 
         XML Schema String Types
      </p>
      
      
      <table border="1" summary="(unspecified contents)">
         
         <colgroup span="1">
            <col width="112" span="1">
            <col width="157" span="1">
            <col width="167" span="1">
         </colgroup>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p style="font-weight: bold; font-family: Arial, Helvetica, sans">Name: 
                  
               </p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p style="font-weight: bold; font-family: Arial, Helvetica, sans">Type: 
                  
               </p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p style="font-weight: bold; font-family: Arial, Helvetica, sans">Examples: 
                  
               </p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>xsd:string</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">A sequence of zero or more Unicode characters that are allowed in an XML document; essentially the only forbidden characters
                  are most of the C0 controls, surrogates, and the byte-order mark
               </p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>p1</code>, <code>p2</code>, <code>123 45 6789</code>, <code>^*&amp;^*&amp;_92</code>, <code>red green blue</code>, <code>NT-Decl</code>, <code>seventeen; Mary had a little lamb</code>, <code>The love of money is the root of all Evil.</code>, <code>Would you paint the lily?</code></p>
               
               <p class="TX"><code>Would you gild gold?</code></p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>xsd:normalizedString</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">A string that does not contain any tabs, carriage returns, or linefeeds</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>PIC1</code>, <code>PIC2</code>, <code>PIC3</code>, <code>cow_movie</code>, <code>MonaLisa</code>, <code>Hello World </code>, <code>Warhol</code>, <code>red green</code></p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>xsd:token</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">A string with no leading or trailing white space, no tabs, no linefeeds, and not more than one consecutive space</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>p1 p2</code>, <code>ss123 45 6789</code>, <code>_92</code>, <code>red</code>, <code>green</code>, <code>NT Decl</code>, <code>seventeenp1</code>, <code>p2</code>, <code>123 45 6789</code>, <code>^*&amp;^*&amp;_92</code>, <code>red green blue</code>, <code>NT-Decl</code>, <code>seventeen; Mary had a little lamb</code>, <code>The love of money is the root of all Evil.</code></p>
               
            </td>
            
         </tr>
         
      </table>
      
      <h3><a id="s" name="s" shape="rect"></a>Binary types
      </h3>
      
      <p class="GX">It's impossible<span style="{font-size: 8pt}"><span class="upCastTextColor-6"><span class="annotation-reference">
                  </span></span></span> to include arbitrary binary files in XML documents because they might contain illegal characters such as a form feed or a
         null that would make the XML document malformed. Therefore, any such data must first be encoded in legal characters. The W3C
         XML Schema Language supports two such encodings, <code>xsd:base64Binary</code> and <code>xsd:hexBinary</code>.
      </p>
      
      <p class="GX">Hexadecimal binary encodes each byte of the input as two hexadecimal digits &#8212; 00, 01, 02, 03, 04, 05, 06, 07, 08, 09, 0A,
         0B, 0C, 0D, 0E, 0F, 10, 11, 12, and so on. Thus, an entire file can be encoded using only the digits 0 through 9 and the letters
         A through F. (Lowercase letters are also allowed, but uppercase letters are customary.) On the other hand, each byte is replaced
         by two bytes so this encoding doubles the size of the data. It's not a very efficient encoding. Hexadecimal binary encoded
         data tends to look like this:
      </p>
      <pre><code>A4E345EC54CC8D52198000FFEA6C807F41F332127323432147A89979EEF3
</code></pre>
      <p class="GX">Base64 encoding uses a more complex algorithm and a larger character set, 65 ASCII characters chosen for their ability to
         pass through almost all gateways, mail relays, and terminal servers intact, as well as their existence with the same code
         points in ASCII, EBCDIC, and most other common character sets. Base64 encodes every three bytes as four characters, typically
         only increasing file size by a third, so it's somewhat more efficient than <code>xsd:hexBinary</code>. Base64 encoded data tends to look something like this:
      </p>
      <pre><code>6jKpNnmkkWeArsn5Oeeg2njcz+nXdk0f9kZI892ddlR8Lg1aMhPeFTYuoq3I6n BjWzuktNZKiXYBfKsSTB8U09dTiJo2ir3HJuY7eW/p89osKMfixPQsp9vQMgzph6Qa lY7j4MB7y5ROJYsTr1/fFwmj/yhkHwpbpzed1LE=
</code></pre>
      <p class="GX">XML Digital Signatures use Base64 encoding to encode the binary signatures before wrapping them in an XML element.</p>
      
      <p class="SBT" style="font-weight: bold; margin-left: 0.5in; margin-right: 0.5in;        font-family: Arial, Helvetica, sans; color: #0000ff">Caution</p>
      
      <p class="SBT" style="font-family: Arial, Helvetica, sans;        margin-left: 0.5in; margin-right: 0.5in">I really discourage you from using either of these if at all possible. If you have binary data, it's much more efficient and
         much less obtuse to link to it using XLink or unparsed entities rather than encoding it in Base64 or hexadecimal binary.
      </p>
      
      <h3>Miscellaneous data types</h3>
      
      <p class="GX">There are two types left over that don&#8217;t fit neatly into the previous categories: <code>xsd:boolean</code>, and <code>xsd:anyURI</code>. The <code>xsd:boolean</code> type represents something similar to C++'s <code>bool</code> data type. It has four legal values: <code>0</code>, <code>1</code>, <code>true</code>, and <code>false</code>. <code>0</code> is considered to be the same as <code>false</code>, and <code>1</code> is considered the same as <code>true</code>.
      </p>
      
      <p class="GX">The final schema simple type is <code>xsd:anyURI</code>. An element of this type contains a relative or absolute URI, possibly a URL, such as <code>urn:isbn:0764547607</code>, <code>http://www.w3.org/TR/2000/WD-xmlschema-2-20000407/#timeDuration</code>,<code> /javafaq/reports/JCE1.2.1.htm</code>, <code>/TR/2000/WD-xmlschema-2-20000407/</code>, or <code>../index.html</code>.
      </p>
      
      <p class="SBT" style="font-weight: bold; margin-left: 0.5in; margin-right: 0.5in;        font-family: Arial, Helvetica, sans; color: #0000ff">Caution</p>
      
      <p class="SBT" style="font-family: Arial, Helvetica, sans;        margin-left: 0.5in; margin-right: 0.5in">Xerces 1.4.0 doesn&#8217;t yet accept relative URLs in elements and attributes with the type <code>xsd:anyURI</code>. This is scheduled to be fixed in Xerces 1.4.1.
      </p>
      
      <h2><a name="d1e4741">Deriving Simple Types</a></h2>
      
      <p class="GX">You're not limited to the 44 simple types that the W3C XML Schema Language defines. As in object-oriented programming languages,
         you can create new data types by deriving from the existing types. The most common such derivation is to restrict a type to
         a subset of its normal values. For instance, you can define an integer type that only holds numbers between 1 and 20 by deriving
         from <code>xsd:positiveInteger</code>. You can create enumerated types that only allow a finite list of fixed values. You can create new types that join together
         the ranges of existing types through a union. For instance you can derive a type that can hold either an <code>xsd:date</code> or an <code>xsd:int</code>.
      </p>
      
      <p class="GX">New simple types are created by <code>xsd:simpleType</code> elements, just as new complex types are created by <code>xsd:complexType</code> elements. The <code>name</code> attribute of <code>xsd:simpleType</code> assigns a name to the new type by which it can be referred to in <code>xsd:element</code> <code>type</code> attributes. The allowed content of elements and attributes with the new type can be specified by one of three child elements:
      </p>
      
      <ul>
         <li><code>xsd:restriction</code> to select a subset of the values allowed by the base type
         </li>
         <li><code>xsd:union</code> to combine multiple types
         </li>
         <li><code>xsd:list</code> to specify a list of elements of an existing simple type
         </li>
      </ul>
      
      
      
      <h3>Deriving by restriction</h3>
      
      <p class="GX">To create a new type by restricting from an existing type you give the <code>xsd:simpleType</code> element an <code>xsd:restriction</code> child element. The <code>base</code> attribute of this element specifies what type you're restricting. For example, this <code>xsd:simpleType</code> element creates a new type named <code>phonoYear</code> that's derived from <code>xsd:gYear</code>:
      </p>
      <pre><code>&lt;xsd:simpleType name="phonoYear"&gt;
  &lt;xsd:restriction base="xsd:gYear"&gt;
  &lt;/xsd:restriction&gt;
&lt;/xsd:simpleType&gt;
</code></pre>
      
      
      
      <p class="GX">With this declaration any legal <code>xsd:gYear</code> is also a legal <code>phonoYear</code>, and any illegal year is also an illegal <code>phonoYear</code>. You can limit <code>phonoYear</code> to a subset of the normal year values by using <span class="italic">facets</span> to specify which values are and are not allowed. For instance, the <code>minInclusive</code> facet defines the minimum legal value for a type. This facet is added to a restriction as an <code>xsd:minInclusive</code> child element. The <code>value</code> attribute of the <code>xsd:minInclusive</code> element sets the minimum allowed value for the year:
      </p>
      <pre><code>&lt;xsd:simpleType name="phonoYear"&gt;
  &lt;xsd:restriction base="xsd:gYear"&gt;
    &lt;xsd:minInclusive value="1877"/&gt;
  &lt;/xsd:restriction&gt;
&lt;/xsd:simpleType&gt;
</code></pre>
      
      
      
      
      <p class="GX">Here the <code>value</code> of <code>xsd:minInclusive</code> is set to 1877, the year Thomas Edison invented the phonograph. Thus, 1877 is a legal <code>phonoYear</code>, 1878 is a legal <code>phonoYear</code>, 2001 is a legal <code>phonoYear</code>, and 3005 is a legal <code>phonoYear</code>. However, 1876, 1875, 1874, and earlier years are not legal <code>phonoYear</code>s, even though they are legal <code>xsd:gYear</code>s.
      </p>
      
      <p class="GX">Once the <code>phonoYear</code> type has been defined, you can use it just like one of the built-in types. For example, in the <code>SONG</code> schema, you'd declare that the <code>year</code> element has the type <code>phonoYear</code> like this:
      </p>
      <pre><code>&lt;xsd:element type="phonoYear"/&gt;
</code></pre>
      <p class="GX"><code>minInclusive</code> is not the only facet you can apply to <code>xsd:gYear</code>. Other facets of <code>xsd:gYea</code>r  are:
      </p>
      
      <ul>
         <li><code>xsd:minExclusive</code>: the minimum value that all instances must be strictly greater than
         </li>
         <li><code>xsd:maxInclusive</code>: the maximum value that all instances must be less than or equal to
         </li>
         <li><code>xsd:maxExclusive</code>: the maximum value that all instances must be strictly less than
         </li>
         <li><code>xsd:enumeration</code>: a list of all legal values
         </li>
         <li><code>xsd:whiteSpace</code>: how white space is treated within the element
         </li>
         <li><code>xsd:pattern</code>: a regular expression to which the instance is compared
         </li>
      </ul>
      
      
      
      
      
      
      <p class="GX">Each facet is represented as an empty element inside an <code>xsd:restriction</code> element. Each facet has a <code>value</code> attribute giving the value of that facet. One restriction can contain more than one facet. For example, this <code>xsd:simpleType</code> element defines a <code>phonoYear</code> as any year between 1877 and 2100, inclusive:
      </p>
      <pre><code>&lt;xsd:simpleType name="phonoYear"&gt;
  &lt;xsd:restriction base="xsd:gYear"&gt;
    &lt;xsd:minInclusive value="1877"/&gt;
    &lt;xsd:maxInclusive value="2100"/&gt;
  &lt;/xsd:restriction&gt;
&lt;/xsd:simpleType&gt;
</code></pre>
      
      
      
      
      
      <p class="GX">It's possible that multiple facets may conflict. For instance, the <code>minInclusive</code> value could be 2100 and the <code>maxInclusive</code> value could be 1877. While this is probably a design mistake, it is syntactically legal. It would just mean that the set
         of <code>phonoYear</code>s was the empty set, and <code>phonoYear</code> type elements could not actually be used in instance documents.
      </p>
      
      <h3>Facets</h3>
      
      <p class="GX">Facets are shared among many types. For instance, the <code>minInclusive</code> facet can constrain essentially any well-ordered type, including not only <code>xsd:gYear</code>, but also <code>xsd:byte</code>, <code>xsd:unsignedByte</code>, <code>xsd:integer</code>, <code>xsd:positiveInteger</code>, <code>xsd:negativeInteger</code>, <code>xsd:nonNegativeInteger</code>, <code>xsd:nonPositiveInteger</code>, <code>xsd:int</code>, <code>xsd:unsignedInt</code>, <code>xsd:long</code>, <code>xsd:unsignedLong</code>, <code>xsd:short</code>, <code>xsd:unsignedShort</code>, <code>xsd:decima</code>l, <code>xsd:float</code>, <code>xsd:double</code>, <code>xsd:time</code>, <code>xsd:dateTime</code>, <code>xsd:duration</code>, <code>xsd:date</code>, <code>xsd:gMonth</code>, <code>xsd:gYearMonth</code>, and <code>xsd:gMonthDay</code>. The complete list of constraining facets that can be applied to different types is:
      </p>
      
      <ul>
         <li><code>xsd:minInclusive</code>: the value that all instances must be greater than or equal to
         </li>
         <li><code>xsd:minExclusive</code>: the value that all instances must be strictly greater than
         </li>
         <li><code>xsd:maxInclusive</code>: the value that all instances must be less than or equal to
         </li>
         <li><code>xsd:maxExclusive</code>: the value that all instances must be strictly less than
         </li>
         <li><code>xsd:enumeration</code>: a list of all legal values
         </li>
         <li><code>xsd:whiteSpace</code>: how white space is treated within the element
         </li>
         <li><code>xsd:pattern</code>: a regular expression to which the instance is compared
         </li>
         <li><code>xsd:length</code>: the exact number of characters in the element
         </li>
         <li><code>xsd:minLength</code>: the minimum number of characters allowed in the element
         </li>
         <li><code>xsd:maxLength</code>: the maximum number of characters allowed in the element
         </li>
         <li><code>xsd:totalDigits</code>: the maximum number of digits allowed in the element
         </li>
         <li><code>xsd:fractionDigits</code>: the maximum number of digits allowed in the fractional part of the element
         </li>
      </ul>
      
      
      
      
      
      
      
      
      
      
      
      
      <p class="GX">Not all facets apply to all types. For instance it doesn&#8217;t make much sense to talk about the minimum value of an <code>xsd:NMTOKEN</code> or the number of fraction digits in an <code>xsd:gYear</code>. However, when the same facet is shared by different types, it has the same syntax and basic meaning for all the types.
      </p>
      
      <h3>Facets for strings: length, minLength, maxLength</h3>
      
      <p class="GX">The three length facets &#8212; <code>xsd:length</code>, <code>xsd:minLength</code>, and <code>xsd:maxLengt</code>h &#8212; apply to the <code>xsd:string</code> type and its subtypes: <code>xsd:normalizedString</code>, <code>xsd:token</code>, <code>xsd:hexBinary</code>, <code>xsd:base64Binary</code>, <code>xsd:QName</code>, <code>xsd:NCName</code>, <code>xsd:ID</code>, <code>xsd:IDREF</code>, <code>xsd:IDREFS</code>, <code>xsd:language</code>, <code>xsd:anyURI</code>, <code>xsd:ENTITY</code>, <code>xsd:ENTITIES</code>, <code>xsd:NOTATION</code>, <code>xsd:NOTATIONS</code>, <code>xsd:NMTOKEN</code>, and <code>xsd:NMTOKENS</code>. These facets specify the number of characters allowed in the element or attribute value. The <code>value</code> attribute of each of these facets must contain a nonnegative integer. <code>xsd:length</code> sets the exact number of characters in the value, whereas <code>xsd:minLength</code> sets the minimum length and <code>xsd:maxLengt</code>h sets the maximum length.
      </p>
      
      <p class="GX">For example, the schema in Listing 24-18 uses the <code>xsd:minLength</code> and <code>xsd:maxLength</code> facets to derive a new <code>Str255</code> data type from <code>xsd:string</code>. Whereas <code>xsd:string</code> allows strings of any length from zero on up, <code>Str255</code> requires each string to have a minimum length of 1 and a maximum length of 255. The schema then assigns this data type to
         all the names and titles to indicate that each must contain between 1 and 255 characters:
      </p>
      
      <p style="font-weight: bold">Listing 24-18: 
         A schema that derives a Str255 data type from xsd:string
      </p>
      
      <pre><code>&lt;?xml version="1.0"?&gt;
&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;xsd:simpleType name="Str255"&gt;
    &lt;xsd:restriction base="xsd:string"&gt;
      &lt;xsd:minLength value="1"/&gt;
      &lt;xsd:maxLength value="255"/&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;
  &lt;xsd:element name="SONG" type="SongType"/&gt;
  &lt;xsd:complexType name="SongType"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="TITLE"     type="Str255"/&gt;
      &lt;xsd:element name="COMPOSER"  type="Str255"
                   maxOccurs="unbounded"/&gt;
      &lt;xsd:element name="PRODUCER"  type="Str255"
                   minOccurs="0"    maxOccurs="unbounded"/&gt;
      &lt;xsd:element name="PUBLISHER" type="Str255"
                   minOccurs="0"/&gt;
      &lt;xsd:element name="LENGTH"    type="xsd:duration"/&gt;
      &lt;xsd:element name="YEAR"      type="xsd:gYear"/&gt;
      &lt;xsd:element name="ARTIST"    type="Str255"
                   maxOccurs="unbounded"/&gt;
      &lt;xsd:element name="PRICE"     type="xsd:string"
                   minOccurs="0"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;
&lt;/xsd:schema&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <h3>The whiteSpace facet</h3>
      
      <p class="GX">The <code>whiteSpace</code> facet is unusual. Unlike the other 11 facets, <code>xsd:whiteSpace</code> does not in any way constrain the allowed content of elements. Instead, it suggests what the application should do with any
         white space that it finds in the instance document. It says how significant that white space is. However, it does not in any
         way say that any particular kind of white space is legal or illegal.
      </p>
      
      <p class="GX">The <code>xsd:whiteSpace</code> facet has three possible values:
      </p>
      
      <ul>
         <li><code>preserve</code>: The white space in the input document is unchanged.
         </li>
         <li><code>replace</code>: Each tab, carriage return, and linefeed is replaced with a single space.
         </li>
         <li><code>collapse</code>: Each tab, carriage return, and linefeed is replaced with a single space. Furthermore, after this replacement is performed,
            all runs of multiple spaces are condensed to a single space. Leading and trailing white space is deleted.
         </li>
      </ul>
      
      
      
      <p class="GX">Again, these are all just hints to the application. None of them have any affect on validation.</p>
      
      <p class="GX">The <code>whiteSpace</code> facet can only be applied to <code>xsd:string</code>, <code>xsd:normalizedString</code>, and <code>xsd:token</code> types. Furthermore, it only fully applies to elements. XML 1.0 requires that parsers replace all white space in attributes,
         and collapse white space in attributes whose type is anything other than CDATA, regardless of what the schema says.
      </p>
      
      <p class="GX">The schema in Listing 24-19 uses the <code>xsd:whiteSpace</code> facets to derive a new <code>CollapsedString</code> data type from <code>xsd:string</code>. Then it assigns this data type to all the names and titles to indicate that white space should be collapsed in these elements:
      </p>
      
      <p style="font-weight: bold">Listing 24-19: 
         A schema that suggests collapsing white space in elements
      </p>
      
      <pre><code>&lt;?xml version="1.0"?&gt;
&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;xsd:element name="SONG" type="SongType"/&gt;
  &lt;xsd:simpleType name="CollapsedString"&gt;
    &lt;xsd:restriction base="xsd:string"&gt;
       &lt;xsd:whiteSpace value="collapse"/&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;
  &lt;xsd:complexType name="SongType"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="TITLE"     type="CollapsedString"/&gt;
      &lt;xsd:element name="COMPOSER"  type="CollapsedString"
        maxOccurs="unbounded"/&gt;
      &lt;xsd:element name="PRODUCER"  type="CollapsedString"
        minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;xsd:element name="PUBLISHER" type="CollapsedString"
        minOccurs="0"/&gt;
      &lt;xsd:element name="LENGTH"    type="xsd:duration"/&gt;
      &lt;xsd:element name="YEAR"      type="xsd:gYear"/&gt;
      &lt;xsd:element name="ARTIST"    type="CollapsedString"
        maxOccurs="unbounded"/&gt;
      &lt;xsd:element name="PRICE"     type="xsd:string"
                   minOccurs="0"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;
&lt;/xsd:schema&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <h3>Facets for decimal numbers: totalDigits and fractionDigits</h3>
      
      <p class="GX">When formatting numbers, it's useful to be able to specify how many digits should be used in the entire number, the integer
         parts, and the fraction parts. Schemas don&#8217;t go as far in this regard as the <code>printf()</code> function in C or the <code>java.text.DecimalFormat</code> class in Java, but they do offer you some control.
      </p>
      
      <p class="GX">The <code>xsd:totalDigits</code> facet specifies the maximum number of decimal digits in a number. It applies to most numeric types including <code>xsd:byte</code>, <code>xsd:unsignedByte</code>, <code>xsd:integer</code>, <code>xsd:positiveInteger</code>, <code>xsd:negativeInteger</code>, <code>xsd:nonNegativeInteger</code>, <code>xsd:nonPositiveInteger</code>, <code>xsd:int</code>, <code>xsd:unsignedInt</code>, <code>xsd:long</code>, <code>xsd:unsignedLong</code>, <code>xsd:short</code>, <code>xsd:unsignedShort</code>, and <code>xsd:decima</code>l. The only exceptions are the IEEE 754 types that occupy a fixed number of bytes; that is, <code>xsd:float</code> and <code>xsd:double</code>. The value of this facet must be a positive integer.
      </p>
      
      <p class="GX">The <code>xsd:fractionDigits</code> facet specifies the maximum number of decimal digits to the right of the decimal point. (There is no facet that allows you
         to specify the minimum number of digits or fraction digits.) This only really applies to <code>xsd:decimal</code>. Technically, it applies to all the integer types to, but for those types it's fixed to the value zero; that is, no fraction
         digits at all. You're only allowed to change it for <code>xsd:decimal</code>. The value of this facet must be a nonnegative integer.
      </p>
      
      <h3>The enumeration facet</h3>
      
      <p class="GX">Rather than setting some sort of range on legal values, the <code>xsd:enumeration</code> facet simply lists all allowed values. It applies to every simple type except <code>xsd:boolean</code>. The syntax is a little unusual. Each possible value gets its own <code>xsd:enumeration</code> element as a child of  the <code>xsd:restriction</code> element.
      </p>
      
      <p class="GX">Listing 24-20 uses an enumeration to derive a <code>PublisherType</code> from <code>xsd:string</code>. It requires that the publisher be one of the oligopoly that controls 90 percent of all U.S. music. (Warner-Elektra-Atlantic,
         Universal Music Group, Sony Music Entertainment, Inc., Capitol Records, Inc., and BMG Music).
      </p>
      
      <p style="font-weight: bold">Listing 24-20: 
         A schema that uses an enumeration to derive a type from xsd:string
      </p>
      
      <pre><code>&lt;?xml version="1.0"?&gt;
&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;xsd:element name="SONG" type="songType"/&gt;
  &lt;xsd:simpleType name="PublisherType"&gt;
    &lt;xsd:restriction base="xsd:string"&gt;
      &lt;xsd:enumeration value="Warner-Elektra-Atlantic"/&gt;
      &lt;xsd:enumeration value="Universal Music Group"/&gt;
      &lt;xsd:enumeration value="Sony Music Entertainment, Inc."/&gt;
      &lt;xsd:enumeration value="Capitol Records, Inc."/&gt;
      &lt;xsd:enumeration value="BMG Music"/&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;
  &lt;xsd:complexType name="songType"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="TITLE"     type="xsd:string"/&gt;
      &lt;xsd:element name="COMPOSER"  type="xsd:string"
        maxOccurs="unbounded"/&gt;
      &lt;xsd:element name="PRODUCER"  type="xsd:string"
        minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;xsd:element name="PUBLISHER" type="PublisherType"
        minOccurs="0"/&gt;
      &lt;xsd:element name="LENGTH"    type="xsd:duration"/&gt;
      &lt;xsd:element name="YEAR"      type="xsd:gYear"/&gt;
      &lt;xsd:element name="ARTIST"    type="xsd:string"
        maxOccurs="unbounded"/&gt;
      &lt;xsd:element name="PRICE"     type="xsd:string"
                   minOccurs="0"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;
&lt;/xsd:schema&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <p class="GX"><code>xsd:string</code> is far from the only type you can derive from via enumeration. You can derive from <code>xsd:int</code>, <code>xsd:NMTOKEN</code>, <code>xsd:date</code>, and, indeed, from all simple types except <code>xsd:boolean</code>. Of course, the enumerated values all have to be legal instances of the base type.
      </p>
      
      <h3>The pattern facet</h3>
      
      <p class="GX">There's one element in the song examples that clearly deserves a data type, but so far doesn&#8217;t have one &#8212; <code>PRICE</code>. However none of the built-in data types really match the format for prices. Recall that <code>PRICE</code> elements look like this:
      </p>
      <pre><code>&lt;PRICE&gt;$1.25&lt;/PRICE&gt;
</code></pre>
      <p class="GX">This isn&#8217;t an integer of any kind, because it has a decimal point. It could be a floating point number, but that wouldn&#8217;t
         account for the currency sign. You could drop off the currency sign like this:
      </p>
      <pre><code>&lt;PRICE&gt;1.25&lt;/PRICE&gt;
</code></pre>
      <p class="GX">However, then you'd have to assume you were working in dollars. What if you wanted to sell songs priced in pounds or yen or
         lira? Perhaps you could make the currency sign part of a separate element, like this:
      </p>
      <pre><code>&lt;PRICE&gt;
  &lt;CURRENCY&gt;$&lt;/CURRENCY&gt;
  &lt;AMOUNT&gt;1.25&lt;/AMOUNT&gt;
&lt;/PRICE&gt;
</code></pre>
      
      
      
      <p class="GX"><code>AMOUNT</code> could be an <code>xsd:float</code>, and <code>CURRENCY</code> could be an <code>xsd:string</code>. However, this still isn&#8217;t perfect. You want to limit the <code>CURRENCY</code> to exactly one character, and that character must be a currency sign. You don't want to allow it to contain any arbitrary
         string. Furthermore, you'd like to limit the precision of the <code>AMOUNT</code> to exactly two decimal places. You probably don&#8217;t want to sell songs that cost $1.1 or $1.99999.
      </p>
      
      <p class="GX">The solution to this problem, and to all similar problems where the values you want to allow don&#8217;t quite fit any of the existing
         types, is to use the <code>xsd:pattern</code> facet whose <code>value</code> attribute contains a regular expression that matches all legal values and doesn&#8217;t match any illegal values.
      </p>
      
      <p class="GX">The regular expressions used in schemas are similar to the regular expressions you might be familiar with from Perl, grep,
         or other languages. You use statements like [A-Z]+ to mean "a string containing one more of the capital letters from A to
         Z" or (club)* to mean "a string composed of zero or more repetitions of the word club".
      </p>
      
      <p class="GX">Table 24-5 summarizes the grammar of XML schema regular expressions. In this table <span class="italic">A</span> and <span class="italic">B</span> represent some string or another regular expression particle from elsewhere in the table; that is, they will be replaced
         by something else when actually used in a regular expression. <span class="italic">n</span> and <span class="italic">m</span> represent some integer that will be replaced by a specific number.
      </p>
      
      <p style="font-weight: bold; text-align: center; font-family: Arial, Helvetica, sans">Table 24-5: 
         Regular Expression Symbols for XML Schema
      </p>
      
      
      <table border="1" summary="(unspecified contents)">
         
         <colgroup span="1">
            <col width="67" span="1">
            <col width="369" span="1">
         </colgroup>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p style="font-weight: bold; font-family: Arial, Helvetica, sans">Symbol: 
                  
               </p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p style="font-weight: bold; font-family: Arial, Helvetica, sans">Meaning: 
                  
               </p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><span class="italic"><code>A</code></span><code>?</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Zero or one occurrences of <span class="italic">A</span></p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><span class="italic"><code>A</code></span><code>*</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Zero or more occurrences of <span class="italic">A</span></p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><span class="italic"><code>A</code></span><code>+</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">One or more occurrences of <span class="italic">A</span></p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><span class="italic"><code>A</code></span><code>{</code><span class="italic"><code>n</code></span><code>,</code><span class="italic"><code>m</code></span><code>}</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Between <span class="italic">n</span> and <span class="italic">m</span> occurrences of <span class="italic">A</span></p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><span class="italic"><code>A</code></span><code>{n}</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Exactly <span class="italic">n</span> occurrences of <span class="italic">A</span></p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><span class="italic"><code>A</code></span><code>{n,}</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">At least <span class="italic">n</span> occurrences of <span class="italic">A</span></p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><span class="italic"><code>A</code></span><code>|</code><span class="italic"><code>B</code></span></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Either <span class="italic">A</span> or <span class="italic">B</span></p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><span class="italic"><code>AB</code></span></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><span class="italic">A</span> followed by <span class="italic">B</span></p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>.</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Any one character</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>\p{</code><span class="italic"><code>A</code></span><code>}</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">One character from Unicode character class <span class="italic">A</span></p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>[</code><span class="italic"><code>abcdefg</code></span><code>]</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">A single occurrence of any of the characters contained in the brackets</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>[^</code><span class="italic"><code>abcdefg</code></span><code>]</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">A single occurrence of any of the characters <span class="italic">not</span> contained in the brackets
               </p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>[</code><span class="italic"><code>a-z</code></span><code>]</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">A single occurrence of any character from <span class="italic">a</span> to <span class="italic">z</span> inclusive
               </p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>[^</code><span class="italic"><code>a-z</code></span><code>]</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">A single occurrence of any of character <span class="italic">except</span> those from <span class="italic">a</span> to <span class="italic">z</span> inclusive
               </p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>\n</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Linefeed</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>\r</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Carriage return</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>\t</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Tab</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>\\</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">The backward slash \</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>\|</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">The vertical bar |</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>\.</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">The period .</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>\-</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">The hyphen -</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>\^</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">The caret ^</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>\?</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">The question mark ?</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>\*</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">The asterisk *</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>\+</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">The plus sign +</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>\{</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">The open brace {</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>\}</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">The closing brace }</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>\(</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">The open parenthesis (</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>\)</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">The closing parenthesis )</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>\[</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">The open bracket [</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><code>\]</code></p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">The close bracket ]</p>
               
            </td>
            
         </tr>
         
      </table>
      
      <p class="GX">For the most part, these symbols have exactly the same meanings that they have in Perl. The schema regular expression syntax
         is somewhat weaker than Perl's, but then whose isn&#8217;t? In any case, this should be sufficient power to meet any reasonable
         needs that schemas have.
      </p>
      
      <p class="GX">Schema regular expressions do have one important feature that isn&#8217;t available prior to Perl 5.6 and is unfamiliar to most
         developers &#8212; you can use <code>\p{}</code> to stand in for a character in a particular Unicode character class. For instance, <code>N</code> is the Unicode character class for numbers. This doesn&#8217;t just include the European digits 0 through 9, but also the Arabic-Indic
         digits, the Devanagari digits, the Thai digits, and many more besides. Therefore <code>\p{N}</code> represents any digit defined anywhere in Unicode. <code>\p{N}+</code> represents a string consisting of one or more Unicode digits. Table 24-6 lists the various Unicode character classes you
         can take advantage of in regular expressions. For the money regular expression, you need the <code>Sc</code> class for currency indicators and the <code>Nd</code> class for decimal digits. This is a little more restrictive than the N class, which includes nondecimal digits, such as the
         Roman numerals and the Han ideograph representing 100,000,000.
      </p>
      
      
      
      <p style="font-weight: bold; text-align: center; font-family: Arial, Helvetica, sans">Table 24-6: 
         Unicode Character Classes
      </p>
      
      
      <table border="1" summary="(unspecified contents)">
         
         <colgroup span="1">
            <col width="72" span="1">
            <col width="217" span="1">
            <col width="147" span="1">
         </colgroup>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p style="font-weight: bold; font-family: Arial, Helvetica, sans">Abbreviation: 
                  
               </p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p style="font-weight: bold; font-family: Arial, Helvetica, sans">Includes: 
                  
               </p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p style="font-weight: bold; font-family: Arial, Helvetica, sans">Examples: 
                  
               </p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="3" rowspan="1">
               
               <p style="font-weight: bold; font-family: Arial, Helvetica, sans">Letters: 
                  
               </p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">L</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">All Letters</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">a, b, c, A, B, C, &uuml;, &Uuml;, &ccedil;, &Ccedil;, <span style="{font-family: Times New Roman Greek}">&#950;, &#952;, &#918;, &#920;, </span><span style="{font-family: Times New Roman Cyr}">&#1072;, &#1073;, &#1074;, &#1040;, &#1041;, &#1042;, </span><span style="{font-family: Arial Unicode MS (Hebrew)}">&#1488;</span>, <span style="{font-family: Arial Unicode MS (Hebrew)}">&#1489;</span>, <span style="{font-family: Arial Unicode MS (Hebrew)}">&#1490;</span>, dz, Dz, DZ
               </p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Lu</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Uppercase letters</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">A, B, C, &Uuml;, &Ccedil;, <span style="{font-family: Times New Roman Greek}">&#918;, &#920;, </span><span style="{font-family: Times New Roman Cyr}">&#1040;, &#1041;, &#1042;, DZ</span></p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Ll</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Lowercase letters</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">a, b, c, &uuml;, &ccedil;, <span style="{font-family: Times New Roman Greek}">&#950;, &#952;, </span><span style="{font-family: Times New Roman Cyr}">&#1072;, &#1073;, &#1074;, dz</span></p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Lt</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Title case letters</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Dz</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Lm</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Modifier letters; letters that are attached to the previous characters somehow</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><sup>h</sup>, <sup>j</sup>, <sup>r</sup>, <sup>w</sup></p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Lo</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Other letters; typically ones from languages that don&#8217;t distinguish upper- and lowercase</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><span style="{font-family: Arial Unicode MS (Hebrew)}">&#1488;</span>, <span style="{font-family: Arial Unicode MS (Hebrew)}">&#1489;</span>, <span style="{font-family: Arial Unicode MS (Hebrew)}">&#1490;</span>, Japanese Katakana and Hiragana, most Han ideographs
               </p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="3" rowspan="1">
               
               <p style="font-weight: bold; font-family: Arial, Helvetica, sans">Marks: 
                  
               </p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">M</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">All Marks</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">&nbsp;</td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Mn</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Nonspacing marks; mostly accent marks that are attached to the previous character on the top or bottom, and thus do not change
                  the amount of space the character occupies
               </p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">`, ', &uml;, &macr;</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Mc</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Spacing combining marks; accent marks that are attached to the previous character on the left or right, and thus do change
                  the amount of space the character occupies
               </p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"><span style="{font-family: Arial}"><sup>T</sup></span>, Gurmukhi vowel sign AA
               </p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Me</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Enclosing marks that completely surround a character</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">The Cyrillic hundred thousands and millions signs</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="3" rowspan="1">
               
               <p style="font-weight: bold; font-family: Arial, Helvetica, sans">Numbers : 
                  
               </p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">N </p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">All numbers</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">0, 1, 2, 3, &frac14;, &frac12;, &sup2;, &sup3;, <span style="{font-family: Arial Unicode MS Western}">&#1632;</span>, <span style="{font-family: Arial Unicode MS Western}">&#1641;</span>, I, II, III, IV, V, <span style="{font-family: MingLiU}">&#12321;</span>, <span style="{font-family: MingLiU}">&#12322;</span>, <span style="{font-family: MingLiU}">&#12323;</span>, <span style="{font-family: MingLiU}">&#12324;</span></p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Nd </p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Decimal digits; characters that represent one of the numbers 0 through 9</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">0, 1, 2, 3, <span style="{font-family: Arial Unicode MS Western}">&#1632;</span>, <span style="{font-family: Arial Unicode MS Western}">&#1641;</span></p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Nl</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Numbers based on letters</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">I, II, III, IV <span style="{font-family: MingLiU}">&#12321;</span>, <span style="{font-family: MingLiU}">&#12322;</span>, <span style="{font-family: MingLiU}">&#12323;</span>, <span style="{font-family: MingLiU}">&#12324;</span></p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">No</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Other numbers</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX"> &frac14;, &frac12;, &sup2;, &sup3;</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="3" rowspan="1">
               
               <p style="font-weight: bold; font-family: Arial, Helvetica, sans">Punctuation: 
                  
               </p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">P</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">All punctuation</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">-, _, <span style="{font-family: MS Mincho}">&#12539;</span>, (, [, {, ), ], }, &#8216;, &#8220;, &laquo;, &#8217;, &#8221;, &raquo;, !, ?, @, *, &iexcl;, &iquest;, &middot;
               </p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Pc</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Connectors</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">_, <span style="{font-family: MS Mincho}">&#12539;</span></p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Pd</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Dashes</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Hyphens, soft hyphens, em dashes, en dashes, etc. </p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Ps</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Opening punctuation</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">(, [, {</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Pe</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Closing punctuation</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">), ], }</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Pi</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Initial quote marks</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">&#8216;, &#8220;, &laquo;</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Pf</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Final quote marks</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">&#8217;, &#8221;, &raquo;</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Po</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Other punctuation marks</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">!, ?, @, *, &iexcl;, &iquest;, &middot;</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="3" rowspan="1">
               
               <p style="font-weight: bold; font-family: Arial, Helvetica, sans">Separators : 
                  
               </p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Z</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">All separators</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">&nbsp;</td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Zs</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Space</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Space, non-breaking space, en space, em space</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Zl</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Line separators</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Unicode character 2028, the line separator</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Zp</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Paragraph separators</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Unicode character 2029, the paragraph separator</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="3" rowspan="1">
               
               <p style="font-weight: bold; font-family: Arial, Helvetica, sans">Symbols: 
                  
               </p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">S</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">All Symbols</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">&#8706;, &#8710;, @@Pi, $, &yen;, &pound;, ~, &macr;, &uml;, @@i, &copy;, &reg;, &deg;, &#9567;&#9650;, &#9786;</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Sm</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Mathematical symbols</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">&#8706;, &#8710;, @@Pi, &#8721;, &#8730;, &#8800;, &#8804;, &#8805;, &#8776;</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Sc</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Currency signs</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">$, &yen;, &pound;, &curren;, &#8364;, &#8355;, &#8356;, &#8359;, &#8362;, &#8363;</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Sk</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Modifier symbols</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">~, &macr;, &uml;</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">So</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Other symbols</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">@@i, &copy;, &reg;, &deg;, &sect;, &para;, &#8596;, &#8453;, &#8467;, @@N, &#9555;, &#9559;,&#9567;&#9650;, &#9786;, &#9792;, &#9794;, &#9824;, &#9834;, Braille, Han radicals</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="3" rowspan="1">
               
               <p style="font-weight: bold; font-family: Arial, Helvetica, sans">Other: 
                  
               </p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">C</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">All Others</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">&nbsp;</td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Cc</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Control characters </p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Carriage return, line feed, tab and the C1 controls</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Cf</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Format characters</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">The left-to-right and right-to-left marks used to indicate change of direction in bidirectional text</p>
               
            </td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Co</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Private use characters; code points which may be used for a program's internal purposes</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">&nbsp;</td>
            
         </tr>
         
         <tr>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Cn</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">
               
               <p class="TX">Unassigned; code points which, while legal in XML, the Unicode specification has not yet assigned a character to.</p>
               
            </td>
            
            <td valign="top" colspan="1" rowspan="1">&nbsp;</td>
            
         </tr>
         
      </table>
      
      <p class="GX">You're now ready to put together a regular expression that describes money strings such as $1.25. What you want to say is
         that each such string contains:
      </p>
      
      <ul>
         <li>&nbsp;1.&nbsp;A currency symbol</li>
         <li>&nbsp;2.&nbsp;One or more decimal digits</li>
         <li>&nbsp;3.&nbsp;An optional fractional part which, if present at all, consists of a decimal point and two decimal digits</li>
      </ul>
      
      
      
      <p class="GX">Here's the regular expression that says that:</p>
      <pre><code>\p{Sc}\p{Nd}+(\.\p{Nd}\p{Nd})?
</code></pre>
      <p class="GX">It begins with <code>\p{Sc}</code> to indicate a currency symbol such as $, &yen;, &pound;, or &curren;
      </p>
      
      <p class="GX">This is followed by <code>\p{Nd}+</code>. <code>\p{Nd}</code> represents any decimal digit character. The <code>+</code> indicates one or more of these characters.
      </p>
      
      <p class="GX">Next there's a parenthesized expression followed by a question mark, <code>(\.\p{Nd}\p{Nd})?</code>. The question mark indicates the parenthesized expression is optional. However, if it does appear its entire contents must
         be present, not just part. In other words, the question mark stands for zero or one, just as it does in DTDs. The contents
         of the parentheses are <code>\.\p{Nd}\p{Nd}</code>, which represents a period followed by two decimal digits, for example .35. Normally a period in a regular expression means
         any character at all, so here it's escaped with a preceding backslash to indicate that we really do want the actual period
         character.
      </p>
      
      <p class="GX">Now that you have a regular expression that represents money, you're ready to define a money type. As for the other facets,
         this is done with the <code>xsd:simpleType</code> and <code>xsd:restriction</code> elements. Putting these together with the regular expression produces this type definition:
      </p>
      <pre><code>&lt;xsd:simpleType name="money"&gt;
  &lt;xsd:restriction base="xsd:string"&gt;
    &lt;xsd:pattern value="\p{Sc}\p{Nd}+(\.\p{Nd}\p{Nd})?"/&gt;
  &lt;/xsd:restriction&gt;
&lt;/xsd:simpleType&gt;
</code></pre>
      
      
      
      
      <p class="GX">Listing 24-21 provides the complete song schema including this type definition. Take special note of the XML comment used
         to elucidate the regular expression. Regular expressions can be quite opaque, and a comment like this one can go a long way
         toward making the schema more understandable.
      </p>
      
      <p style="font-weight: bold">Listing 24-21: 
         A schema that defines a custom money type
      </p>
      
      <pre><code>&lt;?xml version="1.0"?&gt;
&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;xsd:element name="SONG" type="SongType"/&gt;
  &lt;xsd:simpleType name="money"&gt;
    &lt;xsd:restriction base="xsd:string"&gt;
      &lt;xsd:pattern value="\p{Sc}\p{Nd}+(\.\p{Nd}\p{Nd})?"/&gt;
      &lt;!--
         Regular Expression:
         \p{Sc}             Any Unicode currency indicator;
                            e.g., $, &amp;#xA5, &amp;#xA3, &amp;#A4, etc.
         \p{Nd}             A Unicode decimal digit character
         \p{Nd}+            One or more Unicode decimal digits
         \.                 The period character
         (\.\p{Nd}\p{Nd})
         (\.\p{Nd}\p{Nd})?  Zero or one strings of the form .35
         This works for any decimalized currency.
      --&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;
  &lt;xsd:complexType name="SongType"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="TITLE"     type="xsd:string"/&gt;
      &lt;xsd:element name="COMPOSER"  type="PersonType"
                   maxOccurs="unbounded"/&gt;
      &lt;xsd:element name="PRODUCER"  type="PersonType"
                   minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;xsd:element name="PUBLISHER" type="xsd:string"
                   minOccurs="0"/&gt;
      &lt;xsd:element name="LENGTH"    type="xsd:duration"/&gt;
      &lt;xsd:element name="YEAR"      type="xsd:gYear"/&gt;
      &lt;xsd:element name="ARTIST"    type="xsd:string"
                   maxOccurs="unbounded"/&gt;
      &lt;xsd:element name="PRICE" type="money" maxOccurs="1"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;
  &lt;xsd:complexType name="PersonType"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="NAME"&gt;
        &lt;xsd:complexType&gt;
          &lt;xsd:all&gt;
            &lt;xsd:element name="GIVEN"  type="xsd:string"/&gt;
            &lt;xsd:element name="FAMILY" type="xsd:string"/&gt;
          &lt;/xsd:all&gt;
        &lt;/xsd:complexType&gt;
      &lt;/xsd:element&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;
&lt;/xsd:schema&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <h3>Unions</h3>
      
      <p class="GX">Restriction is not the only way to create a new simple type, although it is the most common way. You can also combine types
         using unions. For example, you could combine the built-in <code>xsd:decimal</code> type with the <code>money</code> type just defined to create a type that could contain either a decimal or a money value. To do this, give the <code>xsd:simpleType</code> element an <code>xsd:union</code> child element instead of an <code>xsd:restriction</code> child element. The <code>xsd:union</code> element contains more <code>xsd:simpleType</code> elements identifying the types you're combining in the union. For example, this is the above described <code>money</code>/<code>xsd:decimal</code> combined type:
      </p>
      <pre><code>&lt;xsd:simpleType name="MoneyOrDecimal"&gt;
  &lt;xsd:union&gt;
    &lt;xsd:simpleType&gt;
      &lt;xsd:restriction base="xsd:decimal"&gt;
      &lt;/xsd:restriction&gt;
    &lt;/xsd:simpleType&gt;
    &lt;xsd:simpleType&gt;
      &lt;xsd:restriction base="xsd:string"&gt;
        &lt;xsd:pattern value="\p{Sc}\p{Nd}+(\.\p{Nd}\p{Nd})?"/&gt;
      &lt;/xsd:restriction&gt;
    &lt;/xsd:simpleType&gt;
  &lt;/xsd:union&gt;
&lt;/xsd:simpleType&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      
      <h3>Lists</h3>
      
      <p class="GX">Schemas can also specify that an element or attribute contains a list of a particular simple type. For example, this <code>YEARS</code> element contains a list of years:
      </p>
      <pre><code>&lt;YEARS&gt;1987 1999 1992   2002&lt;/YEARS&gt;
</code></pre>
      <p class="GX">Elements such as this can be specified using an <code>xsd:list</code> in the <code>xsd:simpleType</code>. The <code>itemType</code> attribute says what type of strings may appear in the list. For example:
      </p>
      <pre><code>&lt;xsd:simpleType name="YearList"&gt;
  &lt;xsd:list itemType="xsd:gYear"/&gt;
&lt;/xsd:simpleType&gt;
</code></pre>
      
      
      <p class="GX">requires that elements with type <code>YearList</code> contain a white space-separated list of legal <code>xsd:gYear</code> values.
      </p>
      
      <p class="SBT" style="font-weight: bold; margin-left: 0.5in; margin-right: 0.5in;        font-family: Arial, Helvetica, sans; color: #0000ff">Caution</p>
      
      <p class="SBT" style="font-family: Arial, Helvetica, sans;        margin-left: 0.5in; margin-right: 0.5in">I must admit that I'm not very fond of list types, especially for elements. It seems to me that if you're going to have a
         list of different items, each of those items <span style="{font-size: 8pt}"><span class="upCastTextColor-6"><span style="{font-family: Times New Roman}"><span class="annotation-reference">
                     </span></span></span></span>should be a separate element, possibly a child element of some parent element, but still its own element. Lists make a little
         more sense for attributes, but if there's a lot of substructure in the text, you should probably be using an element instead
         of an attribute anyway.
      </p>
      
      <p class="GX">You can derive another list type from an existing list type. When so doing, you can restrict it according to the <code>length</code>, <code>minLength</code>, <code>maxLength</code>, and <code>enumeration</code> facets. In this case, the values of the three length facets refer to the number of items in the list rather than the number
         of characters in the content. For example, this <code>xsd:simpleType</code> element derives a <code>DoubleYear</code> list type that must hold exactly two years from the <code>YearList</code> type defined above:
      </p>
      <pre><code>&lt;xsd:simpleType name="DoubleYear"&gt;
  &lt;xsd:restriction base="YearList"&gt;
    &lt;xsd:length value="2"/&gt;
  &lt;/xsd:restriction&gt;
&lt;/xsd:simpleType&gt;
</code></pre>
      
      
      
      
      <h2><a name="d1e7792">Empty Elements</a></h2>
      
      <p class="GX">Empty elements are those that cannot contain any child elements or parsed character data. This is the same as using the <code>EMPTY</code> content model in a DTD. As an example of this technique I'll define an empty <code>PHOTO</code> element. This will be used in the next section when attributes are introduced.
      </p>
      
      <p class="GX">To create an empty element, you define it as a type, but don&#8217;t give it an <code>xsd:sequence</code>, <code>xsd:all</code>, or <code>xsd:choice</code> child. Thus, you don&#8217;t actually provide any child elements. For example:
      </p>
      <pre><code>  &lt;!-- An empty element --&gt;
  &lt;xsd:complexType name="PhotoType"&gt;
  &lt;/xsd:complexType&gt;
</code></pre>
      
      
      <p class="SBT" style="font-weight: bold; margin-left: 0.5in; margin-right: 0.5in;        font-family: Arial, Helvetica, sans; color: #0000ff">Caution</p>
      
      <p class="SBT" style="font-family: Arial, Helvetica, sans;        margin-left: 0.5in; margin-right: 0.5in">This does not require the <code>PHOTO</code> element to be defined with an empty element tag such as <code>&lt;PHOTO/&gt;</code>. The start-tag-end-tag pair <code>&lt;PHOTO&gt;&lt;/PHOTO&gt;</code> is also acceptable. In fact, the XML 1.0 specification says these two forms are equivalent. Schemas change nothing about
         XML 1.0. An XML 1.0 parser that knows nothing about schemas will have no trouble reading a document that uses schemas.
      </p>
      
      <h2><a name="d1e7840">Attributes</a></h2>
      
      <p class="GX">In the examples so far, two XML constructs have been conspicuous by their absence: entities and attributes. The omission of
         entities was quite deliberate. Schemas cannot declare entities. If you need entities, you must use a DTD. (Of course, you
         can use a schema as well as the DTD.) However, schemas are fully capable of declaring attributes. Indeed they do a much better
         job of it than DTDs do because schemas can use the full set of data types like <code>xsd:float</code> and <code>xsd:anyURI</code>.
      </p>
      
      <p class="SBT" style="font-weight: bold; margin-left: 0.5in; margin-right: 0.5in;        font-family: Arial, Helvetica, sans; color: #0000ff">Note</p>
      
      <p class="SBT" style="font-family: Arial, Helvetica, sans;        margin-left: 0.5in; margin-right: 0.5in">You may not have noticed my avoidance of attributes because the examples all used <code>xmlns:xsi</code> and <code>xsi:noNamespaceSchemaLocation</code> attributes on the root element. However, as far as a schema validator is concerned, attributes used to declare namespaces,
         or to attach documents to schemas, "don't count". You do not have to, and indeed should not, declare these attributes. However,
         you do have to declare all the other attributes you use.
      </p>
      
      <p class="GX">As a concrete example, let's consider how you might add an empty <code>PHOTO</code> element to the <code>SONG</code> documents. This element would be similar to the <code>IMG</code> element in HTML, and have an <code>SRC</code> attribute that contained a URL pointing to the photo's location, an <code>ALT</code> attribute containing some text in the event that the <code>PHOTO</code> can&#8217;t be displayed, and <code>WIDTH</code> and <code>HEIGHT</code> attributes that together give the size of the image in pixels. Listing 24-22 demonstrates:
      </p>
      
      <p style="font-weight: bold">Listing 24-22: 
         The PHOTO element has several attributes of different types
      </p>
      
      <pre><code>&lt;?xml version="1.0"?&gt;
&lt;SONG xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:noNamespaceSchemaLocation="24-23.xsd"&gt;
  &lt;TITLE&gt;Yes I Am&lt;/TITLE&gt;
  &lt;PHOTO ALT="Melissa Etheridge holding a guitar"
         WIDTH="100" HEIGHT="300"
         SRC="guitar.jpg"/&gt;
  &lt;COMPOSER&gt;
    &lt;NAME&gt;
      &lt;GIVEN&gt;Melissa&lt;/GIVEN&gt;
      &lt;FAMILY&gt;Etheridge&lt;/FAMILY&gt;
    &lt;/NAME&gt;
  &lt;/COMPOSER&gt;
  &lt;PRODUCER&gt;
    &lt;NAME&gt;
      &lt;GIVEN&gt;Hugh&lt;/GIVEN&gt;
      &lt;FAMILY&gt;Padgham&lt;/FAMILY&gt;
    &lt;/NAME&gt;
  &lt;/PRODUCER&gt;
  &lt;PRODUCER&gt;
    &lt;NAME&gt;
      &lt;GIVEN&gt;Melissa&lt;/GIVEN&gt;
      &lt;FAMILY&gt;Etheridge&lt;/FAMILY&gt;
    &lt;/NAME&gt;
  &lt;/PRODUCER&gt;
  &lt;PUBLISHER&gt;Island Records&lt;/PUBLISHER&gt;
  &lt;LENGTH&gt;P0YT4M24S&lt;/LENGTH&gt;
  &lt;YEAR&gt;1993&lt;/YEAR&gt;
  &lt;ARTIST&gt;Melissa Etheridge&lt;/ARTIST&gt;
  &lt;PRICE&gt;$1.25&lt;/PRICE&gt;
&lt;/SONG&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <p class="GX">Even though the <code>PHOTO</code> element is empty, because it has attributes it has a complex type. You define a <code>PhotoType</code> just as you previously defined a <code>PersonType</code> and a <code>SongType</code>. However, where those types used <code>xsd:element</code> to declare child elements, this type will use <code>xsd:attribute</code> to declare attributes.
      </p>
      <pre><code>  &lt;xsd:complexType name="PhotoType"&gt;
    &lt;xsd:attribute name="SRC"    type="xsd:anyURI"/&gt;
    &lt;xsd:attribute name="WIDTH"  type="xsd:positiveInteger"/&gt;
    &lt;xsd:attribute name="HEIGHT" type="xsd:positiveInteger"/&gt;
    &lt;xsd:attribute name="ALT"    type="xsd:string"/&gt;
  &lt;/xsd:complexType&gt;
</code></pre>
      
      
      
      
      
      <p class="GX">Because the <code>SRC</code> attribute should contain a URL, it's been given the type <code>xsd:anyURI</code>. Because the <code>HEIGHT</code> and <code>WIDTH</code> attributes should each be an integer greater than zero, they're given the type <code>xsd:positiveInteger</code>. Finally, because the <code>ALT</code> attribute can contain essentially any string of text of any length, it's set to the most general type, <code>xsd:string</code>.
      </p>
      
      <p class="GX">In this particular example, all the elements either have child elements or attributes, not both. However, that's certainly
         not required. In general, elements can have both child elements and attributes. Just use both <code>xsd:element</code> and <code>xsd:attribute</code> in the same <code>xsd:complexType</code> element. The <code>xsd:attribute</code> elements must come after the <code>xsd:sequence</code>, <code>xsd:choice</code>, or <code>xsd:all</code> group that forms the body of the element. For example, this <code>xsd:element</code> says that a <code>PERSON</code> element may have an optional attribute named <code>ID</code> with type ID:
      </p>
      <pre><code>  &lt;xsd:complexType name="PersonType"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="NAME"&gt;
        &lt;xsd:complexType&gt;
          &lt;xsd:all&gt;
            &lt;xsd:element name="GIVEN"  type="xsd:string"/&gt;
            &lt;xsd:element name="FAMILY" type="xsd:string"/&gt;
          &lt;/xsd:all&gt;
        &lt;/xsd:complexType&gt;
      &lt;/xsd:element&gt;
    &lt;/xsd:sequence&gt;
    &lt;xsd:attribute name="ID" type="xsd:ID"/&gt;
  &lt;/xsd:complexType&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      
      <p class="GX">Attributes can also be attached to elements that can only contain text such as an <code>xsd:string</code> or an <code>xsd:gYear</code>. The details are a little more complex, because an element with attributes by definition has a complex type. To make this
         work, you derive a new complex type from a simple type by giving the <code>xsd:complexType</code> element an <code>xsd:simpleContent</code> child element instead of an <code>xsd:sequence</code>, <code>xsd:choice</code>, or <code>xsd:all</code>. The <code>xsd:simpleContent</code> element itself has an <code>xsd:extension</code> child element whose <code>base</code> attribute identifies the simple type to extend such as <code>xsd:string</code>. The <code>xsd:attribute</code> elements are placed inside the <code>xsd:extension</code> element.
      </p>
      
      <p class="GX">For example, suppose you want to allow the <code>TITLE</code> elements to have <code>ID</code> attributes like this:
      </p>
      <pre><code>&lt;TITLE ID="test"&gt;Yes I Am&lt;/TITLE&gt;
</code></pre>
      <p class="GX">Previously <code>TITLE</code> was defined with type <code>xsd:string</code>. Instead let's derive a new type called <code>StringWithID</code> from <code>xsd:string</code> like this:
      </p>
      <pre><code>&lt;xsd:complexType name="StringWithID"&gt;
  &lt;xsd:simpleContent&gt;
    &lt;xsd:extension base="xsd:string"&gt;
      &lt;xsd:attribute name="ID" type="xsd:ID"/&gt;
    &lt;/xsd:extension&gt;
  &lt;/xsd:simpleContent&gt;
&lt;/xsd:complexType&gt;
</code></pre>
      
      
      
      
      
      
      <p class="GX">The <code>StringWithID</code> type can then be applied to the <code>TITLE</code> element in the usual way like this:
      </p>
      <pre><code>&lt;xsd:element name="TITLE" type="StringWithID"/&gt;
</code></pre>
      <p class="GX">By default attributes declared in schemas are optional (<code>#IMPLIED</code> in DTD terminology). However, an <code>xsd:attribute</code> can have a <code>use</code> attribute with the value <code>required</code> to indicate that the element must occur. In this case, you probably do want to insist that each of the four attributes be
         present. Therefore the declaration of <code>PhotoType</code> becomes this:
      </p>
      <pre><code>  &lt;xsd:complexType name="PhotoType"&gt;
    &lt;xsd:attribute name="SRC"    type="xsd:anyURI"
                   use="required" /&gt;
    &lt;xsd:attribute name="WIDTH"  type="xsd:positiveInteger"
                   use="required" /&gt;
    &lt;xsd:attribute name="HEIGHT" type="xsd:positiveInteger"
                   use="required" /&gt;
    &lt;xsd:attribute name="ALT"    type="xsd:string"
                   use="required" /&gt;
  &lt;/xsd:complexType&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      <p class="GX">The <code>use</code> attribute can also have the value <code>optional</code> to indicate that it may or may not be present. (This is also the default if there is no <code>use</code> attribute.) If <code>optional</code>, then <code>xsd:attribute</code> may also have a <code>default</code> attribute giving the value the parser will provide if it doesn&#8217;t find one in the instance document. If there is no default
         attribute, then this is the same as <code>#IMPLIED</code> in <code>ATTLIST</code> declarations in DTDs. Instead of a <code>use</code> attribute, <code>xsd:attribute</code> can have a <code>fixed</code> attribute whose value is the constant value for the attribute, whether present in the instance document or not. This has
         the same affect as <code>#FIXED</code> in DTDs. Listing 24-23 puts this all together in a complete schema for songs, including a <code>PHOTO</code> element with several required attributes.
      </p>
      
      <p style="font-weight: bold">Listing 24-23: 
         A SONG schema that declares attributes
      </p>
      
      <pre><code>&lt;?xml version="1.0"?&gt;
&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;xsd:element name="SONG" type="SongType"/&gt;
  &lt;xsd:complexType name="PhotoType"&gt;
    &lt;xsd:attribute name="SRC"    type="xsd:anyURI"
                   use="required" /&gt;
    &lt;xsd:attribute name="WIDTH"  type="xsd:positiveInteger"
                   use="required" /&gt;
    &lt;xsd:attribute name="HEIGHT" type="xsd:positiveInteger"
                   use="required" /&gt;
    &lt;xsd:attribute name="ALT"    type="xsd:string"
                   use="required" /&gt;
  &lt;/xsd:complexType&gt;
  &lt;xsd:complexType name="SongType"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="TITLE"     type="xsd:string"/&gt;
      &lt;xsd:element name="PHOTO"     type="PhotoType"/&gt;
      &lt;xsd:element name="COMPOSER"  type="PersonType"
                   maxOccurs="unbounded"/&gt;
      &lt;xsd:element name="PRODUCER"  type="PersonType"
                   minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;xsd:element name="PUBLISHER" type="xsd:string"
                   minOccurs="0"/&gt;
      &lt;xsd:element name="LENGTH"    type="xsd:duration"/&gt;
      &lt;xsd:element name="YEAR"      type="xsd:gYear"/&gt;
      &lt;xsd:element name="ARTIST"    type="xsd:string"
                   maxOccurs="unbounded"/&gt;
      &lt;xsd:element name="PRICE" type="money"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;
  &lt;xsd:simpleType name="money"&gt;
    &lt;xsd:restriction base="xsd:string"&gt;
      &lt;xsd:pattern value="\p{Sc}\p{Nd}+(\.\p{Nd}\p{Nd})?"/&gt;
      &lt;!--
         Regular Expression:
         \p{Sc}             Any Unicode currency indicator;
                            e.g., $, &amp;#xA5, &amp;#xA3, &amp;#A4, etc.
         \p{Nd}             A Unicode decimal digit character
         \p{Nd}+            One or more Unicode decimal digits
         \.                 The period character
         (\.\p{Nd}\p{Nd})
         (\.\p{Nd}\p{Nd})?  Zero or one strings of the form .35
         This works for any decimalized currency.
      --&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;
  &lt;xsd:complexType name="PersonType"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="NAME"&gt;
        &lt;xsd:complexType&gt;
          &lt;xsd:all&gt;
            &lt;xsd:element name="GIVEN"  type="xsd:string"/&gt;
            &lt;xsd:element name="FAMILY" type="xsd:string"/&gt;
          &lt;/xsd:all&gt;
        &lt;/xsd:complexType&gt;
      &lt;/xsd:element&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;
&lt;/xsd:schema&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <h2><a name="d1e8500">Namespaces</a></h2>
      
      <p class="GX">So far the example song documents have been blissfully namespace-free. Adding namespaces to the documents, and designing a
         schema that applies to the namespace-qualified documents is not particularly difficult. Namespaces add some important features,
         such as the ability to write schemas and validate documents that use elements and attributes from multiple XML applications.
         However, the terminology is a little on the confusing side. Some words, such as <span class="italic">qualified, don&#8217;t mean quite the same thing in schemas as they do in other XML technologies, so you do need to pay close attention
            and read what follows carefully.</span></p>
      
      <h3>Schemas for default namespaces</h3>
      
      <p class="GX">Let's begin with a simple example in which the XML application described by the schema uses a single default, nonprefixed
         namespace. Most of the time each namespace URI maps to exactly one schema (though later you'll learn several techniques to
         break large schemas into parts using <code>xsd:import</code> and <code>xsd:include</code>).
      </p>
      
      <p class="GX">The schema for elements that are not in any namespace is identified by an <code>xsi:noNamespaceSchemaLocation</code> attribute. The schemas for elements that are in namespaces are identified by an <code>xsi:schemaLocation</code> attribute. This attribute contains a list of namespace URI/schema URI pairs. Each namespace URI is followed by one schema
         URI. The namespace URI is almost always absolute, but the schema URI is almost always a URL and often a relative URL.
      </p>
      
      <p class="GX">Listing 24-24 demonstrates. This is the familiar hotcop.xml document that you've seen several times already, though it's been
         simplified a bit to keep the examples smaller. All the elements in this document are in the <code>http://ibiblio.org/xml/namespace/song</code> namespace defined by the <code>xmlns</code> attribute on the root element. The attributes in this document are not in any namespace because they don&#8217;t have prefixes.
         There are two things you need to remember here:
      </p>
      
      <ul>
         <li>&nbsp;1.&nbsp;Attributes without prefixes are never in any namespace, no matter what namespace their parent element is in, no matter
            what default namespace the document uses.
         </li>
         <li>&nbsp;2.&nbsp;For purposes of schema validation, namespace declaration attributes, such as <code>xmlns</code> and <code>xmlns:xsi</code>, and schema attachment attributes, such as <code>xsi:schemaLocation</code>, don&#8217;t count. You do not need to declare these in your schema.
         </li>
      </ul>
      
      
      <p class="GX">In this case, all the elements are in the <code>http://ibiblio.org/xml/namespace/song</code> namespace, so an <code>xsi:schemaLocation</code> attribute is needed to associate this namespace with a URL where the schema can be found, <code>namespace_song.xsd</code> for this example.
      </p>
      
      <p style="font-weight: bold">Listing 24-24: 
         A SONG document in the http://ibiblio.org/xml/namespace/song namespace
      </p>
      
      <pre><code>&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;
&lt;SONG xmlns="http://ibiblio.org/xml/namespace/song"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation =
       "http://ibiblio.org/xml/namespace/song
        namespace_song.xsd"
&gt;
  &lt;TITLE&gt;Hot Cop&lt;/TITLE&gt;
  &lt;!-- I've temporarily dropped the SRC attribute on this
       element. I'm going to replace it with XLinks shortly.
    --&gt;
  &lt;PHOTO ALT="Victor Willis in Cop Outfit" WIDTH="100"
         HEIGHT="200"/&gt;
  &lt;COMPOSER&gt;Jacques Morali&lt;/COMPOSER&gt;
  &lt;COMPOSER&gt;Henri Belolo&lt;/COMPOSER&gt;
  &lt;COMPOSER&gt;Victor Willis&lt;/COMPOSER&gt;
  &lt;PRODUCER&gt;Jacques Morali&lt;/PRODUCER&gt;
  &lt;PUBLISHER&gt;PolyGram Records&lt;/PUBLISHER&gt;
  &lt;LENGTH&gt;P0YT6M20S&lt;/LENGTH&gt;
  &lt;YEAR&gt;1978&lt;/YEAR&gt;
  &lt;ARTIST&gt;Village People&lt;/ARTIST&gt;
&lt;/SONG&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <p class="GX">What does namespace_song.xsd look like? Listing 24-25 shows you. It's much the same schema as before, although I've dropped
         the <code>MoneyType</code> and <code>PersonType</code> to save a little room.
      </p>
      
      <p style="font-weight: bold">Listing 24-25: 
         A schema for SONG documents in the http://ibiblio.org/xml/namespace/song namespace
      </p>
      
      <pre><code>&lt;?xml version="1.0"?&gt;
&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"
  xmlns="http://ibiblio.org/xml/namespace/song"
  targetNamespace="http://ibiblio.org/xml/namespace/song"
  elementFormDefault="qualified"
  attributeFormDefault="unqualified"
&gt;
  &lt;xsd:element name="SONG" type="SongType"/&gt;
  &lt;xsd:complexType name="PhotoType"&gt;
    &lt;xsd:attribute name="WIDTH"  type="xsd:positiveInteger"
                   use="required" /&gt;
    &lt;xsd:attribute name="HEIGHT" type="xsd:positiveInteger"
                   use="required" /&gt;
    &lt;xsd:attribute name="ALT"    type="xsd:string"
                   use="required" /&gt;
  &lt;/xsd:complexType&gt;
  &lt;xsd:complexType name="SongType"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="TITLE"     type="xsd:string"/&gt;
      &lt;xsd:element name="PHOTO"     type="PhotoType"/&gt;
      &lt;xsd:element name="COMPOSER"  type="xsd:string"
                   maxOccurs="unbounded"/&gt;
      &lt;xsd:element name="PRODUCER"  type="xsd:string"
                   minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;xsd:element name="PUBLISHER" type="xsd:string"
                   minOccurs="0"/&gt;
      &lt;xsd:element name="LENGTH"    type="xsd:duration"/&gt;
      &lt;xsd:element name="YEAR"      type="xsd:gYear"/&gt;
      &lt;xsd:element name="ARTIST"    type="xsd:string"
                   maxOccurs="unbounded"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;
&lt;/xsd:schema&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <p class="GX">The main body of the schema is much the same as before. However, the <code>xsd:schema</code> start tag has several new attributes. It looks like this:
      </p>
      <pre><code>&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"
  xmlns="http://ibiblio.org/xml/namespace/song"
  targetNamespace="http://ibiblio.org/xml/namespace/song"
  elementFormDefault="qualified"
  attributeFormDefault="unqualified"
&gt;
</code></pre>
      
      
      
      
      
      <p class="GX">The first <code>xmlns</code> attribute establishes the default namespace for this schema, which is, after all, an XML document itself. It sets the namespace
         to <code>http://ibiblio.org/xml/namespace/song</code>, the same as in the instance documents you're trying to model. This says that the unprefixed element names used in this schema
         such as <code>PhotoType</code> are in the <code>http://ibiblio.org/xml/namespace/song</code> namespace.
      </p>
      
      <p class="GX">The second attribute says that this schema applies to documents in the <code>http://ibiblio.org/xml/namespace/song</code> namespace; that is, the elements identified by <code>name</code> attributes such as <code>SONG</code>, <code>PHOTO</code>, and <code>TITLE</code> are in the <code>http://ibiblio.org/xml/namespace/song</code> namespace.
      </p>
      
      <p class="GX">The third attribute, <code>elementFormDefault</code>, has the value <code>qualified</code>. This means that the elements being described in this document are in fact in a namespace; specifically they're in the target
         namespace given previously by the <code>targetNamespace</code> attribute. This does not mean that the elements being modeled necessarily have prefixes, merely that they are in some namespace.
      </p>
      
      <p class="GX">Finally, the fourth attribute, <code>attributeFormDefault</code>, has the value <code>unqualified</code>. This means that the attributes described by this schema are not in a namespace.
      </p>
      
      <p class="GX">Schemas have one major advantage over DTDs when working with documents with namespaces. They validate against the local name
         and the namespace URIs of the elements and attributes, not the prefix and the local name like DTDs do. This means the prefixes
         do not have to match in the schema and in the instance documents. Indeed one might use prefixes and the other might use the
         default namespace.
      </p>
      
      <p class="GX">For instance, consider Listing 24-26. This is the same as Listing 24-24 except that it uses the <code>song</code> prefix rather than the default namespace to indicate the <code>http://ibiblio.org/xml/namespace/song</code> namespace. However, it can use the <span class="italic">exact same schema</span>! The schema does not need to change just because the prefix (or lack thereof) has changed. As long as the namespace URI stays
         the same, the schema is happy.
      </p>
      
      <p style="font-weight: bold">Listing 24-26: 
         A SONG document in the http://ibiblio.org/xml/namespace/song namespace with prefixes
      </p>
      
      <pre><code>&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;
&lt;song:SONG
      xmlns:song="http://ibiblio.org/xml/namespace/song"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation =
       "http://ibiblio.org/xml/namespace/song
        namespace_song.xsd"
&gt;
  &lt;song:TITLE&gt;Hot Cop&lt;/song:TITLE&gt;
  &lt;!-- I've temporarily dropped the SRC attribute on this
       element. I'm going to replace it with XLinks shortly.
    --&gt;
  &lt;song:PHOTO ALT="Victor Willis in Cop Outfit" WIDTH="100"
         HEIGHT="200"/&gt;
  &lt;song:COMPOSER&gt;Jacques Morali&lt;/song:COMPOSER&gt;
  &lt;song:COMPOSER&gt;Henri Belolo&lt;/song:COMPOSER&gt;
  &lt;song:COMPOSER&gt;Victor Willis&lt;/song:COMPOSER&gt;
  &lt;song:PRODUCER&gt;Jacques Morali&lt;/song:PRODUCER&gt;
  &lt;song:PUBLISHER&gt;PolyGram Records&lt;/song:PUBLISHER&gt;
  &lt;song:LENGTH&gt;P0YT6M20S&lt;/song:LENGTH&gt;
  &lt;song:YEAR&gt;1978&lt;/song:YEAR&gt;
  &lt;song:ARTIST&gt;Village People&lt;/song:ARTIST&gt;
&lt;/song:SONG&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <h3>Multiple namespaces, multiple schemas</h3>
      
      <p class="GX">Now let's consider the case in which one document mixes markup from different vocabularies. In particular, let&#8217;s suppose that
         you want to use XLink to connect the <code>PHOTO</code> element to the actual JPEG image rather than application-specific markup such as <code>SRC</code>. You need to set <code>xlink:type</code>, <code>xlink:href</code>, <code>xlink:show</code>, and <code>xlink:actuate</code> attributes on the <code>PHOTO</code> element to give it the proper meaning and behavior like this:
      </p>
      <pre><code>&lt;PHOTO xlink:type="simple" xlink:href="hotcop.jpg"
       xlink:show="embed"  xlink:actuate="onLoad"
       ALT="Victor Willis in Cop Outfit"
       WIDTH="100" HEIGHT="200"/&gt;
</code></pre>
      
      
      
      <p class="SBT" style="font-weight: bold; margin-left: 0.5in; margin-right: 0.5in;        font-family: Arial, Helvetica, sans; color: #0000ff">Cross-Reference</p>
      
      <p class="SBT" style="font-family: Arial, Helvetica, sans;        margin-left: 0.5in; margin-right: 0.5in">XLinks are discussed in Chapter 20<span style="{font-size: 8pt}"><span class="upCastTextColor-6"><span style="{font-family: Times New Roman}"><span class="annotation-reference">
                     </span></span></span></span>.
      </p>
      
      <p class="GX">Now the document uses two main namespaces, the <code>http://ibiblio.org/xml/namespace/song</code> namespace for songs and the <code>http://www.w3.org/1999/xlink</code> namespace for XLinks. Thus, it needs two schemas. However, because the root element can have only one <code>xsi:schemaLocation</code> attribute, it has to serve double duty and declare both. Listing 24-27 demonstrates.
      </p>
      
      <p style="font-weight: bold">Listing 24-27: 
         A SONG document that uses XLink to embed photos
      </p>
      
      <pre><code>&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;
&lt;SONG xmlns="http://ibiblio.org/xml/namespace/song"
      xmlns:xlink="http://www.w3.org/1999/xlink"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation =
      "http://ibiblio.org/xml/namespace/song 24-29.xsd
       http://www.w3.org/1999/xlink xlink.xsd"
&gt;
  &lt;TITLE&gt;Hot Cop&lt;/TITLE&gt;
  &lt;PHOTO xlink:type="simple" xlink:href="hotcop.jpg"
         xlink:show="embed"  xlink:actuate="onLoad"
         ALT="Victor Willis in Cop Outfit"
         WIDTH="100" HEIGHT="200"/&gt;
  &lt;COMPOSER&gt;Jacques Morali&lt;/COMPOSER&gt;
  &lt;COMPOSER&gt;Henri Belolo&lt;/COMPOSER&gt;
  &lt;COMPOSER&gt;Victor Willis&lt;/COMPOSER&gt;
  &lt;PRODUCER&gt;Jacques Morali&lt;/PRODUCER&gt;
  &lt;PUBLISHER&gt;PolyGram Records&lt;/PUBLISHER&gt;
  &lt;LENGTH&gt;P0YT6M20S&lt;/LENGTH&gt;
  &lt;YEAR&gt;1978&lt;/YEAR&gt;
  &lt;ARTIST&gt;Village People&lt;/ARTIST&gt;
&lt;/SONG&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <p class="GX">Listing 24-28 shows the XLink schema. It only declares attributes, no elements at all. You haven&#8217;t seen an example of this
         yet, but it's not hard. Just use <code>xsd:attribute</code> elements at the top-level, that is, as direct children of the <code>xsd:schema</code> element. The other difference between these top-level <code>xsd:attribute</code> elements and the ones you've seen before is that three of the attributes have fixed values, and don&#8217;t even need to be explicitly
         included in the instance document. Only the <code>xlink:href</code> attribute asks the author to supply a value. However, this is rather specific to this particular use of XLink. Almost anything
         else you'd do with an XLink other than embedding an image or other non-XML content into the document would require a different
         schema that used different defaults.
      </p>
      
      <p style="font-weight: bold">Listing 24-28: 
         xlink.xsd: An XLink schema
      </p>
      
      <pre><code>&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;
&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"
  xmlns="http://www.w3.org/1999/xlink"
  targetNamespace="http://www.w3.org/1999/xlink"
  attributeFormDefault="unqualified"
&gt;
  &lt;xsd:attribute name="type"    type="xsd:string"
                 fixed="simple"/&gt;
  &lt;xsd:attribute name="href"    type="xsd:anyURI"/&gt;
  &lt;xsd:attribute name="actuate" type="xsd:string"
                 fixed="onLoad"/&gt;
  &lt;xsd:attribute name="show"    type="xsd:string"
                 fixed="embed"/&gt;
&lt;/xsd:schema&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      
      
      <p class="GX">This schema doesn&#8217;t actually apply these attributes to any elements. Therefore, the schema that does describe the <code>PHOTO</code> element needs to import xlink.xsd in order to reference these declarations. This is done with an <code>xsd:import</code> element. The <code>xsd:import</code>'s<code> schemaLocation</code> attribute tells the processor where to find the schema to import. The <code>namespace</code> attribute says which elements and attributes the schema declares. Once this schema has been imported, you can add those attributes
         to any <code>xsd:complexType</code> by giving it an <code>xsd:attribute</code> child whose <code>ref</code> attribute identifies the attribute to be attached. Listing 24-29 demonstrates.
      </p>
      
      <p style="font-weight: bold">Listing 24-29: 
         A SONG schema that imports the XLink schema
      </p>
      
      
      <p class="query">[If you&#8217;re going to use <a href="http://ibiblio.org/xml/namespace/song" shape="rect"><span class="underline"><span class="upCastTextColor-2"><span class="Hyperlink">http://ibiblio.org/xml/namespace/song</span></span></span></a> as a namespace, you might want to follow your own advice and RDDL it.]
      </p>
      
      <p class="query">stet - erh</p>
      <pre><code>&lt;?xml version="1.0"?&gt;
&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"
  xmlns="http://ibiblio.org/xml/namespace/song"
  xmlns:xlink="http://www.w3.org/1999/xlink"
  targetNamespace="http://ibiblio.org/xml/namespace/song"
  elementFormDefault="qualified"
  attributeFormDefault="unqualified"
&gt;
  &lt;xsd:import namespace="http://www.w3.org/1999/xlink"
              schemaLocation="xlink.xsd"/&gt;
  &lt;xsd:element name="SONG" type="SongType"/&gt;
  &lt;xsd:complexType name="PhotoType"&gt;
    &lt;xsd:attribute name="WIDTH"  type="xsd:positiveInteger"
                   use="required" /&gt;
    &lt;xsd:attribute name="HEIGHT" type="xsd:positiveInteger"
                   use="required" /&gt;
    &lt;xsd:attribute name="ALT"    type="xsd:string"
                   use="required" /&gt;
    &lt;xsd:attribute ref="xlink:type"/&gt;
    &lt;xsd:attribute ref="xlink:href" use="required"/&gt;
    &lt;xsd:attribute ref="xlink:actuate"/&gt;
    &lt;xsd:attribute ref="xlink:show"/&gt;
  &lt;/xsd:complexType&gt;
  &lt;xsd:complexType name="SongType"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="TITLE"     type="xsd:string"/&gt;
      &lt;xsd:element name="PHOTO"     type="PhotoType"/&gt;
      &lt;xsd:element name="COMPOSER"  type="xsd:string"
                   maxOccurs="unbounded"/&gt;
      &lt;xsd:element name="PRODUCER"  type="xsd:string"
                   minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;xsd:element name="PUBLISHER" type="xsd:string"
                   minOccurs="0"/&gt;
      &lt;xsd:element name="LENGTH"    type="xsd:duration"/&gt;
      &lt;xsd:element name="YEAR"      type="xsd:gYear"/&gt;
      &lt;xsd:element name="ARTIST"    type="xsd:string"
                   maxOccurs="unbounded"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;
&lt;/xsd:schema&gt;
</code></pre>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <h2><a name="d1e9286">Annotations</a></h2>
      
      <p class="GX">At some point in this chapter, it's likely to have occurred to you that schemas can get rather large and rather complex. If
         that hasn&#8217;t occurred to you yet, just imagine a schema not for the very small and simple song documents demonstrated in this
         chapter, but for much larger XML applications such as Scalable Vector Graphics, XHTML, and DocBook.
      </p>
      
      <p class="GX">You can certainly use regular XML comments to describe schemas, and I encourage you to do so, especially when you're doing
         something less than obvious in the schema. The W3C XML Schema language also provides a more formal mechanism for annotating
         schemas. Both the top-level <code>xsd:schema</code> element itself and the various other schema elements (<code>xsd:complexType</code>, <code>xsd:all</code>, <code>xsd:element</code>, <code>xsd:attribute</code>, and so on) can contain <code>xsd:annotation</code> child elements that describe that part of the schema for human readers or for other computer programs. This element has two
         kinds of child elements:
      </p>
      
      <ul>
         <li>The <code>xsd:documentation</code> child element describes the schema for human readers. It often contains copyright and similar information.
         </li>
         <li>The <code>xsd:appInfo</code> child element describes the schema for computer programs. For instance, it might contain instructions about what style sheets
            to apply to the schema.
         </li>
      </ul>
      
      
      <p class="GX">Each <code>xsd:annotation</code> element can contain any number of either of these. However, no special syntax has been defined for the content of these elements.
         You can put anything in there you find convenient, including other XML markup, subject only to the usual well-formedness constraints.
         Thus an <code>xsd:documentation</code> element might contain XHTML and an <code>xsd:appInfo</code> element might contain XSLT. Then again either or both might simply contain plain, unmarked-up text. For example, this annotation
         could be added to the song schemas developed in this chapter:
      </p>
      <pre><code>  &lt;xsd:annotation&gt;
   &lt;xsd:documentation&gt;
    Song schema for Chapter 23 of the XML Bible, Gold Edition
    Copyright 2001 Elliotte Rusty Harold.
    elharo@metalab.unc.edu
   &lt;/xsd:documentation&gt;
  &lt;/xsd:annotation&gt;
</code></pre>
      
      
      
      
      
      
      <h2 class="sum-H">Summary</h2>
      
      <p class="sum-X">In this chapter, you learned that:</p>
      
      <ul>
         <li>Schemas address a number of perceived limitations of DTDs, including a strange, non-XML syntax, namespace incompatibility,
            lack of data typing, and limited extensibility and scalability.
         </li>
         <li>There are multiple XML schema languages including Relax, Schematron, TREX, and the W3C XML Schema language described in this
            chapter.
         </li>
         <li>An XML document can indicate the schema that applies to its non-namespace-qualified elements via an <code>xsi:noNamespaceSchemaLocation</code> attribute, which is normally placed on the root element.
         </li>
         <li>An XML document can indicate the schema that applies to its namespace qualified elements via an <code>xsi:schemaLocation</code> attribute, which is normally placed on the root element.
         </li>
         <li>Schemas declare elements with <code>xsd:element</code> elements.
         </li>
         <li>The <code>type</code> attribute of <code>xsd:element</code> specifies the data type of that element.
         </li>
         <li>Elements with complex types can have attributes and child elements.</li>
         <li>Elements with simple types only contain parsed character data.</li>
         <li>The <code>xsd:complexType</code> element defines a new type for an element that can contain child elements, attributes, and/or mixed content.
         </li>
         <li>The <code>xsd:group</code>, <code>xsd:all</code>, <code>xsd:choice</code>, and <code>xsd:sequence</code> elements let you specify particular combinations of elements in an element's content model.
         </li>
         <li>The <code>minOccurs</code> and <code>maxOccurs</code> attributes of <code>xsd:element</code> determine how many of a given element are allowed in the instance document at that point. The default for each is 1. <code>maxOccurs</code> can be set to <code>unbounded</code> to indicate that any number of the element may appear.
         </li>
         <li>There are 44 built-in simple types, including many numeric, string, time, and XML types.</li>
         <li>The <code>xsd:simpleType</code> element defines a new type for an element or attribute that can only contain character data.
         </li>
         <li>You can define your own simple types by restricting an existing type such as <code>xsd:string</code> with the <code>xsd:restriction</code> element. The <code>base</code> attribute of the <code>xsd:restriction</code> child specifies what type you're deriving from.
         </li>
         <li>Each <code>xsd:restriction</code> element contains one or more child elements representing facets: <code>xsd:minInclusive</code>, <code>xsd:minExclusive</code>, <code>xsd:maxInclusive</code>, <code>xsd:maxExclusive</code>, <code>xsd:enumeration</code>, <code>xsd:whiteSpace</code>, <code>xsd:pattern</code>, <code>xsd:length</code>, <code>xsd:minLength</code>, <code>xsd:maxLength, xsd:totalDigits</code>, and/or <code>xsd:fractionDigits</code>.
         </li>
         <li>An <code>xsd:simpleType</code> element can create a new type by unifying the value spaces of existing types. Each existing type combined into the new type
            is identified by an <code>xsd:union</code> child element.
         </li>
         <li>A list type can hold one or more white space-separated instances of an existing type. Such a type is defined by the <code>xsd:list</code> child of an <code>xsd:simpleType</code> element.
         </li>
         <li>Schemas declare attributes with <code>xsd:attribute</code> elements.
         </li>
         <li>The <code>xsd:import</code> element imports declarations for elements and attributes in a different namespace from another schema document.
         </li>
         <li>Adding <code>xsd:annotation</code> elements helps make your schemas more readable.
         </li>
         <li>The <code>xsd:documentation</code> child of an <code>xsd:annotation</code> element provides information for human readers.
         </li>
         <li>The <code>xsd:appInfo</code> child of an <code>xsd:annotation</code> element provides information for software programs reading the schema, though schema validators ignore it.
         </li>
      </ul>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <p class="sum-X">In the next chapter, we explore another standard XML application from the W3C, the Resource Description Framework (RDF). RDF
         is an XML application for encoding meta-data and information structures.
      </p>
      
      <hr>
      <div style="text-align: center">
         [ <a href="../../index.html">Cafe con Leche</a> 
         | <a href="../index.html">XML Bible Home Page</a>
         | Order from <a href="http://www.amazon.com/exec/obidos/ASIN/0764547607/ref=nosim/cafeaulaitA/">amazon.com</a> ]
         
      </div>
      <hr>
      Copyright 2001 <a href="http://www.macfaq.com/personal.html">Elliotte Rusty Harold</a><br><a href="mailto:elharo@metalab.unc.edu">elharo@metalab.unc.edu</a><br>
      Last Modified June 3, 2001  
      
   </body>
</html>