<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>The Element Class</title><meta name="generator" content="DocBook XSL Stylesheets V1.52.2"><meta name="description" content="The complete text of Elliotte Rusty Harold's book Processing XML with Java.         published by Addison-Wesley, November 2002"><script language="javascript"><!--
/* Only sunsites are allowed to mirror this page and then
only with explicit, prior permission. For details,
send email to elharo@metalab.unc.edu */
if (location.protocol.toLowerCase().indexOf("file") != 0 ) { 
  if (0 > location.host.toLowerCase().indexOf("cafeconleche.org")
      && 0 > location.host.toLowerCase().indexOf("ibiblio.org")) {
    location.href="http://www.cafeconleche.org/books/xmljava/chapters/";
  }
} // --></script><link rel="home" href="index.html" title="Processing XML with Java"><link rel="up" href="ch15.html" title="Chapter&nbsp;15.&nbsp;The JDOM Model"><link rel="previous" href="ch15.html" title="Chapter&nbsp;15.&nbsp;The JDOM Model"><link rel="next" href="ch15s03.html" title="The Attribute Class"><link rel="preface" href="pr01.html" title="Preface"><link rel="preface" href="pr02.html" title="Acknowledgements"><link rel="chapter" href="ch01.html" title="Chapter&nbsp;1.&nbsp;XML for Data"><link rel="chapter" href="ch02.html" title="Chapter&nbsp;2.&nbsp;XML Protocols: XML-RPC and SOAP"><link rel="chapter" href="ch03.html" title="Chapter&nbsp;3.&nbsp;Writing XML with Java"><link rel="chapter" href="ch04.html" title="Chapter&nbsp;4.&nbsp;Converting Flat Files to XML"><link rel="chapter" href="ch05.html" title="Chapter&nbsp;5.&nbsp;Reading XML"><link rel="chapter" href="ch06.html" title="Chapter&nbsp;6.&nbsp;SAX"><link rel="chapter" href="ch07.html" title="Chapter&nbsp;7.&nbsp;The XMLReader Interface"><link rel="chapter" href="ch08.html" title="Chapter&nbsp;8.&nbsp;SAX Filters"><link rel="chapter" href="ch09.html" title="Chapter&nbsp;9.&nbsp;The Document Object Model"><link rel="chapter" href="ch10.html" title="Chapter&nbsp;10.&nbsp;Creating XML Documents with DOM"><link rel="chapter" href="ch11.html" title="Chapter&nbsp;11.&nbsp;The Document Object Model Core"><link rel="chapter" href="ch12.html" title="Chapter&nbsp;12.&nbsp;The DOM Traversal Module"><link rel="chapter" href="ch13.html" title="Chapter&nbsp;13.&nbsp;Output from DOM"><link rel="chapter" href="ch14.html" title="Chapter&nbsp;14.&nbsp;JDOM"><link rel="chapter" href="ch15.html" title="Chapter&nbsp;15.&nbsp;The JDOM Model"><link rel="chapter" href="ch16.html" title="Chapter&nbsp;16.&nbsp;XPath"><link rel="chapter" href="ch17.html" title="Chapter&nbsp;17.&nbsp;XSLT"><link rel="appendix" href="apa.html" title="Appendix&nbsp;A.&nbsp;XML APIs Quick Reference"><link rel="appendix" href="apb.html" title="Appendix&nbsp;B.&nbsp;SOAP 1.1 Schemas"><link rel="index" href="ix01.html" title="Index"><link rel="subsection" href="ch15s02.html#d0e24212" title="Constructors"><link rel="subsection" href="ch15s02.html#d0e24311" title="Navigation and Search"><link rel="subsection" href="ch15s02.html#d0e25563" title="Attributes"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">The Element Class</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch15.html">Prev</a>&nbsp;</td><th width="60%" align="center">Chapter&nbsp;15.&nbsp;The JDOM Model</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="ch15s03.html">Next</a></td></tr></table><hr></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="d0e23797"></a>The Element Class</h2></div></div><p>
    The structure of an XML document is based on its
    elements, so it should come as no surprise that the
    <tt>Element</tt> class is one of the larger and
    more important in JDOM. Since JDOM does not have any generic
    <tt>Node</tt> class or interface,
    the  <tt>Element</tt> class is the primary
    means by which a program
    navigates the tree to find particular content.
  </p><p>
    Each  <tt>Element</tt> object has the following
    seven basic properties:
  </p><div class="variablelist"><dl><dt><span class="term">Local name</span></dt><dd><p>A <tt>String</tt> that is initialized when the 
      <tt>Element</tt> is constructed, and which
      can never be null or the empty string.
      It is accessible through the
      <tt>setName()</tt> and
      <tt>getName()</tt> methods:</p><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">Element&nbsp;</span><span class="methodname"><b>setName</b></span>(<span class="methodparam"><span class="type">String&nbsp;</span><span class="parameter"><i>name</i></span></span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;throws&nbsp;<span class="exceptionname">IllegalNameException</span>;</code><br><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">String&nbsp;</span><span class="methodname"><b>getName</b></span>();</code></dd><dt><span class="term">Namespace</span></dt><dd><p>A <tt>Namespace</tt> object which encapsulates both the 
      namespace URI and an optional prefix. 
      This can be the named constant <tt>Namespace.NO_NAMESPACE</tt> 
       if the element does not have a namespace. 
      A namespace is always set 
      when the <tt>Element</tt> is constructed but
      can be changed
       by 
      <tt>setNamespace()</tt>. It can be read by
      the
      <tt>getNamespace()</tt> method.
       </p><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">Element&nbsp;</span><span class="methodname"><b>setNamespace</b></span>(<span class="methodparam"><span class="type">Namespace&nbsp;</span><span class="parameter"><i>namespace</i></span></span>);</code><br><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">String&nbsp;</span><span class="methodname"><b>getNamespace</b></span>();</code></dd><dt><span class="term">Content</span></dt><dd><p>A <tt>List</tt> with no duplicates
      containing
      all the
      element&#8217;s children in order.
      This  is accessible through the
      <tt>getContent()</tt> and
      <tt>setContent()</tt> methods. 
      The list is live so you can change the contents of the
      <tt>Element</tt> using the 
      methods of the <tt>List</tt> class. 
     </p><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">Element&nbsp;</span><span class="methodname"><b>setContent</b></span>(<span class="methodparam"><span class="type">List&nbsp;</span><span class="parameter"><i>list</i></span></span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;throws&nbsp;<span class="exceptionname">IllegalAddException</span>;</code><br><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">List&nbsp;</span><span class="methodname"><b>getContent</b></span>();</code><p>
      In addition, individual nodes can be added to and removed from 
      the list via the
      <tt>addContent()</tt> and   
        <tt>removeContent()</tt> methods.
      </p></dd><dt><span class="term">Parent</span></dt><dd><p>The parent <tt>Element</tt>
      that contains this 
      <tt>Element</tt>. 
      It will be null  if this is the root element,
      and may be null if this  <tt>Element</tt> is not
      currently part of a <tt>Document</tt>.
      This is accessible through the 
      <tt>getParent()</tt> method:
     </p><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">Element&nbsp;</span><span class="methodname"><b>getParent</b></span>();</code><br><p>
      The parent can be changed only by adding the <tt>Element</tt>
      to a new parent using the parent&#8217;s
      <tt>addContent()</tt> method. This is only
      possible if 
      the <tt>Element</tt> does not already have a parent.
      Before a parent can adopt a  child
      <tt>Element</tt>, the child&#8217;s
       <tt>detach()</tt> method must be invoked
      to remove it from its current parent:
      </p><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">Element&nbsp;</span><span class="methodname"><b>detach</b></span>();</code></dd><dt><span class="term">Owner document</span></dt><dd><p>The  <tt>Document</tt>
      that contains this 
      <tt>Element</tt>. 
      It will be null  if this  <tt>Element</tt> is not
      currently part of a <tt>Document</tt>.
      It can be read by the 
      <tt>getDocument()</tt> method:
      </p><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">Document&nbsp;</span><span class="methodname"><b>getDocument</b></span>();</code><p> 
      It can be changed by adding the <tt>Element</tt>
      to a new document after first detaching it from
      its previous parent with the
      <tt>detach()</tt> method.
      </p></dd><dt><span class="term">Attributes</span></dt><dd><p>A <tt>List</tt> containing 
      <tt>Attribute</tt> objects, one for each of
      the
      element&#8217;s attributes. 
      Although JDOM stores attributes in a list for convenience,
      order is not significant, and is not likely to be the same
      as the order in which the attributes appeared in the
      original document. 
      The list is accessible through the
      <tt>getAttributes()</tt> and
      <tt>setAttributes()</tt> methods:
      </p><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">Element&nbsp;</span><span class="methodname"><b>setAttributes</b></span>(<span class="methodparam"><span class="type">List&nbsp;</span><span class="parameter"><i>attributes</i></span></span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;throws&nbsp;<span class="exceptionname">IllegalAddException</span>;</code><br><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">List&nbsp;</span><span class="methodname"><b>getAttributes</b></span>();</code><p>
      The items in 
      this list can be read and modified via the
      <tt>getAttribute()</tt>,
      <tt>getAttributeValue()</tt>,
      and  
        <tt>setAttribute()</tt> methods.
        Attributes that declare namespaces are not included in
        this list. 
      </p></dd><dt><span class="term">Additional namespaces</span></dt><dd><p>A <tt>List</tt> containing 
      <tt>Namespace</tt> objects, one for
      each 
      additional namespace prefix declared by the element
      (that is, other than those that declare the namespace of
      the element and the namespaces of its attributes). 
      As with the list of attributes,  order is not significant.
      The entire list is accessible through the
      <tt>getAdditionalNamespaces()</tt> method:
      </p><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">List&nbsp;</span><span class="methodname"><b>getAdditionalNamespaces</b></span>();</code><br><p>
      Namespaces can be added to and removed from the list using
      the
      <tt>addNamespaceDeclaration()</tt>, and
      <tt>removeNamespaceDeclaration()</tt>
      methods:
      </p><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">Element&nbsp;</span><span class="methodname"><b>addNamespaceDeclaration</b></span>(<span class="methodparam"><span class="type">Namespace&nbsp;</span><span class="parameter"><i>namespace</i></span></span>);</code><br><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">Element&nbsp;</span><span class="methodname"><b>removeNamespaceDeclaration</b></span>(<span class="methodparam"><span class="type">Namespace&nbsp;</span><span class="parameter"><i>namespace</i></span></span>);</code></dd></dl></div><p>
    In addition, there are some other properties which are not
    independent of the above seven. For instance, 
    the prefix, namespace URI, and fully qualified name 
      are separately readable through 
      the <tt>getNamespaceURI()</tt>, 
       <tt>getNamespacePrefix()</tt>, 
       and <tt>getQualifiedName()</tt> convenience methods:
   </p><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">String&nbsp;</span><span class="methodname"><b>getNamespaceURI</b></span>();</code><br><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">String&nbsp;</span><span class="methodname"><b>getNamespacePrefix</b></span>();</code><br><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">String&nbsp;</span><span class="methodname"><b>getQualifiedName</b></span>();</code><p>
    These just return the relevant parts of the
    element&#8217;s namespace and name. 
  </p><p>
      All these getter methods behave pretty much like any other getter methods. 
      That is, they return an object of the relevant type,
      generally a <tt>String</tt>, and do not throw
      any exceptions.
      The setter methods are more unusual, however. This is one
      of the few areas where JDOM does not follow standard Java
      conventions. Instead of returning <tt>void</tt>,
      these methods all return the <tt>Element</tt>
      object that invoked the method. That is,
      <tt>a.set<i><tt>Foo</tt></i>(b)</tt> returns <tt>a</tt>.
      Many other methods you'd naturally expect to return void
      also do this. 
      The purpose is to allow setters to be chained.
     For example, this code fragment can build up an entire
     <tt>channel</tt> element in just a couple of
     statements:
   </p><div class="informalexample"><pre class="programlisting"> Element channel = (new Element("channel"))
 .addContent((new Element("title")).setText("Cafe con Leche"))
 .addContent((new Element("link"))
  .setText("http://www.cafeconleche.org/"))
 .addContent((new Element("description"))
  .setText("XML News"));</pre></div><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in; font-family: Helvetica, Arial, sans"><h3 class="title">Caution</h3><p>
     I must say that I personally don&#8217;t find this style of code
     easier to write or read than the multi-statement approach.
     However, this is why the adder and setter methods 
     all return the object that did the adding or setting so I
     felt compelled to show it to you. But I really recommend
     strongly that you don&#8217;t use it. 
   </p></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="d0e24212"></a>Constructors</h3></div></div><p>
    The four public <tt>Element</tt>
    constructors 
    all require you to specify a local name as a <tt>String</tt>. 
    If the element is in a namespace, then you also 
    need to specify the namespace URI as a
    <tt>String</tt> or a 
    <tt>Namespace</tt> object. The prefix can also
    be specified as a
    <tt>String</tt> or a piece of a
    <tt>Namespace</tt> object.
   </p><code class="constructorsynopsis"><span class="modifier">public&nbsp;</span><span class="methodname"><b>Element</b></span>(<span class="methodparam"><span class="type">String&nbsp;</span><span class="parameter"><i>localName</i></span></span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;throws&nbsp;<span class="exceptionname">IllegalNameException</span>;</code><br><code class="constructorsynopsis"><span class="modifier">public&nbsp;</span><span class="methodname"><b>Element</b></span>(<span class="methodparam"><span class="type">String&nbsp;</span><span class="parameter"><i>localName</i></span></span>, <span class="methodparam"><span class="type">Namespace&nbsp;</span><span class="parameter"><i>namespace</i></span></span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;throws&nbsp;<span class="exceptionname">IllegalNameException</span>;</code><br><code class="constructorsynopsis"><span class="modifier">public&nbsp;</span><span class="methodname"><b>Element</b></span>(<span class="methodparam"><span class="type">String&nbsp;</span><span class="parameter"><i>localName</i></span></span>, <span class="methodparam"><span class="type">String&nbsp;</span><span class="parameter"><i>namespaceURI</i></span></span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;throws&nbsp;<span class="exceptionname">IllegalNameException</span>;</code><br><code class="constructorsynopsis"><span class="modifier">public&nbsp;</span><span class="methodname"><b>Element</b></span>(<span class="methodparam"><span class="type">String&nbsp;</span><span class="parameter"><i>localName</i></span></span>, <span class="methodparam"><span class="type">String&nbsp;</span><span class="parameter"><i>prefix</i></span></span>, <span class="methodparam"><span class="type">String&nbsp;</span><span class="parameter"><i>namespaceURI</i></span></span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;throws&nbsp;<span class="exceptionname">IllegalNameException</span>;</code><p>
     For example, this code fragment creates four
     <tt>Element</tt> objects using the various
     constructors:
   </p><div class="informalexample"><pre class="programlisting">Element xmlRPCRoot = new Element("methodCall");
Element xhtmlRoot = new Element("html", 
 "http://www.w3.org/1999/xhtml");
Element soapRoot = new Element("Envelope", "SOAP-ENV", 
 "http://schemas.xmlsoap.org/soap/envelope/");
Namespace xsd = Namespace.getNamespace("xsd", 
 "http://www.w3.org/2001/XMLSchema");
Element schemaRoot = new Element("schema", xsd);</pre></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="d0e24311"></a>Navigation and Search</h3></div></div><p>
    As you learned in the last chapter, the
    <tt>getContent()</tt> method is
    the fundamental means of navigating through an XML document
    with JDOM.
    This method returns a live <tt>List</tt>
    which includes all the children of an element including comments,
    processing instructions, text nodes, and elements.
    To search deeper, you apply <tt>getContent()</tt> 
    to the child elements of the current element,
    normally through recursion.
  </p><p>
    For example, here&#8217;s a simple program that walks the XML
    document tree, starting at the root element,
    and prints out the content of the various properties of each
    element. This is not the most interesting program in the book,
    but it does  demonstrate all the major getter methods and basic navigation:
    Pay special attention to the <tt>process()</tt>
    method. You have to write a method very much like this
    for any JDOM
    program that needs to search an entire XML document. It
    begins with an <tt>Element</tt> (normally
    the root element) and recursively applies itself to all the
    child elements of the root element. 
    The <tt>instanceof</tt> operator tests each object
    in the <tt>Element</tt>&#8217;s
    content list to determine its type and dispatch it to the
    right method. Here, <tt>TreePrinter</tt>
    dispatches <tt>Element</tt> objects to the
    <tt>process()</tt> method recursively, and
    ignores all other objects. 
  </p><div class="example"><a name="TreePrinter.java"></a><p class="title"><b>Example&nbsp;15.2.&nbsp;Inspecting elements</b></p><pre class="programlisting">import org.jdom.*;
import org.jdom.input.SAXBuilder;
import java.io.IOException;
import java.util.*;


public class TreePrinter {

  // Recursively descend the tree
  public static void process(Element element) {
    
    inspect(element);
    List content = element.getContent();
    Iterator iterator = content.iterator();
    while (iterator.hasNext()) {
      Object o = iterator.next();
      if (o instanceof Element) {
        Element child = (Element) o;
        process(child);
      }
    }
    
  }

  // Print the properties of each element
  public static void inspect(Element element) {
    
    if (!element.isRootElement()) {
      // Print a blank line to separate it from the previous
      // element.
      System.out.println(); 
    }
    
    String qualifiedName = element.getQualifiedName();
    System.out.println(qualifiedName + ":");
    
    Namespace namespace = element.getNamespace();
    if (namespace != Namespace.NO_NAMESPACE) {
      String localName = element.getName();
      String uri = element.getNamespaceURI();
      String prefix = element.getNamespacePrefix();
      System.out.println("  Local name: " + localName);
      System.out.println("  Namespace URI: " + uri);
      if (!"".equals(prefix)) {
        System.out.println("  Namespace prefix: " + prefix);
      }
    }
    List attributes = element.getAttributes();
    if (!attributes.isEmpty()) {
      Iterator iterator = attributes.iterator();
      while (iterator.hasNext()) {
        Attribute attribute = (Attribute) iterator.next();
        String name = attribute.getName();
        String value = attribute.getValue();
        Namespace attributeNamespace = attribute.getNamespace();
        if (attributeNamespace == Namespace.NO_NAMESPACE) {
          System.out.println("  " + name + "=\"" + value + "\""); 
        }
        else {
          String prefix = attributeNamespace.getPrefix();
          System.out.println(
           "  " + prefix + ":" + name + "=\"" + value + "\""); 
        }
      }
    }
    
    List namespaces = element.getAdditionalNamespaces();
    if (!namespaces.isEmpty()) {
      Iterator iterator = namespaces.iterator();
      while (iterator.hasNext()) {
        Namespace additional = (Namespace) iterator.next();
        String uri = additional.getURI();
        String prefix = additional.getPrefix();
          System.out.println(
           "  xmlns:" + prefix + "=\"" + uri + "\""); 
      }
    }
    
  }
  
  public static void main(String[] args) {

    if (args.length &lt;= 0) {
      System.out.println("Usage: java TreePrinter URL");
      return;
    }
    
    String url = args[0];
    
    try {
      SAXBuilder parser = new SAXBuilder();
      
      // Parse the document
      Document document = parser.build(url); 
      
      // Process the root element
      process(document.getRootElement());

    }
    catch (JDOMException e) {
      System.out.println(url + " is not well-formed.");
    }
    catch (IOException e) { 
      System.out.println(
       "Due to an IOException, the parser could not encode " + url
      ); 
    }
     
  } // end main

}
</pre></div><p>
    Here&#8217;s the beginning of output when this chapter&#8217;s XML source
    code is fed into <tt>TreePrinter</tt>. DocBook
    doesn&#8217;t use namespaces,
    but the XInclude elements do. The root element has some
    attributes, but most of the structure is based on element
    name alone.
  </p><pre class="screen"><tt>D:\books\XMLJAVA&gt;</tt><b><tt>java TreePrinter jdom_model.xml</tt></b>
<tt>chapter:
  revision="20020430"
  status="rough"
  id="ch_jdom_model"
  xmlns:xinclude="http://www.w3.org/2001/XInclude"

title:

para:

para:

itemizedlist:

listitem:

para:

classname:
&#8230;</tt></pre><p>
      While in theory you could navigate and query a
      document using only the
      <tt>List</tt> objects returned by
      <tt>getContent()</tt>, JDOM provides many
      methods to simplify the process for special cases
      including methods that return lists containing child
      elements only, methods that return particular named child
      elements, methods that return the complete text of an element,
      methods that return the text of a child element,
      methods to remove children identified by name and
      reference, methods that return the first child of an element,
      and more.
    </p><div class="sect3"><div class="titlepage"><div><h4 class="title"><a name="d0e24374"></a>Child Elements</h4></div></div><p>
       The <tt>Element</tt> class has two 
       methods (five total when you count overloaded
       variants separately)
       that only operate on the child elements of an element,
       and not on other content
       like processing intructions and text nodes. These are
       <tt>getChildren()</tt> and
      <tt>removeChildren()</tt>:
    </p><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">List&nbsp;</span><span class="methodname"><b>getChildren</b></span>();</code><br><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">List&nbsp;</span><span class="methodname"><b>getChildren</b></span>(<span class="methodparam"><span class="type">String&nbsp;</span><span class="parameter"><i>name</i></span></span>);</code><br><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">List&nbsp;</span><span class="methodname"><b>getChildren</b></span>(<span class="methodparam"><span class="type">String&nbsp;</span><span class="parameter"><i>name</i></span></span>, <span class="methodparam"><span class="type">Namespace&nbsp;</span><span class="parameter"><i>namespace</i></span></span>);</code><br><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">List&nbsp;</span><span class="methodname"><b>removeChildren</b></span>(<span class="methodparam"><span class="type">String&nbsp;</span><span class="parameter"><i>name</i></span></span>);</code><br><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">List&nbsp;</span><span class="methodname"><b>removeChildren</b></span>(<span class="methodparam"><span class="type">String&nbsp;</span><span class="parameter"><i>name</i></span></span>, <span class="methodparam"><span class="type">Namespace&nbsp;</span><span class="parameter"><i>namespace</i></span></span>);</code><p>
    These methods are similar to
    <tt>getContent()</tt> and
       <tt>removeContent()</tt>
       except that the lists returned only contain child elements,
       never other kinds of children like 
       comments and processing instructions.
       <sup>[<a name="d0e24462" href="#ftn.d0e24462">1</a>]</sup> The <tt>getChildren()</tt>
       methods simply ignore non-elements. For instance,
       the earlier <tt>TreePrinter</tt>
       example only considered elements.
       Consequently, 
       it could use the <tt>getChildren()</tt> 
       method instead of   <tt>getContent()</tt>:
   </p><div class="informalexample"><pre class="programlisting">  public static void process(Element element) {
    
    inspect(element);
    List content = element.getChildren();
    Iterator iterator = content.iterator();
    while (iterator.hasNext()) {
      Object o = iterator.next();  
      Element child = (Element) o;
      process(child);
    }
    
  }</pre></div><p>
    This eliminates one <tt>instanceof</tt> 
    check and one <tt>if</tt> block. This is not a huge
    savings, I admit; but the code is marginally more readable.
    However, because JDOM uses Java&#8217;s <tt>Object</tt>-based
    <tt>List</tt>
    class, you still have to cast all the items in the
    list
    <tt>getChildren()</tt> returns to
    <tt>Element</tt>. 
  </p><p>    
       The <tt>removeChildren()</tt> methods
       remove all the elements that match the specified
       name and namespace URI. If no namespace URI is given, then
       it removes elements with the given name in no
       namespace. 
       Other content&#8212;comments, processing instructions,
      text, etc.&#8212;is not touched. 
  </p><p>
    For example, this method recursively descends through an
    element, cutting out all the <tt>note</tt> elements. 
  </p><div class="informalexample"><pre class="programlisting">  public static void cutNotes(Element element) {
    
    List notes = element.getChildren("note");
    element.removeChildren(notes);
    // The element's children have changed so we have to call
    // getChildren() again
    List children = element.getChildren();
    Iterator iterator = children.iterator();
    while (iterator.hasNext()) {
      Object o = iterator.next();  
      Element child = (Element) o;
      cutNotes(child);
    }
    
  }</pre></div><p>
    It&#8217;s important to
    remember that when an element is removed, the entire element
    is removed, not just its start and end-tags. Any content
    inside the element is lost including, in this case, elements
    that aren&#8217;t named <tt>note</tt>.
  </p></div><div class="sect3"><div class="titlepage"><div><h4 class="title"><a name="d0e24525"></a>Single children</h4></div></div><p>
     Often you want to follow a very specific 
     path through a document. For instance, consider the XML-RPC
     request document in <a href="ch15s02.html#requestexample.xml" title="Example&nbsp;15.3.&nbsp;An XML-RPC request document">Example&nbsp;15.3</a>. 
     A program that reads this is
     probably primarily concerned with the content of the
     <tt>string</tt>
     element. 
   </p><div class="example"><a name="requestexample.xml"></a><p class="title"><b>Example&nbsp;15.3.&nbsp;An XML-RPC request document</b></p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;methodCall&gt;
  &lt;methodName&gt;getQuote&lt;/methodName&gt;
  &lt;params&gt;
    &lt;param&gt;
      &lt;value&gt;&lt;string&gt;RHAT&lt;/string&gt;&lt;/value&gt;
    &lt;/param&gt;
  &lt;/params&gt;
&lt;/methodCall&gt;
</pre></div><p>
     To get the <tt>string</tt>
     element, you&#8217;ll ask for the 
     <tt>string</tt> child
     element
      of the
      <tt>value</tt> child
     element
      of the
     <tt>param</tt> child
     element
      of the <tt>params</tt> child element of the root element.
     Rather than iterating through a list of all the child
     elements when there&#8217;s only one of each of these,
     you can ask for the one you want  directly using one of the 
     <tt>getChild()</tt> methods:
   </p><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">Element&nbsp;</span><span class="methodname"><b>getChild</b></span>(<span class="methodparam"><span class="type">String&nbsp;</span><span class="parameter"><i>name</i></span></span>);</code><br><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">Element&nbsp;</span><span class="methodname"><b>getChild</b></span>(<span class="methodparam"><span class="type">String&nbsp;</span><span class="parameter"><i>name</i></span></span>, <span class="methodparam"><span class="type">Namespace&nbsp;</span><span class="parameter"><i>namespace</i></span></span>);</code><br><p>
    For example,
  </p><div class="informalexample"><pre class="programlisting">Element root   = document.getRootElement();
Element params = root.getChild("params");
Element param  = params.getChild("param");
Element value  = param.getChild("value");
Element symbol = params.getChild("string");</pre></div><p>
    Or, more concisely,
  </p><div class="informalexample"><pre class="programlisting">Element symbol = document.getRootElement()
                  .getChild("params")
                  .getChild("param");
                  .getChild("value")
                  .getChild("string");</pre></div><p>
    This method has two nasty problems.
    The first is that it only returns the first such child. If there&#8217;s more
    than one child element with the specified name and namespace,
    you still only get the first one. 
    The second problem is that if there's no such child, then 
    <tt>getChild()</tt> returns null,
    thus leading to a <tt>NullPointerException</tt>.
     Since both of these are very real possibilities in many
    applications, including XML-RPC,
    you should normally prefer
    <tt>getChildren()</tt> unless
    you&#8217;ve used some form of schema or DTD to verify that
    there&#8217;s exactly one of each child you address with these
    methods. 
     <tt>getChildren()</tt> always returns a non-null list
     you can safely iterate through to process anywhere from zero to thousands of child
     elements.
  </p><p>
  Similarly, you can remove  a single named child element
  with
  one of the two <tt>removeChild()</tt> methods,
  each of which returns the removed <tt>Element</tt>
  in case you want to save it for later use:
</p><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">Element&nbsp;</span><span class="methodname"><b>removeChild</b></span>(<span class="methodparam"><span class="type">String&nbsp;</span><span class="parameter"><i>name</i></span></span>);</code><br><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">Element&nbsp;</span><span class="methodname"><b>removeChild</b></span>(<span class="methodparam"><span class="type">String&nbsp;</span><span class="parameter"><i>name</i></span></span>, <span class="methodparam"><span class="type">Namespace&nbsp;</span><span class="parameter"><i>namespace</i></span></span>);</code><p>
    The <tt>removeChild()</tt> method shares with 
    <tt>getChild()</tt> the problem of operating only on
    the first such element. However, after you&#8217;ve removed the
    first child, the second child is now the first.
    After you&#8217;ve removed that one, the original third child is
    now the first, and so on.
    Thus, there is one option that doesn&#8217;t work with 
    <tt>getChild()</tt>.
    You can simply call <tt>removeChild()</tt>
    repeatedly until it returns null, indicating that there was
    no further such child.
    For example, this code fragment removes
    all the immediate <tt>note</tt> children of the
    <tt>Element</tt> named <tt>element</tt>: 
  </p><div class="informalexample"><pre class="programlisting">while (element.removeChild("note") != null) ;</pre></div><p>
      However, unlike the earlier example with
      <tt>removeChildren()</tt>, this is not
      recursive and will not find <tt>note</tt> elements
      deeper in the tree.
    </p></div><div class="sect3"><div class="titlepage"><div><h4 class="title"><a name="d0e24684"></a>Getting and setting the text of an element</h4></div></div><p>
      Sometimes what you want is the text of an element.
      For this purpose, JDOM provides these four methods: 
      </p><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">String&nbsp;</span><span class="methodname"><b>getText</b></span>();</code><br><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">String&nbsp;</span><span class="methodname"><b>getTextTrim</b></span>();</code><br><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">String&nbsp;</span><span class="methodname"><b>getTextNormalize</b></span>();</code><br><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">Element&nbsp;</span><span class="methodname"><b>setText</b></span>(<span class="methodparam"><span class="type">String&nbsp;</span><span class="parameter"><i>text</i></span></span>);</code><p>
     The <tt>getText()</tt> method returns the
      PCDATA content of the element. The  <tt>getTextTrim()</tt> method
      returns pretty much the same content except that  all leading and
      trailing whitespace has been removed.
      The  <tt>getTextNormalize()</tt> method
     not only strips all leading and
      trailing whitespace; it also converts all runs of spaces to
      a single space.
      For example, consider this <tt>street</tt> element:
   </p><div class="informalexample"><pre class="programlisting">&lt;street&gt; 135  Airline  Highway &lt;/street&gt;</pre></div><p>
     For this element,
     <tt>getText()</tt> returns 
     &#8220;<tt>&nbsp;135&nbsp;&nbsp;Airline&nbsp;&nbsp;Highway&nbsp;</tt>&#8221;
     with the white space unchanged.
     However, <tt>getTextTrim()</tt>  returns 
     &#8220;<tt>135&nbsp;&nbsp;Airline&nbsp;&nbsp;Highway</tt>&#8221;,
     and 
      <tt>getTextNormalize()</tt> returns
      &#8220;<tt>135&nbsp;Airline&nbsp;Highway</tt>&#8221;.
      It&#8217;s an application level decision which one you want.
   </p><p>
    This is trickier than you might think at first
     glance.
     For instance, consider this <tt>street</tt> element:
   </p><div class="informalexample"><pre class="programlisting">
&lt;street&gt;135&lt;!-- The building doesn't actually have a number.
                It's next door to 133 --&gt;Airline Highway&lt;/street&gt;</pre></div><p>
     <tt>getText()</tt> returns &#8220;135Airline Highway&#8221;.
     It ignores comments and processing instructions as if they
     weren&#8217;t there. For the most part that seems reasonable.
   </p><p>
     Now consider this <tt>street</tt> element:
   </p><div class="informalexample"><pre class="programlisting">
&lt;street&gt;135 Airline Highway &lt;apartment&gt;2B&lt;/apartment&gt;&lt;/street&gt;</pre></div><p>
     <tt>getText()</tt> returns 
     &#8220;<tt>135&nbsp;Airline&nbsp;Highway&nbsp;</tt>&#8221;.
     The content in the child <tt>apartment</tt> element is completely lost.
     This is not really a good thing. (I argued about this in the
     JDOM group, but I lost.) Before you can reliably use any of
     the
     <tt>getText()</tt>/<tt>getTextTrim()</tt>/ <tt>getTextNormalize()</tt>
     methods you need to be very sure that the 
     element does not have any child elements. One way to do this
     is to test if the number of child elements is zero
     before invoking the text getter. For example,
   </p><div class="informalexample"><pre class="programlisting">if (element.getChildren().size() == 0) {
   String result = element.getText();
   // work with result &#8230;
}
else {
  // do something more complex &#8230;
}</pre></div><p>
      An alternative is to write your own method that recursively
      descends through the element, accumulating all its text.
      I&#8217;ll demonstrate this in the section on the
      <tt>Text</tt> class shortly. 
    </p><p>
    Do not use any of these getter methods unless you have
    first validated the document against a DTD or schema that
    explicitly requires the element only to contain 
    #PCDATA. Do not assume that you &#8220;know&#8221; that this
    is true in your domain without individually testing each
    document.
    Invariably, sooner or later, you will encounter a document
    that purports to adhere to the implicit schema, and indeed
    is very close to it, but does not quite match what you were
    assuming. Explicit validation is necessary.
  </p><p>
    The <tt>setText()</tt> method is a little
    less fraught. You can set the text content of any element to
    whatever text you desire. For example, this code fragment
    sets the text of the <tt>street</tt> element to 
    the string &#8220;3520 Airline Drive&#8221;:
  </p><div class="informalexample"><pre class="programlisting">street.setText("3520 Airline Drive");</pre></div><p>
   This completely wipes out any existing content the element
   has: child elements, descendants, comments, processing
   instructions, other text, etc. If you just want to append the
   string to the existing text, use the
   <tt>addContent()</tt> method instead.
  </p></div><div class="sect3"><div class="titlepage"><div><h4 class="title"><a name="d0e24842"></a>Getting child text</h4></div></div><p>
     One common pattern in XML documents is an element
     that contains only other elements, all 
     of which contain only PCDATA such as this <tt>channel</tt>
     element from 
     Slashdot&#8217;s RSS file:
   </p><div class="informalexample"><pre class="programlisting">&lt;channel&gt;
  &lt;title&gt;Slashdot: News for nerds, stuff that matters&lt;/title&gt;
  &lt;link&gt;http://slashdot.org/&lt;/link&gt;
  &lt;description&gt;News for nerds, stuff that matters&lt;/description&gt;
&lt;/channel&gt;</pre></div><p>
     Given such an element, JDOM provides six convenience methods
     for extracting the text, the trimmed text,
     and the normalized text from these child elements:
   </p><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">String&nbsp;</span><span class="methodname"><b>getChildText</b></span>(<span class="methodparam"><span class="type">String&nbsp;</span><span class="parameter"><i>name</i></span></span>);</code><br><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">String&nbsp;</span><span class="methodname"><b>getChildText</b></span>(<span class="methodparam"><span class="type">String&nbsp;</span><span class="parameter"><i>name</i></span></span>, <span class="methodparam"><span class="type">Namespace&nbsp;</span><span class="parameter"><i>namespace</i></span></span>);</code><br><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">String&nbsp;</span><span class="methodname"><b>getChildTextTrim</b></span>(<span class="methodparam"><span class="type">String&nbsp;</span><span class="parameter"><i>name</i></span></span>);</code><br><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">String&nbsp;</span><span class="methodname"><b>getChildTextTrim</b></span>(<span class="methodparam"><span class="type">String&nbsp;</span><span class="parameter"><i>name</i></span></span>, <span class="methodparam"><span class="type">Namespace&nbsp;</span><span class="parameter"><i>namespace</i></span></span>);</code><br><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">String&nbsp;</span><span class="methodname"><b>getChildTextNormalize</b></span>(<span class="methodparam"><span class="type">String&nbsp;</span><span class="parameter"><i>name</i></span></span>);</code><br><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">String&nbsp;</span><span class="methodname"><b>getChildTextNormalize</b></span>(<span class="methodparam"><span class="type">String&nbsp;</span><span class="parameter"><i>name</i></span></span>, <span class="methodparam"><span class="type">Namespace&nbsp;</span><span class="parameter"><i>namespace</i></span></span>);</code><p>
    For example, assuming the <tt>Element</tt>
    object <tt>channel</tt> represents the above
    <tt>channel</tt> element, this code fragment
    retrieves the content of the 
     <tt>title</tt>, 
     <tt>link</tt>, and
     <tt>description</tt> elements: 
  </p><div class="informalexample"><pre class="programlisting">String title = channel.getChildText("title");
String description = channel.getChildText("description");
String link = channel.getChildText("link");</pre></div><p>
    There are two things I really don&#8217;t like about these methods.
    First, like the <tt>getText/getTextTrim/getTextNormalize()</tt> 
    methods, they all fail unexpectedly and silently
    if any of the child elements unexpectedly contain child
    elements. For example, the above code fragment fails
    massively if Slashdot changes its format and begins
    distributing content like this instead: 
  </p><div class="informalexample"><pre class="programlisting">&lt;channel&gt;
  &lt;title&gt;
    &lt;trademark&gt;Slashdot&lt;/trademark&gt; 
    &lt;trademark&gt;News for nerds, stuff that matters&lt;/trademark&gt;
  &lt;/title&gt;
  &lt;link&gt;http://slashdot.org/&lt;/link&gt;
  &lt;description&gt;
    &lt;trademark&gt;News for nerds, stuff that matters&lt;/trademark&gt;
  &lt;/description&gt;
&lt;/channel&gt;</pre></div><p>
    Secondly, these methods fail unexpectedly and silently
    if the any of the child elements are repeated. For example, suppose instead the 
    <tt>channel</tt> element has three <tt>link</tt>
    children like this:
  </p><div class="informalexample"><pre class="programlisting">&lt;channel&gt;
  &lt;title&gt;Slashdot: News for nerds, stuff that matters&lt;/title&gt;
  &lt;link&gt;http://slashdot.org/&lt;/link&gt;
  &lt;link&gt;http://www.slashdot.org/&lt;/link&gt;
  &lt;link&gt;http://slashdot.com/&lt;/link&gt;
  &lt;description&gt;News for nerds, stuff that matters&lt;/description&gt;
&lt;/channel&gt;</pre></div><p>
    All three methods return the text from the first
    <tt>link</tt> element, and do not bother to inform
    the client program that there are more it may be interested in. 
  </p><p>
    As with <tt>getText/getTextTrim/getTextNormalize()</tt>,
    do not use any of these methods without first validating
    the document against a DTD or schema that
    explicitly requires the child elements only to contain 
    #PCDATA and  to occur exactly once each in each parent element. 
  </p></div><div class="sect3"><div class="titlepage"><div><h4 class="title"><a name="d0e24994"></a>Filters</h4></div></div><p>
      You can pass an <tt>org.jdom.filter.Filter</tt> object
      to the <tt>getContent()</tt> method to
      limit the content returned by the method. This interface,
      shown in <a href="ch15s02.html#CompactFilter.java" title="Example&nbsp;15.4.&nbsp;The JDOM Filter interface">Example&nbsp;15.4</a>, 
      determines whether an object can be added to, removed from,
      or included in a particular list.
      For the purposes of navigation and search, only the
      <tt>matches()</tt> method really matters.
      It determines whether or not any particular object is
      included in the <tt>List</tt> returned by 
      <tt>getContent()</tt>.
      The <tt>canAdd()</tt>
      and <tt>canRemove()</tt>
      methods test whether a particular object can be added to or
      removed from the list respectively. However, in the 
      two default implementations of this class in 
      <tt>ElementFilter</tt> and
      <tt>ContentFilter</tt>, both of these methods
      just call <tt>matches()</tt>.
    </p><div class="example"><a name="CompactFilter.java"></a><p class="title"><b>Example&nbsp;15.4.&nbsp;The JDOM Filter interface</b></p><pre class="programlisting">package org.jdom.filter;

public interface Filter {

  public boolean canAdd(Object o);
  public boolean canRemove(Object o);
  public boolean matches(Object o);
    
}
</pre></div><p>
      The <tt>org.jdom.filter</tt>
      package includes two implementations of this
      interface, <tt>ContentFilter</tt> (<a href="ch15s02.html#CompactContentFilter.java" title="Example&nbsp;15.5.&nbsp;The ContentFilter class">Example&nbsp;15.5</a>)
      and <tt>ElementFilter</tt>
      (<a href="ch15s02.html#CompactElementFilter.java" title="Example&nbsp;15.6.&nbsp;The ElementFilter class">Example&nbsp;15.6</a>). The 
      <tt>ContentFilter</tt> class allows you to specify
      the visibility of different JDOM node types like 
      <tt>ProcessingInstruction</tt>
      and  <tt>Text</tt>.
      <tt>ElementFilter</tt> allows you to 
      select elements with certain names or namespaces.
      Finally, you can write your own custom implementations
      that
      filter according to application-specific criteria. 
    </p><div class="example"><a name="CompactContentFilter.java"></a><p class="title"><b>Example&nbsp;15.5.&nbsp;The ContentFilter class</b></p><pre class="programlisting">package org.jdom.filter;

public class ContentFilter implements Filter {

  public static final int ELEMENT   = 1;
  public static final int CDATA     = 2;
  public static final int TEXT      = 4;
  public static final int COMMENT   = 8;
  public static final int PI        = 16;
  public static final int ENTITYREF = 32;
  public static final int DOCUMENT  = 64;

  protected int filterMask;

  public ContentFilter();
  public ContentFilter(boolean allVisible);
  public ContentFilter(int mask);
  
  public int  getFilterMask();
  public void setFilterMask(int mask);
  public void setDefaultMask();
  
  public void setDocumentContent();
  public void setElementContent();
  
  public void setElementVisible(boolean visible);
  public void setCDATAVisible(boolean visible)
  public void setTextVisible(boolean visible);
  public void setCommentVisible(boolean visible);
  public void setPIVisible(boolean visible);
  public void setEntityRefVisible(boolean visible);
  
  public boolean canAdd(Object o);
  public boolean canRemove(Object o);
  public boolean matches(Object o);

  
  public boolean equals(Object o);
  
}
</pre></div><p>
  For example, suppose your application only needs to concern
  itself with elements and text, but can completely skip all
  comments and processing instructions. You can simplify the
  code by using an appropriately configured 
  <tt>ContentFilter</tt>. The most convenient
  approach is to construct a filter that 
  filters out all nodes by passing false to the constructor,
  and then turn on only the types you want
  to let through like this:
</p><div class="informalexample"><pre class="programlisting">// Filter out everything by default
Filter filter = new ContentFilter(false);
// Allow elements through the filter
filter.setElementVisible(true);
// Allow text nodes through the filter
filter.setTextVisible(true);</pre></div><p>
  You&#8217;ll need to pass <tt>filter</tt>
  to <tt>getContent()</tt> every time you call
  it, like so:
</p><div class="informalexample"><pre class="programlisting">  Filter filter; // set up in constructor
   
  public static void process(Element element) {
   
    List children = element.getContent(filter);
    Iterator iterator = children.iterator();
    while (iterator.hasNext()) {
      Object o = iterator.next();
      if (o instanceof Element) {
        Element child = (Element) o;
        process(element);
      }
      else { // Due to filter, the only other possibility is Text
        Text text = (Text) o;
        handleText(text);
      }
    }
    
  }</pre></div><p>
  You normally want to allow elements to pass the filter, even
  if you&#8217;re only looking at other things like
  <tt>Text</tt>. In JDOM recursing through the
   <tt>Element</tt> objects is the only way to
   search a complete tree. If you filter out the
   <tt>Element</tt>s, you won&#8217;t be able to go more
   than one level deep from where you start.
</p><p>
     If you only want to select elements, you can use an 
     <tt>ElementFilter</tt> instead.
     This can be set up to select all elements,
     elements with a certain name, 
     elements in a certain namespace, 
     or elements with a certain
     name in a certain namespace.
   </p><div class="example"><a name="CompactElementFilter.java"></a><p class="title"><b>Example&nbsp;15.6.&nbsp;The ElementFilter class</b></p><pre class="programlisting">package org.jdom.filter;

public class ElementFilter implements Filter {

  protected String    name;
  protected Namespace namespace;
  
  public ElementFilter();
  public ElementFilter(String name);
  public ElementFilter(Namespace namespace);
  public ElementFilter(String name, Namespace namespace);

  public boolean canAdd(Object o);
  public boolean canRemove(Object o);
  public boolean matches(Object o);

  public boolean equals(Object o);
  
}
</pre></div><p>
      For example, this 
      code fragment uses an <tt>ElementFilter</tt> to 
      create a <tt>List</tt> named
      <tt>content</tt> that only contains
       XSLT elements:
    </p><div class="informalexample"><pre class="programlisting">Namespace xslt = Namespace.getNamespace(
                   "http://www.w3.org/1999/XSL/Transform");   
Filter filter = new ElementFilter(xslt);
List content = element.getContent(filter);</pre></div><p>
      Once again, however, this method proves to be less generally
      useful than the DOM equivalents because the
      <tt>getContent()</tt> method only returns
      children, not all descendants. For example, you couldn&#8217;t
      really use this to select the XSLT elements or the
      non-XSLT elements in a stylesheet because each type can 
      appear as children of the other type. 
    </p><p>
    Filters also work in the <tt>Document</tt>
    class, pretty much the same way they work in the
    <tt>Element</tt> class. For example, suppose
    you want to find all the processing instructions in the
    <tt>Document</tt> object <tt>doc</tt>
    outside the
    root element. This code fragment creates a
    <tt>List</tt> containing those:
  </p><div class="informalexample"><pre class="programlisting">// Filter out everything by default
Filter pisOnly = new ContentFilter(false);
// Allow processing instructions through the filter
pisOnly.setPIVisible(true);
// Get the content
List pis = doc.getContent(pisOnly);</pre></div><p>
      If you want something a little more useful, 
      like  a filter that selects all <tt>xml-stylesheet</tt> 
      processing instructions in the prolog only, then
      you need to write a custom implementation of
      <tt>Filter</tt>.
      <a href="ch15s02.html#StylesheetFilter.java" title="Example&nbsp;15.7.&nbsp;A filter for xml-stylesheet processing instructions in the prolog">Example&nbsp;15.7</a> demonstrates.
    </p><div class="example"><a name="StylesheetFilter.java"></a><p class="title"><b>Example&nbsp;15.7.&nbsp;A filter for xml-stylesheet processing instructions in the prolog</b></p><pre class="programlisting">import org.jdom.filter.Filter;
import org.jdom.*;
import java.util.List;


public class StylesheetFilter implements Filter {

  // This filter is read-only. Nothing can be added or removed.
  public boolean canAdd(Object o) {
    return false; 
  }
  
  public boolean canRemove(Object o) {
    return false;  
  }
  
  public boolean matches(Object o) {
   
    if (o instanceof ProcessingInstruction) {
      ProcessingInstruction pi = (ProcessingInstruction) o; 
      if (pi.getTarget().equals("xml-stylesheet")) {
        // Test to see if we're outside the root element
        if (pi.getParent() == null) {
          Document doc = pi.getDocument();
          Element root = doc.getRootElement();
          List content = doc.getContent();
          if (content.indexOf(pi) &lt; content.indexOf(root)) {
            // In prolog
            return true;
          }
        }
      }
    }
    return false;
   
  }
    
}
</pre></div></div><div class="sect3"><div class="titlepage"><div><h4 class="title"><a name="d0e25162"></a>Adding and removing children</h4></div></div><p>
     You can append any legal node to an <tt>Element</tt>
     using the 6-way overloaded
     <tt>addContent()</tt> methods:
   </p><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">Element&nbsp;</span><span class="methodname"><b>addContent</b></span>(<span class="methodparam"><span class="type">String&nbsp;</span><span class="parameter"><i>s</i></span></span>);</code><br><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">Element&nbsp;</span><span class="methodname"><b>addContent</b></span>(<span class="methodparam"><span class="type">Text&nbsp;</span><span class="parameter"><i>text</i></span></span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;throws&nbsp;<span class="exceptionname">IllegalAddException</span>;</code><br><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">Element&nbsp;</span><span class="methodname"><b>addContent</b></span>(<span class="methodparam"><span class="type">Element&nbsp;</span><span class="parameter"><i>element</i></span></span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;throws&nbsp;<span class="exceptionname">IllegalAddException</span>;</code><br><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">Element&nbsp;</span><span class="methodname"><b>addContent</b></span>(<span class="methodparam"><span class="type">ProcessingInstruction&nbsp;</span><span class="parameter"><i>instruction</i></span></span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;throws&nbsp;<span class="exceptionname">IllegalAddException</span>;</code><br><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">Element&nbsp;</span><span class="methodname"><b>addContent</b></span>(<span class="methodparam"><span class="type">EntityRef&nbsp;</span><span class="parameter"><i>ref</i></span></span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;throws&nbsp;<span class="exceptionname">IllegalAddException</span>;</code><br><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">Element&nbsp;</span><span class="methodname"><b>addContent</b></span>(<span class="methodparam"><span class="type">Comment&nbsp;</span><span class="parameter"><i>comment</i></span></span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;throws&nbsp;<span class="exceptionname">IllegalAddException</span>;</code><br><p>
     These methods append their argument to
     <tt>Element</tt>&#8217;s child list.
     Except for <tt>addContent(String)</tt>,
     they all throw an 
     <tt>IllegalAddException</tt> if the
     argument already has a parent element.
     (The <tt>addContent(String)</tt> method
     is just a convenience that creates a new
     <tt>Text</tt> node behind the scenes. It does not actually
     add a <tt>String</tt> object to the content list.)
     All return the
     same <tt>Element</tt> object that invoked them which
     allows for convenient chaining. 
   </p><p>
     These methods all add the new node to the end of the 
     <tt>Element</tt>&#8217;s list. If you want to insert
     a node in a different position, you&#8217;ll have to retrieve the
     <tt>List</tt> object itself.
     For example, this code fragment creates the same
     <tt>channel</tt> element by inserting all the child nodes
     in reverse order at the beginning of the list using the
     <tt>add(int index, Object o)</tt> method:
   </p><div class="informalexample"><pre class="programlisting">Element channel     = new Element("channel");
Element link        = new Element("link");
Element description = new Element("description");
Element title       = new Element("title");
title.setText("Slashdot");
link.setText("http://slashdot.org/");
description.setText("News for nerds");

List content = channel.getContent();
content.add(0, description);
content.add(0, link);
content.add(0, title);</pre></div><p>
     There are six <tt>removeContent()</tt>
     methods that remove a node from the list, wherever it resides:
   </p><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">Element&nbsp;</span><span class="methodname"><b>removeContent</b></span>(<span class="methodparam"><span class="type">Text&nbsp;</span><span class="parameter"><i>text</i></span></span>);</code><br><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">Element&nbsp;</span><span class="methodname"><b>removeContent</b></span>(<span class="methodparam"><span class="type">CDATA&nbsp;</span><span class="parameter"><i>cdata</i></span></span>);</code><br><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">Element&nbsp;</span><span class="methodname"><b>removeContent</b></span>(<span class="methodparam"><span class="type">Element&nbsp;</span><span class="parameter"><i>element</i></span></span>);</code><br><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">Element&nbsp;</span><span class="methodname"><b>removeContent</b></span>(<span class="methodparam"><span class="type">ProcessingInstruction&nbsp;</span><span class="parameter"><i>instruction</i></span></span>);</code><br><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">Element&nbsp;</span><span class="methodname"><b>removeContent</b></span>(<span class="methodparam"><span class="type">EntityRef&nbsp;</span><span class="parameter"><i>ref</i></span></span>);</code><br><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">Element&nbsp;</span><span class="methodname"><b>removeContent</b></span>(<span class="methodparam"><span class="type">Comment&nbsp;</span><span class="parameter"><i>comment</i></span></span>);</code><p>
     Of course, you can also retrieve the
     <tt>List</tt> from the <tt>Element</tt>
     with <tt>getContent()</tt> and remove elements 
     by position using the list&#8217;s <tt>remove()</tt> and
     <tt>removeAll()</tt> methods.
     However, doing so is relatively rare.
     Normally you have or can easily get 
     a  reference to the specific node you
     want to remove. For example,
     this deletes the first <tt>link</tt> child element
     of the <tt>channel</tt> element:
   </p><div class="informalexample"><pre class="programlisting">channel.removeContent(channel.getChild("link"));</pre></div><p>
     There is currently no method to remove all the content from
     an <tt>Element</tt>. Instead, just pass null to
    <tt>setContent()</tt>. That is,
   </p><div class="informalexample"><pre class="programlisting">element.setContent(null);</pre></div></div><div class="sect3"><div class="titlepage"><div><h4 class="title"><a name="d0e25409"></a>Parents and ancestors</h4></div></div><p>
     So far we&#8217;ve mostly focused on moving down the tree using
     methods that return children and recursion.
     However, JDOM can also move up the tree as well.
     <sup>[<a name="d0e25414" href="#ftn.d0e25414">2</a>]</sup>
     As with the child-returning methods, you can only jump one
     level at a time. That is, you can only get the parent
     directly. To get other ancestor elements, you need to ask
     for the parent&#8217;s parent, the parent of the parent&#8217;s parent,
     and so forth, until eventually you find an element whose
     parent is null, which is of course the root of the tree.
   </p><p>  
     Each <tt>Element</tt> object has 
     zero or one parents. If the <tt>Element</tt>
     is the root element of the document (or at least the root 
     of the tree in the event that the <tt>Element</tt> is
     not currently part of a <tt>Document</tt>), then this parent is
     null.
     Otherwise it is another <tt>Element</tt> object. 
     JDOM does not consider the owner document to be the parent
     of the root element.
     These three methods enable you to 
     determine whether or not an <tt>Element</tt> object
     represents a root element, and what its parent and owner
     document are:
   </p><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">Document&nbsp;</span><span class="methodname"><b>getDocument</b></span>();</code><br><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">boolean&nbsp;</span><span class="methodname"><b>isRootElement</b></span>();</code><br><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">Element&nbsp;</span><span class="methodname"><b>getParent</b></span>();</code><br><p>
    Unlike DOM <tt>Element</tt>s, JDOM 
    <tt>Element</tt>s are not irrevocably tied to
    their owner document. An <tt>Element</tt> may
    be in no document at all (in which case
    <tt>getDocument()</tt> returns null);
    and it may be moved from one document to another.
    However, JDOM  <tt>Element</tt>s cannot have more than one
    parent at a time. Before you can move an element to a different <tt>Document</tt>
    or a different position in the same <tt>Document</tt>, 
    you first have to detach it from its current parent by
    invoking the <tt>detach()</tt> method:
  </p><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">Element&nbsp;</span><span class="methodname"><b>detach</b></span>();</code><br><p>
   After you&#8217;ve called <tt>detach()</tt>, you are
   free to add the <tt>Element</tt> to any other
   <tt>Element</tt> or
   <tt>Document</tt>.
   For example, <a href="ch15s02.html#Linkset.java" title="Example&nbsp;15.8.&nbsp;Moving elements between documents">Example&nbsp;15.8</a> loads the 
   XML document at 
   <tt>http://www.slashdot.org/slashdot.rdf</tt>,
   detaches all the <tt>link</tt> elements from that
   document,
   and inserts them in a new <tt>linkset</tt> element,
   which it then outputs. Without the call to
   <tt>detach()</tt>, this would fail with an
   <tt>IllegalAddException</tt>.
 </p><div class="example"><a name="Linkset.java"></a><p class="title"><b>Example&nbsp;15.8.&nbsp;Moving elements between documents</b></p><pre class="programlisting">import org.jdom.*;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import java.io.IOException;
import java.util.*;


public class Linkset {
  
  public static void main(String[] args) {
    
    String url = "http://www.slashdot.org/slashdot.rdf";
    
    try {
      SAXBuilder parser = new SAXBuilder();
      
      // Parse the document
      Document document = parser.build(url); 
      Element oldRoot = document.getRootElement();
      Element newRoot = new Element("linkset");
      List content = oldRoot.getChildren();
      Iterator iterator = content.iterator();
      while (iterator.hasNext()) {
        Object next = iterator.next();
        Element element = (Element) next; 
        Element link = element.getChild("link", 
         Namespace.getNamespace(
         "http://my.netscape.com/rdf/simple/0.9/"));
        link.detach();
        newRoot.addContent(link);
      }

      XMLOutputter outputter = new XMLOutputter("  ", true);
      outputter.output(newRoot, System.out);
    }
    catch (JDOMException e) {
      System.out.println(url + " is not well-formed.");
    }
    catch (IOException e) { 
      System.out.println(
       "Due to an IOException, the parser could not read " + url
      ); 
    }
     
  } // end main

}
</pre></div><p>
   As usual, this only affects the JDOM
   <tt>Document</tt> object in memory. It has no
   effect on the original document read from the remote URL.
 </p><p>
   Another natural limitation is that an element cannot be its
   own parent or ancestor, directly or indirectly.
   Trying to add an element where it would violate this restriction
   throws an <tt>IllegalAddException</tt>.
   You can test whether one element is an ancestor of another
   using the <tt>isAncestor()</tt> method:
 </p><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">boolean&nbsp;</span><span class="methodname"><b>isAncestor</b></span>(<span class="methodparam"><span class="type">Element&nbsp;</span><span class="parameter"><i>element</i></span></span>);</code></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="d0e25563"></a>Attributes</h3></div></div><p>
      The <tt>Element</tt> 
      class has thirteen methods that read and write the values of the
      various attributes of the element. 
      Except for certain unusual cases (mostly involving attribute
      types)
      these thirteen methods are all that&#8217;s needed to handle attributes.
      You rarely need to concern yourself with the
      <tt>Attribute</tt> class directly.
    </p><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">Attribute&nbsp;</span><span class="methodname"><b>getAttribute</b></span>(<span class="methodparam"><span class="type">String&nbsp;</span><span class="parameter"><i>name</i></span></span>);</code><br><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">Attribute&nbsp;</span><span class="methodname"><b>getAttribute</b></span>(<span class="methodparam"><span class="type">String&nbsp;</span><span class="parameter"><i>name</i></span></span>, <span class="methodparam"><span class="type">Namespace&nbsp;</span><span class="parameter"><i>namespace</i></span></span>);</code><br><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">String&nbsp;</span><span class="methodname"><b>getAttributeValue</b></span>(<span class="methodparam"><span class="type">String&nbsp;</span><span class="parameter"><i>name</i></span></span>);</code><br><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">String&nbsp;</span><span class="methodname"><b>getAttributeValue</b></span>(<span class="methodparam"><span class="type">String&nbsp;</span><span class="parameter"><i>name</i></span></span>, <span class="methodparam"><span class="type">Namespace&nbsp;</span><span class="parameter"><i>namespace</i></span></span>);</code><br><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">String&nbsp;</span><span class="methodname"><b>getAttributeValue</b></span>(<span class="methodparam"><span class="type">String&nbsp;</span><span class="parameter"><i>name</i></span></span>, <span class="methodparam"><span class="type">String&nbsp;</span><span class="parameter"><i>default</i></span></span>);</code><br><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">String&nbsp;</span><span class="methodname"><b>getAttributeValue</b></span>(<span class="methodparam"><span class="type">String&nbsp;</span><span class="parameter"><i>name</i></span></span>, <span class="methodparam"><span class="type">Namespace&nbsp;</span><span class="parameter"><i>namespace</i></span></span>, <span class="methodparam"><span class="type">String&nbsp;</span><span class="parameter"><i>default</i></span></span>);</code><br><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">Element&nbsp;</span><span class="methodname"><b>setAttributes</b></span>(<span class="methodparam"><span class="type">List&nbsp;</span><span class="parameter"><i>attributes</i></span></span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;throws&nbsp;<span class="exceptionname">IllegalAddException</span>;</code><br><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">Element&nbsp;</span><span class="methodname"><b>setAttribute</b></span>(<span class="methodparam"><span class="type">String&nbsp;</span><span class="parameter"><i>name</i></span></span>, <span class="methodparam"><span class="type">String&nbsp;</span><span class="parameter"><i>value</i></span></span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;throws&nbsp;<span class="exceptionname">IllegalNameException</span>, <span class="exceptionname">IllegalDataException</span>;</code><br><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">Element&nbsp;</span><span class="methodname"><b>setAttribute</b></span>(<span class="methodparam"><span class="type">String&nbsp;</span><span class="parameter"><i>name</i></span></span>, <span class="methodparam"><span class="type">String&nbsp;</span><span class="parameter"><i>value</i></span></span>, <span class="methodparam"><span class="type">Namespace&nbsp;</span><span class="parameter"><i>namespace</i></span></span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;throws&nbsp;<span class="exceptionname">IllegalNameException</span>, <span class="exceptionname">IllegalDataException</span>;</code><br><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">Element&nbsp;</span><span class="methodname"><b>setAttribute</b></span>(<span class="methodparam"><span class="type">Attribute&nbsp;</span><span class="parameter"><i>attribute</i></span></span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;throws&nbsp;<span class="exceptionname">IllegalAddException</span>;</code><br><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">boolean&nbsp;</span><span class="methodname"><b>removeAttribute</b></span>(<span class="methodparam"><span class="type">String&nbsp;</span><span class="parameter"><i>name</i></span></span>, <span class="methodparam"><span class="type">String&nbsp;</span><span class="parameter"><i>value</i></span></span>);</code><br><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">boolean&nbsp;</span><span class="methodname"><b>removeAttribute</b></span>(<span class="methodparam"><span class="type">String&nbsp;</span><span class="parameter"><i>name</i></span></span>, <span class="methodparam"><span class="type">Namespace&nbsp;</span><span class="parameter"><i>namespace</i></span></span>);</code><br><code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">boolean&nbsp;</span><span class="methodname"><b>removeAttribute</b></span>(<span class="methodparam"><span class="type">Attribute&nbsp;</span><span class="parameter"><i>attribute</i></span></span>);</code><p> 
      These methods all follow the same basic rules.
      If an attribute is in a
      namespace,  specify the local name and namespace to access it.
      If the attribute is not in a namespace, then only use the
      name. 
      The setters must also specify the value to set the attribute
      to.
      The getters may optionally specify a default value used if
      the attribute is not found. 
      Alternately, you can use an
      <tt>Attribute</tt> object to replace all of
      these. Most of the time, however, strings are more
      convenient.
    </p><p>
   The <tt>getAttributeValue()</tt> methods all return the 
   <tt>String</tt> value of the
   attribute.
   If the attribute was read by a parser, the value will be
   normalized according to its type. However, attributes added
   in-memory with <tt>setAttribute(</tt>) 
   and its ilk will not be
   normalized. 
   The setter methods all return the
   <tt>Element</tt> object itself so they can be
   used in a chain.
   The remove methods all return a <tt>boolean</tt>,
   true if the attribute was removed, false if it wasn&#8217;t. 
 </p><p>
      As with most other constructs, JDOM checks all the 
      attributes you set for well-formedness and throws an
      exception if anything looks amiss.
      In particular,
    </p><div class="itemizedlist"><ul type="disc"><li><p>
          The local name must be a non-colonized name.
        </p></li><li><p>
          The value can&#8217;t contain any illegal characters like null
          or the byte order mark.
        </p></li><li><p>
          The attribute cannot be a namespace declaration such
          as <tt>xmlns</tt> or 
          <tt>xmlns:<i><tt>prefix</tt></i></tt>.
          (JDOM stores these separately.)
        </p></li></ul></div><p>
     For example, let&#8217;s suppose you want to process a RDDL
     document to find  resources related to a particular
     namespace URI.
     Each of these is enclosed in a
     <tt>rddl:resource</tt> element like this one from 
     the RDDL specification itself:
   </p><div class="informalexample"><pre class="programlisting">&lt;rddl:resource xlink:type="simple"
        xlink:title="RDDL Natures"
        xlink:role="http://www.rddl.org/"
        xlink:arcrole="http://www.rddl.org/purposes#directory"
        xlink:href="http://www.rddl.org/natures"
&gt;
&lt;div class="resource"&gt;
&lt;p&gt;It is anticipated that many related-resource natures will be 
   well known. A list of well-known natures may be found in the 
   RDDL directory &lt;a href=
   "http://www.rddl.org/natures"&gt;http://www.rddl.org/natures&lt;/a&gt;.
&lt;/p&gt;
&lt;/div&gt;
&lt;/rddl:resource&gt;</pre></div><p> 
    All the information required to locate the resources is included
    in the attributes of the <tt>rddl:resource</tt> elements.  
    The rest of the content in the document is relevant only to a
    browser showing the document to a human reader.
    Most software will want to read these <tt>rddl:resource</tt> elements
    and ignore the rest of the document.
    <a href="ch15s02.html#RDDLLister.java" title="Example&nbsp;15.9.&nbsp;Searching for RDDL resources">Example&nbsp;15.9</a>
    is such a program. It searches a document for
    related resources and
    outputs an HTML table containing their information. 
    The <tt>xlink:href</tt> attribute becomes an HTML
    hyperlink. The other URLs in the <tt>xlink:role</tt> and 
    <tt>xlink:arcrole</tt> attributes are purely descriptive 
    (like namespace URLs) and not
    intended to be resolved, so they&#8217;re merely output as plain text.
  </p><div class="example"><a name="RDDLLister.java"></a><p class="title"><b>Example&nbsp;15.9.&nbsp;Searching for RDDL resources</b></p><pre class="programlisting">import org.jdom.*;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import java.util.*;
import java.io.IOException;


public class RDDLLister {
  
  public final static Namespace XLINK_NAMESPACE = 
   Namespace.getNamespace("xl", "http://www.w3.org/1999/xlink");
  public final static String RDDL_NAMESPACE 
   = "http://www.rddl.org/";

  public static void main(String[] args) {
    
    if (args.length &lt;= 0) {
      System.out.println("Usage: java RDDLLister url");
      return; 
    }
    
    SAXBuilder builder = new SAXBuilder();
    
    try {
      // Prepare the output document
      Element html = new Element("html");
      Element body = new Element("body");
      Element table = new Element("table");
      html.addContent(body);
      body.addContent(table);
      Document output = new Document(html);
      
      // Read the entire document into memory
      Document doc = builder.build(args[0]);
      Element root = doc.getRootElement();
      processElement(root, table); 
      
      // Serialize the output document
      XMLOutputter outputter = new XMLOutputter("  ", true);
      outputter.output(output, System.out);
      
    }
    catch (JDOMException e) {
      System.err.println(e); 
    }
    catch (IOException e) {
      System.err.println(e); 
    }
        
  } // end main

  public static void processElement(Element input, Element output) {
    
    if (input.getName().equals("resource") 
     &amp;&amp; input.getNamespaceURI().equals(RDDL_NAMESPACE)) {
     
       String href    = input.getAttributeValue("href", XLINK_NAMESPACE);
       String title   = input.getAttributeValue("title", XLINK_NAMESPACE);
       String role    = input.getAttributeValue("role", XLINK_NAMESPACE);
       String arcrole = input.getAttributeValue("arcrole", XLINK_NAMESPACE);
     
       // Wrap this up in a table row
       Element tr = new Element("tr");
       
       Element titleCell = new Element("td");
       titleCell.setText(title);
       tr.addContent(titleCell);
       
       Element hrefCell = new Element("td");
       Element a = new Element("a");
       a.setAttribute("href", href);
       a.setText(href);
       hrefCell.addContent(a);
       tr.addContent(hrefCell);
       
       Element roleCell = new Element("td");
       roleCell.setText(role);
       tr.addContent(roleCell);
       
       Element arcroleCell = new Element("td");
       arcroleCell.setText(arcrole);
       tr.addContent(arcroleCell);
  
       output.addContent(tr);       
     
    }
    
    // Recurse
    List content = input.getContent();
    Iterator iterator = content.iterator();
    while (iterator.hasNext()) {
      Object o = iterator.next();
      if (o instanceof Element) {
        processElement((Element) o, output);   
      }
    } // end while
    
  }

}
</pre></div><p>
    The <tt>main()</tt> method builds the general
    outline of a well-formed HTML document, and then parses the
    input RDDL document in the usual fashion. It retrieves the
    root element with <tt>getRootElement()</tt>
    and then passes this root element and the
    <tt>table</tt> element to the
    <tt>processElement()</tt> method.
    </p><p>
   First <tt>processElement()</tt> checks to see if the element is a
   <tt>rddl:resource</tt> element. If it is, then 
   <tt>processElement()</tt> extracts the four XLink attributes using
   <tt>getAttributeValue()</tt>. Each of these is
   then inserted in a <tt>td</tt> element which is
   appended to a <tt>tr</tt> element which is added
   to the <tt>table</tt> element. The
   <tt>setAttribute()</tt> method 
   attaches an <tt>href</tt> attribute to the
   <tt>a</tt> element that defines the HTML link.
   Finally, the <tt>processElement()</tt> method
   is invoked on all child elements of the current elements to
   find any <tt>rddl:resource</tt> elements that are
   deeper down the tree.
    </p><p>
      Here&#8217;s the beginning of output from when I ran this program
      against the RDDL specification itself:
    </p><pre class="screen"><tt>D:\books\XMLJAVA&gt;</tt><b><tt>java RDDLLister http://www.rddl.org</tt></b>
<tt>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;html&gt;
  &lt;body&gt;
    &lt;table&gt;
      &lt;tr&gt;
        &lt;td&gt;RDDL Natures&lt;/td&gt;
        &lt;td&gt;
          &lt;a href="http://www.rddl.org/natures"&gt;
           http://www.rddl.org/natures&lt;/a&gt;
        &lt;/td&gt;
        &lt;td&gt;http://www.rddl.org/&lt;/td&gt;
        &lt;td&gt;http://www.rddl.org/purposes#directory&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;td&gt;RDDL Purposes&lt;/td&gt;
        &lt;td&gt;
          &lt;a href="http://www.rddl.org/purposes"&gt;
           http://www.rddl.org/purposes&lt;/a&gt;
        &lt;/td&gt;
        &lt;td&gt;http://www.rddl.org/&lt;/td&gt;
        &lt;td&gt;http://www.rddl.org/purposes#directory&lt;/td&gt;
      &lt;/tr&gt;
&#8230;</tt></pre></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.d0e24462" href="#d0e24462">1</a>] </sup>The name is a little misleading. An earlier beta called these methods 
       <tt>getChildElements()</tt>
       and <tt>removeChildElements()</tt>, much
       better names in my opinion.
       </p></div><div class="footnote"><p><sup>[<a name="ftn.d0e25414" href="#d0e25414">2</a>] </sup>Sideways movement, e.g. getting the previous or next sibling,
     is noticeably lacking. For this, you normally use 
     <tt>List</tt>
     and <tt>Iterator</tt>.</p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch15.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="ch15.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="ch15s03.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;15.&nbsp;The JDOM Model&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;The Attribute Class</td></tr></table></div><hr xmlns:dt="http://xsltsl.org/date-time"><table xmlns:dt="http://xsltsl.org/date-time" width="100%" summary="Cafe con Leche footer"><tr><td width="34%" align="left">Copyright 2001, 2002 Elliotte Rusty Harold</td><td width="32%" align="center"><a href="mailto:elharo@metalab.unc.edu">elharo@metalab.unc.edu</a></td><td width="34%" align="right">Last Modified 
December 10,
2002</td></tr><tr><td width="34%" align="left"></td><td width="32%" align="center"><a href="http://www.cafeconleche.org/">Up To Cafe con Leche</a></td><td width="34%" align="right"></td></tr></table></body></html>