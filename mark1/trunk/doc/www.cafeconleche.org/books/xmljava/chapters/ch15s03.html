<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>The Attribute Class</title><meta name="generator" content="DocBook XSL Stylesheets V1.52.2"><meta name="description" content="The complete text of Elliotte Rusty Harold's book Processing XML with Java.         published by Addison-Wesley, November 2002"><script language="javascript"><!--
/* Only sunsites are allowed to mirror this page and then
only with explicit, prior permission. For details,
send email to elharo@metalab.unc.edu */
if (location.protocol.toLowerCase().indexOf("file") != 0 ) { 
  if (0 > location.host.toLowerCase().indexOf("cafeconleche.org")
      && 0 > location.host.toLowerCase().indexOf("ibiblio.org")) {
    location.href="http://www.cafeconleche.org/books/xmljava/chapters/";
  }
} // --></script><link rel="home" href="index.html" title="Processing XML with Java"><link rel="up" href="ch15.html" title="Chapter&nbsp;15.&nbsp;The JDOM Model"><link rel="previous" href="ch15s02.html" title="The Element Class"><link rel="next" href="ch15s04.html" title="The Text Class"><link rel="preface" href="pr01.html" title="Preface"><link rel="preface" href="pr02.html" title="Acknowledgements"><link rel="chapter" href="ch01.html" title="Chapter&nbsp;1.&nbsp;XML for Data"><link rel="chapter" href="ch02.html" title="Chapter&nbsp;2.&nbsp;XML Protocols: XML-RPC and SOAP"><link rel="chapter" href="ch03.html" title="Chapter&nbsp;3.&nbsp;Writing XML with Java"><link rel="chapter" href="ch04.html" title="Chapter&nbsp;4.&nbsp;Converting Flat Files to XML"><link rel="chapter" href="ch05.html" title="Chapter&nbsp;5.&nbsp;Reading XML"><link rel="chapter" href="ch06.html" title="Chapter&nbsp;6.&nbsp;SAX"><link rel="chapter" href="ch07.html" title="Chapter&nbsp;7.&nbsp;The XMLReader Interface"><link rel="chapter" href="ch08.html" title="Chapter&nbsp;8.&nbsp;SAX Filters"><link rel="chapter" href="ch09.html" title="Chapter&nbsp;9.&nbsp;The Document Object Model"><link rel="chapter" href="ch10.html" title="Chapter&nbsp;10.&nbsp;Creating XML Documents with DOM"><link rel="chapter" href="ch11.html" title="Chapter&nbsp;11.&nbsp;The Document Object Model Core"><link rel="chapter" href="ch12.html" title="Chapter&nbsp;12.&nbsp;The DOM Traversal Module"><link rel="chapter" href="ch13.html" title="Chapter&nbsp;13.&nbsp;Output from DOM"><link rel="chapter" href="ch14.html" title="Chapter&nbsp;14.&nbsp;JDOM"><link rel="chapter" href="ch15.html" title="Chapter&nbsp;15.&nbsp;The JDOM Model"><link rel="chapter" href="ch16.html" title="Chapter&nbsp;16.&nbsp;XPath"><link rel="chapter" href="ch17.html" title="Chapter&nbsp;17.&nbsp;XSLT"><link rel="appendix" href="apa.html" title="Appendix&nbsp;A.&nbsp;XML APIs Quick Reference"><link rel="appendix" href="apb.html" title="Appendix&nbsp;B.&nbsp;SOAP 1.1 Schemas"><link rel="index" href="ix01.html" title="Index"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">The Attribute Class</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch15s02.html">Prev</a>&nbsp;</td><th width="60%" align="center">Chapter&nbsp;15.&nbsp;The JDOM Model</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="ch15s04.html">Next</a></td></tr></table><hr></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="d0e25928"></a>The Attribute Class</h2></div></div><p>
    The <tt>Attribute</tt> class, shown in 
    <a href="ch15s03.html#ZCompactAttribute.java" title="Example&nbsp;15.10.&nbsp;The JDOM Attribute class">Example&nbsp;15.10</a>, represents an
    attribute of an element, other than one that declares a
    namespace. Each attribute has these
    five basic properties.
  </p><div class="variablelist"><dl><dt><span class="term">Local name</span></dt><dd><p>A <tt>String</tt> accessible through the
      <tt>setName()</tt> and <tt>getName()</tt> methods</p></dd><dt><span class="term">Namespace</span></dt><dd><p>A <tt>Namespace</tt> object which encapsulates both the 
      namespace URI and prefix. This is
      accessible through the
      <tt>setNamespace()</tt> and
      <tt>getNamespace()</tt> methods.
      For all unprefixed attributes this is
      <tt>Namespace.NO_NAMESPACE</tt>. 
      The prefix, URI, and fully qualified name 
      are separately readable through 
      the <tt>getNamespaceURI()</tt>, 
       <tt>getNamespacePrefix()</tt>, 
       and <tt>getQualifiedName()</tt> convenience methods.
       </p></dd><dt><span class="term">Value</span></dt><dd><p>A <tt>String</tt> containing the
      attribute&#8217;s normalized value.
      This is accessible through the
      <tt>getValue()</tt> and
      <tt>setValue()</tt> methods. 
      The unnormalized value is not available.
      There are also convenience methods that read the attribute value
      as a <tt>double</tt>,
      <tt>float</tt>, <tt>long</tt>,
      <tt>int</tt>, or <tt>boolean</tt>.
      </p></dd><dt><span class="term">Parent</span></dt><dd><p>The  
      <tt>Element</tt> that possesses this
      <tt>Attribute</tt>.
      This is accessible through the 
      <tt>getParent()</tt> and
      <tt>setParent()</tt> methods.
      An  <tt>Attribute</tt> cannot have more than
      one parent.
      Before attaching a new parent <tt>Element</tt>,
      you must first
      invoke <tt>detach()</tt> to remove the <tt>Attribute</tt>
      from
      its current parent.
      </p></dd><dt><span class="term">Type</span></dt><dd><p>The <tt>Attribute</tt>&#8217;s type, as specified in the DTD.
      This is one of the ten named constants
      <tt>Attribute.CDATA_ATTRIBUTE</tt>,
      <tt>Attribute.ID_ATTRIBUTE</tt>,
      <tt>Attribute.IDREFS_ATTRIBUTE</tt>,
      <tt>Attribute.IDREFS_ATTRIBUTE</tt>,
      <tt>Attribute.ENUMERATED_ATTRIBUTE</tt>,
      and so forth. If the DTD does not specify the attribute&#8217;s type, then the
      type is set to <tt>Attribute.UNDECLARED_ATTRIBUTE</tt>.<sup>[<a name="d0e26068" href="#ftn.d0e26068">3</a>]</sup>
      The <tt>getAttributeType()</tt> 
      and <tt>setAttributeType()</tt> 
      methods access this property.
      </p></dd></dl></div><p>
    In addition, you can get the <tt>Document</tt> to
    which the <tt>Attribute</tt> belongs with the
    <tt>getDocument()</tt> method. However, this is not
    really independent of the <tt>Element</tt> to which
    the <tt>attribute</tt> is attached.
  </p><div class="example"><a name="ZCompactAttribute.java"></a><p class="title"><b>Example&nbsp;15.10.&nbsp;The JDOM Attribute class</b></p><pre class="programlisting">package org.jdom;

public class Attribute implements Serializable, Cloneable {

  public final static int UNDECLARED_ATTRIBUTE = 0;
  public final static int CDATA_ATTRIBUTE      = 1;
  public final static int ID_ATTRIBUTE         = 2;
  public final static int IDREF_ATTRIBUTE      = 3;
  public final static int IDREFS_ATTRIBUTE     = 4;
  public final static int ENTITY_ATTRIBUTE     = 5;
  public final static int ENTITIES_ATTRIBUTE   = 6;
  public final static int NMTOKEN_ATTRIBUTE    = 7;
  public final static int NMTOKENS_ATTRIBUTE   = 8;
  public final static int NOTATION_ATTRIBUTE   = 9;
  public final static int ENUMERATED_ATTRIBUTE = 10;

  protected           String    name;
  protected transient Namespace namespace;
  protected           String    value;
  protected           int       type;
  protected           Object    parent;

  protected Attribute();
  
  public Attribute(String name, String value, 
   Namespace namespace);
  public Attribute(String name, String value, int type, 
   Namespace namespace);
  public Attribute(String name, String value);
  public Attribute(String name, String value, int type);

  public Document     getDocument();
  public Element      getParent();
  protected Attribute setParent(Element parent);
  public Attribute    detach();
  public String       getName();
  public Attribute    setName(String name);
  public String       getQualifiedName();
  public String       getNamespacePrefix();
  public String       getNamespaceURI();
  public Namespace    getNamespace();
  public Attribute    setNamespace(Namespace namespace);
  public String       getValue();
  public Attribute    setValue(String value);
  public int          getAttributeType();
  public Attribute    setAttributeType(int type);
  
  public String        toString();
  public final boolean equals(Object o);
  public final int     hashCode();
  public Object        clone();

  public int     getIntValue() throws DataConversionException;
  public long    getLongValue() throws DataConversionException;
  public float   getFloatValue() throws DataConversionException;
  public double  getDoubleValue() throws DataConversionException;
  public boolean getBooleanValue() throws DataConversionException;

}
</pre></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in; font-family: Helvetica, Arial, sans"><h3 class="title">Tip</h3><p>
    One of the key things to remember when working with
    attributes, whether in JDOM or any other XML technology,
    is that unprefixed attributes are never in any namespace.
    In particular,
  </p><div class="orderedlist"><ol type="1"><li><p>
          Attributes are never in the default namespace.
        </p></li><li><p>
          An attribute is not in the same namespace as its parent element
          (except in the unusual case where it happens to have the same prefix as
          its parent element).
        </p></li></ol></div></div><p>
    90% or more of the time, you&#8217;re just going to use the 
    the <tt>set/get/removeAttribute()</tt>
    methods in the
    <tt>Element</tt> class rather than using the
    <tt>Attribute</tt> class. The only major case
    where 
    you really need to use the <tt>Attribute</tt> class
    directly is when the attribute type matters; for instance when
    you want to treat an ID-type attribute differently than a
    CDATA attribute or a NOTATIONS attribute differently than a
    NMTOKENS attribute. 
  </p><p>
    For example, consider attribute value normalization.
    When a parser reports an attribute value to the client
    application it adjusts the white space according to the
    attribute type. Attributes of type CDATA and undeclared
    attributes preserve all white space. However, white space is
    trimmed from the edges of all other attribute types, and all runs
    of white space are compressed to a single space. For
    instance, consider this <tt>fact</tt> start-tag:
  </p><div class="informalexample"><pre class="programlisting">&lt;fact source=" f21 f32   f33
 f122 f87 f893  "&gt;</pre></div><p>
    If the document&#8217;s DTD declares that the
    <tt>source</tt> attribute has type IDREFS,
    then the parser will report its value as 
    <tt>f21&nbsp;f32&nbsp;f33&nbsp;f122&nbsp;f87&nbsp;f893</tt>.
    On the other hand, if the DTD declares that it has type CDATA
    or does not assign it a type at all, then the parser will
    report its value with all the spaces and line breaks intact.
  </p><p>
    JDOM will accept whatever value the parser initially reports
    when the document is constructed. However, if attributes are
    added or their values modified later, then attributes will
    no longer be in normalized form. To fix this, we can write a method that
    searches a document for attributes whose type is
    something other than CDATA and normalizes their space.
    As usual the method is recursive:
  </p><div class="informalexample"><pre class="programlisting">  public void normalizeAttributes(Element element) {

    List attributes = element.getAttributes();
    Iterator iterator = attributes.iterator();
    while (iterator.hasNext()) {
      Attribute attribute = (Attribute) iterator.next();
      int type = attribute.getAttributeType();
      if (type != Attribute.CDATA_ATTRIBUTE 
       &amp;&amp; type != Attribute.UNDECLARED_ATTRIBUTE) {
         String oldValue = attribute.getValue();
         String newValue = Text.normalizeString(oldValue);
         attribute.setValue(newValue);
      }
    }
    
    List content = element.getContent();
    Iterator children = content.iterator();
    while (children.hasNext()) {
      Object o = children.next();
      if (o instanceof Element) {
        Element child = (Element) o;
        normalizeAttributes(child);
      }
    }
    
  }</pre></div><p>
   The actual normalization is performed by the static 
   <tt>Text.normalizeString()</tt> method from the
   <tt>Text</tt> class. 
  </p><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.d0e26068" href="#d0e26068">3</a>] </sup>In practice, SAX gets this
      wrong. It does not distinguish between CDATA type attributes and
      undeclared attributes. Thus when a SAX parser builds
      a JDOM <tt>Document</tt>, no attributes will have
      type <tt>Attribute.UNDECLARED_ATTRIBUTE</tt>.
      </p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch15s02.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="ch15.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="ch15s04.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">The Element Class&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;The Text Class</td></tr></table></div><hr xmlns:dt="http://xsltsl.org/date-time"><table xmlns:dt="http://xsltsl.org/date-time" width="100%" summary="Cafe con Leche footer"><tr><td width="34%" align="left">Copyright 2001, 2002 Elliotte Rusty Harold</td><td width="32%" align="center"><a href="mailto:elharo@metalab.unc.edu">elharo@metalab.unc.edu</a></td><td width="34%" align="right">Last Modified 
April 30,
2002</td></tr><tr><td width="34%" align="left"></td><td width="32%" align="center"><a href="http://www.cafeconleche.org/">Up To Cafe con Leche</a></td><td width="34%" align="right"></td></tr></table></body></html>