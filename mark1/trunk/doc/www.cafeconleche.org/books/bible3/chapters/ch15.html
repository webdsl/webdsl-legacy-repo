<html><head><title>XSL Transformations</title></head><body><div style="text-align: center">                [ <a href="../../../index.html">Cafe con Leche</a>          | <a href="../index.html">XML Bible Home Page</a>       | Order  from  <a href="http://www.amazon.com/exec/obidos/ASIN/0764549863/ref=nosim/cafeaulaitA/">amazon.com</a>  |  <a href="http://www.wiley.com/WileyCDA/WileyTitle/productCd-0764549863.html">Publisher Page</a> ]         </div><hr /><b><font face="Arial" size=2><p>In This Chapter</p></b></font><ul>	<li><p>What is XSL?</p></li>	<li><p>Overview of XSL transformations</p></li>	<li><p>Understanding XSL templates</p></li>	<li><p>Computing the value of a node with xsl:value-of</p></li>	<li><p>Processing multiple elements with xsl:for-each</p></li>	<li><p>Matching and selecting nodes with patterns</p></li>	<li><p>Understanding the default template rules</p></li>	<li><p>Attribute value templates</p></li>	<li><p>Deciding which output to include</p></li>	<li><p>Counting nodes</p></li>	<li><p>Sorting output</p></li>	<li><p>Modes</p></li>	<li><p>Output methods</p></li></ul><h1>XSL Transformations</h1><p>The Extensible Stylesheet Language (XSL) includes both a transformation language and a formatting language. Each of these is an XML application. The transformation language provides elements that define rules for how one XML document is transformed into another XML document. The transformed XML document may use the vocabulary of the original document, or it may use a completely different set of elements. In particular, it may use the elements defined by the second part of XSL, the formatting objects. This chapter discusses the transformation language half of XSL.</p><h2>What Is XSL?</h2><p>The transformation and formatting halves of XSL can function independently of each other. For instance, the transformation language can transform an XML document into a well-formed HTML file, and completely ignore XSL formatting objects. This is the style of XSL previewed in Chapter 5 and emphasized in this chapter. Furthermore, it&#146;s not absolutely required that a document written in XSL formatting objects be produced by using the transformation part of XSL on another XML document. For example, a program written in Java could read TeX or PDF files and translate them into XSL formatting objects.</p><p>In essence, XSL is two languages, not one. The first is a transformation language, the second a formatting language. The transformation language is useful independently of the formatting language. Its ability to move data from one XML representation to another makes it an important component of XML-based electronic commerce, electronic data interchange, metadata exchange, and any application that needs to convert between different XML representations of the same information. These uses are also united by their lack of concern with rendering data on a display for humans to read. They are purely about moving data from one computer system or program to another.</p><p>Consequently, many implementations of XSL focus exclusively on the transformation part and ignore the formatting objects. These are incomplete implementations, but nonetheless useful. Not all data must ultimately be rendered on a computer monitor or printed on paper.</p><dir><b><font face="Arial" size=1 color="#000080"><p>Cross-Reference</p></b></font><p>Chapter 16 discusses the XSL formatting language.</p></dir><dir><b><font face="Arial" size=1 color="#000080"><p>Caution</p></b></font><p>XSL is still under development. The language has changed radically in the past, and will almost certainly change again in the future. This chapter is based on the November 16, 1999, XSLT 1.0 Recommendation. Because XSLT is now an official Recommendation of the World Wide Web Consortium (W3C), I&#146;m hopeful that any changes that do occur will simply add to the existing syntax without invalidating style sheets that adhere to the 1.0 spec. Indeed, the W3C has begun work on XSLT 2.0, and it does seem likely that all legal XSLT 1.0 documents will still be legal XSLT 2.0 documents.</p><p>Not all software has caught up to the 1.0 Recommendation, however. In particular, Version 5.5 and earlier of Internet Explorer only implement a very old working draft of XSLT that looks almost nothing like the finished standard. You should not expect most of the examples in this chapter to work with these versions of IE, even after substantial tweaking. Internet Explorer 6.0 does implement something close to XSLT 1.0. However, there are still some bugs and areas where Microsoft did not follow the standard.</p></dir><h2>Overview of XSL Transformations</h2><p>In an XSL transformation, an XSLT processor reads both an XML document and an XSLT style sheet. The processor applies the instructions in the XSLT style sheet to the data in the input document to generate a new XML document or fragment thereof. Most processors can also output HTML. With some effort, most XSLT processors can also be made to output essentially arbitrary text, though XSLT is designed primarily for XML-to-XML and XML-to-HTML transformations.</p><h2>Trees</h2><p>As you learned in Chapter 6, every well-formed XML document forms a tree. A tree is a data structure composed of connected nodes beginning with a top node called the root. The root is connected to its child nodes, each of which is connected to zero or more children of its own, and so forth. A diagram of a tree looks much like a genealogical descendant chart that lists the descendants of a single ancestor. One useful property of a tree is that each node and its children also form a tree. Thus, a tree is a hierarchical structure of trees in which each tree is built out of smaller trees.</p><p>For the purposes of XSLT, elements, attributes, namespaces, processing instructions, comments, and parsed character data are counted as nodes. Furthermore, the document itself is the root of the tree. Thus, XSLT processors model an XML document as a tree that contains seven kinds of nodes:</p><ul>	<li><p>The root</p></li>	<li><p>Elements</p></li>	<li><p>Text</p></li>	<li><p>Attributes</p></li>	<li><p>Namespaces</p></li>	<li><p>Processing instructions</p></li>	<li><p>Comments</p></li></ul><p>The DTD and document type declaration are specifically not included in this tree. However, a DTD may add default attribute values to some elements, which then become additional attribute nodes in the tree. Entity and character references are resolved into their replacement text. They are not counted as separate kinds of nodes themselves. Similarly, CDATA sections merely become part of text nodes. They are not treated differently than any other text.</p><p>For example, consider the XML document in Listing 15-1. This shows part of the periodic table of the elements. I&#146;ll be using this as an example in this chapter. The root <code>PERIODIC_TABLE</code> element contains <code>ATOM</code> child elements. Each <code>ATOM</code> element contains several child elements providing the atomic number, atomic weight, symbol, boiling point, and so forth. A <code>UNITS</code> attribute specifies the units for those elements that have units.</p><dir><b><font face="Arial" size=1 color="#000080"><p>Note</p></b></font><code><p>ELEMENT</code> would be a more appropriate name here than <code>ATOM</code>. However, writing about <code>ELEMENT</code> elements and trying to distinguish between chemical elements and XML elements might create confusion. Thus, for the purposes of this chapter, <code>ATOM</code> seemed like the more legible option.</p></dir><font face="Arial"><p>Listing 15-1: An XML Periodic Table with Two Atoms: Hydrogen and Helium</p></font><pre>&lt;?xml version="1.0"?&gt;&lt;?xml-stylesheet type="application/xml" href="15-2.xsl"?&gt;&lt;PERIODIC_TABLE&gt;  &lt;ATOM STATE="GAS"&gt;    &lt;NAME&gt;Hydrogen&lt;/NAME&gt;    &lt;SYMBOL&gt;H&lt;/SYMBOL&gt;    &lt;ATOMIC_NUMBER&gt;1&lt;/ATOMIC_NUMBER&gt;    &lt;ATOMIC_WEIGHT&gt;1.00794&lt;/ATOMIC_WEIGHT&gt;    &lt;BOILING_POINT UNITS="Kelvin"&gt;20.28&lt;/BOILING_POINT&gt;    &lt;MELTING_POINT UNITS="Kelvin"&gt;13.81&lt;/MELTING_POINT&gt;    &lt;DENSITY UNITS="grams/cubic centimeter"&gt;      &lt;!-- At 300K, 1 atm --&gt;      0.0000899    &lt;/DENSITY&gt;  &lt;/ATOM&gt;  &lt;ATOM STATE="GAS"&gt;    &lt;NAME&gt;Helium&lt;/NAME&gt;    &lt;SYMBOL&gt;He&lt;/SYMBOL&gt;    &lt;ATOMIC_NUMBER&gt;2&lt;/ATOMIC_NUMBER&gt;    &lt;ATOMIC_WEIGHT&gt;4.0026&lt;/ATOMIC_WEIGHT&gt;    &lt;BOILING_POINT UNITS="Kelvin"&gt;4.216&lt;/BOILING_POINT&gt;    &lt;MELTING_POINT UNITS="Kelvin"&gt;0.95&lt;/MELTING_POINT&gt;    &lt;DENSITY UNITS="grams/cubic centimeter"&gt;&lt;!-- At 300K --&gt;      0.0001785    &lt;/DENSITY&gt;  &lt;/ATOM&gt;&lt;/PERIODIC_TABLE&gt;</pre><dir><b><font face="Arial" size=1 color="#000080"><p>Note</p></b></font><p>You can find a much longer version of Listing 15-1 that includes all elements through atomic number 110 <code>http://www.cafeconleche.org/examples/periodic_table/allelements.xml</code>. This longer version is used in several of the examples in this chapter.</p></dir><p>Figure 15-1 displays a tree diagram of this document. It begins at the top with the root node (not the same as the root element), which contains two child nodes, the <code>xml-stylesheet</code> processing instruction and the root element <code>PERIODIC_TABLE</code>. (The XML declaration is not directly visible to the XSLT processor and is not included in the tree the XSLT processor operates on.) The <code>PERIODIC_TABLE</code> element contains five child nodes. Two of them are obvious, the two <code>ATOM</code> elements. The other three are almost invisible. These are the boundary white-space-text nodes between <code>&lt;PERIODIC_TABLE&gt;</code> and <code>&lt;ATOM STATE="GAS"&gt;</code>, between <code>&lt;/ATOM&gt;</code> and <code>&lt;ATOM STATE="GAS"&gt;</code>, and between <code>&lt;/ATOM&gt;</code> and <code>&lt;/PERIODIC_TABLE&gt;</code>. XSLT can see all the white space between tags. It&#146;s up to the style sheet to decide whether or not boundary white space is significant and should be preserved. Figure 15-1 is drawn under the assumption that these nodes aren't important, and thus omits them. However, other applications might treat them as significant.</p><p>Each <code>ATOM</code> element has an attribute node for its <code>STATE</code> attribute, text nodes for all the white space between tags, and a variety of child element nodes. Each child element contains a node for its text content, as well as nodes for any attributes, comments, and processing instructions it possesses. Notice, in particular, that many nodes are something other than elements. There are nodes for text, attributes, comments, namespaces, and processing instructions. Unlike CSS, XSL is not limited to working only with whole elements. It has a much more granular view of a document that enables you to base styles on comments, attributes, processing instructions, element content, and more.</p><p><img src="picture1.jpg"></p><p>Figure 15-1: Listing 15-1 as a tree diagram</p><p>XSLT operates by transforming one XML tree into another XML tree. More precisely, an XSLT processor accepts as input a tree represented as an XML document and produces as output a new tree, also represented as an XML document or document fragment. Consequently, the transformation part of XSL is also called the tree construction part. The XSL transformation language contains operators for selecting nodes from the tree, reordering the nodes, and outputting nodes. If one of these nodes is an element node, it may be an entire tree itself. Remember that all these operators, both for input and output, are designed for operation on a tree.</p><p>The input must be an XML document. XSLT cannot transform from non-XML formats such as PDF, TeX, Microsoft Word, PostScript, MIDI, or others. HTML and SGML are borderline cases because they're so close to XML. XSLT can work with HTML and SGML documents that satisfy XML&#146;s well-formedness rules. However, XSLT cannot handle the wide variety of non-well-formed HTML and SGML that you encounter on most web sites and document production systems. XSLT is not a general-purpose language for transforming arbitrary data.</p><p>Most of the time, the output of an XSLT transformation is also an XML document. However, it can also be a result tree fragment that could be used as an external parsed entity in another XML document. (That is, it would be a well-formed XML document if it were enclosed in a single root element.) In other words, the output may not necessarily be a well-formed XML document, but it will at least be a plausible part of a well-formed XML document.</p><dir><b><font face="Arial" size=1 color="#000080"><p>Tip</p></b></font><p>The <code>xsl:output</code> element and <code>disable-output-escaping</code> attribute discussed later in this chapter loosen this restriction somewhat.</p></dir><p>Most XSLT processors also support output as HTML and/or raw text, although the specification does not require them to do so. To some extent, this allows you to transform to non-XML formats such as TeX, RTF, or PostScript. However, XSLT is not designed to make these transformations easy. It is designed for XML-to-XML transformations. If you need a non-XML output format, it will probably be easier to use XSLT to transform the XML to an intermediate XML format such as XSL-FO, and then use additional, non-XSLT software to transform that into the format you want.</p><h2>XSLT style sheet documents</h2><p>An XSLT document contains <i>template rules</i>. A template rule has a pattern specifying the nodes it matches and a template to be instantiated and output when the pattern is matched. When an XSLT processor transforms an XML document under the control of an XSLT style sheet, it walks the XML document tree starting at the root, and following an order defined by the template rules. As the processor visits each node in the XML document, it compares that node with the pattern of each template rule in the style sheet. When it finds a node that matches a template rule&#146;s pattern, it outputs the rule's template. This template generally includes some markup, new data, data copied out of the source XML document, as well as some directions about which nodes to process next.</p><p>XSLT uses XML to describe these rules, templates, and patterns. The root element of the XSLT document is either a <code>stylesheet</code> or a <code>transform</code> element in the <code>http://www.w3.org/1999/XSL/Transform</code> namespace. By convention, this namespace is mapped to the <code>xsl</code> prefix, but you&#146;re free to pick another prefix if you prefer. In this chapter, I always use the <code>xsl</code> prefix. From this point forward, it should be understood that the prefix <code>xsl</code> is mapped to the <code>http://www.w3.org/1999/XSL/Transform</code> namespace.</p><dir><b><font face="Arial" size=1 color="#000080"><p>Tip</p></b></font><p>If you get the namespace URI wrong, either by using a URI from an older draft of the specification, such as <code>http://www.w3.org/TR/WD-xsl</code>, or simply by making a typo in the normal URI, the XSLT processor will output the style sheet document itself instead of the transformed input document. This is the result of the interaction between several obscure sections of the XSLT 1.0 specification. The details aren&#146;t important. What is important is that this very unusual behavior looks very much like a bug in the processor if you aren&#146;t familiar with it. If you are familiar with it, fixing it is trivial; just correct the namespace URI to <code>http://www.w3.org/1999/XSL/Transform</code>.</p></dir><p>Each template rule is an <code>xsl:template</code> element. The pattern of the rule is placed in the <code>match</code> attribute of the <code>xsl:template</code> element. The output template is the content of the <code>xsl:template</code> element. All instructions in the template for doing things, such as selecting parts of the input tree to include in the output tree, are performed by XSLT elements. These are identified by the <code>xsl:</code> prefix on the element names. Elements that do not have an <code>xsl:</code> prefix are part of the result tree.</p><p>Listing 15-2 shows a very simple XSLT style sheet with two template rules. The first template rule matches the root element <code>PERIODIC_TABLE</code>. It replaces this element with an <code>html</code> element. The contents of the <code>html</code> element are the results of applying the other templates in the document to the contents of the <code>PERIODIC_TABLE</code> element.</p><p>The second template matches <code>ATOM</code> elements. It converts each <code>ATOM</code> element in the input document into a <code>P</code> element in the output document. The <code>xsl:apply-templates</code> rule inserts the text of the matched source element into the output document. Thus, the contents of a <code>P</code> element will be the text (but not the markup) contained in the corresponding <code>ATOM</code> element.</p><p>The <code>xsl:stylesheet</code> root element must have a <code>version</code> attribute with the value <code>1.0</code>. It will normally also have an <code>xmlns:xsl</code> namespace declaration that binds the prefix <code>xsl</code> to the  <code>http://www.w3.org/1999/XSL/Transform</code> namespace URI.</p><font face="Arial"><p>Listing 15-2: An XSLT Style Sheet for the Periodic Table with Two Template Rules</p></font><pre>&lt;?xml version="1.0"?&gt;&lt;xsl:stylesheet version="1.0"           xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;  &lt;xsl:template match="PERIODIC_TABLE"&gt;    &lt;HTML&gt;      &lt;xsl:apply-templates/&gt;    &lt;/HTML&gt;  &lt;/xsl:template&gt;  &lt;xsl:template match="ATOM"&gt;    &lt;P&gt;      &lt;xsl:apply-templates/&gt;    &lt;/P&gt;  &lt;/xsl:template&gt;&lt;/xsl:stylesheet&gt;</pre><p>The <code>xsl:transform</code> element can be used in place of <code>xsl:stylesheet</code> if you prefer. This is an exact synonym with the same syntax, semantics, and attributes, as in this example:</p><pre>&lt;?xml version="1.0"?&gt;&lt;xsl:transform version="1.0"          xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;  &lt;!-- templates go here --&gt;&lt;/xsl:transform&gt;</pre><p>In this book, I will stick to <code>xsl:stylesheet</code>.</p><h2>Where does the XML transformation happen?</h2><p>There are three primary ways to transform XML documents into other formats, such as HTML, with an XSLT style sheet:</p><ol>	<li><p>The XML document and associated style sheet are both served to the client (web browser), which then transforms the document as specified by the style sheet and presents it to the user.</p></li>	<li><p>The server applies an XSLT style sheet to an XML document to transform it to some other format (generally HTML) and sends the transformed document to the client (web browser).</p></li>	<li><p>A third program transforms the original XML document into some other format (often HTML) before the document is placed on the server. Both server and client only deal with the transformed document.</p></li></ol><p>Each of these three approaches uses different software, although they all use the same XML documents and XSLT style sheets. A typical web server sending XML documents to Mozilla is an example of the first approach. A servlet-compatible web server using Apache&#146;s Cocoon (<code>http://cocoon.apache.org</code>) is an example of the second approach. A human using Michael Kay&#146;s command-line Saxon program (<code>http://saxon.sourceforge.net</code>) to transform XML documents to HTML documents, then placing the HTML documents on a web server is an example of the third approach. However, these all use the same XSLT language.</p><p>In this chapter, I emphasize the third approach, primarily because at the time of this writing, specialized converter programs, such as Michael Kay's Saxon and the Gnome Project&#146;s xsltproc (<code>http://xmlsoft.org/XSLT.html</code>), provide the most complete and accurate implementations of the XSLT specification. Furthermore, this approach offers the broadest compatibility with legacy web browsers and servers, whereas the first approach requires a more recent browser than many users use, and the second approach requires special web server software. In practice, though, requiring a different server is not nearly as onerous as requiring a particular client. You, yourself, can install your own special server software; but you cannot rely on your visitors to install particular client software.</p><h2>Using xsltproc</h2><p>xsltproc is a character mode application written in C. It was originally developed for Linux, but has been ported to most common UNIXes, Windows, and Mac OS X. It may be installed by default on a few Linux distros, but most users will need to download it from <code>http://xmlsoft.org/XSLT/downloads.html</code> first. You&#146;ll also need to install libxml, the XML parser it depends on. You can download this from <code>http://www.xmlsoft.org/downloads.html</code>.</p><dir><b><font face="Arial" size=1 color="#000080"><p>Tip</p></b></font><p>On Windows, you&#146;ll also need to install the iconv library, which you can get from the same site. All three libraries are distributed as zip files. When unzipped, these archives each contain a lib and util directory. Simply copy the complete contents of all three lib and util directories to your C:\WINDOWS or C:\WINNT directory.</p><b><font face="Arial" size=1 color="#000080"><p>Note</p></b></font><p>Although I primarily use xsltproc in this chapter, the examples should work with Saxon, Xalan, or any other XSLT processor that implements the XSLT 1.0 Recommendation. Some processors may produce slightly different output that does not affect the final results, especially when outputting HTML. For example, they may indent the tags a little differently, or add a <code>META</code> tag or two to the <code>HEAD</code>. Normally these details aren&#146;t very relevant, but if they concern you, you can control them using the <code>xsl:output</code> instruction discussed toward the end of this chapter.</p></dir><p>After everything&#146;s installed in the right locations, you run xsltproc by typing the following at the shell prompt or in a DOS window:</p><pre>C:\&gt; xsltproc stylesheet.xsl document.xml</pre><p>The first argument is the style sheet. The second argument is the XML document to transform. You can add additional filenames or URLs to transform more than one document. By default, the output is printed in the same shell prompt/DOS window where you launched the processor. To redirect the output into a file, you can use the <code>-o</code> option. For example, this command applies the style sheet in Listing 15-2 to the document in Listing 15-1, and puts the output in the file 15-3.html:</p><pre>C:\&gt; xsltproc -o 15.3.html 15-2.xsl 15-1.xml</pre><p>Listing 15-2 transforms input documents to well-formed HTML files, as discussed in Chapter 6. However, you can transform from any XML application to any other as long as you can write a style sheet to support the transformation. For example, you can imagine a style sheet that transforms from Vector Markup Language (VML) documents to Scalable Vector Graphics (SVG) documents:</p><pre>% xsltproc -o pinktriangle.svg VMLToSVG.xsl pinktriangle.vml</pre><p>Most other command-line XSLT processors behave similarly, though of course they'll have different command-line arguments and options.</p><p>Listing 15-3 shows the output of running Listing 15-1 through xsltproc with the XSLT style sheet in Listing 15-2. Notice that xsltproc does not attempt to clean up the HTML it generates, which has a lot of white space. This is not important because ultimately you want to view the file in a web browser that trims white space. Figure 15-2 shows Listing 15-3 loaded into Netscape Navigator 3.0. Because Listing 15-3 is standard HTML, you don&#146;t need an XML-capable browser to view it.</p><font face="Arial"><p>Listing 15-3: The HTML Produced by Applying the Style Sheet in Listing 15-2 to the XML in Listing 15-1</p></font><pre>&lt;HTML&gt;  &lt;P&gt;    Hydrogen    H    1    1.00794    20.28    13.81      0.0000899  &lt;/P&gt;  &lt;P&gt;    Helium    He    2    4.0026    4.216    0.95      0.0001785  &lt;/P&gt;&lt;/HTML&gt;</pre><p><img src="Image8.gif" width=384 height=287></p><p>Figure 15-2: The page produced by applying the style sheet in Listing 15-2 to the XML document in Listing 15-1.</p><h2>Browser display of XML files with XSLT style sheets</h2><p>Instead of preprocessing the XML document, you can send the client both the XML file and the XSLT file that describes how to render it. The client is responsible for applying the style sheet to the document and rendering it accordingly. This is more work for the client, but places much less load on the server. In this case, the XSLT style sheet must transform the document into an XML vocabulary the client understands. HTML is a likely choice, though other XML formats are options as well.</p><p>Attaching an XSLT style sheet to an XML document is easy. Simply insert an <code>xml-stylesheet</code> processing instruction in the prolog immediately after the XML declaration. This processing instruction should have a <code>type</code> attribute with the value <code>application/xml</code> and an <code>href</code> attribute whose value is a URL pointing to the style sheet, as shown here:</p><pre>&lt;?xml version="1.0"?&gt;&lt;?xml-stylesheet type="application/xml" href="15-2.xsl"?&gt;</pre><p>This is also how you attach a CSS style sheet to a document. The only difference here is that the <code>type</code> attribute has the value <code>application/xml</code> instead of <code>text/css</code>.</p><dir><b><font face="Arial" size=1 color="#000080"><p>Note</p></b></font><p>In the not too distant future, the more specific MIME media type <code>application/xslt+xml</code> will be available to distinguish XSLT documents from all other XML documents. After browsers are revised to support this, you will be able to write the <code>xml-stylesheet</code> processing instruction like this instead:</p><pre><p>&lt;?xml-stylesheet type="application/xslt+xml"                  href="15-2.xsl"?&gt;</pre></dir><p>Internet Explorer&#146;s XSLT support differs from the XSLT 1.0 Recommendation in several ways. Most importantly, it expects the nonstandard MIME media type <code>text/xsl</code> in the <code>xml-stylesheet</code> processing instruction rather than <code>application/xml</code>. Otherwise, Internet Explorer 6.0 has reasonable, though imperfect, support for XSLT.</p><p>Internet Explorer 5.0 and 5.5 do not support XSLT 1.0 out of the box. They support an earlier, beta version of XSLT with some Microsoft extensions. You can tell the difference by looking at the namespace URI. Style sheets written for IE5 use the URI <code>http://www.w3.org/TR/WD-xsl</code>. Style sheets written for all other processors use the URI <code>http://www.w3.org/1999/XSL/Transform</code>. To work with XML, it really helps to upgrade to Internet Explorer 6.0 or later. If you must stick with IE 5.5 or earlier, you can upgrade the MSXML parser instead. Download MSXML 3.0 from <code>http://msdn.microsoft.com/library/default.asp?url=/downloads/list/xmlgeneral.asp</code>. This installer does not automatically replace the earlier, nonstandard-compliant MSXML 2.5 that is bundled. To replace the old version, you also have to download and run a separate program called xmlinst.exe, which you can get from the same page where you found MSXML 3.0. Otherwise, you&#146;ll still be stuck with the old, out-of-date beta version of XSLT.</p><dir><b><font face="Arial" size=1 color="#000080"><p>Caution</p></b></font><p>MSXML 4.0 is also available but cannot replace the MSXML 2.5 bundled with Internet Explorer 5.5 and earlier. If you're using Internet Explorer 5.x, you should use MSXML 3.0, not an earlier, nor a later, version.</p></dir><p>Even once this is done, there are still some bugs and areas where Microsoft did not follow the specification, so this is not quite a complete implementation of XSLT 1.0. If you find that something in this chapter doesn&#146;t work in Internet Explorer, please complain to Microsoft, not to me.</p><h2>XSL Templates</h2><p>Template rules defined by <code>xsl:template</code> elements are the most important part of an XSLT style sheet. These associate particular output with particular input. Each <code>xsl:template</code> element has a <code>match</code> attribute that specifies which nodes of the input document the template is instantiated for.</p><p>The content of the <code>xsl:template</code> element is the template to be instantiated. A template may contain both text, which will appear literally in the output document, and XSLT instructions that copy data from the input XML document to the result. Because all XSLT instructions are in the <code>http://www.w3.org/1999/XSL/Transform</code> namespace, it&#146;s easy to distinguish between the elements that are literal data to be copied to the output and instructions. For example, here is a template that matches the root node of the input tree:</p><pre>&lt;xsl:template match="/"&gt;  &lt;HTML&gt;    &lt;HEAD&gt;    &lt;/HEAD&gt;    &lt;BODY&gt;    &lt;/BODY&gt;  &lt;/HTML&gt;&lt;/xsl:template&gt;</pre><p>When the XSLT processor reads the input document, the first node it sees is the root. This rule matches that root node, and tells the XSLT processor to emit this element:</p><pre>&lt;HTML&gt;  &lt;HEAD&gt;  &lt;/HEAD&gt;  &lt;BODY&gt;  &lt;/BODY&gt;&lt;/HTML&gt;</pre><p>This text is well-formed HTML. Because the XSLT document is itself an XML document, its contents&#150;templates included&#150;must be well-formed XML.</p><p>If you were to use the preceding rule, and only the preceding rule, in an XSLT style sheet, the output would be limited to the above six tags. That&#146;s because no instructions in the rule tell the formatter to move down the tree and look for further matches against the templates in the style sheet.</p><h2>The xsl:apply-templates element</h2><p>To get beyond the root, you have to tell the formatting engine to process the children of the root. In general, to include content in the child nodes, you have to recursively process the nodes through the XML document. The element that does this is <code>xsl:apply-templates</code>. An <code>xsl:apply-templates</code> element tells the processor to compare each child node of the matched source element against the templates in the style sheet and, if a match is found, output the template for the matched node. The template for the matched node may itself contain <code>xsl:apply-templates</code> elements to search for matches for its children. When the XSLT engine processes a node, the node is treated as a complete tree. This is the advantage of the tree structure. Each part can be treated the same way as the whole. For example, Listing 15-4 is an XSLT style sheet that uses the <code>xsl:apply templates</code> element to process the child nodes.</p><font face="Arial"><p>Listing 15-4: An XSLT Style Sheet That Recursively Processes the Children of the Root</p></font><pre>&lt;?xml version="1.0"?&gt;&lt;xsl:stylesheet version="1.0"   xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;  &lt;xsl:template match="/"&gt;    &lt;HTML&gt;      &lt;xsl:apply-templates/&gt;    &lt;/HTML&gt;  &lt;/xsl:template&gt;  &lt;xsl:template match="PERIODIC_TABLE"&gt;    &lt;BODY&gt;      &lt;xsl:apply-templates/&gt;    &lt;/BODY&gt;  &lt;/xsl:template&gt;  &lt;xsl:template match="ATOM"&gt;    An Atom  &lt;/xsl:template&gt;&lt;/xsl:stylesheet&gt;</pre><p>When this style sheet is applied to Listing 15-1, here&#146;s what happens:</p><p> The root node is compared with all template rules in the style sheet. It matches the first one.</p><p>The <code>&lt;HTML&gt;</code> tag is written out.</p><p>The <code>xsl:apply-templates</code> element causes the formatting engine to process the child nodes of the root node of the input document.</p><p>The first child of the root, the <code>xml-stylesheet</code> processing instruction, is compared with the template rules. It doesn&#146;t match any of them, so no output is generated.</p><p>The second child of the root node of the input document, the root element <code>PERIODIC_TABLE</code>, is compared with the template rules. It matches the second template rule.</p><p>The <code>&lt;BODY&gt;</code> tag is written out.</p><p>The <code>xsl:apply-templates</code> element in the <code>body</code> element causes the XSLT engine to process the child nodes of <code>PERIODIC_TABLE</code>.</p><p>a. The first child of the <code>PERIODIC_TABLE</code> element, that is the Hydrogen <code>ATOM</code> element, is compared with the template rules. It matches the third template rule.</p><p>b. The text &quot;An Atom&quot; is output.</p><p>c. The second child of the <code>PERIODIC_TABLE</code> element, that is the Helium <code>ATOM</code> element, is compared with the template rules. It matches the third template rule.</p><p>d. The text &quot;An Atom&quot; is output.</p><p> e. The <code>&lt;/BODY&gt;</code> tag is written out.</p><p> 4. The <code>&lt;/HTML&gt;</code> tag is written out.</p><p> 5. Processing is complete.</p></dir><p>The end result is as follows:</p><pre>&lt;HTML&gt;&lt;BODY&gt;    An Atom    An Atom&lt;/BODY&gt;&lt;/HTML&gt;</pre><dir><b><font face="Arial" size=1 color="#000080"><p>Note</p></b></font><p>I actually skipped a couple of steps here. The boundary white space text nodes were also processed. Their values were copied by the default template rules, which is why there&#146;s so much white space in the output. You&#146;ll learn about the default template rules for text nodes shortly.</p></dir><h2>The select attribute</h2><p>To replace the text &quot;An Atom&quot; with the name of the <code>ATOM</code> element as given by its <code>NAME</code> child, you need to specify that templates should be applied to the <code>NAME</code> children of the <code>ATOM</code> element. To choose a particular set of children instead of all children, supply <code>xsl:apply-templates</code> with a <code>select</code> attribute designating the children to be selected, as in this  template rule:</p><pre>&lt;xsl:template match="ATOM"&gt;  &lt;xsl:apply-templates select="NAME"/&gt;&lt;/xsl:template&gt;</pre><p>The <code>select</code> attribute uses the same kind of patterns as the <code>match</code> attribute of the <code>xsl:template</code> element. For now, I&#146;ll stick to simple names of elements; but in the section on patterns for matching and selecting later in this chapter, you&#146;ll see many more possibilities for both <code>select</code> and <code>match</code>. If no <code>select</code> attribute is present, all child element, text, comment, and processing instruction nodes are selected. (Attribute and namespace nodes are not selected.)</p><p>The result of adding this rule to the style sheet of Listing 15-5 and applying it to Listing 15-1 is this:</p><pre>&lt;HTML&gt;&lt;BODY&gt;  Hydrogen  Helium&lt;/BODY&gt;&lt;/HTML&gt;</pre><h2>Computing the Value of a Node with xsl:value-of</h2><p>The <code>xsl:value-of</code> element computes the string value of something (most of the time, though not always, something in the input document) and copies that plain text value into the output document. The <code>select</code> attribute of the <code>xsl:value-of</code> element specifies exactly which something&#146;s value is being computed.</p><p>The exact content of the string value depends on the type of the node. The most common type of node is element, and the value of an element node is particularly simple. It&#146;s the concatenation of all the character data (but not markup) between the element's start-tag and end-tag. For example, the first <code>ATOM</code> element in Listing 15-1 is as follows:</p><pre>  &lt;ATOM STATE="GAS"&gt;    &lt;NAME&gt;Hydrogen&lt;/NAME&gt;    &lt;SYMBOL&gt;H&lt;/SYMBOL&gt;    &lt;ATOMIC_NUMBER&gt;1&lt;/ATOMIC_NUMBER&gt;    &lt;ATOMIC_WEIGHT&gt;1.00794&lt;/ATOMIC_WEIGHT&gt;    &lt;BOILING_POINT UNITS="Kelvin"&gt;20.28&lt;/BOILING_POINT&gt;    &lt;MELTING_POINT UNITS="Kelvin"&gt;13.81&lt;/MELTING_POINT&gt;    &lt;DENSITY UNITS="grams/cubic centimeter"&gt;      &lt;!-- At 300K, 1 atm --&gt;      0.0000899    &lt;/DENSITY&gt;  &lt;/ATOM&gt;</pre><p>The value of this element is:</p><pre>  Hydrogen  H  1  1.00794  1  20.28  13.81    0.0000899</pre><p>I calculated this value by stripping out all the tags and comments. Everything else including white space was left intact. The values of the other six node types are calculated similarly, mostly in obvious ways. Table 15-1 summarizes.</p><font face="Arial"><p align="CENTER">Table 15-1</p><b><p align="CENTER">Values of Nodes</p></b></font><p align="CENTER"><center><table border cellspacing=1 bordercolor="#000000" width=338><tr><td width="24%" valign="TOP"><b><i><font face="Arial" size=1><p>Node Type</b></i></font></td><td width="76%" valign="TOP"><b><i><font face="Arial" size=1><p>Value</b></i></font></td></tr><tr><td width="24%" valign="TOP"><font face="Arial" size=1><p>Root</font></td><td width="76%" valign="TOP"><font face="Arial" size=1><p>The value of the root element</font></td></tr><tr><td width="24%" valign="TOP"><font face="Arial" size=1><p>Element</font></td><td width="76%" valign="TOP"><font face="Arial" size=1><p>The concatenation of all parsed character data contained in the element, including character data in any of the descendants of the element</font></td></tr><tr><td width="24%" valign="TOP"><font face="Arial" size=1><p>Text</font></td><td width="76%" valign="TOP"><font face="Arial" size=1><p>The text of the node; essentially the node itself</font></td></tr><tr><td width="24%" valign="TOP"><font face="Arial" size=1><p>Attribute</font></td><td width="76%" valign="TOP"><font face="Arial" size=1><p>The normalized attribute value as specified by Section 3.3.3 of the XML 1.0 Recommendation; basically the attribute value after entities are resolved and leading and trailing white space is stripped; does not include the name of the attribute, the equals sign, or the quotation marks</font></td></tr><tr><td width="24%" valign="TOP"><font face="Arial" size=1><p>Namespace</font></td><td width="76%" valign="TOP"><font face="Arial" size=1><p>The URI of the namespace</font></td></tr><tr><td width="24%" valign="TOP"><font face="Arial" size=1><p>Processing instruction</font></td><td width="76%" valign="TOP"><font face="Arial" size=1><p>The data in the processing instruction; does not include the target, <code>&lt;?</code> or <code>?&gt;</code></font></td></tr><tr><td width="24%" valign="TOP"><font face="Arial" size=1><p>Comment</font></td><td width="76%" valign="TOP"><font face="Arial" size=1><p>The text of the comment, <code>&lt;!--</code> and <code>--&gt;</code> not included</font></td></tr></table></center></p><p>For example, suppose you want to replace the literal text &quot;An Atom&quot; with the name of the <code>ATOM</code> element, as given by the contents of its <code>NAME</code> child. You can replace "An Atom" with <code>&lt;xsl:value-of select="NAME"/&gt;</code>, like this:</p><pre>&lt;xsl:template match="ATOM"&gt;  &lt;xsl:value-of select="NAME"/&gt;&lt;/xsl:template&gt;</pre><p>Then, when you apply the style sheet to Listing 15-1, this text is generated:</p><pre>&lt;HTML&gt;&lt;BODY&gt;  Hydrogen  Helium&lt;/BODY&gt;&lt;/HTML&gt;</pre><p>The item whose value is selected, the <code>NAME</code> element in this example, is relative to the current node. The current node is the item matched by the template, the particular <code>ATOM</code> element in this example. Thus, when the Hydrogen <code>ATOM</code> is matched by <code>&lt;xsl:template match="ATOM"&gt;</code>, the Hydrogen <code>ATOM</code>&#146;s <code>NAME</code> is selected by <code>xsl:value-of</code>. When the Helium <code>ATOM</code> is matched by <code>&lt;xsl:template match="ATOM"&gt;</code>, the Helium <code>ATOM</code>'s <code>NAME</code> is selected by <code>xsl:value-of</code>.</p><h2>Processing Multiple Elements with xsl:for-each</h2><p>The <code>xsl:value-of</code> element should only be used in contexts where it is obvious which node&#146;s value is being taken. If there are multiple possible items that could be selected, only the first one will be chosen. For example, this is a poor rule because a typical <code>PERIODIC_TABLE</code> element contains more than one <code>ATOM</code>:</p><pre>&lt;xsl:template match="PERIODIC_TABLE"&gt;  &lt;xsl:value-of select="ATOM"/&gt;&lt;/xsl:template&gt;</pre><p>There are two ways of processing multiple elements in turn. The first method you&#146;ve already seen. Simply use <code>xsl:apply-templates</code> with a <code>select</code> attribute that chooses the particular elements that you want to visit, like this:</p><pre>  &lt;xsl:template match="PERIODIC_TABLE"&gt;    &lt;xsl:apply-templates select="ATOM"/&gt;  &lt;/xsl:template&gt;  &lt;xsl:template match="ATOM"&gt;    &lt;xsl:value-of select="."/&gt;  &lt;/xsl:template&gt;</pre><p>The <code>select="."</code> in the second template tells the formatter to take the value of the matched node, <code>ATOM</code> in this example.</p><p>The second option is <code>xsl:for-each</code>. The <code>xsl:for-each</code> element processes each element chosen by its <code>select</code> attribute in turn. However, no additional template rule is required. Instead, the content of the <code>xsl:for-each</code> element serves as a template. For example:</p><pre>&lt;xsl:template match="PERIODIC_TABLE"&gt;  &lt;xsl:for-each select="ATOM"&gt;    &lt;xsl:value-of select="."/&gt;  &lt;/xsl:for-each&gt;&lt;/xsl:template&gt;</pre><p>This is useful when you need to format the same content differently in different places in the style sheet.</p><h2>Patterns for Matching Nodes</h2><p>The <code>match</code> attribute of the <code>xsl:template</code> element supports a complex syntax that allows you to indicate precisely which nodes you do and do not want to match. The <code>select</code> attribute of <code>xsl:apply-templates</code>, <code>xsl:value-of</code>, <code>xsl:for-each</code>, <code>xsl:copy-of</code>, and <code>xsl:sort</code> supports an even more powerful superset of this syntax called XPath that allows you to express exactly which nodes you do and do not want to select. Various patterns for matching and selecting nodes are discussed in following sections.</p><h2>Matching the root node</h2><p>In order that the output document be well-formed, the first thing output from an XSL transformation should be the output document&#146;s root element. Consequently, XSLT style sheets generally start with a rule that applies to the root node. To specify the root node in a rule, you give its <code>match</code> attribute the value <code>"/"</code>, as in the following example:</p><pre>&lt;xsl:template match="/"&gt;  &lt;DOCUMENT&gt;    &lt;xsl:apply-templates/&gt;  &lt;/DOCUMENT&gt;&lt;/xsl:template&gt;</pre><p>This rule applies to the root node and only the root node of the input tree. When the root node is read, the tag <code>&lt;DOCUMENT&gt;</code> is output, the children of the root node are processed, then the <code>&lt;/DOCUMENT&gt;</code> tag is output. This rule overrides the default rule for the root node. Listing 15-5 shows a style sheet with a single rule that applies to the root node.</p><font face="Arial"><p>Listing 15-5: An XSLT Style Sheet with One Rule for the Root Node</p></font><pre>&lt;?xml version="1.0"?&gt;&lt;xsl:stylesheet version="1.0"  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;    &lt;xsl:template match="/"&gt;      &lt;HTML&gt;        &lt;HEAD&gt;          &lt;TITLE&gt;Atomic Number vs. Atomic Weight&lt;/TITLE&gt;        &lt;/HEAD&gt;        &lt;BODY&gt;          &lt;TABLE&gt;            Atom data will go here          &lt;/TABLE&gt;        &lt;/BODY&gt;      &lt;/HTML&gt;    &lt;/xsl:template&gt;&lt;/xsl:stylesheet&gt;</pre><p>Because this style sheet only provides a rule for the root node, and because that rule&#146;s template does not specify any further processing of child nodes, only literal output that&#146;s included in the template is inserted in the resulting document. In other words, the result of applying the style sheet in Listing 15-5 to Listing 15-1 (or any other well-formed XML document) is this:</p><pre>&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Atomic Number vs. Atomic Weight&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;TABLE&gt;            Atom data will go here          &lt;/TABLE&gt;&lt;/BODY&gt;&lt;/HTML&gt;</pre><h2>Matching element names</h2><p>As previously mentioned, the most basic pattern contains a single element name that matches all elements with that name. For example, this template matches <code>ATOM</code> elements and makes their <code>ATOMIC_NUMBER</code> children bold:</p><pre>&lt;xsl:template match="ATOM"&gt;  &lt;B&gt;&lt;xsl:value-of select="ATOMIC_NUMBER"/&gt;&lt;/B&gt;&lt;/xsl:template&gt;</pre><p>Listing 15-6 demonstrates a style sheet that expands on Listing 15-5. First, an <code>xsl:apply-templates</code> element is included in the template rule for the root node. This element uses a <code>select</code> attribute to ensure that only <code>PERIODIC_TABLE</code> elements are processed.</p><p>Second, a rule that only applies to <code>PERIODIC_TABLE</code> elements is created using <code>match="PERIODIC_TABLE"</code>. This rule sets up the header for the table, and then applies templates to form the body of the table from <code>ATOM</code> elements.</p><p>Finally, the <code>ATOM</code> rule specifically selects the <code>ATOM</code> element's <code>NAME</code>, <code>ATOMIC_NUMBER</code>, and <code>ATOMIC_WEIGHT</code> child elements with <code>&lt;xsl:value-of select="NAME"/&gt;</code>, <code>&lt;xsl:value-of select="ATOMIC_NUMBER"/&gt;</code>, and <code>&lt;xsl:value-of select="ATOMIC_WEIGHT"/&gt;</code>. These are wrapped up inside HTML&#146;s <code>TR</code> and <code>TD</code> elements, so that the end result is a table of atomic numbers matched to atomic weights. Figure 15-3 shows the output of applying the style sheet in Listing 15-6 to the complete periodic table document rendered in Netscape Navigator.</p><p>One thing you might want to note about this style sheet: The exact order of the <code>NAME</code>, <code>ATOMIC_NUMBER,</code> and <code>ATOMIC_WEIGHT</code> elements in the input document is irrelevant. They appear in the output in the order they were selected; that is, first number, then weight. Conversely, the individual atoms are sorted in alphabetical order as they appear in the input document. Later, you&#146;ll see how to use an <code>xsl:sort</code> element to change that so you can arrange the atoms in the more conventional atomic number order.</p><font face="Arial"><p>Listing 15-6: Templates Applied to Specific Classes of Element with Select</p></font><pre>&lt;?xml version="1.0"?&gt;&lt;xsl:stylesheet version="1.0"   xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;    &lt;xsl:template match="/"&gt;      &lt;HTML&gt;        &lt;HEAD&gt;          &lt;TITLE&gt;Atomic Number vs. Atomic Weight&lt;/TITLE&gt;        &lt;/HEAD&gt;        &lt;BODY&gt;          &lt;xsl:apply-templates select="PERIODIC_TABLE"/&gt;        &lt;/BODY&gt;      &lt;/HTML&gt;    &lt;/xsl:template&gt;    &lt;xsl:template match="PERIODIC_TABLE"&gt;      &lt;H1&gt;Atomic Number vs. Atomic Weight&lt;/H1&gt;      &lt;TABLE&gt;        &lt;TH&gt;Element&lt;/TH&gt;        &lt;TH&gt;Atomic Number&lt;/TH&gt;        &lt;TH&gt;Atomic Weight&lt;/TH&gt;          &lt;xsl:apply-templates select="ATOM"/&gt;      &lt;/TABLE&gt;    &lt;/xsl:template&gt;    &lt;xsl:template match="ATOM"&gt;      &lt;TR&gt;        &lt;TD&gt;&lt;xsl:value-of select="NAME"/&gt;&lt;/TD&gt;        &lt;TD&gt;&lt;xsl:value-of select="ATOMIC_NUMBER"/&gt;&lt;/TD&gt;        &lt;TD&gt;&lt;xsl:value-of select="ATOMIC_WEIGHT"/&gt;&lt;/TD&gt;      &lt;/TR&gt;    &lt;/xsl:template&gt;&lt;/xsl:stylesheet&gt;</pre><p><img src="Image8.gif" width=384 height=287></p><p>Figure 15-3: A table showing atomic number versus atomic weight in Netscape Navigator</p><h2>Wildcards</h2><p>Sometimes you want a single template to apply to more than one element. You can indicate that a template matches all elements by using the asterisk wildcard (<code>*</code>) in place of an element name in the <code>match</code> attribute. For example, this template says that all input elements should be wrapped in a <code>P</code> element:</p><pre>    &lt;xsl:template match="*"&gt;      &lt;P&gt;        &lt;xsl:value-of select="."/&gt;      &lt;/P&gt;    &lt;/xsl:template&gt;</pre><p>Of course this is probably more than you want. You&#146;d like to use the template rules already defined for <code>PERIODIC_TABLE</code> and <code>ATOM</code> elements as well as the root node, and only use this rule for the other elements. Fortunately, you can. In the event that two rules both match a single node, by default the more specific one takes precedence. In this case, that means that <code>ATOM</code> elements will use the template with <code>match="ATOM"</code> instead of a template that merely has <code>match="*"</code>. However, <code>NAME</code>, <code>BOILING_POINT</code>, <code>ATOMIC_NUMBER</code> and other elements that don&#146;t match a more specific template will cause the <code>match="*"</code> template to activate.</p><p>You can place a namespace prefix in front of the asterisk to indicate that only elements in a particular namespace should be matched. For example, this template matches all SVG elements, presuming that the prefix <code>svg</code> is mapped to the normal SVG URI <code>http://www.w3.org/2000/svg</code> in the style sheet.</p><pre>    &lt;xsl:template match="svg:*"&gt;      &lt;DIV&gt;        &lt;xsl:value-of select="."/&gt;      &lt;/DIV&gt;    &lt;/xsl:template&gt;</pre><p>Of course in Listing 15-1, there aren&#146;t any elements from this namespace, so this template wouldn&#146;t produce any output. However, it might when applied to a different document that did include some SVG.</p><h2>Matching children with /</h2><p>You&#146;re not limited to the children of the current node in <code>match</code> attributes. You can use the <code>/</code> symbol to match hierarchies of elements. Alone, the <code>/</code> symbol refers to the root node. However, between two names it indicates that the second is the child of the first. For example, <code>ATOM/NAME</code> refers to <code>NAME</code> elements that are children of <code>ATOM</code> elements.</p><p>In <code>xsl:template</code> elements, this enables you to match only some of the elements of a given kind. For example, this template rule marks <code>SYMBOL</code> elements that are children of <code>ATOM</code> elements strong. It does nothing to <code>SYMBOL</code> elements that are not direct children of <code>ATOM</code> elements.</p><pre>&lt;xsl:template match="ATOM/SYMBOL"&gt;  &lt;STRONG&gt;&lt;xsl:value-of select="."/&gt;&lt;/STRONG&gt;&lt;/xsl:template&gt;</pre><dir><b><font face="Arial" size=1 color="#000080"><p>Caution</p></b></font><p>Remember that this rule selects <code>SYMBOL</code> elements that are children of <code>ATOM</code> elements, not <code>ATOM</code> elements that have <code>SYMBOL</code> children. In other words, the <code>.</code> in <code>&lt;xsl:value-of select="."/&gt;</code> refers to the <code>SYMBOL</code> and not to the <code>ATOM</code>.</p></dir><p>You can specify deeper matches by stringing patterns together. For example, <code>PERIODIC_TABLE/ATOM/NAME</code> selects <code>NAME</code> elements whose parent is an <code>ATOM</code> element whose parent is a <code>PERIODIC_TABLE</code> element.</p><p>You can also use the <code>*</code> wildcard to substitute for an arbitrary element name in a hierarchy. For example, this template rule applies to all <code>SYMBOL</code> elements that are grandchildren of a <code>PERIODIC_TABLE</code> element.</p><pre>&lt;xsl:template match="PERIODIC_TABLE/*/SYMBOL"&gt;  &lt;STRONG&gt;&lt;xsl:value-of select="."/&gt;&lt;/STRONG&gt;&lt;/xsl:template&gt;</pre><p>Finally, as previously described, a <code>/</code> by itself selects the root node of the document. For example, this rule applies to all <code>PERIODIC_TABLE</code> elements that are root elements of the document:</p><pre>&lt;xsl:template match="/PERIODIC_TABLE"&gt;  &lt;HTML&gt;&lt;xsl:apply-templates/&gt;&lt;/HTML&gt;&lt;/xsl:template&gt;</pre><p>While <code>/</code> refers to the root node, <code>/*</code> refers to the root element, whatever it is. For example, this template doesn't care whether the root element is <code>PERIODIC_TABLE</code>, <code>DOCUMENT</code>, or <code>SCHENECTADY</code>. It produces the same output in all cases.</p><pre>&lt;xsl:template match="/*"&gt;  &lt;HTML&gt;    &lt;HEAD&gt;      &lt;TITLE&gt;Atomic Number vs. Atomic Weight&lt;/TITLE&gt;    &lt;/HEAD&gt;    &lt;BODY&gt;      &lt;xsl:apply-templates/&gt;    &lt;/BODY&gt;  &lt;/HTML&gt;&lt;/xsl:template&gt;</pre><h2>Matching descendants with //</h2><p>Sometimes, especially with an uneven hierarchy, you&#146;ll find it easier to bypass intermediate nodes and simply select all the elements of a given type, whether they&#146;re immediate children, grandchildren, great-grandchildren, or what have you. The double slash, <code>//</code>, refers to a descendant at an arbitrary level. For example, this template rule applies to all <code>NAME</code> descendants of <code>PERIODIC_TABLE</code>, no matter how deep:</p><pre>&lt;xsl:template match="PERIODIC_TABLE//NAME"&gt;  &lt;EM&gt;&lt;xsl:value-of select="."/&gt;&lt;/EM&gt;&lt;/xsl:template&gt;</pre><p>The periodic table example is fairly shallow, but this trick becomes more important in deeper and less predictable hierarchies, especially when an element can contain other elements of its own type (for example, an <code>ATOM</code> contains an <code>ATOM</code>).</p><p>The <code>//</code> operator at the beginning of a pattern selects any descendant of the root node. For example, this template rule processes all <code>ATOMIC_NUMBER</code> elements while completely ignoring their location:</p><pre>&lt;xsl:template match="//ATOMIC_NUMBER"&gt;  &lt;EM&gt;&lt;xsl:value-of select="."/&gt;&lt;/EM&gt;&lt;/xsl:template&gt;</pre><h2>Matching by ID</h2><p>You might want to apply a particular style to a particular single element without changing all other elements of that type. The simplest way to do this in XSLT is to attach a style to the element's ID. This is done with the <code>id()</code> selector, which contains the ID value in single quotes. For example, this rule makes the element with the ID <code>e47</code> bold:</p><pre>&lt;xsl:template match="id('e47')"&gt;  &lt;B&gt;&lt;xsl:value-of select="."/&gt;&lt;/B&gt;&lt;/xsl:template&gt;</pre><p>This assumes, of course, that the elements you want to select in this fashion have an attribute declared as type <code>ID</code> in the source document's DTD. This may not be the case, however. For one thing, many documents do not have DTDs. They&#146;re merely well-formed, not valid. And even if they have a DTD, there&#146;s no guarantee that any element has an <code>ID</code> type attribute.</p><dir><b><font face="Arial" size=1 color="#000080"><p>Cross-Reference</p></b></font><p>ID-type attributes are not simply attributes with the name <code>ID</code>. ID type attributes are discussed in Chapter 9.</p></dir><h2>Matching attributes with @</h2><p>As you saw in Chapter 5, the <code>@</code> sign matches against attributes and selects nodes according to attribute names. Simply prefix the name of the attribute you want to select with the <code>@</code> sign. For example, this template rule matches <code>UNITS</code> attributes, and wraps them in an <code>I</code> element:</p><pre>    &lt;xsl:template match="@UNITS"&gt;      &lt;I&gt;&lt;xsl:value-of select="."/&gt;&lt;/I&gt;    &lt;/xsl:template&gt;</pre><p>However, merely adding this rule to the style sheet will not automatically produce italicized units in the output, because attributes are not children of the elements that contain them. Therefore, by default, when an XSLT processor is walking the tree, it does not see attribute nodes. You have to explicitly process them using <code>xsl:apply-templates</code> with an appropriate <code>select</code> attribute. Listing 15-7 demonstrates with a style sheet that outputs a table of atomic numbers versus melting points. Not only is the value of the <code>MELTING_POINT</code> element written out, so is the value of its <code>UNITS</code> attribute. This is selected by <code>&lt;xsl:apply-templates select="@UNITS"/&gt;</code> in the template rule for <code>MELTING_POINT</code> elements.</p><font face="Arial"><p>Listing 15-7: An XSLT Style Sheet That Selects the UNITS Attribute with @</p></font><pre>&lt;?xml version="1.0"?&gt;&lt;xsl:stylesheet version="1.0"  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;    &lt;xsl:template match="/PERIODIC_TABLE"&gt;      &lt;HTML&gt;        &lt;BODY&gt;          &lt;H1&gt;Atomic Number vs. Melting Point&lt;/H1&gt;          &lt;TABLE&gt;            &lt;TH&gt;Element&lt;/TH&gt;            &lt;TH&gt;Atomic Number&lt;/TH&gt;            &lt;TH&gt;Melting Point&lt;/TH&gt;            &lt;xsl:apply-templates/&gt;          &lt;/TABLE&gt;        &lt;/BODY&gt;      &lt;/HTML&gt;    &lt;/xsl:template&gt;    &lt;xsl:template match="ATOM"&gt;       &lt;TR&gt;        &lt;TD&gt;&lt;xsl:value-of select="NAME"/&gt;&lt;/TD&gt;        &lt;TD&gt;&lt;xsl:value-of select="ATOMIC_NUMBER"/&gt;&lt;/TD&gt;        &lt;TD&gt;&lt;xsl:apply-templates select="MELTING_POINT"/&gt;&lt;/TD&gt;      &lt;/TR&gt;    &lt;/xsl:template&gt;    &lt;xsl:template match="MELTING_POINT"&gt;      &lt;xsl:value-of select="."/&gt;      &lt;xsl:apply-templates select="@UNITS"/&gt;    &lt;/xsl:template&gt;    &lt;xsl:template match="@UNITS"&gt;      &lt;I&gt;&lt;xsl:value-of select="."/&gt;&lt;/I&gt;    &lt;/xsl:template&gt;&lt;/xsl:stylesheet&gt;</pre><p>Recall that the value of an attribute node is simply the normalized string value of the attribute. After you apply the style sheet in Listing 15-7, <code>ATOM</code> elements come out formatted like this:</p><pre>  &lt;TR&gt;&lt;TD&gt;Hydrogen&lt;/TD&gt;&lt;TD&gt;1&lt;/TD&gt;&lt;TD&gt;13.81&lt;I&gt;Kelvin&lt;/I&gt;&lt;/TD&gt;&lt;/TR&gt;  &lt;TR&gt;&lt;TD&gt;Helium&lt;/TD&gt;&lt;TD&gt;2&lt;/TD&gt;&lt;TD&gt;0.95&lt;I&gt;Kelvin&lt;/I&gt;&lt;/TD&gt;&lt;/TR&gt;</pre><p>You can combine attributes with elements using the various hierarchy operators. For example, the pattern <code>BOILING_POINT/@UNITS</code> refers to the <code>UNITS</code> attribute of a <code>BOILING_POINT</code> element. <code>ATOM/*/@UNITS</code> matches any <code>UNITS</code> attribute of a child element of an <code>ATOM</code> element. This is especially helpful when matching against attributes in template rules.</p><p>You can also use the <code>@*</code> wildcard to match all attributes of an element, for example <code>BOILING_POINT/@*</code> to match all attributes of <code>BOILING_POINT</code> elements. You can also add a namespace prefix after the <code>@</code> to match all attributes in a declared namespace. For example, <code>@xlink:*</code> matches all the XLink attributes, such as <code>xlink:show</code>, <code>xlink:type</code>, and <code>xlink:href</code>, assuming the <code>xlink</code> prefix is mapped to the <code>http://www.w3.org/1999/xlink</code> XLink namespace URI.</p><h2>Matching comments with comment()</h2><p>Most of the time, you should simply ignore comments in XML documents. Making comments an essential part of a document is a very bad idea. By default, an XSLT style sheet won&#146;t do anything with comments. Nonetheless, XSLT does provide a means to match a comment if you absolutely have to.</p><p>To match a comment, use the <code>comment()</code> pattern. Although this pattern has functionlike parentheses, it never actually takes any arguments. For example, this template rule italicizes all comments:</p><pre>    &lt;xsl:template match="comment()"&gt;      &lt;I&gt;&lt;xsl:value-of select="."/&gt;&lt;/I&gt;    &lt;/xsl:template&gt;</pre><p>You can use the hierarchy operators to select particular comments. For example, recall that a <code>DENSITY</code> element looks like this:</p><pre>    &lt;DENSITY UNITS="grams/cubic centimeter"&gt;      &lt;!-- At 300K, 1 atm --&gt;      0.0000899    &lt;/DENSITY&gt;</pre><p>This rule only matches comments that occur inside <code>DENSITY</code> elements:</p><pre>&lt;xsl:template match="DENSITY/comment()"&gt;  &lt;I&gt;&lt;xsl:value-of select="."/&gt;&lt;/I&gt;&lt;/xsl:template&gt;</pre><p>The only reason Listing 15-1 uses a comment to specify conditions instead of an attribute or element is precisely for this example. In practice, you should never put important information in comments. The real reason XSLT allows you to select comments is so that a style sheet can transform from one XML application to another while leaving the comments intact. Any other use indicates a poorly designed original document. The following rule matches all comments, and copies them back out again using the <code>xsl:comment</code> element.</p><pre>&lt;xsl:template match="comment()"&gt;  &lt;xsl:comment&gt;&lt;xsl:value-of select="."/&gt;&lt;/xsl:comment&gt;&lt;/xsl:template&gt;</pre><h2>Matching processing instructions with processing-instruction()</h2><p>When it comes to writing structured, intelligible, maintainable XML, processing instructions aren&#146;t much better than comments. However, there are occasional genuine needs for them, including attaching style sheets to documents.</p><p>The <code>processing-instruction()</code> function matches processing instructions. The argument to <code>processing-instruction()</code> is a quoted string giving the target of the processing instruction to select. If you do not include an argument, all processing instructions are matched. For example, this rule matches the processing instruction children of the root node (most likely the <code>xml-stylesheet</code> processing instruction). The <code>xsl:processing-instruction</code> element inserts a processing instruction with the specified name and value in the output document. For example, this template rule matches all processing instructions in the document&#146;s prolog and epilog and changes each one into a comment containing the processing instruction data:</p><pre>&lt;xsl:template match="/processing-instruction()"&gt;  &lt;xsl:comment&gt;    &lt;xsl:value-of select="."/&gt;  &lt;/xsl:comment&gt;&lt;/xsl:template&gt;</pre><p>This rule only matches <code>xml-stylesheet</code> processing instructions:</p><pre>&lt;xsl:template  match="processing-instruction('xml-stylesheet')"&gt;  &lt;xsl:comment&gt;    &lt;xsl:value-of select="."/&gt;  &lt;/xsl:comment&gt;&lt;/xsl:template&gt;</pre><p>In fact, one of the primary reasons for distinguishing between the root element and the root node is so that processing instructions from the prolog can be read and processed. Although the <code>xml-stylesheet</code> processing instruction uses a name = value syntax, XSL does not consider these to be attributes because processing instructions are not elements. The value of a processing instruction is simply everything between the white space following its name and the closing <code>?&gt;</code>.</p><h2>Matching text nodes with text()</h2><p>Text nodes are generally ignored as nodes, although their values are included as part of the value of a selected element. However, the <code>text()</code> operator does enable you to specifically select the text child of an element. Despite the parentheses, this operator takes no arguments. For example, this rule emboldens all text:</p><pre>&lt;xsl:template match="text()"&gt;  &lt;B&gt;&lt;xsl:value-of select="."/&gt;&lt;/B&gt;&lt;/xsl:template&gt;</pre><p>The main reason this operator exists is for the default rules. XSLT processors must provide the following default rule whether the author specifies it or not:</p><pre>&lt;xsl:template match="text()"&gt;  &lt;xsl:value-of select="."/&gt;&lt;/xsl:template&gt;</pre><p>This means that whenever a template is applied to a text node, the text of the node is output. If you do not want the default behavior, you can override it. For example, including the following empty template rule in your style sheet will prevent text nodes from being output unless specifically matched by another rule:</p><pre>&lt;xsl:template match="text()" /&gt;</pre><h2>Using the or operator |</h2><p>The vertical bar (<code>|</code>) allows a template rule to match multiple patterns. If a node matches one pattern or the other, it will activate the template. For example, this template rule matches both <code>ATOMIC_NUMBER</code> and <code>ATOMIC_WEIGHT</code> elements:</p><pre>&lt;xsl:template match="ATOMIC_NUMBER|ATOMIC_WEIGHT"&gt;  &lt;B&gt;&lt;xsl:apply-templates/&gt;&lt;/B&gt;&lt;/xsl:template&gt;</pre><p>You can include white space around the <code>|</code> if that makes the code clearer, as in this template rule:</p><pre>&lt;xsl:template match="ATOMIC_NUMBER | ATOMIC_WEIGHT"&gt;  &lt;B&gt;&lt;xsl:apply-templates/&gt;&lt;/B&gt;&lt;/xsl:template&gt;</pre><p>You can also use more than two patterns in sequence. For example, this template rule applies to <code>ATOMIC_NUMBER</code>, <code>ATOMIC_WEIGHT</code>, and <code>SYMBOL</code> elements (that is, it matches <code>ATOMIC_NUMBER</code>, <code>ATOMIC_WEIGHT</code> and <code>SYMBOL</code> elements):</p><pre>&lt;xsl:template match="ATOMIC_NUMBER | ATOMIC_WEIGHT | SYMBOL"&gt;  &lt;B&gt;&lt;xsl:apply-templates/&gt;&lt;/B&gt;&lt;/xsl:template&gt;</pre><p>The <code>/</code> operator is evaluated before the <code>|</code> operator. Thus, the following template rule matches an <code>ATOMIC_NUMBER</code> child of an <code>ATOM</code>, or an <code>ATOMIC_WEIGHT</code> of unspecified parentage, not an <code>ATOMIC_NUMBER</code> child of an <code>ATOM</code> or an <code>ATOMIC_WEIGHT</code> child of an <code>ATOM</code>.</p><pre>&lt;xsl:template match="ATOM/ATOMIC_NUMBER|ATOMIC_WEIGHT"&gt;  &lt;B&gt;&lt;xsl:apply-templates/&gt;&lt;/B&gt;&lt;/xsl:template&gt;</pre><h2>Testing with [ ]</h2><p>So far, I&#146;ve merely tested for the presence of various nodes. However, you can test for more details about the nodes that match a pattern using <code>[]</code>. You can perform many different tests, including the following:</p><dir><p>Whether an element contains a given child, attribute, or other node</p><p>Whether the value of an attribute is a certain string</p><p>Whether the value of an element contains a string</p><p>What position a given node occupies in the hierarchy</p></dir><p>For example, seaborgium, element 106, has only been created in microscopic quantities. Even its most long-lived isotope has a half-life of only 30 seconds. With such a hard-to-create, short-lived element, it&#146;s virtually impossible to measure the density, melting point, and other bulk properties. Consequently, the periodic table document omits the elements describing the bulk properties of seaborgium and similar atoms because the data simply doesn&#146;t exist. If you want to create a table of atomic number versus melting point, you should omit those elements with unknown melting points. To do this, you can provide one template for <code>ATOM</code> elements that have <code>MELTING_POINT</code> children and another one for elements that don&#146;t, like this:</p><pre>&lt;!-- Include nothing for arbitrary atoms --&gt;&lt;xsl:template match="ATOM" /&gt;&lt;!-- Include a table row for atoms that do have      melting points. This rule will override the      previous one for those atoms that do have      melting points. --&gt;&lt;xsl:template match="ATOM[MELTING_POINT]"&gt;  &lt;TR&gt;    &lt;TD&gt;&lt;xsl:value-of select="NAME"/&gt;&lt;/TD&gt;    &lt;TD&gt;&lt;xsl:value-of select="MELTING_POINT"/&gt;&lt;/TD&gt;  &lt;/TR&gt;&lt;/xsl:template&gt;</pre><p>Note here that it is the <code>ATOM</code> element being matched, not the <code>MELTING_POINT</code> element as in the case of <code>ATOM/MELTING_POINT</code>.</p><p>The test brackets can contain more than simply a child-element name. In fact, they can contain any XPath expression. (XPath expressions are a superset of match patterns that are discussed in the next section.) If the specified element has a child matching that expression, it is considered to match the total pattern. For example, this template rule matches <code>ATOM</code> elements with <code>NAME</code> or <code>SYMBOL</code> children:</p><pre>&lt;xsl:template match="ATOM[NAME | SYMBOL]"&gt;&lt;/xsl:template&gt;</pre><p>This template rule matches <code>ATOM</code> elements with a <code>DENSITY</code> child element that has a <code>UNITS</code> attribute:</p><pre>&lt;xsl:template match="ATOM[DENSITY/@UNITS]"&gt;&lt;/xsl:template&gt;</pre><p>To find all child elements that have <code>UNITS</code> attributes, use <code>*</code> to find all elements and <code>[@UNITS]</code> to winnow those down to the ones with <code>UNITS</code> attributes, like this:</p><pre>&lt;xsl:template match="ATOM"&gt;  &lt;xsl:apply-templates select="*[@UNITS]"/&gt;&lt;/xsl:template&gt;</pre><p>One type of pattern testing that proves especially useful is string equality. An equals sign (<code>=</code>) can test whether the value of a node identically matches a string. For example, this template finds the <code>ATOM</code> element that contains an <code>ATOMIC_NUMBER</code> element whose content is the string <code>10</code> (Neon).</p><pre>&lt;xsl:template match="ATOM[ATOMIC_NUMBER='10']"&gt;  This is Neon!&lt;/xsl:template&gt;</pre><p>Testing against element content may seem extremely tricky because of the need to get the value exactly right, including white space. You may find it easier to test against attribute values because those are less likely to contain insignificant white space. For example, the style sheet in Listing 15-8 applies templates only to those <code>ATOM</code> elements whose <code>STATE</code> attribute value is the three letters <code>GAS</code>.</p><font face="Arial"><p>Listing 15-8: An XSLT Style Sheet That Selects Only Those ATOM Elements Whose STATE Attribute Has the Value GAS</p></font><pre>&lt;?xml version="1.0"?&gt;&lt;xsl:stylesheet version="1.0"   xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;  &lt;xsl:template match="PERIODIC_TABLE"&gt;    &lt;HTML&gt;      &lt;HEAD&gt;&lt;TITLE&gt;Gases&lt;/TITLE&gt;&lt;/HEAD&gt;      &lt;BODY&gt;        &lt;xsl:apply-templates/&gt;      &lt;/BODY&gt;    &lt;/HTML&gt;  &lt;/xsl:template&gt;  &lt;xsl:template match="ATOM"/&gt;  &lt;xsl:template match="ATOM[@STATE='GAS']"&gt;    &lt;P&gt;&lt;xsl:value-of select="."/&gt;&lt;/P&gt;  &lt;/xsl:template&gt;&lt;/xsl:stylesheet&gt;</pre><p>You can use other XPath expressions for more complex matches. For example, you can select all elements whose names begin with &quot;A&quot; or all elements with an atomic number less than 100.</p><h2>XPath Expressions for Selecting Nodes</h2><p>The <code>select</code> attribute is used in <code>xsl:apply-templates</code>, <code>xsl:value-of</code>, <code>xsl:for-each</code>, <code>xsl:copy-of</code>, <code>xsl:variable</code>, <code>xsl:param</code>, and <code>xsl:sort</code> to specify exactly which nodes are operated on. The value of this attribute is an <i>expression</i> written in the XPath language. The XPath language provides a means of identifying a particular element, group of elements, text fragment, or other part of an XML document. The XPath syntax is used both for XSLT and XPointer.</p><dir><b><font face="Arial" size=1 color="#000080"><p>Cross-Reference</p></b></font><p>XPointers are discussed in Chapter 18. XPath is discussed further in that chapter as well.</p></dir><p>Expressions are a superset of the match patterns discussed in the last section. That is, all match patterns are expressions, but not all expressions are match patterns. Recall that match patterns enable you to match nodes by element name, child elements, descendants, and attributes, as well as by making simple tests on these items. XPath expressions allow you to select nodes through all these criteria, but also by referring to ancestor nodes, parent nodes, sibling nodes, preceding nodes, and following nodes. Furthermore, expressions aren&#146;t limited to producing merely a list of nodes, but can also produce booleans, numbers, and strings.</p><h2>Node axes</h2><p>Expressions are not limited to specifying the children and descendants of the current node. XPath provides a number of axes that you can use to select from different parts of the tree relative to some particular node in the tree called the context node. In XSLT, the context node is normally initialized to the current node that the template matches, though there are ways to change this. Table 15-2 summarizes the axes and their meanings.</p><font face="Arial"><p align="CENTER">Table 15-2</p><b><p align="CENTER">Expression Axes</p></b></font><p align="CENTER"><center><table border cellspacing=1 bordercolor="#000000" width=409><tr><td width="21%" valign="TOP"><b><i><font face="Arial" size=1><p>Axis</b></i></font></td><td width="79%" valign="TOP"><b><i><font face="Arial" size=1><p>Selects From</b></i></font></td></tr><tr><td width="21%" valign="TOP"><code><font face="Arial" size=1><p>ancestor</code></font></td><td width="79%" valign="TOP"><font face="Arial" size=1><p>The parent of the context node, the parent of the parent of the context node, the parent of the parent of the parent of the context node, and so forth back to the root node</font></td></tr><tr><td width="21%" valign="TOP"><code><font face="Arial" size=1><p>ancestor-or-self</code></font></td><td width="79%" valign="TOP"><font face="Arial" size=1><p>The ancestors of the context node and the context node itself</font></td></tr><tr><td width="21%" valign="TOP"><code><font face="Arial" size=1><p>attribute</code></font></td><td width="79%" valign="TOP"><font face="Arial" size=1><p>The attributes of the context node</font></td></tr><tr><td width="21%" valign="TOP"><code><font face="Arial" size=1><p>child</code></font></td><td width="79%" valign="TOP"><font face="Arial" size=1><p>The immediate children of the context node</font></td></tr><tr><td width="21%" valign="TOP"><code><font face="Arial" size=1><p>descendant</code></font></td><td width="79%" valign="TOP"><font face="Arial" size=1><p>The children of the context node, the children of the children of the context node, and so forth</font></td></tr><tr><td width="21%" valign="TOP"><code><font face="Arial" size=1><p>descendant-or-self</code></font></td><td width="79%" valign="TOP"><font face="Arial" size=1><p>The context node itself and its descendants</font></td></tr><tr><td width="21%" valign="TOP"><code><font face="Arial" size=1><p>following</code></font></td><td width="79%" valign="TOP"><font face="Arial" size=1><p>All nodes that start after the end of the context node, excluding attribute and namespace nodes</font></td></tr><tr><td width="21%" valign="TOP"><code><font face="Arial" size=1><p>following-sibling</code></font></td><td width="79%" valign="TOP"><font face="Arial" size=1><p>All nodes that start after the end of the context node and have the same parent as the context node</font></td></tr><tr><td width="21%" valign="TOP"><code><font face="Arial" size=1><p>namespace</code></font></td><td width="79%" valign="TOP"><font face="Arial" size=1><p>The namespace of the context node</font></td></tr><tr><td width="21%" valign="TOP"><code><font face="Arial" size=1><p>parent</code></font></td><td width="79%" valign="TOP"><font face="Arial" size=1><p>The unique parent node of the context node</font></td></tr><tr><td width="21%" valign="TOP"><code><font face="Arial" size=1><p>preceding</code></font></td><td width="79%" valign="TOP"><font face="Arial" size=1><p>All nodes that finish before the beginning of the context node, excluding attribute and namespace nodes </font></td></tr><tr><td width="21%" valign="TOP"><code><font face="Arial" size=1><p>preceding-sibling</code></font></td><td width="79%" valign="TOP"><font face="Arial" size=1><p>All nodes that start before the beginning of the context node and have the same parent as the context node</font></td></tr><tr><td width="21%" valign="TOP"><code><font face="Helvetica" size=1><p>self</code></font></td><td width="79%" valign="TOP"><font face="Arial" size=1><p>The context node</font></td></tr></table></center></p><p>Choosing an axis limits the expression so that it only selects from the set of nodes indicated in the second column of Table 15-2. The axis is generally followed by a double colon (<code>::</code>) and a node test that further winnows down this node-set. For example, a node test may contain the name of the element to be selected, as in the following template rule:</p><pre>&lt;xsl:template match="ATOM"&gt;  &lt;TR&gt;    &lt;TD&gt;      &lt;xsl:value-of select="child::NAME"/&gt;    &lt;/TD&gt;    &lt;TD&gt;      &lt;xsl:value-of select="child::ATOMIC_NUMBER"/&gt;    &lt;/TD&gt;    &lt;TD&gt;      &lt;xsl:value-of select="child::ATOMIC_WEIGHT"/&gt;    &lt;/TD&gt;  &lt;/TR&gt;&lt;/xsl:template&gt;</pre><p>This template rule matches <code>ATOM</code> elements. When an <code>ATOM</code> element is matched, that element becomes the context node. A <code>NAME</code> element, an <code>ATOMIC_NUMBER</code> element, and an <code>ATOMIC_WEIGHT</code> element are all selected from the children of that matched <code>ATOM</code> element and output as table cells. (If there's one more than one of these desired elements&#150;for example, three <code>NAME</code> elements&#150;all are selected but only the value of the first one is taken.)</p><p>The <code>child</code> axis doesn&#146;t let you do anything that you can't do with element names alone. In fact, <code>select="ATOMIC_WEIGHT"</code> is just an abbreviated form of <code>select="child::ATOMIC_WEIGHT"</code>. However, the other axes are a little more interesting.</p><p>Referring to the parent element is illegal in match patterns, but not in expressions. To refer to the parent, use the <code>parent</code> axis. For example, this template matches <code>BOILING_POINT</code> elements but outputs the value of the parent <code>ATOM</code> element:</p><pre>&lt;xsl:template match="BOILING_POINT"&gt;  &lt;P&gt;&lt;xsl:value-of select="parent::ATOM"/&gt;&lt;/P&gt;&lt;/xsl:template&gt;</pre><p>Some radioactive atoms, such as polonium, have half-lives so short that bulk properties, such as the boiling point and melting point, can&#146;t be measured. Therefore, not all <code>ATOM</code> elements necessarily have <code>BOILING_POINT</code> child elements. The preceding rule enables you to write a template that only outputs those elements that actually have boiling points. Expanding on this example, Listing 15-9 matches the <code>MELTING_POINT</code> elements but actually outputs the parent <code>ATOM</code> element using <code>parent::ATOM</code>.</p><font face="Arial"><p>Listing 15-9: A Style Sheet That Outputs Only Those Elements with Known Melting Points</p></font><pre>&lt;?xml version="1.0"?&gt;&lt;xsl:stylesheet version="1.0"   xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;    &lt;xsl:template match="/"&gt;      &lt;HTML&gt;        &lt;BODY&gt;          &lt;xsl:apply-templates select="PERIODIC_TABLE"/&gt;        &lt;/BODY&gt;      &lt;/HTML&gt;    &lt;/xsl:template&gt;    &lt;xsl:template match="PERIODIC_TABLE"&gt;      &lt;H1&gt;Elements with known Melting Points&lt;/H1&gt;      &lt;xsl:apply-templates select=".//MELTING_POINT"/&gt;    &lt;/xsl:template&gt;    &lt;xsl:template match="MELTING_POINT"&gt;      &lt;p&gt;        &lt;xsl:value-of select="parent::ATOM"/&gt;      &lt;/p&gt;    &lt;/xsl:template&gt;&lt;/xsl:stylesheet&gt;</pre><p>Once in awhile, you may need to select from the ancestors of an element. The <code>ancestor</code> axis does this. For example, this rule inserts the value of the nearest <code>PERIODIC_TABLE</code> element that contains the matched <code>SYMBOL</code> element.</p><pre>&lt;xsl:template match="SYMBOL"&gt;  &lt;xsl:value-of select="ancestor::PERIODIC_TABLE"/&gt;&lt;/xsl:template&gt;</pre><p>The <code>ancestor-or-self</code> axis behaves like the <code>ancestor</code> axis except that if the context node passes the node test, it will be returned as well. For example, this rule matches all elements. If the matched element is a <code>PERIODIC_TABLE</code>, that very <code>PERIODIC_TABLE</code> is selected in <code>xsl:value-of</code>.</p><pre>&lt;xsl:template match="*"&gt;  &lt;xsl:value-of select="ancestor-or-self::PERIODIC_TABLE"/&gt;&lt;/xsl:template&gt;</pre><h4>Node tests</h4><p>Instead of the name of a node, the axis can be followed by one of these four node-type functions:</p><ul>	<li><p><code>comment()</code></p></li>	<li><p><code>text()</code></p></li>	<li><p><code>processing-instruction()</code></p></li>	<li><p><code>node ()</code></p></li></ul><p>The <code>comment()</code> function selects a comment node. The <code>text()</code> function selects a text node. The <code>processing-instruction()</code> function selects a processing instruction node, and the <code>node()</code> function selects any type of node. (The <code>*</code> wildcard only selects element nodes.) The <code>processing-instruction()</code> node type can also contain an optional argument specifying the name of the processing instruction to select.</p><h4>Hierarchy operators</h4><p>You can use the <code>/</code> and <code>//</code> operators to string expressions together. For example, Listing 15-10 prints a table of element names, atomic numbers, and melting points for only those elements that have melting points. It does this by selecting the parent of the <code>MELTING_POINT</code> element, then finding that parent's <code>NAME</code> and <code>ATOMIC_NUMBER</code> children with <code>select="parent::*/child::NAME)"</code>.</p><font face="Arial"><p>Listing 15-10: A Table of Melting Point versus Atomic Number</p></font><pre>&lt;?xml version="1.0"?&gt;&lt;xsl:stylesheet version="1.0"  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;    &lt;xsl:template match="/PERIODIC_TABLE"&gt;      &lt;HTML&gt;        &lt;BODY&gt;          &lt;H1&gt;Atomic Number vs. Melting Point&lt;/H1&gt;          &lt;TABLE&gt;            &lt;TH&gt;Element&lt;/TH&gt;            &lt;TH&gt;Atomic Number&lt;/TH&gt;            &lt;TH&gt;Melting Point&lt;/TH&gt;            &lt;xsl:apply-templates select="child::ATOM"/&gt;          &lt;/TABLE&gt;        &lt;/BODY&gt;      &lt;/HTML&gt;    &lt;/xsl:template&gt;    &lt;xsl:template match="ATOM"&gt;      &lt;xsl:apply-templates       select="child::MELTING_POINT"/&gt;    &lt;/xsl:template&gt;    &lt;xsl:template match="MELTING_POINT"&gt;       &lt;TR&gt;        &lt;TD&gt;          &lt;xsl:value-of select="parent::*/child::NAME"/&gt;        &lt;/TD&gt;        &lt;TD&gt;          &lt;xsl:value-of         select="parent::*/child::ATOMIC_NUMBER"/&gt;        &lt;/TD&gt;        &lt;TD&gt;          &lt;xsl:value-of select="self::*"/&gt;          &lt;xsl:value-of select="attribute::UNITS"/&gt;        &lt;/TD&gt;      &lt;/TR&gt;   &lt;/xsl:template&gt;&lt;/xsl:stylesheet&gt;</pre><p>This is not the only way to solve the problem. Another possibility is to use the <code>preceding-sibling</code> and <code>following-sibling</code> axes, or both if the relative location (preceding or following) is uncertain. The necessary template rule for the <code>MELTING_POINT</code> element looks like this:</p><pre> &lt;xsl:template match="MELTING_POINT"&gt;    &lt;TR&gt;     &lt;TD&gt;       &lt;xsl:value-of        select="preceding-sibling::NAME              | following-sibling::NAME"/&gt;     &lt;/TD&gt;     &lt;TD&gt;       &lt;xsl:value-of        select="preceding-sibling::ATOMIC_NUMBER              | following-sibling::ATOMIC_NUMBER"/&gt;     &lt;/TD&gt;     &lt;TD&gt;       &lt;xsl:value-of select="self::*"/&gt;       &lt;xsl:value-of select="attribute::UNITS"/&gt;     &lt;/TD&gt;   &lt;/TR&gt;&lt;/xsl:template&gt;</pre><h4>Abbreviated syntax</h4><p>The various axes in Table 15-2 are a bit too wordy for comfortable typing. XPath also defines an abbreviated syntax that can substitute for the most common of these axes and is more commonly used in practice. Table 15-3 shows the full and abbreviated equivalents.</p><font face="Arial"><p align="CENTER">Table 15-3</p><b><p align="CENTER">Abbreviated Syntax for XPath Expressions</p></b></font><p align="CENTER"><center><table border cellspacing=1 bordercolor="#000000" width=307><tr><td width="39%" valign="TOP"><b><i><font face="Arial" size=1><p>Abbreviation</b></i></font></td><td width="61%" valign="TOP"><b><i><font face="Arial" size=1><p>Full</b></i></font></td></tr><tr><td width="39%" valign="TOP"><code><font face="Arial" size=1><p>.</code></font></td><td width="61%" valign="TOP"><code><font face="Arial" size=1><p>self::node()</code></font></td></tr><tr><td width="39%" valign="TOP"><code><font face="Arial" size=1><p>..</code></font></td><td width="61%" valign="TOP"><code><font face="Arial" size=1><p>parent::node()</code></font></td></tr><tr><td width="39%" valign="TOP"><i><code><font face="Arial" size=1><p>name</i></code></font></td><td width="61%" valign="TOP"><code><font face="Arial" size=1><p>child::<i>name</i></code></font></td></tr><tr><td width="39%" valign="TOP"><code><font face="Arial" size=1><p>@<i>name</i></code></font></td><td width="61%" valign="TOP"><code><font face="Arial" size=1><p>attribute::<i>name</i></code></font></td></tr><tr><td width="39%" valign="TOP"><code><font face="Helvetica" size=1><p>//</code></font></td><td width="61%" valign="TOP"><code><font face="Arial" size=1><p>/descendant-or-self::node()/</code></font></td></tr></table></center></p><p>Listing 15-11 demonstrates by rewriting Listing 15-10 using the abbreviated syntax. The output produced by the two style sheets is exactly the same, however.</p><font face="Arial"><p>Listing 15-11: A Table of Melting Point versus Atomic Number Using the Abbreviated Syntax</p></font><pre>&lt;?xml version="1.0"?&gt;&lt;xsl:stylesheet version="1.0"  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;    &lt;xsl:template match="/PERIODIC_TABLE"&gt;      &lt;HTML&gt;        &lt;BODY&gt;          &lt;H1&gt;Atomic Number vs. Melting Point&lt;/H1&gt;          &lt;TABLE&gt;            &lt;TH&gt;Element&lt;/TH&gt;            &lt;TH&gt;Atomic Number&lt;/TH&gt;            &lt;TH&gt;Melting Point&lt;/TH&gt;            &lt;xsl:apply-templates select="ATOM"/&gt;          &lt;/TABLE&gt;        &lt;/BODY&gt;      &lt;/HTML&gt;    &lt;/xsl:template&gt;    &lt;xsl:template match="ATOM"&gt;      &lt;xsl:apply-templates       select="MELTING_POINT"/&gt;    &lt;/xsl:template&gt;    &lt;xsl:template match="MELTING_POINT"&gt;       &lt;TR&gt;        &lt;TD&gt;          &lt;xsl:value-of           select="../NAME"/&gt;        &lt;/TD&gt;        &lt;TD&gt;          &lt;xsl:value-of         select="../ATOMIC_NUMBER"/&gt;        &lt;/TD&gt;        &lt;TD&gt;          &lt;xsl:value-of select="."/&gt;          &lt;xsl:value-of select="@UNITS"/&gt;        &lt;/TD&gt;      &lt;/TR&gt;   &lt;/xsl:template&gt;&lt;/xsl:stylesheet&gt;</pre><p>Match patterns can only use the abbreviated syntax and the unabbreviated <code>child</code> and <code>attribute</code> axes. The full syntax using the axes of Table 15-2 is restricted to expressions.</p><h2>Expression types</h2><p>Every XPath expression evaluates to a single value. For example, the expression <code>3 + 2</code> evaluates to the value <code>5</code>. The expressions used so far have all evaluated to node-sets. However, there are four types of expressions in XPath:</p><ul>	<li><p>Node-sets</p></li>	<li><p>Booleans</p></li>	<li><p>Numbers</p></li><li><p>Strings</p></li></ul><p>In addition, XSLT adds one type to this list, the result tree fragment. This is what an <code>xsl:template</code> element creates. However, it is not used by other non-XSLT uses of XPath.</p><h4>Node-sets</h4><p>A <i>node-set</i> is an unordered group of nodes from the input document. The axes in Table 15-2 all return a node-set containing the nodes they match. Which nodes are in the node-set depends on the context node, the node test, and the axis.</p><p>For example, when the context node is the <code>PERIODIC_TABLE</code> element of Listing 15-1, the XPath expression <code>select="child::ATOM"</code> returns a node-set that contains both <code>ATOM</code> elements in that document. The XPath expression <code>select="child::ATOM/child::NAME"</code> returns a node-set containing the two element nodes <code>&lt;NAME&gt;Hydrogen&lt;/NAME&gt;</code> and <code>&lt;NAME&gt;Helium&lt;/NAME&gt;</code> when the context node is the <code>PERIODIC_TABLE</code> element of Listing 15-1.</p><p>The context node is a member of the <i>context node list</i>. The context node list is that group of elements that all match the same rule at the same time, generally as a result of one <code>xsl:apply-templates</code> or <code>xsl:for-each</code> instruction. For example, when Listing 15-11 is applied to Listing 15-1, the <code>ATOM</code> template is invoked twice, first for the hydrogen atom, then for the helium atom. The first time it&#146;s invoked, the context node is the hydrogen <code>ATOM</code> element. The second time it&#146;s invoked, the context node is the helium <code>ATOM</code> element. However, both times the context node list is the set containing both the helium and hydrogen <code>ATOM</code> elements.</p><p>Table 15-4 lists a number of functions that operate on node-sets, either as arguments or as the context node.</p><font face="Arial"><p align="CENTER">Table 15-4</p><b><p align="CENTER">Functions That Operate on or Return Node-sets</p></b></font><p align="CENTER"><center><table border cellspacing=1 bordercolor="#000000" width=367><tr><td width="30%" valign="TOP"><b><i><font face="Arial" size=1><p>Function</b></i></font></td><td width="20%" valign="TOP"><b><i><font face="Arial" size=1><p>Return Type</b></i></font></td><td width="50%" valign="TOP"><b><i><font face="Arial" size=1><p>Returns</b></i></font></td></tr><tr><td width="30%" valign="TOP"><code><font face="Arial" size=1><p>position()</code></font></td><td width="20%" valign="TOP"><font face="Arial" size=1><p>number</font></td><td width="50%" valign="TOP"><font face="Arial" size=1><p>The position of the context node in the context node list; the first node in the list has position 1.</font></td></tr><tr><td width="30%" valign="TOP"><code><font face="Arial" size=1><p>last()</code></font></td><td width="20%" valign="TOP"><font face="Arial" size=1><p>number</font></td><td width="50%" valign="TOP"><font face="Arial" size=1><p>The number of nodes in the context node list; this is the same as the position of the last node in the list.</font></td></tr><tr><td width="30%" valign="TOP"><code><font face="Arial" size=1><p>count(<i>node-set</i>)</code></font></td><td width="20%" valign="TOP"><font face="Arial" size=1><p>number</font></td><td width="50%" valign="TOP"><font face="Arial" size=1><p>The number of nodes in <i><code>node-set</i></code>.</font></td></tr><tr><td width="30%" valign="TOP"><code><font face="Arial" size=1><p>id(<i>string1 string2 string3&#133;</i>)</code></font></td><td width="20%" valign="TOP"><font face="Arial" size=1><p>node-set</font></td><td width="50%" valign="TOP"><font face="Arial" size=1><p>A node-set containing all the elements anywhere in the same document that have an ID named in the argument list; the empty set if no element has the specified ID.</font></td></tr><tr><td width="30%" valign="TOP"><code><font face="Arial" size=1><p>key(<i>string name</i>, <i>Object value</i>)</code></font></td><td width="20%" valign="TOP"><font face="Arial" size=1><p>node-set</font></td><td width="50%" valign="TOP"><font face="Arial" size=1><p>A node-set containing all nodes in this document that have a key with the specified value. Keys are set with the top-level <code>xsl:key</code> element.</font></td></tr><tr><td width="30%" valign="TOP"><code><font face="Arial" size=1><p>document(<i>string URI, string base</i>)</code></font></td><td width="20%" valign="TOP"><font face="Arial" size=1><p>node-set</font></td><td width="50%" valign="TOP"><font face="Arial" size=1><p>A node-set from the document referred to by the URI; the exact subset of nodes are chosen from that document are selected by the XPointer in the URI's fragment identifier. If the URI does not have a fragment identifier, then the root element of the named document is the node-set. Relative URIs are relative to the base URI given in the second argument. If the second argument is omitted, then relative URIs are relative to the URI of the style sheet (not the source document!).</font></td></tr><tr><td width="30%" valign="TOP"><code><font face="Arial" size=1><p>local-name(<i>node-set</i>)</code></font></td><td width="20%" valign="TOP"><font face="Arial" size=1><p>string</font></td><td width="50%" valign="TOP"><font face="Arial" size=1><p>The local name (everything after the namespace prefix) of the first node in the <i><code>node-set</i></code> argument; can be used without any arguments to get the local name of the context node.</font></td></tr><tr><td width="30%" valign="TOP"><code><font face="Arial" size=1><p>namespace-uri(<i>node-set</i>)</code></font></td><td width="20%" valign="TOP"><font face="Arial" size=1><p>string</font></td><td width="50%" valign="TOP"><font face="Arial" size=1><p>The URI of the namespace of the first node in <i><code>node-set</i></code>; can be used without any arguments to get the URI of the namespace of the context node; returns an empty string if the node is not in a namespace.</font></td></tr><tr><td width="30%" valign="TOP"><code><font face="Arial" size=1><p>name(<i>node-set</i>)</code></font></td><td width="20%" valign="TOP"><font face="Arial" size=1><p>string</font></td><td width="50%" valign="TOP"><font face="Arial" size=1><p>The qualified name (both prefix and local part) of the first node in <i><code>node-set</i></code>; can be used without an argument to get the qualified name of the context node.</font></td></tr><tr><td width="30%" valign="TOP"><code><font face="Arial" size=1><p>generate-id(<i>node-set</i>)</code></font></td><td width="20%" valign="TOP"><font face="Arial" size=1><p>string</font></td><td width="50%" valign="TOP"><font face="Arial" size=1><p>A unique string for the first node in the argument </font><i><code><font face="Helvetica" size=1>node-set</i></code></font><font face="Arial" size=1>; can be used without any argument to generate an ID for the context node.</font></td></tr></table></center></p><p>If an argument of the wrong type is passed to one of these functions, XSLT will attempt to convert that argument to the correct type; for example, by converting the number 12 to the string "12". However, no arguments can be converted to node-sets.</p><p>You can use the <code>position()</code> function to determine an element&#146;s position within a node-set. Listing 15-12 is a style sheet that prefixes the name of each atom's name with its position in the document relative to the other atom names using <code>&lt;xsl:value-of select="position()"/&gt;</code>.</p><font face="Arial"><p>Listing 15-12: A Style Sheet That Numbers the Atoms in the Order They Appear in the Document</p></font><pre>&lt;?xml version="1.0"?&gt;&lt;xsl:stylesheet version="1.0"   xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;  &lt;xsl:template match="/PERIODIC_TABLE"&gt;    &lt;HTML&gt;      &lt;HEAD&gt;&lt;TITLE&gt;The Elements&lt;/TITLE&gt;&lt;/HEAD&gt;      &lt;BODY&gt;        &lt;xsl:apply-templates select="ATOM"/&gt;      &lt;/BODY&gt;    &lt;/HTML&gt;  &lt;/xsl:template&gt;  &lt;xsl:template match="ATOM"&gt;    &lt;P&gt;      &lt;xsl:value-of select="position()"/&gt;.      &lt;xsl:value-of select="NAME"/&gt;    &lt;/P&gt;  &lt;/xsl:template&gt;&lt;/xsl:stylesheet&gt;</pre><p>When this style sheet is applied to Listing 15-1, the output is this:</p><pre>&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;The Elements&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;P&gt;1.      Hydrogen&lt;/P&gt;&lt;P&gt;2.      Helium&lt;/P&gt;&lt;/BODY&gt;&lt;/HTML&gt;</pre><h4>Booleans</h4><p>A <i>boolean</i> has one of two values: true or false. XSLT allows any kind of data to be transformed into a boolean. This is often done implicitly when a string or a number or a node-set is used where a boolean is expected, as in the <code>test</code> attribute of an <code>xsl:if</code> element. These conversions can also be performed by the <code>boolean()</code> function, which converts an argument of any type to a boolean according to these rules:</p><ul><li><p>A number is false if it&#146;s zero or NaN (a special symbol meaning Not a Number, used for the result of dividing by zero and similar illegal operations); true otherwise.</p></li>	<li><p>An empty node-set is false. All other node-sets are true.</p></li>	<li><p>An empty result tree fragment is false. All other result tree fragments are true.</p></li>	<li><p>A zero length string is false. All other strings are true.</p></li></ul><p>Booleans are also produced as the result of expressions involving these operators:</p><ul>	<li><p><code>=</code> Equal to</p></li>	<li><p>!<code>=</code> Not equal to</p></li>	<li><p><code>&lt;</code> Less than (really <code>&amp;lt;</code>)</p></li>	<li><p><code>&gt;</code> Greater than</p></li>	<li><p><code>&lt;=</code> Less than or equal to (really <code>&amp;lt;=</code>)</p></li>	<li><p><code>&gt;=</code> Greater than or equal to</p></li></ul><dir><b><font face="Arial" size=1 color="#000080"><p>Caution</p></b></font><p>The <code>&lt;</code> sign must be replaced by <code>&amp;lt;</code> even when used as the less &#151;than operator in an XML document such as an XSLT style sheet.</p></dir><p>These operators are most commonly used in predicate tests to determine whether a rule should be invoked. An XPath expression can contain not only a pattern that selects certain nodes, but also a predicate that further filters the set of nodes selected. For example, <code>child::ATOM</code> selects all the <code>ATOM</code> children of the context node. However, <code>child::ATOM[position()=1]</code> selects only the first <code>ATOM</code> child of the context node. <code>[position()=1]</code> is a predicate on the node test <code>ATOM</code> that returns a boolean result: true if the position of the <code>ATOM</code> is equal to one; false otherwise. Each node test can have any number of predicates. However, more than one is unusual.</p><p>For example, this template rule applies to the first <code>ATOM</code> element in the periodic table, but not to subsequent ones, by testing whether or not the position of the element equals 1.</p><pre>&lt;xsl:template match="PERIODIC_TABLE/ATOM[position()=1]"&gt;  &lt;xsl:value-of select="."/&gt;&lt;/xsl:template&gt;</pre><p>This template rule applies to all <code>ATOM</code> elements that are not the first child element of the <code>PERIODIC_TABLE</code> by testing whether the position is greater than 1:</p><pre>&lt;xsl:template match="PERIODIC_TABLE/ATOM[position()&gt;1]"&gt;  &lt;xsl:value-of select="."/&gt;&lt;/xsl:template&gt;</pre><p>The keywords <code>and</code> and <code>or</code> logically combine two boolean expressions according to the normal rules of logic. For example, suppose you want a template that matches an <code>ATOMIC_NUMBER</code> element that is both the first and last child of its parent element; that is, it is the only element of its parent. This template rule uses <code>and</code> to accomplish that:</p><pre>&lt;xsl:template match="ATOMIC_NUMBER[position()=1 and position()=last()]"&gt;  &lt;xsl:value-of select="."/&gt;&lt;/xsl:template&gt;</pre><p>This template matches both the first and last <code>ATOM</code> elements in their parent by matching when the position is 1 or when the position is equal to the number of elements in the set (using the <code>last()</code> function):</p><pre>&lt;xsl:template match="ATOM[position()=1 or position()=last()]"&gt;  &lt;xsl:value-of select="."/&gt;&lt;/xsl:template&gt;</pre><p>This is logical <code>or</code>, so it will also match if both conditions are true. That is, it will match an <code>ATOM</code> that is both the first and last child of its parent (in other words, if the <code>ATOM</code> is the only child of its parent). </p><p>The <code>not()</code> function reverses the result of an operation. For example, this template rule matches all <code>ATOM</code> elements that are not the first child of their parents:</p><pre>&lt;xsl:template match="ATOM[not(position()=1)]"&gt;  &lt;xsl:value-of select="."/&gt;&lt;/xsl:template&gt;</pre><p>The same template rule could be written using the not equal operator <code>!=</code> instead:</p><pre>&lt;xsl:template match="ATOM[position()!=1]"&gt;  &lt;xsl:value-of select="."/&gt;&lt;/xsl:template&gt;</pre><p>This template rule matches all <code>ATOM</code> elements that are neither the first nor last <code>ATOM</code> child of their parent:</p><pre>&lt;xsl:template match = "ATOM[not(position()=1 or position()=last())]"&gt;  &lt;xsl:value-of select="."/&gt;&lt;/xsl:template&gt;</pre><p>XSLT does not have an exclusive <code>or</code> operator. However, one can be formed by judicious use of <code>not()</code>, <code>and</code>, and <code>or</code>. For example, this rule selects those <code>ATOM</code> elements that are either the first or last child, but not both:</p><pre>&lt;xsl:template match="ATOM[(position()=1 or position()=last())              and not(position()=1 and position()=last())]"&gt;  &lt;xsl:value-of select="."/&gt;&lt;/xsl:template&gt;</pre><p>There are three remaining functions that return booleans:</p><ul>	<li><p><code>true()</code> always returns true.</p></li>	<li><p><code>false()</code> always returns false.</p></li>	<li><p><code>lang(<i>code</i>)</code> returns true if the current node has the same language (as given by the <code>xml:lang</code> attribute) as the <i><code>code</i></code> argument.</p></li></ul><h4>Numbers</h4><p>XPath numbers are 64-bit IEEE 754 floating-point doubles. Even numbers like 43 or -7000 that look like integers are stored as doubles. Non-number values, such as strings and booleans, are converted to numbers automatically as necessary, or at user request through the <code>number()</code> function using these rules:</p><ul>	<li><p>Booleans are 1 if true, 0 if false.</p></li>	<li><p>A string is trimmed of leading and trailing white space, then converted to a number in the fashion you would expect; for example, the string &quot;12&quot; is converted to the number 12. If the string cannot be interpreted as a number, it is converted to NaN.</p></li>	<li><p>A node-set is converted to a string; the string is then converted to a number.</p></li></ul><p>For example, this template only outputs the transuranium elements; that is, those elements with atomic numbers greater than 92 (the atomic number of uranium). The node-set produced by <code>ATOMIC_NUMBER</code> is implicitly converted to the string value of the current <code>ATOMIC_NUMBER</code> node. This string is then converted into a number.</p><pre>&lt;xsl:template match="/PERIODIC_TABLE"&gt;  &lt;HTML&gt;    &lt;HEAD&gt;&lt;TITLE&gt;The Transuranium Elements&lt;/TITLE&gt;&lt;/HEAD&gt;    &lt;BODY&gt;      &lt;xsl:apply-templates select="ATOM[ATOMIC_NUMBER&gt;92]"/&gt;    &lt;/BODY&gt;  &lt;/HTML&gt;&lt;/xsl:template&gt;</pre><p>XPath provides the standard four arithmetic operators:</p><ul>	<li><p><code>+</code> for addition</p></li>	<li><p><code>-</code> for subtraction</p></li>	<li><p><code>*</code> for multiplication</p></li>	<li><p><code>div</code> for division (the more common <code>/</code> is already used for other purposes in XPath)</p></li></ul><p>For example, <code>&lt;xsl:value-of select="2+2"/&gt;</code> inserts the string &quot;4&quot; into the output document. These operations are more commonly used as part of a test. For example, this rule selects those elements whose atomic weight is more than twice their atomic number:</p><pre>&lt;xsl:template match="/PERIODIC_TABLE"&gt;  &lt;HTML&gt;    &lt;BODY&gt;      &lt;H1&gt;High Atomic Weight to Atomic Number Ratios&lt;/H1&gt;      &lt;xsl:apply-templates        select="ATOM[ATOMIC_WEIGHT &gt; 2 * ATOMIC_NUMBER]"/&gt;    &lt;/BODY&gt;  &lt;/HTML&gt;&lt;/xsl:template&gt;</pre><p>This template prints the ratio of atomic weight to atomic number:</p><pre>&lt;xsl:template match="ATOM"&gt;  &lt;p&gt;    &lt;xsl:value-of select="NAME"/&gt;    &lt;xsl:value-of select="ATOMIC_WEIGHT div ATOMIC_NUMBER"/&gt;  &lt;/p&gt;&lt;/xsl:template&gt;</pre><p>XPath also provides the less familiar <code>mod</code> operator, which takes the remainder of two numbers. When used in conjunction with <code>position()</code>, this operator enables you to perform tasks such as outputting every second <code>ATOM</code> or alternating colors between rows in a table. Just define templates that apply different styles when the position mod two is one and when it&#146;s zero. For example, these two rules use different colors for alternate rows of a table:</p><pre>   &lt;xsl:template match="ATOM[position() mod 2 = 1]"&gt;       &lt;TR&gt;        &lt;TD&gt;&lt;xsl:value-of select="NAME"/&gt;&lt;/TD&gt;        &lt;TD&gt;&lt;xsl:value-of select="ATOMIC_NUMBER"/&gt;&lt;/TD&gt;        &lt;TD&gt;&lt;xsl:apply-templates select="MELTING_POINT"/&gt;&lt;/TD&gt;      &lt;/TR&gt;   &lt;/xsl:template&gt;   &lt;xsl:template match="ATOM[position() mod 2 = 0]"&gt;       &lt;tr style="color: #666666"&gt;        &lt;TD&gt;&lt;xsl:value-of select="NAME"/&gt;&lt;/TD&gt;        &lt;TD&gt;&lt;xsl:value-of select="ATOMIC_NUMBER"/&gt;&lt;/TD&gt;        &lt;TD&gt;&lt;xsl:apply-templates select="MELTING_POINT"/&gt;&lt;/TD&gt;      &lt;/TR&gt;   &lt;/xsl:template&gt;</pre><p>You can change the divisor to 3 to apply different styles to every third element, to 4 to apply different styles to every fourth element, and so forth.</p><p>Finally, XPath includes four functions that operate on numbers:</p><ul>	<li><p><code>floor()</code> returns the greatest integer less than or equal to the number.</p></li>	<li><p><code>ceiling()</code> returns the smallest integer greater than or equal to the number.</p></li>	<li><p><code>round()</code> rounds the number to the nearest integer.</p></li>	<li><p><code>sum()</code> returns the sum of its arguments.</p></li></ul><p>For example, this template rule estimates the number of neutrons in an atom by subtracting the atomic number (the number of protons) from the atomic weight (the weighted average over the natural distribution of isotopes of the number of neutrons plus the number of protons) and rounding to the nearest integer:</p><pre>&lt;xsl:template match="ATOM"&gt;  &lt;p&gt;    &lt;xsl:value-of select="NAME"/&gt;    &lt;xsl:value-of     select="round(ATOMIC_WEIGHT - ATOMIC_NUMBER)"/&gt;  &lt;/p&gt;&lt;/xsl:template&gt;</pre><p>This rule calculates the average atomic weight of all the atoms in the table by adding all the atomic weights, and then dividing by the number of atoms:</p><pre>&lt;xsl:template match="/PERIODIC_TABLE"&gt;  &lt;HTML&gt;    &lt;BODY&gt;    &lt;H1&gt;Average Atomic Weight&lt;/H1&gt;      &lt;xsl:value-of       select="sum(descendant::ATOMIC_WEIGHT)               div count(descendant::ATOMIC_WEIGHT)"/&gt;    &lt;/BODY&gt;  &lt;/HTML&gt;&lt;/xsl:template&gt;</pre><h4>Strings</h4><p>A <i>string</i> is a sequence of Unicode characters. Other data types can be converted to strings using the <code>string()</code> function according to these rules:</p><ul><li><p>Node-sets are converted to strings by taking the value of the first node in the set, as calculated by the <code>xsl:value-of</code> element, according to the rules given in Table 15-1.</p></li>	<li><p>Result tree fragments are converted by acting as if they&#146;re contained in a single element, and then taking the value of that imaginary element. Again, the value of this element is calculated by the <code>xsl:value-of</code> element according to the rules given in Table 15-1. That is, all the result tree fragment&#146;s text (but not markup) is concatenated.</p></li>	<li><p>A number is converted to a European-style number string such as -12 or 3.1415292.</p></li>	<li><p>Boolean false is converted to the English word false. Boolean true is converted to the English word true.</p></li></ul><p>Besides <code>string()</code>, XSLT contains 10 functions that manipulate strings. These are summarized in Table 15-5.</p><font face="Arial"><p align="CENTER">Table 15-5</p><b><p align="CENTER">XPath String Functions</p></b></font><p align="CENTER"><center><table border cellspacing=1 bordercolor="#000000" width=389><tr><td width="37%" valign="TOP"><b><i><font face="Arial" size=1><p>Function</b></i></font></td><td width="16%" valign="TOP"><b><i><font face="Arial" size=1><p>Return Type</b></i></font></td><td width="47%" valign="TOP"><b><i><font face="Arial" size=1><p>Returns</b></i></font></td></tr><tr><td width="37%" valign="TOP"><code><font face="Arial" size=1><p>starts-with(<i>main_string</i>, <i>prefix_string</i>)</code></font></td><td width="16%" valign="TOP"><font face="Arial" size=1><p>Boolean</font></td><td width="47%" valign="TOP"><font face="Arial" size=1><p>True if <i><code>main_string</i></code> starts with <i><code>prefix_string</i></code>; false otherwise.</font></td></tr><tr><td width="37%" valign="TOP"><code><font face="Arial" size=1><p>contains(<i>containing_string</i>, <i>contained_string</i>)</code></font></td><td width="16%" valign="TOP"><font face="Arial" size=1><p>Boolean</font></td><td width="47%" valign="TOP"><font face="Arial" size=1><p>True if the <i><code>contained_string</i></code> is part of the <i><code>containing_string</i></code>; false otherwise.</font></td></tr><tr><td width="37%" valign="TOP"><code><font face="Arial" size=1><p>substring(<i>string</i>, <i>offset, length</i>)</code></font></td><td width="16%" valign="TOP"><font face="Arial" size=1><p>String</font></td><td width="47%" valign="TOP"><i><code><font face="Arial" size=1><p>length</i></code> characters from the specified <i><code>offset</i></code> in <i><code>string</i></code>; or all characters from the <i><code>offset</i></code> to the end of the <i><code>string</i></code> if <i><code>length</i></code> is omitted; <i><code>length</i></code> and <i><code>offset</i></code> are rounded to the nearest integer if necessary; the first character in the string is at offset 1.</font></td></tr><tr><td width="37%" valign="TOP"><code><font face="Arial" size=1><p>substring-before(<i>string</i>, <i>marker-string</i>)</code></font></td><td width="16%" valign="TOP"><font face="Arial" size=1><p>String</font></td><td width="47%" valign="TOP"><font face="Arial" size=1><p>The part of the <i><code>string</i></code> from the first character up to (but not including) the first occurrence of <i><code>marker-string.</i></code></font></td></tr><tr><td width="37%" valign="TOP"><code><font face="Arial" size=1><p>substring-after(<i>string</i>, <i>marker-string</i>)</code></font></td><td width="16%" valign="TOP"><font face="Arial" size=1><p>String</font></td><td width="47%" valign="TOP"><font face="Arial" size=1><p>The part of the <i><code>string</i></code> from the point immediately after the first occurrence of <i><code>marker-string</i></code> to the end of <i><code>string.</i></code></font></td></tr><tr><td width="37%" valign="TOP"><code><font face="Arial" size=1><p>string-length(<i>string</i>)</code></font></td><td width="16%" valign="TOP"><font face="Arial" size=1><p>Number</font></td><td width="47%" valign="TOP"><font face="Arial" size=1><p>The number of characters in <i><code>string.</i></code></font></td></tr><tr><td width="37%" valign="TOP"><code><font face="Arial" size=1><p>normalize-space(<i>string</i>)</code></font></td><td width="16%" valign="TOP"><font face="Arial" size=1><p>String</font></td><td width="47%" valign="TOP"><font face="Arial" size=1><p>The <i><code>string</i></code> after leading and trailing white space is stripped and runs of white space are replaced with a single space; if the argument is omitted the string value of the context node is normalized.</font></td></tr><tr><td width="37%" valign="TOP"><code><font face="Arial" size=1><p>translate(<i>string</i>, <i>replaced_text</i>, <i>replacement_text</i>)</code></font></td><td width="16%" valign="TOP"><font face="Arial" size=1><p>String</font></td><td width="47%" valign="TOP"><font face="Arial" size=1><p>Returns <i><code>string</i></code> with occurrences of characters in <i><code>replaced_text</i></code> replaced by the corresponding characters from <i><code>replacement_text.</i></code></font></td></tr><tr><td width="37%" valign="TOP"><code><font face="Arial" size=1><p>concat(<i>string1, string2, . . . </i>)</code></font></td><td width="16%" valign="TOP"><font face="Arial" size=1><p>String</font></td><td width="47%" valign="TOP"><font face="Arial" size=1><p>Returns the concatenation of as many strings as are passed as arguments in the order they were passed.</font></td></tr><tr><td width="37%" valign="TOP"><code><font face="Arial" size=1><p>format-number(<i>number, format-string, locale-string</i>)</code></font></td><td width="16%" valign="TOP"><font face="Arial" size=1><p>String</font></td><td width="47%" valign="TOP"><font face="Arial" size=1><p>Returns the string form of <i><code>number</i></code> formatted according to the specified <i><code>format-string</i></code> as if by Java 1.1's<i> </i><code>java.text.DecimalFormat</code> class (see <code>http://java.sun.com/products/archive/jdk/1.1/index.html</code>); the <i><code>locale-string</i></code> is an optional argument that provides the name of the <code>xsl:decimal-format</code> element used to interpret the <i><code>format-string.</i></code></font></td></tr></table></center></p><h2>The Default Template Rules</h2><p>Having to carefully map the hierarchy of an XML document in an XSLT style sheet may be inconvenient. This is especially true if the document does not follow a stable, predictable order like the periodic table, but rather throws elements together willy-nilly like many web pages. In those cases, you should have general rules that can find an element and apply templates to it regardless of where it appears in the source document.</p><p>To make this process easier, XSLT defines several default template rules that are implicitly included in all style sheets. The first default rule matches root and element nodes, and applies templates to all child nodes. The second default rule matches text nodes and attributes, copying their values into the output. Together, these two rules mean that even a blank XSLT style sheet with just one empty <code>xsl:stylesheet</code> element will still produce the raw character data of the input XML document as output.</p><h3>The default rule for elements</h3><p>The first default rule applies to element nodes and the root node:</p><pre>&lt;xsl:template match="*|/"&gt;  &lt;xsl:apply-templates/&gt;&lt;/xsl:template&gt;</pre><code><p>*|/</code> is XPath shorthand for &quot;any element node or the root node.&quot; The purpose of this rule is to ensure that all elements are recursively processed even if they aren&#146;t reached by following the explicit rules. That is, unless another rule overrides this one (especially for the root element), all element nodes will be processed.</p><p>However, once an explicit rule for any parent of an element is present, this rule will not be activated for the child elements unless the template rule for the parent has an <code>xsl:apply-templates</code> child. For example, you can stop all processing by matching the root element and neither applying templates nor using <code>xsl:for-each</code> to process the children, like this:</p><pre>&lt;xsl:template match="/"&gt;&lt;/xsl:template&gt;</pre><h3>The default rule for text nodes and attributes</h3><p>Exceptionally observant readers may have noted that several of the examples seem to have output the contents of some elements without actually taking the value of the element they were outputting! These contents were provided by XSLT&#146;s default rule for text and attribute nodes. This rule is as follows:</p><pre>&lt;xsl:template match="text()|@*"&gt;  &lt;xsl:value-of select="."/&gt;&lt;/xsl:template&gt;</pre><p>This rule matches all text and attribute nodes (<code>match="text()</code>|<code>@*"</code>) and outputs the value of the node (<code>&lt;xsl:value-of select="."/&gt;</code>). In other words, it copies the text from the input to the output. This rule ensures that, at the very least, an element&#146;s text is output, even if no rule specifically matches it. Another rule can override this one for specific elements where you want either more or less than the text content of an element.</p><p>This rule also copies attribute values (but not names). However, they turn from attributes in the input to simple text in the output. Because there's no default rule that ever applies templates to attributes, this rule won't be activated for attributes unless you specifically add a nondefault rule somewhere in the style sheet that does apply templates to attributes of one or more elements.</p><h3>The default rule for processing instructions and comments</h3><p>There&#146;s also a default rule for processing instructions and comments. It simply says to do nothing; that is, drop the processing instructions and comments from the output as if they didn&#146;t exist. It looks like this:</p><pre>&lt;xsl:template match="processing-instruction()|comment()"/&gt;</pre><p>You can, of course, replace this with your own rule for handling processing instructions and comments if you want to.</p><h3>Implications of the default rules</h3><p>Together, the default rules imply that applying an empty style sheet with only an <code>xsl:stylesheet</code> or <code>xsl:transform</code> element but no children (such as Listing 15-13) to an XML document copies all the <code>#PCDATA</code> out of the elements in the input to the output. However, this method produces no markup. These are, however, extremely low priority rules. Consequently, any other matches take precedence over the default rules.</p><font face="Arial"><p>Listing 15-13: An Empty XML Style Sheet</p></font><pre>&lt;?xml version="1.0"?&gt;&lt;xsl:stylesheet version="1.0"              xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;&lt;/xsl:stylesheet&gt;</pre><dir><b><font face="Arial" size=1 color="#000080"><p>Caution</p></b></font><p>One of the most common sources of confusion about XSLT in Internet Explorer 5.5 and earlier is that IE does not provide any of these default rules. You have to make sure that you explicitly match any node whose contents (including descendants) you want to output.</p></dir><h2>Attribute Value Templates</h2><p>Attribute value templates enable a style sheet to determine the content of an attribute dynamically based on the content of the input document rather than using a literal fixed value in the style sheet. For example, suppose you want to convert the periodic table into empty <code>ATOM</code> elements with this attribute-based form:</p><pre>&lt;ATOM NAME="Vanadium"  ATOMIC_WEIGHT="50.9415"  ATOMIC_NUMBER="23"/&gt;</pre><p>To do this, you must extract the contents of elements in the input document and place those in attribute values in the output document. The first thing you&#146;re likely to attempt is something similar to this:</p><pre>&lt;xsl:template match="ATOM"&gt;  &lt;ATOM NAME="&lt;xsl:value-of select='NAME'/&gt;"    ATOMIC_WEIGHT="&lt;xsl:value-of select='ATOMIC_WEIGHT'/&gt;"    ATOMIC_NUMBER="&lt;xsl:value-of select='ATOMIC_NUMBER'/&gt;"  /&gt;&lt;/xsl:template&gt;</pre><p>But this is malformed XML. The <code>&lt;</code> character is not allowed in an attribute value. Instead, inside attribute values, data enclosed in curly braces <code>{}</code>, takes the place of the <code>xsl:value-of</code> element. The correct way to write the preceding template rule is like this:</p><pre>&lt;xsl:template match="ATOM"&gt;  &lt;ATOM NAME="{NAME}"/&gt;    ATOMIC_WEIGHT="{ATOMIC_WEIGHT}"    ATOMIC_NUMBER="{ATOMIC_NUMBER}"  /&gt;&lt;/xsl:template&gt;</pre><p>In the output, <code>{NAME}</code> is replaced by the value of the <code>NAME</code> child element of the matched <code>ATOM</code>. <code>{ATOMIC_WEIGHT}</code> is replaced by the value of the <code>ATOMIC_WEIGHT</code> child element of the matched <code>ATOM</code>. <code>{ATOMIC_NUMBER}</code> is replaced by the value of the <code>ATOMIC_NUMBER</code> child element, and so on.</p><p>Attribute value templates can have more complicated patterns than merely an element name. In fact, you can use any XPath expression in an attribute value template. For example, this template rule selects <code>DENSITY</code> elements in the form seen in Listing 15-1:</p><pre>&lt;xsl:template match="DENSITY"&gt;  &lt;BULK_PROPERTY    NAME="DENSITY"    ATOM="{../NAME}"    VALUE="{normalize-space(.)}"    UNITS="{@UNITS}"  /&gt;&lt;/xsl:template&gt;</pre><p>It converts them into <code>BULK_PROPERTY</code> elements that look like this:</p><pre>&lt;BULK_PROPERTY NAME="DENSITY" ATOM="Helium"  VALUE="0.0001785" UNITS="grams/cubic centimeter"/&gt;</pre><p>Attribute values are not limited to a single attribute value template. You can combine an attribute value template with literal data or with other attribute value templates. For example, this template rule matches <code>ATOM</code> elements and replaces them with their name formatted as a link to a file in the format H.html, He.html, and so on. The filename is derived from the attribute value template <code>{SYMBOL}</code>, while the literal data provides the period and extension.</p><pre>&lt;xsl:template match="ATOM"&gt;  &lt;A HREF="{SYMBOL}.html"&gt;    &lt;xsl:value-of select="NAME"/&gt;  &lt;/A&gt;&lt;/xsl:template&gt;</pre><p>More than one attribute value template can be included in an attribute value. For example, this template rule includes the density units as part of the <code>VALUE</code> attribute rather than making them a separate attribute:</p><pre>&lt;xsl:template match="DENSITY"&gt;  &lt;BULK_PROPERTY    NAME="DENSITY"    ATOM="{../NAME}"    VALUE="{normalize-space(.)} {@UNITS}"  /&gt;&lt;/xsl:template&gt;</pre><p>You can place attribute value templates in many attributes in an XSLT style sheet. This is particularly important in <code>xsl:element</code>, <code>xsl:attribute</code>, and <code>xsl:processing-instruction</code> elements (discussed in the next section), where attribute value templates allow the designer to defer the decision about exactly what element, attribute, or processing instruction appears in the output until the input document is read. You cannot use attribute value templates as the value of a <code>select</code> or <code>match</code> attribute, an <code>xmlns</code> attribute, an attribute that provides the name of another XSLT instruction element, or an attribute of a top-level element (one that&#146;s an immediate child of <code>xsl:stylesheet</code>).</p><h2>Deciding What Output to Include</h2><p>It&#146;s often necessary to defer decisions about what markup to emit until the input document has been read. For example, you might want to change the contents of a <code>FILENAME</code> element into the <code>HREF</code> attribute of an <code>A</code> element, or replace one element type in the input with several different element types in the output depending on the value of an attribute. This is accomplished with <code>xsl:element</code>, <code>xsl:attribute</code>, <code>xsl:processing-instruction</code>, <code>xsl:comment</code>, and <code>xsl:text</code> elements. </p><h2>Inserting elements into the output with xsl:element</h2><p>Elements are usually included in the output document simply by including the literal start- and end-tags in template content. For instance, to insert a <code>P</code> element, you merely type <code>&lt;P&gt;</code> and <code>&lt;/P&gt;</code> at the appropriate points in the style sheet. However, occasionally, you need to use details from the input document to determine which element to place in the output document. This might happen, for example, when making a transformation from a source vocabulary that uses attributes for information to an output vocabulary that uses elements for the same information.</p><p>The <code>xsl:element</code> element inserts an element into the output document. The name of the element is given by an attribute value template in the <code>name</code> attribute of <code>xsl:element</code>. The content of the element derives from the content of the <code>xsl:element</code> element, which may include <code>xsl:attribute</code>, <code>xsl:processing-instruction,</code> and <code>xsl:comment</code> instructions (all discussed shortly) to insert these items.</p><p>For example, suppose you want to replace the <code>ATOM</code> elements with <code>GAS</code>, <code>LIQUID</code>, and <code>SOLID</code> elements, depending on the value of the <code>STATE</code> attribute. Using <code>xsl:element</code>, a single rule can do this by converting the value of the <code>STATE</code> attribute to an element name. This is how it is done:</p><pre>&lt;xsl:template match="ATOM"&gt;  &lt;xsl:element name="{@STATE}"&gt;    &lt;NAME&gt;&lt;xsl:value-of select="NAME"/&gt;&lt;/NAME&gt;    &lt;!-- rules for other children&#133; --&gt;  &lt;/xsl:element&gt;&lt;/xsl:template&gt;</pre><p>By using more complicated attribute value templates, you can perform most of the calculations that you might need.</p><h2>Inserting attributes into the output with xsl:attribute</h2><p>You can include attributes in the output document simply by typing the literal attributes themselves. For example, to insert a <code>DIV</code> element with an <code>ALIGN</code> attribute bearing the value <code>CENTER</code>, you merely type <code>&lt;DIV ALIGN="CENTER"&gt;</code> and <code>&lt;/DIV&gt;</code> at the appropriate points in the style sheet. However, you frequently have to rely on data that you read from the input document to determine an attribute value and sometimes even to determine the attribute name.</p><p>For example, suppose you want a style sheet that selects atom names and formats them as links to files named H.html, He.html, Li.html, and so forth, like this:</p><pre>&lt;LI&gt;&lt;A HREF="H.html"&gt;Hydrogen&lt;/A&gt;&lt;/LI&gt;&lt;LI&gt;&lt;A HREF="He.html"&gt;Helium&lt;/A&gt;&lt;/LI&gt;&lt;LI&gt;&lt;A HREF="Li.html"&gt;Lithium&lt;/A&gt;&lt;/LI&gt;</pre><p>Each different element in the input will have a different value for the <code>HREF</code> attribute. The <code>xsl:attribute</code> element calculates an attribute name and value and inserts it into the output. Each <code>xsl:attribute</code> element is a child of either an <code>xsl:element</code> element or a literal result element. The attribute calculated by <code>xsl:attribute</code> will be attached to the element calculated by its parent in the output. The name of the attribute is specified by the <code>name</code> attribute of the <code>xsl:attribute</code> element. The value of the attribute is given by the contents of the <code>xsl:attribute</code> element. For example, this template rule produces the output previously shown:</p><pre>&lt;xsl:template match="ATOM"&gt;  &lt;LI&gt;&lt;A&gt;    &lt;xsl:attribute name="HREF"&gt;      &lt;xsl:value-of select="SYMBOL"/&gt;.html    &lt;/xsl:attribute&gt;    &lt;xsl:value-of select="NAME"/&gt;  &lt;/A&gt;&lt;/LI&gt;&lt;/xsl:template&gt;</pre><p>All <code>xsl:attribute</code> elements must come before any other content of their parent element. You can&#146;t add an attribute to an element after you&#146;ve already started writing out its content. For example, this template is illegal:</p><pre>&lt;xsl:template match="ATOM"&gt;  &lt;LI&gt;&lt;A&gt;    &lt;xsl:value-of select="NAME"/&gt;    &lt;xsl:attribute name="HREF"&gt;      &lt;xsl:value-of select="SYMBOL"/&gt;.html    &lt;/xsl:attribute&gt;  &lt;/A&gt;&lt;/LI&gt;&lt;/xsl:template&gt;</pre><h2>Defining attribute sets</h2><p>You often need to apply the same group of attributes to many different elements of either the same or different classes. For example, you might want to apply a <code>style</code> attribute to each cell in an HTML table. To make this simpler, you can define one or more attributes as members of an attribute set at the top level of the style sheet with <code>xsl:attribute-set</code>, and then include that attribute set in an element with an <code>xsl:use-attribute-sets</code> attribute.</p><p>For example, this <code>xsl:attribute-set</code> element defines an element named <code>CELLSTYLE</code> with a <code>font-family</code> attribute of <code>New York</code>, <code>Times</code> <code>New Roman</code>, <code>Times</code>, <code>serif</code>, and a <code>font-size</code> attribute of <code>12pt</code>:</p><pre>&lt;xsl:attribute-set name="CELLSTYLE"&gt;  &lt;xsl:attribute name="font-family"&gt;    New York, Times New Roman, Times, serif  &lt;/xsl:attribute&gt;  &lt;xsl:attribute name="font-size"&gt;12pt&lt;/xsl:attribute&gt;&lt;/xsl:attribute-set&gt;</pre><p>This template rule then applies those attributes to <code>TD</code> elements in the output:</p><pre>&lt;xsl:template match="ATOM"&gt;  &lt;TR&gt;    &lt;TD xsl:use-attribute-sets="CELLSTYLE"&gt;      &lt;xsl:value-of select="NAME"/&gt;    &lt;/TD&gt;    &lt;TD xsl:use-attribute-sets="CELLSTYLE"&gt;      &lt;xsl:value-of select="ATOMIC_NUMBER"/&gt;    &lt;/TD&gt;  &lt;/TR&gt;&lt;/xsl:template&gt;</pre><p>An element can use more than one attribute set by specifying the names of the all the sets in a white-space-separated list in the value of the <code>xsl:use-attribute-sets</code> attribute. All attributes from all the sets are applied to the element. For example, this <code>TD</code> element possesses attributes from both the <code>CELLSTYLE</code> and the <code>NUMBERSTYLE</code> attribute sets:</p><pre>    &lt;TD xsl:use-attribute-sets="CELLSTYLE NUMBERSTYLE"&gt;      &lt;xsl:value-of select="ATOMIC_NUMBER"/&gt;    &lt;/TD&gt;</pre><p>If more than one attribute set defines the same attribute, the last attribute set mentioned is used. If there is more than one attribute set with the same name, the attributes in the sets are merged.</p><p>You can also include attribute sets in particular elements by adding a <code>use-attribute-sets</code> element to an <code>xsl:element</code>, <code>xsl:copy</code>, or <code>xsl:attribute-set</code> element, as in the following example:</p><pre>    &lt;xsl:element name="TD" use-attribute-sets="CELLSTYLE"&gt;      &lt;xsl:value-of select="ATOMIC_NUMBER"/&gt;    &lt;/xsl:element&gt;</pre><p>The <code>xsl:</code> prefix is unnecessary (and in fact prohibited) when <code>use-attribute-sets</code> is an attribute of an XSLT element rather than a literal result element.</p><h2>Generating processing instructions with xsl:processing-instruction</h2><p>The <code>xsl:processing-instruction</code> element places a processing instruction in the output document. The target of the processing instruction is specified by a required <code>name</code> attribute. The contents of the <code>xsl:processing-instruction</code> element become the contents of the processing instruction. For example, this rule replaces <code>PROGRAM</code> elements with a <code>gcc</code> processing instruction:</p><pre>&lt;xsl:template match="PROGRAM"&gt;  &lt;xsl:processing-instruction name="gcc"&gt; -O4  &lt;/xsl:processing-instruction&gt;&lt;/xsl:template&gt;</pre><code><p>PROGRAM</code> elements in the input are replaced by this processing instruction in the output:</p><pre>&lt;?gcc -O4  ?&gt;</pre><p>The contents of the <code>xsl:processing-instruction</code> element can include <code>xsl:value-of</code> elements and <code>xsl:apply-templates</code> elements, provided the result of these instructions is pure text. For example:</p><pre>&lt;xsl:template match="PROGRAM"&gt;  &lt;xsl:processing-instruction name="gcc"&gt;-O4    &lt;xsl:value-of select="NAME"/&gt;  &lt;/xsl:processing-instruction&gt;&lt;/xsl:template&gt;</pre><p>The <code>xsl:processing-instruction</code> element cannot contain <code>xsl:element</code> and other instructions that produce elements and attributes in the result. Furthermore, <code>xsl:processing-instruction</code> cannot include any instructions or literal text that insert a <code>?&gt;</code> in the output, because that would prematurely end the processing instruction.</p><h2>Generating comments with xsl:comment</h2><p>The <code>xsl:comment</code> element inserts a comment in the output document. It has no attributes. Its contents are the text of the comment, as in the following example:</p><pre>&lt;xsl:template match="ATOM"&gt;  &lt;xsl:comment&gt;There was an atom here once.&lt;/xsl:comment&gt;&lt;/xsl:template&gt;</pre><p>This rule replaces <code>ATOM</code> nodes with the following comment:</p><pre>&lt;!--There was an atom here once.--&gt;</pre><p>The contents of the <code>xsl:comment</code> element can include <code>xsl:value-of</code> elements and <code>xsl:apply-templates</code> elements, provided the results of these instructions are pure text. It cannot contain <code>xsl:element</code> and other instructions that produce elements and attributes in the result. Furthermore, <code>xsl:comment</code> cannot include any instructions or literal text that inserts a double hyphen in the comment. This would result in a malformed comment in the output.</p><h2>Generating text with xsl:text</h2><p>The <code>xsl:text</code> element inserts its contents into the output document as literal text. For example, this rule replaces each <code>ATOM</code> element with the string &quot;There was an atom here once&quot;:</p><pre>&lt;xsl:template match="ATOM"&gt;  &lt;xsl:text&gt;There was an atom here once.&lt;/xsl:text&gt;&lt;/xsl:template&gt;</pre><p>The <code>xsl:text</code> element isn&#146;t often used because most of the time it&#146;s easier to simply type the text. However, <code>xsl:text</code> does have a couple of advantages. The first is that it preserves white space exactly, even if the node contains nothing but white space. By default, XSLT processors delete all text nodes from the style sheet that contain only white space. Thus, this element is useful when dealing with concrete poetry, computer source code, or other text in which white space is significant.</p><p>The <code>xsl:text</code> element also enables you to insert unescaped <code>&lt;</code> and <code>&amp;</code> into your output document that are not converted to <code>&amp;lt;</code> and <code>&amp;amp;</code>. To do this, place the general entity reference for the symbol (<code>&amp;lt;</code> or <code>&amp;amp;</code>) in an <code>xsl:text</code> element; then set the <code>xsl:text</code> element's <code>disable-output-escaping</code> attribute to <code>yes</code>. This can be useful when you need to include JavaScript source code in the output document, as in the following example:</p><pre>&lt;xsl:template match="SCRIPT"&gt;  &lt;script language="javascript"&gt;    &lt;xsl:text disable-output-escaping="yes"&gt;      &amp;lt;!-- if (         location.host.tolowercase().indexof("ibiblio")         &amp;lt; 0) {           location.href="http://www.ibiblio.org/";        }      } // --&amp;gt;    &lt;/xsl:text&gt;  &lt;/script&gt;&lt;/xsl:template&gt;</pre><p>This may produce output that is not well-formed XML. However, if you&#146;re trying to write a non-XML format, such as HTML or TeX, this may be what you want. Note, however, that the style sheet and the input document are both still well-formed XML.</p><h2>Copying the Context Node with xsl:copy</h2><p>The <code>xsl:copy</code> element copies the source node into the output tree. Child elements, attributes, and other content are not automatically copied. However, the contents of the <code>xsl:copy</code> element are a template that can select these things to be copied as well. This is often useful when transforming a document from one markup vocabulary to the same or a closely related markup vocabulary. For example, this template rule strips the attributes and child elements off an <code>ATOM</code> and replaces it with the value of its contents enclosed in a <code>B</code> element:</p><pre>&lt;xsl:template match="ATOM"&gt;   &lt;xsl:copy&gt;     &lt;B&gt;&lt;xsl:value-of select="."/&gt;&lt;/B&gt;   &lt;/xsl:copy&gt;&lt;/xsl:template&gt;</pre><p>One useful template <code>xsl:copy</code> makes possible is the identity transformation; that is, a transformation from a document into itself. Such a transformation looks like this:</p><pre>&lt;xsl:template   match="*|@*|comment()|processing-instruction()|text()"&gt;  &lt;xsl:copy&gt;    &lt;xsl:apply-templates     select="*|@*|comment()|processing-instruction()|text()"/&gt;  &lt;/xsl:copy&gt;&lt;/xsl:template&gt;</pre><p>You can adjust the identity transformation a little to produce similar documents. For example, Listing 15-14 is a style sheet that strips comments from a document, leaving the document otherwise untouched. It simply omits the <code>comment()</code> node test from the <code>match</code> and <code>select</code> attribute values in the identity transformation.</p><font face="Arial"><p>Listing 15-14: An XSLT Style Sheet That Strips Comments from a Document</p></font><pre>&lt;?xml version="1.0"?&gt;&lt;xsl:stylesheet version="1.0"  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;  &lt;xsl:template      match="*|@*|processing-instruction()|text()"&gt;    &lt;xsl:copy&gt;      &lt;xsl:apply-templates        select="*|@*|processing-instruction()|text()"/&gt;    &lt;/xsl:copy&gt;  &lt;/xsl:template&gt;&lt;/xsl:stylesheet&gt;</pre><code><p>xsl:copy</code> only copies the source node. However, it does not automatically copy the node&#146;s attributes, children, or namespaces. In other words, it is a shallow copy. To deep copy the entire node including all its attributes and descendants, use <code>xsl:copy-of</code>. The <code>select</code> attribute of <code>xsl:copy-of</code> chooses the nodes to be copied. For example, Listing 15-15 is a style sheet that uses <code>xsl:copy-of</code> to strip out elements without melting points from the periodic table by copying only <code>ATOM</code> elements that have <code>MELTING_POINT</code> children.</p><font face="Arial"><p>Listing 15-15: A Style Sheet That Copies only ATOM Elements That Have MELTING_POINT Children</p></font><pre>&lt;?xml version="1.0"?&gt;&lt;xsl:stylesheet version="1.0"  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;    &lt;xsl:template match="/PERIODIC_TABLE"&gt;      &lt;PERIODIC_TABLE&gt;        &lt;xsl:apply-templates select="ATOM"/&gt;      &lt;/PERIODIC_TABLE&gt;    &lt;/xsl:template&gt;    &lt;xsl:template match="ATOM"&gt;                  &lt;xsl:apply-templates select="MELTING_POINT"/&gt;    &lt;/xsl:template&gt;   &lt;xsl:template match="MELTING_POINT"&gt;     &lt;xsl:copy-of select=".."/&gt;  &lt;/xsl:template&gt;&lt;/xsl:stylesheet&gt;</pre><dir><b><font face="Arial" size=1 color="#000080"><p>Note</p></b></font><p>Listings 15-14 and 15-15 are examples of XSL transformations from a source vocabulary to the same vocabulary. Unlike most of the examples in this chapter, they do not transform to well-formed HTML.</p></dir><h2>Counting Nodes with xsl:number</h2><p>The <code>xsl:number</code> element inserts a formatted integer into the output document. The value of the integer is given by the <code>value</code> attribute. This contains a number, which is rounded to the nearest integer, then formatted according to the value of the <code>format</code> attribute. Reasonable defaults are provided for both these attributes. For example, consider the style sheet for the <code>ATOM</code> elements in Listing 15-16.</p><font face="Arial"><p>Listing 15-16: An XSLT Style Sheet That Counts Atoms</p></font><pre>&lt;?xml version="1.0"?&gt;&lt;xsl:stylesheet version="1.0"   xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;    &lt;xsl:template match="PERIODIC_TABLE"&gt;      &lt;HTML&gt;        &lt;HEAD&gt;&lt;TITLE&gt;The Elements&lt;/TITLE&gt;&lt;/HEAD&gt;        &lt;BODY&gt;          &lt;TABLE&gt;            &lt;TR&gt;&lt;xsl:apply-templates select="ATOM"/&gt;&lt;/TR&gt;          &lt;/TABLE&gt;        &lt;/BODY&gt;      &lt;/HTML&gt;    &lt;/xsl:template&gt;    &lt;xsl:template match="ATOM"&gt;      &lt;TD&gt;&lt;xsl:number value="ATOMIC_NUMBER"/&gt;&lt;/TD&gt;          &lt;TD&gt;&lt;xsl:value-of select="NAME"/&gt;&lt;/TD&gt;    &lt;/xsl:template&gt;&lt;/xsl:stylesheet&gt;</pre><p>When this style sheet is applied to Listing 15-1, the output appears like this:</p><pre>&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;The Elements&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;TABLE&gt;&lt;TR&gt;&lt;TD&gt;1&lt;/TD&gt;&lt;TD&gt;Hydrogen&lt;/TD&gt;&lt;TD&gt;2&lt;/TD&gt;&lt;TD&gt;Helium&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&lt;/BODY&gt;&lt;/HTML&gt;</pre><p>Each element is matched with its atomic number. The <code>value</code> attribute can contain any data that XPath knows how to convert to a number. In this case, the <code>ATOMIC_NUMBER</code> child element of the matched <code>ATOM</code> is converted.</p><h2>Default numbers</h2><p>If you use the <code>value</code> attribute to calculate the number, that&#146;s all you need. However, if the <code>value</code> attribute is omitted, the position of the current node in the source tree is used as the number. For example, consider Listing 15-17, which produces a table of atoms that have boiling points less than or equal to the boiling point of nitrogen.</p><font face="Arial"><p>Listing 15-17: An XSLT Style Sheet That Counts Atoms</p></font><pre>&lt;?xml version="1.0"?&gt;&lt;xsl:stylesheet version="1.0"   xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;    &lt;xsl:template match="PERIODIC_TABLE"&gt;      &lt;HTML&gt;        &lt;HEAD&gt;&lt;TITLE&gt;The Elements&lt;/TITLE&gt;&lt;/HEAD&gt;        &lt;BODY&gt;          &lt;TABLE&gt;            &lt;TR&gt;              &lt;TD&gt;Name&lt;/TD&gt;              &lt;TD&gt;Position&lt;/TD&gt;              &lt;TD&gt;Default Number&lt;/TD&gt;              &lt;TD&gt;Boiling Point&lt;/TD&gt;            &lt;/TR&gt;            &lt;xsl:apply-templates               select="ATOM[BOILING_POINT &amp;lt;= 77.344]"/&gt;          &lt;/TABLE&gt;        &lt;/BODY&gt;      &lt;/HTML&gt;    &lt;/xsl:template&gt;    &lt;xsl:template match="ATOM"&gt;      &lt;TR&gt;        &lt;TD&gt;&lt;xsl:value-of select="NAME"/&gt;&lt;/TD&gt;        &lt;TD&gt;&lt;xsl:number value="position()"/&gt;&lt;/TD&gt;        &lt;TD&gt;&lt;xsl:number/&gt;&lt;/TD&gt;        &lt;TD&gt;&lt;xsl:number value="BOILING_POINT"/&gt;&lt;/TD&gt;      &lt;/TR&gt;    &lt;/xsl:template&gt;&lt;/xsl:stylesheet&gt;</pre><p>Figure 15-4 shows the finished table produced by applying this style sheet to the complete periodic table. This shows that the default value calculated by <code>xsl:number</code> is the position of the node among other sibling nodes of the same type (<code>ATOM</code> elements in this case). This is not the same as the number returned by the <code>position()</code> function, which only calculates position relative to other nodes in the context node list (the nodes which the template matched&#150;hydrogen, helium, nitrogen, and neon, in this example). You can change what <code>xsl:number</code> counts using these three attributes:</p><ul>	<li><p><code>level</code></p></li>	<li><p><code>count</code></p></li>	<li><p><code>from</code></p></li></ul><p><img src="Image9.gif" width=381 height=134></p><p>Figure 15-4: Atoms with boiling points less than or equal to nitrogen&#146;s</p><h2>Number to string conversion</h2><p>Until now, I&#146;ve implicitly assumed that numbers looked like 1, 2, 3, and so on; that is, a European numeral starting from 1 and counting by 1. However, that&#146;s not the only possibility. For example, the page numbers in the preface and other front matter of books often appear in small Roman numerals such as i, ii, iii, iv, and so on. And different countries use different conventions to group the digits, separate the integer and fractional parts of a real number, and represent the symbols for the various digits. These are all adjustable through four attributes of <code>xsl:number</code>:</p><ul>	<li><p><code>format</code></p></li>	<li><p><code>letter-value</code></p></li>	<li><p><code>grouping-separator</code></p></li>	<li><p><code>grouping-size</code></p></li></ul><h4>The format attribute</h4><p>You can adjust the numbering style used by <code>xsl:number</code> using the <code>format</code> attribute. This attribute generally has one of the following values:</p><ul>	<li><p><code>i</code>&#150;The lowercase Roman numerals i, ii, iii, iv, v, vi, . . .</p></li>	<li><p><code>I</code>&#150;The uppercase Roman numerals I, II, III, IV, V, VI, . . .</p></li>	<li><p><code>a</code>&#150;The lowercase letters a, b, c, d, e, f, . . .</p></li>	<li><p><code>A</code>&#150;The uppercase letters A, B, C, D, E, F, . . .</p></li></ul><p>For example, this rule numbers the atoms with capital Roman numerals:</p><pre>&lt;xsl:template match="ATOM"&gt;  &lt;P&gt;    &lt;xsl:number value="position()" format="I"/&gt;    &lt;xsl:value-of select="."/&gt;  &lt;/P&gt;&lt;/xsl:template&gt;</pre><p>You can specify decimal numbering with leading zeros by including the number of leading zeros you want in the <code>format</code> attribute. For example, setting <code>format="01"</code> produces the sequence 01, 02, 03, 04, 05, 06, 07, 08, 09, 10, 11, 12, . . .. You might find this useful when lining numbers up in columns.</p><h4>The letter-value attribute</h4><p>The <code>letter-value</code> attribute distinguishes between letters interpreted as numbers and letters interpreted as letters. For instance, if you want to use <code>format="I"</code> to start the sequence I, J, K, L, M, N, . . . instead of I, II, III, IV, V, VI, . . ., you would set the <code>letter-value</code> attribute to the keyword <code>alphabetic</code>. The keyword <code>traditional</code> specifies a numeric sequence, as in the following example:</p><pre>&lt;xsl:template match="ATOM"&gt;  &lt;P&gt;   &lt;xsl:number value="position()"               format="I" letter-value="alphabetic"/&gt;   &lt;xsl:value-of select="."/&gt;  &lt;/P&gt;&lt;/xsl:template&gt;</pre><h4>Grouping attributes</h4><p>In the United States, we tend to write large numbers with commas grouping every three digits; for example, 4,567,302,000. However, in many languages and countries, a period or a space separates the groups instead; for instance, 4.567.302.000 or 4 567 302 000. Furthermore, in some countries, it&#146;s customary to group large numbers every four digits instead of every three; for example, 4,5673,0000.</p><p>The <code>grouping-separator</code> attribute specifies the grouping separator used between groups of digits. The <code>grouping-size</code> attribute specifies the number of digits used in a group, as in the following example:</p><pre>&lt;xsl:number grouping-separator=" " grouping-SIZE="3"/&gt;</pre><p>Generally, you'd make these attributes contingent on the language.</p><h2>Sorting Output</h2><p>The <code>xsl:sort</code> element sorts the output nodes into a different order than they were generated in. An <code>xsl:sort</code> element appears as a child of an <code>xsl:apply-templates</code> element or <code>xsl:for-each</code> element. The <code>select</code> attribute of the <code>xsl:sort</code> element defines the key used to sort the element&#146;s output by <code>xsl:apply-templates</code> or <code>xsl:for-each</code>.</p><p>By default, sorting is performed in alphabetical order of the keys. If more than one <code>xsl:sort</code> element is present in a given <code>xsl:apply-templates</code> or <code>xsl:for-each</code> element, the elements are sorted first by the first key, then by the second key, and so on. If any elements still compare equally, they are output in the order they appear in the source document.</p><p>For example, suppose you have a file full of <code>ATOM</code> elements arranged alphabetically. To sort by atomic number, you can use the style sheet in Listing 15-18.</p><font face="Arial"><p>Listing 15-18: An XSLT Style Sheet That Sorts by Atomic Number</p></font><pre>&lt;?xml version="1.0"?&gt;&lt;xsl:stylesheet version="1.0"   xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;    &lt;xsl:template match="PERIODIC_TABLE"&gt;      &lt;HTML&gt;        &lt;HEAD&gt;          &lt;TITLE&gt;Atomic Number vs. Atomic Weight&lt;/TITLE&gt;        &lt;/HEAD&gt;        &lt;BODY&gt;          &lt;H1&gt;Atomic Number vs. Atomic Weight&lt;/H1&gt;          &lt;TABLE&gt;            &lt;TH&gt;Element&lt;/TH&gt;            &lt;TH&gt;Atomic Number&lt;/TH&gt;            &lt;TH&gt;Atomic Weight&lt;/TH&gt;            &lt;xsl:apply-templates&gt;              &lt;xsl:sort select="ATOMIC_NUMBER"/&gt;            &lt;/xsl:apply-templates&gt;          &lt;/TABLE&gt;        &lt;/BODY&gt;      &lt;/HTML&gt;    &lt;/xsl:template&gt;    &lt;xsl:template match="ATOM"&gt;      &lt;TR&gt;        &lt;TD&gt;&lt;xsl:apply-templates select="NAME"/&gt;&lt;/TD&gt;        &lt;TD&gt;&lt;xsl:apply-templates select="ATOMIC_NUMBER"/&gt;&lt;/TD&gt;        &lt;TD&gt;&lt;xsl:apply-templates select="ATOMIC_WEIGHT"/&gt;&lt;/TD&gt;      &lt;/TR&gt;    &lt;/xsl:template&gt;&lt;/xsl:stylesheet&gt;</pre><p>Figure 15-5 shows the limits of alphabetical sorting. Hydrogen, atomic number 1, is the first element. However, the second element is not helium, atomic number 2, but rather neon, atomic number 10. Although 10 sorts after 9 numerically, alphabetically 10 falls before 2.</p><p><img src="Image10.gif" width=384 height=287></p><p>Figure 15-5: Atoms alphabetically sorted by atomic number</p><p>You can, however, adjust the order of the sort by setting the optional <code>data-type</code> attribute to the value <code>number</code>, as in this element:</p><pre>&lt;xsl:sort data-type="number" select="ATOMIC_NUMBER"/&gt;</pre><p>Figure 15-6 shows the elements sorted properly.</p><p><img src="Image11.gif" width=384 height=287></p><p>Figure 15-6: Atoms numerically sorted by atomic number</p><p>You can change the order of the sort from the default ascending order to descending by setting the <code>order</code> attribute to <code>descending</code>, like this:</p><pre>&lt;xsl:sort order="descending"          data-type="number"          select="ATOMIC_NUMBER"/&gt;</pre><p>This sorts the elements from the largest atomic number to the smallest so that hydrogen now appears last in the list.</p><p>Alphabetical sorting naturally depends on the alphabet. The <code>lang</code> attribute can set the language of the keys. The value of this attribute should be an ISO 639 language code such as <code>en</code> for English. However, processors are not required to know how to sort in all the different languages that might be encountered in XML. While English sorting is fairly straightforward, many other languages require much more complicated algorithms. Indeed, a few languages actually have multiple standard ways of sorting based on different criteria. The <code>lang</code> attribute is ignored if <code>data-type</code> is <code>number</code>.</p><dir><b><font face="Arial" size=1 color="#000080"><p>Cross-Reference</p></b></font><p>These are the same values supported by the <code>xml:lang</code> attribute discussed in Chapter 6.</p></dir><p>Finally, you can set the <code>case-order</code> attribute to one of the two values, <code>upper-first</code> or <code>lower-first</code>, to specify whether uppercase letters sort before lowercase letters or vice versa. The default depends on the language.</p><h2>Modes</h2><p>Sometimes you want to include the same content from the source document in the output document multiple times. That&#146;s easy to do simply by applying templates multiple times, once in each place where you want the data to appear. However, suppose you want the data to be formatted differently in different locations? That&#146;s a little trickier.</p><p>For example, suppose you want the output of processing the periodic table to be a series of 100 links to more detailed descriptions of the individual atoms. In this case, the output document would start like this:</p><pre>&lt;UL&gt;&lt;LI&gt;&lt;A HREF="#Ac"&gt;Actinium&lt;/A&gt;&lt;/LI&gt;&lt;LI&gt;&lt;A HREF="#Al"&gt;Aluminum&lt;/A&gt;&lt;/LI&gt;&lt;LI&gt;&lt;A HREF="#Am"&gt;Americium&lt;/A&gt;&lt;/LI&gt;&lt;LI&gt;&lt;A HREF="#Sb"&gt;Antimony&lt;/A&gt;&lt;/LI&gt;&lt;LI&gt;&lt;A HREF="#Ar"&gt;Argon&lt;/A&gt;&lt;/LI&gt;&#133;</pre><p>Later in the document, the actual atom descriptions would appear, formatted like this:</p><pre>&lt;H3&gt;&lt;A NAME="H"&gt;Hydrogen&lt;/A&gt;&lt;/H3&gt;&lt;P&gt;    Hydrogen    H    1    1.00794    20.28    13.81      0.0000899  &lt;/P&gt;</pre><p>This sort of application is common anytime you automatically generate a table of contents or an index. The <code>NAME</code> of the atom must be formatted differently in the table of contents than in the body of the document. You need two different rules that both apply to the <code>ATOM</code> element at different places in the document. The solution is to give each of the different rules a <code>mode</code> attribute. Then you can choose which template to apply by setting the <code>mode</code> attribute of the <code>xsl:apply-templates</code> element. Listing 15-19 demonstrates.</p><font face="Arial"><p>Listing 15-19: An XSLT Style Sheet That Uses Modes to Format the Same Data Differently in Two Different Places</p></font><pre>&lt;?xml version="1.0"?&gt;&lt;xsl:stylesheet version="1.0"  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;  &lt;xsl:template match="/PERIODIC_TABLE"&gt;    &lt;HTML&gt;      &lt;HEAD&gt;&lt;TITLE&gt;The Elements&lt;/TITLE&gt;&lt;/HEAD&gt;      &lt;BODY&gt;        &lt;H2&gt;Table of Contents&lt;/H2&gt;        &lt;UL&gt;          &lt;xsl:apply-templates select="ATOM" mode="toc"/&gt;        &lt;/UL&gt;        &lt;H2&gt;The Elements&lt;/H2&gt;        &lt;xsl:apply-templates select="ATOM" mode="full"/&gt;      &lt;/BODY&gt;    &lt;/HTML&gt;  &lt;/xsl:template&gt;  &lt;xsl:template match="ATOM" mode="toc"&gt;    &lt;LI&gt;&lt;A&gt;      &lt;xsl:attribute name="HREF"&gt;#&lt;xsl:value-of        select="SYMBOL"/&gt;&lt;/xsl:attribute&gt;      &lt;xsl:value-of select="NAME"/&gt;    &lt;/A&gt;&lt;/LI&gt;  &lt;/xsl:template&gt;  &lt;xsl:template match="ATOM" mode="full"&gt;    &lt;H3&gt;&lt;A&gt;      &lt;xsl:attribute name="NAME"&gt;        &lt;xsl:value-of select="SYMBOL"/&gt;      &lt;/xsl:attribute&gt;      &lt;xsl:value-of select="NAME"/&gt;    &lt;/A&gt;&lt;/H3&gt;      &lt;P&gt;        &lt;xsl:value-of select="."/&gt;      &lt;/P&gt;  &lt;/xsl:template&gt;&lt;/xsl:stylesheet&gt;</pre><p>The default template rule for nodes preserves modes. That is, for every mode <i>n</i> you declare in your style sheet, the XSLT processor adds one template rule that applies specifically to that mode and looks like this:</p><pre>&lt;xsl:template match="*|/" mode="<i>n</i>"&gt;  &lt;xsl:apply-templates mode="<i>n</i>"/&gt;&lt;/xsl:template&gt;</pre><p>As usual, you are free to override this default rule with one of your own design.</p><h2>Defining Constants with xsl:variable</h2><p>Named constants help clean up code. They can replace commonly used boilerplate text with a simple name and reference. They can also make it easy to adjust boilerplate text that appears in multiple locations by simply changing the constant definition.</p><p>The <code>xsl:variable</code> element defines a named string for use elsewhere in the style sheet via an attribute value template. It has a single attribute, <code>name,</code> which provides a name by which the variable can be referred to. The contents of the <code>xsl:variable</code> element provide the replacement text. For example, this <code>xsl:variable</code> element defines a variable with the name <code>copy04</code> and the value <code>Copyright 2004 Elliotte Rusty Harold</code>:</p><pre>&lt;xsl:variable name="copy04"&gt;  Copyright 2004 Elliotte Rusty Harold&lt;/xsl:variable&gt;</pre><p>To access the value of this variable, you prefix a dollar sign to the name of the variable. To insert this in an attribute, use an attribute value template. For example:</p><pre>&lt;BLOCK COPYRIGHT="{$copy04}"&gt;&lt;/BLOCK&gt;</pre><p>An <code>xsl:value-of</code> element can insert the variable&#146;s replacement text into the output document as text:</p><pre>&lt;xsl:value-of select="$copy04"/&gt;</pre><p>The contents of the <code>xsl:variable</code> element can contain markup including other XSLT instructions. This means that you can calculate the value of a variable based on other information, including the value of other variables. However, a variable may not refer to itself recursively, either directly or indirectly. For instance, the following example is in error:</p><pre>&lt;xsl:variable name="GNU"&gt;  &lt;xsl:value-of select="$GNU"/&gt;'s not Unix&lt;/xsl:variable&gt;</pre><p>Similarly, two variables may not refer to each other in a circular fashion, like this:</p><pre>&lt;xsl:variable name="Thing1"&gt;  Thing1 loves &lt;xsl:value-of select="$Thing2"/&gt;&lt;/xsl:variable&gt;&lt;xsl:variable name="Thing2"&gt;  Thing2 loves &lt;xsl:value-of select="$Thing1"/&gt;&lt;/xsl:variable&gt;</pre><code><p>xsl:variable</code> elements can either be top-level children of the <code>xsl:stylesheet</code> root element or they can be included inside template rules. A variable present at the top level of a style sheet can be accessed anywhere in the style sheet. It&#146;s a global variable. By contrast, a variable that&#146;s declared inside a template rule is only accessible by its following sibling elements and their descendants (the <i>scope</i> of the variable). It&#146;s a <i>local variable</i>. That is, it only applies inside that one template rule. It is local to the template. Local variables override global variables with the same name. Local variables can also override other local variables. In the event of a conflict between two variables with the same name, the closest local variable with the same name is used.</p><p>Unlike variables in traditional programming languages such as Java, XSLT variables may not be changed. After the value of a variable has been set, it cannot be changed. It can be shadowed by another variable with the same name in a more local scope, but its own value is fixed. An XSLT variable is more like an algebraic variable than a programming language variable. </p><h2>Named Templates</h2><p>Variables are limited to basic text and markup. XSLT provides a more powerful macro facility that can wrap standard markup and text around changing data. For example, suppose you want an atom&#146;s atomic number, atomic weight, and other key values formatted as a table cell in small, bold Times font in blue. In other words, you want the output to look like this:</p><pre>&lt;TD&gt;  &lt;FONT FACE="Times, serif" COLOR="blue" SIZE="2"&gt;    &lt;B&gt;52&lt;/B&gt;  &lt;/FONT&gt;&lt;/TD&gt;</pre><p>You can certainly include all that in a template rule like this:</p><pre>&lt;xsl:template match="ATOMIC_NUMBER"&gt;  &lt;TD&gt;    &lt;FONT FACE="Times, serif" COLOR="blue" SIZE="2"&gt;      &lt;B&gt;        &lt;xsl:value-of select="."/&gt;      &lt;/B&gt;    &lt;/FONT&gt;  &lt;/TD&gt;&lt;/xsl:template&gt;</pre><p>This markup can be repeated inside other template rules. When the detailed markup grows more complex, and when it appears in several different places in a style sheet, you may elect to turn it into a named template. Named templates resemble variables. However, they enable you to include data from the place where the template is applied, rather than merely inserting fixed text.</p><p>The <code>xsl:template</code> element can have a <code>name</code> attribute by which it can be explicitly invoked, even when it isn't applied indirectly. For example, this shows a sample named template for the preceding pattern:</p><pre>&lt;xsl:template name="ATOM_CELL"&gt;  &lt;TD&gt;    &lt;font FACE="Times, serif" COLOR="blue" SIZE="2"&gt;      &lt;B&gt;        &lt;xsl:value-of select="."/&gt;      &lt;/B&gt;    &lt;/FONT&gt;  &lt;/TD&gt;&lt;/xsl:template&gt;</pre><p>The <code>&lt;xsl:value-of select="."/&gt;</code> element in the middle of the named template will be replaced by the value of the current node from which this template was called.</p><p>The <code>xsl:call-template</code> element appears in the contents of a template rule. It has a required <code>name</code> argument that names the template it will call. When processed, the <code>xsl:call-template</code> element is replaced by the contents of the <code>xsl:template</code> element it names. For example, you can now rewrite the <code>ATOMIC_NUMBER</code> rule like this by using the <code>xsl:call-template</code> element to call the <code>ATOM_CELL</code> named template:</p><pre>&lt;xsl:template match="ATOMIC_NUMBER"&gt;  &lt;xsl:call-template name="ATOM_CELL"/&gt;&lt;/xsl:template&gt;</pre><p>This fairly simple example only saves a few lines of code, but the more complicated the template, and the more times it&#146;s reused, the greater the reduction in complexity of the style sheet. Named templates also have the advantage, like variables, of factoring out common patterns in the style sheet so that you can edit them as one. For example, if you decide to change the color of atomic number, atomic weight, and other key values from blue to red, you only need to change it once in the named template. You do not have to change it in each separate template rule. This facilitates greater consistency of style.</p><h2>Passing Parameters to Templates</h2><p>Each separate invocation of a template can pass parameters to the template to customize its output. This is done the same way for named templates and unnamed templates. In the <code>xsl:template</code> element, the parameters are represented as <code>xsl:param</code> child elements. In <code>xsl:call-template</code> or <code>xsl:apply-templates</code> elements, parameters are represented as <code>xsl:with-param</code> child elements.</p><p>For example, suppose you also want to include a link to a particular file for each atom cell. The output should look something like this:</p><pre>&lt;TD&gt;  &lt;FONT FACE="Times, serif" COLOR="blue" SIZE="2"&gt;    &lt;B&gt;      &lt;A HREF="atomic_number.html"&gt;52&lt;/A&gt;    &lt;/B&gt;  &lt;/FONT&gt;&lt;/TD&gt;</pre><p>The trick is that the value of the <code>HREF</code> attribute has to be passed in from the point where the template is invoked because it changes for each separate invocation of the template. For example, atomic weights will have to be formatted like this:</p><pre>&lt;TD&gt;  &lt;font FACE="Times, serif" COLOR="blue" SIZE="2"&gt;    &lt;B&gt;      &lt;A HREF="atomic_weight.html"&gt;4.0026&lt;/A&gt;    &lt;/B&gt;  &lt;/FONT&gt;&lt;/TD&gt;</pre><p>This template accomplishes that task:</p><pre>&lt;xsl:template name="ATOM_CELL"&gt;  &lt;xsl:param name="file"&gt;index.html&lt;/xsl:param&gt;  &lt;TD&gt;    &lt;font FACE="Times, serif" COLOR="blue" SIZE="2"&gt;      &lt;B&gt;        &lt;A HREF="{$file}"&gt;&lt;xsl:value-of select="."/&gt;&lt;/A&gt;      &lt;/B&gt;    &lt;/FONT&gt;  &lt;/TD&gt;&lt;/xsl:template&gt;</pre><p>The <code>name</code> attribute of the <code>xsl:param</code> element gives the parameter a name (important if there are multiple arguments), and the contents of the <code>xsl:param</code> element supplies a default value for this parameter to be used if the invocation doesn&#146;t provide a value. (This can also be given as a string expression by using a <code>select</code> attribute.)</p><p>When this template is called, an <code>xsl:with-param</code> child of the <code>xsl:call-template</code> element provides the value of the parameter using its <code>name</code> attribute to identify the parameter and its contents to provide a value for the parameter. For example:</p><pre>&lt;xsl:template match="ATOMIC_NUMBER"&gt;  &lt;xsl:call-template name="ATOM_CELL"&gt;    &lt;xsl:with-param                name="file"&gt;atomic_number.html&lt;/xsl:with-param&gt;  &lt;/xsl:call-template&gt;&lt;/xsl:template&gt;</pre><p>Again, this is a simple example. However, much more complex named templates exist. For example, you could define header and footer templates for pages on a web site for importing by many different style sheets, each of which would only have to change a few parameters for the name of the page author, the title of the page, and the copyright date.</p><h2>Stripping and Preserving White Space</h2><p>You may have noticed that most of the examples of output have been formatted a little strangely. The reason the examples appeared strange is that the source document needed to break long elements across multiple lines to fit between the margins of this book. Unfortunately, the extra white space added to the input document carried over into the output document. For a computer, the details of insignificant white space aren&#146;t important, but for a person they can be distracting.</p><p>The default behavior for text nodes read from the input document, such as the content of an <code>ATOMIC_NUMBER</code> or <code>DENSITY</code> element, is to preserve all white space. A typical <code>DENSITY</code> element looks like this:</p><pre>    &lt;DENSITY UNITS="grams/cubic centimeter"&gt;      &lt;!-- At 300K, 1 atm --&gt;      0.0000899    &lt;/DENSITY&gt;</pre><p>When its value is taken the leading and trailing white space is included, like this, even though the space is really only there to help fit the example on this printed page and isn&#146;t at all significant:</p><pre>      0.0000899</pre><p>You can use the <code>normalize-space()</code> function to strip the leading and trailing white space from this or any other string. For example, instead of writing <code>&lt;xsl:value-of select="DENSITY"/&gt;</code>, you would write <code>&lt;xsl:value-of select="normalize-space(DENSITY)"/&gt;</code>.</p><p>You can also automatically delete white-space-only nodes in the input document by using <code>xsl:strip-space</code>. The <code>elements</code> attribute of this top-level element contains a list of elements from which text nodes that contain nothing but white space should be deleted. For example, this element says that nodes containing only white space should be stripped from <code>DENSITY</code>, <code>NAME</code>, <code>SYMBOL</code>, and <code>BOILING_POINT</code> elements:</p><pre>&lt;xsl:strip-space elements="DENSITY NAME SYMBOL BOILING_POINT"/&gt;</pre><dir><b><font face="Arial" size=1 color="#000080"><p>Caution</p></b></font><p>This is not the same as trimming white space from the ends of text nodes like <code>normalize-space()</code> does. This only affects nodes that contain nothing but white space, not nodes that contain white space and other nonspace content.</p></dir><p>You can strip space-only nodes in all elements by using the <code>*</code> wildcard, like this:</p><pre>&lt;xsl:strip-space elements="*"/&gt;</pre><p>There&#146;s also an <code>xsl:preserve-space</code> element with a similar syntax but opposite meaning. However, because preserving space is the default, this element isn&#146;t much used. Its main purpose is to override <code>xsl:strip-space</code> elements imported from other style sheets or to specify a few elements where space is preserved when the default has been reset to stripping by <code>&lt;xsl:strip-space elements="*"/&gt;</code>.</p><p>White-space-only text nodes in the style sheet, as opposed to the input document, are another matter. They are stripped by default. If you want to preserve one, you attach an <code>xml:space</code> attribute with the value <code>preserve</code> to its parent element or to another one of its ancestors.</p><dir><b><font face="Arial" size=1 color="#000080"><p>Cross-Reference</p></b></font><p>The <code>xml:space</code> attribute was discussed in Chapter 6.</p></dir><p>Sometimes the easiest way to include significant white space in a style sheet is to wrap it in an <code>xsl:text</code> element. Space inside an <code>xsl:text</code> element is treated literally and not stripped.</p><h2>Making Choices</h2><p>XSLT provides two elements that allow you to choose different output based on the input. The <code>xsl:if</code> element either does or does not output a given fragment of XML depending on what patterns are present in the input. The <code>xsl:choose</code> element picks one of several possible XML fragments, depending on what patterns are present in the input. Most of what you can do with <code>xsl:if</code> and <code>xsl:choose</code> can also be done by a suitable application of templates. However, sometimes the solution with <code>xsl:if</code> or <code>xsl:choose</code> is simpler and more obvious.</p><h2>xsl:if</h2><p>The <code>xsl:if</code> element provides a simple facility for changing the output based on a pattern. The <code>test</code> attribute of <code>xsl:if</code> contains an expression that evaluates to a boolean. If the expression is true, the contents of the <code>xsl:if</code> element are output. Otherwise, they&#146;re not. For example, this template writes out the names of all <code>ATOM</code> elements. A comma and a space is added after all except the last element in the list.</p><pre>&lt;xsl:template match="ATOM"&gt;  &lt;xsl:value-of select="NAME"/&gt;  &lt;xsl:if test="position()!=last()"&gt;, &lt;/xsl:if&gt;&lt;/xsl:template&gt;</pre><p>This ensures that the list looks like &quot;Hydrogen, Helium&quot; and not &quot;Hydrogen, Helium, ".&quot;</p><p>There are no <code>xsl:else</code> or <code>xsl:else-if</code> elements. The <code>xsl:choose</code> element provides this functionality.</p><h2>xsl:choose</h2><p>The <code>xsl:choose</code> element selects one of several possible outputs depending on several possible conditions. Each condition and its associated output template is provided by an <code>xsl:when</code> child element. The <code>test</code> attribute of the <code>xsl:when</code> element is an XPath expression with a boolean value. If multiple conditions are true, only the first true one is instantiated. If none of the <code>xsl:when</code> elements are true, the <code>xsl:otherwise</code> child element is instantiated. If the  <code>xsl:choose</code> element does not have an <code>xsl:otherwise</code> element, no output created. For example, this rule changes the color of the output based on whether the <code>STATE</code> attribute of the <code>ATOM</code> element is <code>SOLID</code>, <code>LIQUID</code>, or <code>GAS</code>:</p><pre>&lt;xsl:template match="ATOM"&gt;  &lt;xsl:choose&gt;    &lt;xsl:when test="@STATE='SOLID'"&gt;      &lt;P style="color: black"&gt;        &lt;xsl:value-of select="."/&gt;      &lt;/P&gt;    &lt;/xsl:when&gt;    &lt;xsl:when test="@STATE='LIQUID'"&gt;      &lt;P style="color: blue"&gt;        &lt;xsl:value-of select="."/&gt;      &lt;/P&gt;    &lt;/xsl:when&gt;    &lt;xsl:when test="@STATE='GAS'"&gt;      &lt;P style="color: red"&gt;        &lt;xsl:value-of select="."/&gt;      &lt;/P&gt;    &lt;/xsl:when&gt;    &lt;xsl:otherwise&gt;      &lt;P style="color: green"&gt;        &lt;xsl:value-of select="."/&gt;      &lt;/P&gt;    &lt;/xsl:otherwise&gt;  &lt;/xsl:choose&gt;&lt;/xsl:template&gt;</pre><h2>Merging Multiple Style Sheets</h2><p>A single XML document may use many different markup vocabularies. You may wish to use different standard style sheets for those different vocabularies. However, you&#146;ll also want style rules for particular documents. The <code>xsl:import</code> and <code>xsl:include</code> elements enable you to merge multiple style sheets so that you can organize and reuse style sheets for different vocabularies and purposes.</p><h2>Importing with xsl:import</h2><p>The <code>xsl:import</code> element is a top-level element whose <code>href</code> attribute provides the URI of a style sheet to import. All <code>xsl:import</code> elements must appear before any other top-level element in the <code>xsl:stylesheet</code> root element. For example, these <code>xsl:import</code> elements import the style sheets genealogy.xsl and standards.xsl.</p><pre>&lt;xsl:stylesheet version="1.0"   xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;  &lt;xsl:import href="genealogy.xsl"/&gt;  &lt;xsl:import href="standards.xsl"/&gt;  &lt;!-- other child elements follow --&gt;&lt;/xsl:stylesheet&gt;</pre><p>Rules in the imported style sheets may conflict with rules in the importing style sheet. If so, rules in the importing style sheet take precedence. If two rules in different imported style sheets conflict, the rule in the last style sheet imported (standards.xsl above) takes precedence.</p><p>The <code>xsl:apply-imports</code> element is a slight variant of <code>xsl:apply-templates</code> that only uses imported rules. It does not use any rules from the importing style sheet. This allows access to imported rules that would otherwise be overridden by rules in the importing style sheet. Other than the name, it has identical syntax to <code>xsl:apply-templates</code>. The only behavioral difference is that it only matches template rules in imported style sheets.</p><h2>Inclusion with xsl:include</h2><p>The <code>xsl:include</code> element is a top-level element that copies another style sheet into the current style sheet at the point where it occurs. (More precisely, it copies the contents of the <code>xsl-stylesheet</code> or <code>xsl:transform</code> element in the remote document into the current document.) Its <code>href</code> attribute provides the URI of the style sheet to include. An <code>xsl:include</code> element can occur anywhere at the top level after the last <code>xsl:import</code> element.</p><p>Unlike rules included by <code>xsl:import</code> elements, rules included by <code>xsl:include</code> elements have the same precedence in the including style sheet that they would have if they were copied and pasted from one style sheet to the other. As far as the XSLT processor is concerned, there is no difference between an included rule and a rule that&#146;s physically present.</p><h2>Output Methods</h2><p>Most of the examples in this chapter have focused on transforming XML into well-formed HTML. However, most XSLT processors actually support three different output methods:</p><ul>	<li><p>XML</p></li>	<li><p>HTML</p></li>	<li><p>Text</p></li></ul><p>The XSLT processor behaves differently depending on which of these output methods it uses. The XML format is the default and in many ways the simplest. The output is mostly exactly what you request in your style sheet. Because well-formed XML does not permit raw less &#151;than signs and ampersands, if you use a character reference such as <code>&amp;#60;</code> or the entity reference <code>&amp;lt;</code> to insert the <code>&lt;</code> character, the formatter will output <code>&amp;lt;</code> or perhaps <code>&amp;#60;</code>. If you use a character reference such as <code>&amp;#38;</code> or the entity reference <code>&amp;amp;</code> to insert the <code>&amp;</code> character, the formatter will insert <code>&amp;amp;</code> or perhaps <code>&amp;#38;</code>.</p><p>The HTML output method is designed to output standard HTML 4.0. This is not the well-formed HTML used in this book, but rather traditional HTML in which empty-element tags look like <code>&lt;HR&gt;</code> and <code>&lt;IMG&gt;</code> instead of <code>&lt;HR/&gt;</code> and <code>&lt;IMG/&gt;</code>, processing instructions are terminated with a <code>&gt;</code> instead of <code>?&gt;</code>, and <code>&lt;</code> signs used in JavaScript are not converted to <code>&amp;lt;</code>. This makes it much easier to output HTML that works across many browsers and platforms without odd effects such as double lines where a single line is expected or other detritus caused by forcing HTML into the XML mold. The HTML output method is automatically selected when the formatter notices that the root output element is <code>html</code>, <code>HTML</code>, <code>HtMl</code>, or any other combination of case that still spells Hypertext Markup Language.</p><p>The final output method is pure text. The text output method operates by first forming a full result tree as per the XML output method, but then only outputting the string value of that tree. This is useful for transforming to non-XML formats such as RTF or TeX. The primary benefit of the text output format is that less than signs are not converted to <code>&amp;lt;</code> or <code>&amp;#60;</code> and ampersands are not converted to <code>&amp;amp;</code> or <code>&amp;#38;</code>. This allows you to output effectively arbitrary text.</p><p>By default, an XSLT processor will use the XML output method, unless it recognizes the output root element as <code>HTML</code>, in which case it uses the HTML output method. You can change this by using a top-level <code>xsl:output</code> element. The <code>method</code> attribute of the <code>xsl:output</code> element specifies which output method to use and normally has one of these three values:</p><ul>	<li><p><code>xml</code></p></li>	<li><p><code>html</code></p></li>	<li><p><code>text</code></p></li></ul><p>For example, to specify that you want pure well-formed HTML as output, with all the empty-element tags properly indicated, all less than signs escaped, and so forth, you would use this <code>xsl:output</code> element at the top level of your style sheet:</p><pre>&lt;xsl:output method="xml"/&gt;</pre><p>To indicate that you want regular HTML output even though you aren&#146;t using an <code>html</code> root element, you&#146;d put this <code>xsl:output</code> element at the top level of your style sheet:</p><pre>&lt;xsl:output method="html"/&gt;</pre><p>The <code>xsl:output</code> element also has a number of other allowed attributes that modify how XML is output. These allow you to change the prolog of the document, how the output is indented with insignificant white space, and which elements use <code>CDATA</code> sections rather than escaping <code>&lt;</code> and <code>&amp;</code> characters.</p><h2>XML Declaration</h2><p>Four attributes of <code>xsl:output</code> format the XML declaration used in your document. This assumes the output method is xml. These attributes are as follows:</p><ul><li><code>omit-xml-declaration</code></li><li><code>version</code></li><li><code>encoding</code></li><li><code>standalone</code></li></ul><p>The <code>omit-xml-declaration</code> attribute has the value <code>yes</code> or <code>no</code>. If <code>yes</code>, an XML declaration is not included in the output document. If <code>no</code>, then it is. For example, to insert a very basic <code>&lt;?xml version="1.0"?&gt;</code> XML declaration in the output document you would use this <code>xsl:output</code> element at the top level of your style sheet:</p><pre>&lt;xsl:output method="xml" omit-xml-declaration="no"/&gt;</pre><p>You could also include it as two separate <code>xsl:output</code> elements, like this:</p><pre>&lt;xsl:output method="xml"/&gt;&lt;xsl:output omit-xml-declaration="no"/&gt;</pre><p>The default value of the <code>version</code> attribute of the XML declaration is 1.0. If you really, really need to (and you almost certainly don't), the <code>version</code> attribute of <code>xsl:output</code>  enables you to change the version used in the XML declaration, as in the following example:</p><pre>&lt;xsl:output version="1.1"/&gt;</pre><p>You can set the <code>standalone</code> attribute of the XML declaration to the value <code>yes</code> or <code>no</code> using the <code>standalone</code> attribute of the <code>xsl:output</code> element. For example, this <code>xsl:output</code> element would insert the XML declaration <code>&lt;?xml version="1.0" standalone="yes"?&gt;</code>:</p><pre>&lt;xsl:output method="xml"            omit-xml-declaration="no" standalone="yes"/&gt;</pre><p>The final possible piece of an XML declaration is the <code>encoding</code> declaration. As you probably guessed this can be set with the encoding attribute of the <code>xsl:output</code> element. For example, to insert the XML declaration <code>&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;</code>, you&#146;d use this <code>xsl:output</code> element:</p><pre>&lt;xsl:output method="xml"          omit-xml-declaration="no" encoding="ISO-8859-1"/&gt;</pre><p>This also changes the encoding the XSLT processor uses for the output document from its default UTF-8. However, not all processors support all possible encodings. Those written in Java are likely to support the most encodings because Java&#146;s rich class library makes it almost trivial to support several dozen popular encodings.</p><h2>Document Type Declaration</h2><p>XSLT does not provide any elements for building a DTD for the output document with <code>&lt;!ELEMENT&gt;</code>, <code>&lt;!ATTLIST&gt;</code>, <code>&lt;!ENTITY&gt;</code>, and <code>&lt;!NOTATION&gt;</code> declarations, either as an internal or external DTD subset. However, it does provide two attributes of the <code>xsl:output</code> element you can use to include a <code>DOCTYPE</code> declaration that points to an external DTD. These are <code>doctype-system</code> and <code>doctype-public</code>. The first inserts a <code>SYSTEM</code> identifier for the DTD; the second a <code>PUBLIC</code> identifier. For example, suppose you want this <code>DOCTYPE</code> declaration in your output document:</p><pre>&lt;!DOCTYPE PERIODIC_TABLE SYSTEM "chemistry.dtd"&gt;</pre><p>Then you would use this <code>xsl:output</code> element at the top level of your style sheet:</p><pre>&lt;xsl:output doctype-system="chemistry.dtd"/&gt;</pre><p>The XSLT processor determines the proper root element for the document type declaration by looking at the root element of the output tree. Using a full URL instead of a relative URL is equally easy:</p><pre>&lt;xsl:output  doctype-system="http://www.example.com/chemistry.dtd"/&gt;</pre><p>On the other hand, suppose you want this <code>DOCTYPE</code> declaration in your output document:</p><pre>&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"         "http://www.w3.org/TR/REC-html40/loose.dtd"&gt;</pre><p>Then you would use both <code>doctype-system</code> and <code>doctype-public</code> attributes so your <code>DOCTYPE</code> declaration will have both a <code>PUBLIC</code> and a <code>SYSTEM</code> identifier. For example:</p><pre>&lt;xsl:output  doctype-system="http://www.w3.org/TR/REC-html40/loose.dtd"  doctype-public="-//W3C//DTD HTML 4.0 Transitional//EN"/&gt;</pre><h2>Indentation</h2><p>The indentation of many of the output examples in this chapter has been more than a little flaky. It&#146;s certainly not as neat as the carefully hand-coded indentation of the input documents. However, if white space isn&#146;t particularly significant in your output format, you can ask the formatter for &quot;pretty printed&quot; XML with the nesting of different elements indicated by the indentation. This is accomplished by the <code>indent</code> attribute of the <code>xsl:output</code> element. If this attribute has the value <code>yes</code> (the default is <code>no</code>), the processor is allowed (but not required) to insert (but not remove) extra white space into the output to try to pretty print the output. This may include indentation and line breaks. For example, this element requests indenting:</p><pre>&lt;xsl:output indent="yes"/&gt;</pre><p>You cannot specify how much you want each level indented (for example, by two spaces or one tab). That&#146;s up to the formatter. Nonetheless, the <code>xsl:strip-space</code> and the <code>indent</code> attribute of the <code>xsl:output</code> element allow you to produce output that&#146;s almost as attractive as the most painstakingly hand-crafted XML.</p><h2>CDATA sections</h2><p>XSLT does not allow you to insert CDATA sections at arbitrary locations in XML documents produced by XSL transformations. However, you can specify that the text contents of a particular element be placed in a <code>CDATA</code> section. In this case the <code>&lt;</code> and <code>&amp;</code> symbols are not encoded as <code>&amp;lt;</code> and <code>&amp;amp;</code> as they would normally be. To do this, place the name of the element whose text contents should be wrapped in CDATA delimiters in the <code>cdata-section-elements</code> attribute of the <code>xsl:output</code> element. For example, this <code>xsl:output</code> element says that the contents of the <code>SCRIPT</code> element should be wrapped in a CDATA section:</p><pre>&lt;xsl:output cdata-section-elements="SCRIPT"/&gt;</pre><p>You can enclose multiple names of elements whose text contents should be wrapped in CDATA delimiters in one <code>cdata-section-elements</code> attribute simply by separating the names with white space. For example, this <code>xsl:output</code> element says that the contents of both the <code>SCRIPT</code> and <code>CODE</code> elements should be wrapped in a CDATA section:</p><pre>&lt;xsl:output cdata-section-elements="SCRIPT CODE"/&gt;</pre><p>Alternately, you can just use multiple <code>xsl:output</code> elements, each naming one element. For example:</p><pre>&lt;xsl:output cdata-section-elements="SCRIPT"/&gt;&lt;xsl:output cdata-section-elements="CODE"/&gt;</pre><h2>Summary</h2><p>In this chapter, you learned about XSL transformations. In particular, you learned the following:</p><ul><li>The Extensible Stylesheet Language (XSL) comprises two separate XML applications for transforming and formatting XML documents.</li><li>An XSL transformation applies rules to a tree read from an XML document to transform it into an output tree written out as an XML document.</li><li>An XSL template rule is represented as an <code>xsl:template</code> element. The <code>match</code> attribute determines which nodes the template matches. The contents of the <code>xsl:template</code> element are a template that is instantiated when a node is matched.</li><li>The value of a node is a pure text (no markup) string containing the contents of the node. This can be calculated by the <code>xsl:value-of</code> element.</li><li>You can process multiple elements in two ways: using the <code>xsl:apply-templates</code> element and the <code>xsl:for each</code> element.</li><li>The value of the <code>match</code> attribute of the <code>xsl:template</code> element is a match pattern specifying which nodes the template matches.</li><li>XPath expressions (or simply expressions) are a superset of match patterns used by the <code>select</code> attribute of <code>xsl:apply-templates</code>, <code>xsl:value-of</code>, <code>xsl:for-each</code>, <code>xsl:copy-of</code>, <code>xsl:variable</code>, <code>xsl:param</code>, <code>xsl:with-param</code>, and <code>xsl:sort</code> elements.</li><li>Default rules apply templates to element nodes and take the value of text nodes and attributes.</li><li>Attribute value templates are braced XPath expressions in certain attributes that are evaluated to create an attribute value.</li><li>The <code>xsl:element</code>, <code>xsl:attribute</code>, <code>xsl:processing-instruction</code>, <code>xsl:comment</code>, and <code>xsl:text</code> elements output elements, attributes, processing instructions, comments, and text calculated from data in the input document.</li><li>The <code>xsl:attribute-set</code> element defines a common group of attributes that can be applied to multiple elements in different templates with the <code>xsl:use-attribute-sets</code>.</li><li>The <code>xsl:copy</code> element shallow copies the current node from the input into the output.</li><li>The <code>xsl:copy-of</code> element deep copies the current node from the input into the output.</li><li>The <code>xsl:number</code> element inserts the number specified by its <code>value</code> attribute into the output using a specified number format given by the <code>format</code> attribute.</li><li>The <code>xsl:sort</code> element can reorder the input nodes before copying them to the output.</li><li>Modes can apply different templates to the same element from different locations in the style sheet.</li><li>The <code>xsl:variable</code> element defines named constants that can clarify your code.</li><li>Named templates help you reuse common template code. Parameters can be defined and passed to templates using the <code>xsl:param</code> and <code>xsl:with-param</code> elements.</li><li>White space in the input document is maintained by default, unless an <code>xsl:strip-space</code> element or <code>xml:space</code> attribute says otherwise.</li><li>The <code>xsl:if</code> element produces output if, and only if, its <code>test</code> attribute is true.</li><li>The <code>xsl:choose</code> element outputs the template of the first one of its <code>xsl:when</code> children whose <code>test</code> attribute is true, or the template of its <code>xsl:otherwise</code> element if no <code>xsl:when</code> element has a <code>true</code><code>test</code> attribute.</li><li>The <code>xsl:import</code> and <code>xsl:include</code> elements merge rules from different style sheets.</li><li>The <code>xsl:stylesheet</code> element allows you to include a style sheet directly in the document it applies to.</li><li>Various attributes of the <code>xsl:output</code> element allow you to specify the output document&#146;s format, XML declaration, document type declaration, indentation, encoding, and MIME media type.</li></ul><p>The next chapter takes up the second half of XSL: the formatting objects vocabulary. Formatting objects are an extremely powerful way of specifying the precise layout you want your pages to have. XSL transformations are used to transform an XML document into an XSL formatting object document.</p>   <hr />From XML 1.1 Bible, by <a href="http://www.elharo.com/">Elliotte Rusty Harold</a>. &copy; 2004 byWiley Publishing, Inc.  All rights reserved.  Reproduced here by permissionof the publisher.      <hr />      <div style="text-align: center">                [ <a href="../../index.html">Cafe con Leche</a>          | <a href="../index.html">XML Bible Home Page</a>       | Order  from  <a href="http://www.amazon.com/exec/obidos/ASIN/0764549863/ref=nosim/cafeaulaitA/">amazon.com</a>  |  <a href="http://www.wiley.com/WileyCDA/WileyTitle/productCd-0764549863.html">Publisher Page</a> ]         </div></body></html>