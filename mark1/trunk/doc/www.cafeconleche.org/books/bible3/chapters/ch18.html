<html><head><title>XPointer</title></head><body text="#000000" link="#0000ff" vlink="#800080"><div style="text-align: center">                [ <a href="../../../index.html">Cafe con Leche</a>          | <a href="../index.html">XML Bible Home Page</a>       | Order  from  <a href="http://www.amazon.com/exec/obidos/ASIN/0764549863/ref=nosim/cafeaulaitA/">amazon.com</a>  |  <a href="http://www.wiley.com/WileyCDA/WileyTitle/productCd-0764549863.html">Publisher Page</a> ]         </div><hr /><b><font face="Arial" size=2><p>In This Chapter</p></font></b><ul>	<li><p>Why XPointers?</p></li>	<li><p>XPointer examples</p></li>	<li><p>Location paths, steps, and sets</p></li>	<li><p>The root node</p></li>	<li><p>Axes</p></li>	<li><p>Node tests</p></li>	<li><p>Predicates</p></li>	<li><p>Functions that return node-sets</p></li>	<li><p>Points</p></li>	<li><p>Ranges</p></li>	<li><p>Child sequences</p></li></ul><font face="Arial Black" size=7><p>XPointers</p></dir></font><p>XPointer, the XML Pointer Language, defines an addressing scheme for individual parts of an XML document. These addresses can be used by any application that needs to identify parts of or locations in an XML document. For example, an XML editor could use an XPointer to identify the current position of the insertion point or the range of the selection. An XInclude processor can use an XPointer to determine what part of a document to include. You can also add an XPointer fragment identifier to the URI in an XLink to change it into a URI reference that locates one particular element in the targeted document. XPointers use the same XPath syntax that you&#146;re familiar with from XSLT to identify the parts of the document they point to, along with a few additional pieces.</p><dir><b><font face="Arial" size=1 color="#000080"><p>Caution</p></b></font><p>No mainstream browsers have any support for XPointers. You can use URLs with XPointer fragment identifiers in web pages, but browsers will mostly ignore them.</p></dir><h2>Why XPointers?</h2></font><p>Traditional URLs are simple and easy to use, but they&#146;re also quite limited. For one thing, a URL only points at a single, complete document. More granularity than that, such as linking to the third sentence of the seventeenth paragraph in a document, requires the author of the targeted document to manually insert named anchors at the targeted location. The author of the document doing the linking can&#146;t do this unless he or she also has write access to the document being linked to. Even if the author doing the linking can insert named anchors into the targeted document, it&#146;s almost always inconvenient.</p><p>It would be more useful to be able to link to a particular element or group of elements on a page without having to change the document you&#146;re linking to. For example, given a large document such as the television listings of Chapters 4 and 5, you might want to link to only one station or one show. There are several parts to this problem. The first part is addressing the individual elements. This is the part that XPointers solve. XPointers enable you to target a given element by number, name, type, or relation to other elements in the document.</p><p>The second part of the problem is the protocol by which a browser asks a web server to send only part of a document rather than the whole thing. This is an area of active research. More work is needed. XPointers do little to solve this problem, except for providing a foundation on which such systems can build. For example, the best efforts to date are the so-called byte range extensions to HTTP available in HTTP 1.1. So far, these have not achieved widespread adoption, mostly because web authors aren&#146;t comfortable specifying a byte range in a document. Furthermore, byte ranges are extremely fragile. Trivial edits to a document, even simple reformatting, can destroy byte range links. HTTP 1.1 does allow other range units besides raw bytes (for example, XML elements), but does not require web servers or browsers to support such units.</p><p>For the moment, therefore, an XPointer can be used as an index into a complete document, the whole of which is loaded and then positioned at the location identified by the XPointer, and even this is more than most browsers can handle. In the long term, extensions to XML, XLink, HTTP, and other protocols may allow more sophisticated uses of XPointers. For example, XInclude will let you quote a remote document by using an XPointer to tell browsers where to copy the quote in the original document, rather than retyping the text of the quote. You could include cross-references inside a document that automatically update themselves as the document is revised. These uses, however, will have to wait for the development of several next-generation technologies. For now, you must be content with precisely identifying the part of a document you want to jump to when following an XLink.</p><h2>XPointer Examples</h2></font><p>HTML links generally point to one particular document. Additional granularity&#151;that is, pointing to a particular section, chapter, or paragraph of a particular document&#151;isn&#146;t well supported. Provided you control both the linking and the linked document, you can insert a named anchor into an HTML file at the position to which you want to link, as in the following example:</p><pre>&lt;H2&gt;&lt;A NAME="xtocid20.2"&gt;XPointer Examples&lt;/A&gt;&lt;/H2&gt;</pre><p>You can then link to this position in the file by adding a <code>#</code> and the name of the anchor to the URL. The piece of the URL after the # is called the <i>fragment identifier</i>. For example, in this link the fragment identifier is <code>xtocid20.2</code>:</p><pre>&lt;A HREF="http://www.cafeconleche.org/bible/20.html#xtocid20.2"&gt;  XPointer Examples&lt;/A&gt;</pre><dir><b><font face="Arial" size=1 color="#000080"><p>Note</p></b></font><p>A URL with a fragment identifier is technically a URL reference, not a URL; but outside of specification documents, the distinction is almost never made, nor does it matter.</p></dir></font><p>However, this solution is a kludge. It&#146;s not always possible to modify the target document so that the source document can link to it. The target document might be on a different server controlled by someone other than the author of the source document. And the author of the target document might change or move it without notifying the author of the source.</p><p>Furthermore, named anchors violate the principle of separating markup from content. Placing a named anchor in a document says nothing about the document or its content. It&#146;s just a marker for other documents to refer to. It adds nothing to the document&#146;s own content.</p><p>XPointers allow much more sophisticated connections between parts of documents. An XPointer can refer to any element of a document; to the first, second, or seventeenth element; to the seventh element named <code>P;</code> to the first element that&#146;s a child of the second <code>DIV</code> element; and so on. XPointers provide precisely targeted addresses of particular parts of documents. They do not require the targeted document to contain additional markup just so its individual pieces can be linked to.</p><p>Furthermore, unlike HTML anchors, XPointers don&#146;t point to just a single point in a document. They can point to entire elements, to noncontiguous sets of elements, or to a range of text between two points. Thus, you can use an XPointer to select a particular part of a document, perhaps so it can be copied or loaded into a program.</p><p>Here are a few examples of XPointers:</p><pre>xpointer(id("ebnf"))xpointer(descendant::language[position()=2])ebnfxpointer(/child::spec/child::body/child::*/child::language[2])xpointer(/spec/body/*/language[2])element(/1/14/2)xpointer(id("ebnf"))xpointer(id("EBNF"))</pre><p>Each of these seven XPointers selects a particular element in a document. The first finds the element with the ID <code>ebnf</code>. The second finds the second <code>language</code> element in the document. The third is a shorthand form of finding the element with the ID <code>ebnf</code>. The fourth and fifth both specify the second <code>language</code> child element of any child element of the <code>body</code> child elements of the <code>spec</code> child of the root node. The sixth finds the second child element of the fourteenth child element of the root element. The final one also points to the element with the ID <code>ebnf</code>. However, if no such element is present, it then finds the element with the ID <code>EBNF</code>.</p><p>The document is not specified by the XPointer; rather, the URI that precedes the XPointer specifies the document. This URI may be contained in an XLink linking element or in anything else that contains a URI pointing at an XML document. The XLinks and URIs you saw in Chapter 17 did not contain XPointers, but it isn&#146;t hard to add XPointers to them. Most of the time, you simply append the XPointer to the URI separated by a <code>#</code>, just as you do with named anchors in HTML. For example, the preceding list of XPointers could be suffixed to URLs and come out looking similar to the following:</p><pre>http://www.w3.org/TR/1998/REC-xml-19980210.xml#xpointer(id("ebnf"))http://www.w3.org/TR/1998/REC-xml-19980210.xml#xpointer(descendant::language[position()=2])http://www.w3.org/TR/1998/REC-xml-19980210.xml#ebnfhttp://www.w3.org/TR/1998/REC-xml-19980210.xml#xpointer(/child::spec/child::body/child::*/child::language[2])http://www.w3.org/TR/1998/REC-xml-19980210.xml#xpointer(/spec/body/*/language[2])http://www.w3.org/TR/1998/REC-xml-19980210.xml#element(/1/14/2)http://www.w3.org/TR/1998/REC-xml-19980210.xml#xpointer(id("ebnf"))xpointer(id("EBNF"))</pre><p>In fact, these URIs are just six different ways of pointing to the same element of the document at <code>http://www.w3.org/TR/1998/REC-xml-19980210.xml</code>. Often, such URIs are values of the <code>xlink:href</code> attribute of a linking element, as in the following example:</p><pre>&lt;SPECIFICATION xmlns:xlink="http://www.w3.org/1999/xlink" xlink:type="simple" xlink:href=  "http://www.w3.org/TR/1998/REC-xml-19980210.xml#xpointer(id('ebnf'))" xlink:actuate="onRequest" xlink:show="replace"&gt;  Extensible Markup Language (XML) 1.0&lt;/SPECIFICATION&gt;</pre><p>XPointers don&#146;t have any special exemptions from the rules of URIs. In particular, if the XPointer contains characters that are not allowed in URLs such as @@OM or ^, these characters must be encoded in UTF-8, and the bytes of the UTF-8 encoding must be hex-escaped using a percent sign. For example, the capital Greek letter omega is Unicode character 3A9 in hexadecimal. When encoded in UTF-8, this character is the two bytes 206 and 169. In hexadecimal, that&#146;s CE and A9. Therefore, the XPointer <code>xpointer(id("@@OM"))</code> would be encoded in a URL as <code>xpointer(id("%CE%A9"))</code>. </p><ul><li>The caret is Unicode character 5E in hexadecimal.</li><li>The equals sign is Unicode character 3D in hexadecimal.</li><li>The colon is Unicode character 3A in hexadecimal.</li></ul></font><p>Because these three characters are part of the ASCII character set, their UTF-8 encodings are simply their values. Therefore, <code>xpointer(descendant::*[.='^'])</code> would be encoded in a URL as <code>xpointer(descendant%3A%3A*[.%3D'%5E'])</code>. Modern web browsers allow the square brackets [ and ] in URLs. However, some older browsers do not, so for maximum compatibility you should escape these characters as %5B and %5D, respectively. Thus, the preceding XPointer would become <code>xpointer(descendant%3A%3A*%5B.%3D'%5E'%5D)</code>.</p><h2>A Concrete Example</h2></font><p>To demonstrate the different types of XPointers, it&#146;s useful to have a concrete example in mind. Listing 18-1 is a simple, valid document that should be self-explanatory. It contains information about two related families and their members. The root element is <code>FAMILYTREE</code>. A <code>FAMILYTREE</code> can contain <code>PERSON</code> and <code>FAMILY</code> elements. Each <code>PERSON</code> and <code>FAMILY</code> element has a required <code>ID</code> attribute. Persons contain a name, birth date, death date, and spouse. Families contain a husband, a wife, and zero or more children. The individual persons are referred to from the family by reference to their IDs.</p><dir><b><font face="Arial" size=1 color="#000080"><p>Cross-Reference</p></b></font><p>This XML application is revisited in Chapter 25.</p><font face="Arial"><p>Listing 18-1: A Family Tree</p></font><pre>&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE FAMILYTREE [  &lt;!ELEMENT FAMILYTREE (PERSON | FAMILY)*&gt;  &lt;!-- PERSON elements --&gt;  &lt;!ELEMENT PERSON (NAME*, BORN*, DIED*, SPOUSE*)&gt;  &lt;!ATTLIST PERSON    ID      ID     #REQUIRED    FATHER  CDATA  #IMPLIED    MOTHER  CDATA  #IMPLIED  &gt;  &lt;!ELEMENT NAME (#PCDATA)&gt;  &lt;!ELEMENT BORN (#PCDATA)&gt;  &lt;!ELEMENT DIED  (#PCDATA)&gt;  &lt;!ELEMENT SPOUSE EMPTY&gt;  &lt;!ATTLIST SPOUSE IDREF IDREF #REQUIRED&gt;  &lt;!--FAMILY--&gt;  &lt;!ELEMENT FAMILY (HUSBAND?, WIFE?, CHILD*) &gt;  &lt;!ATTLIST FAMILY ID ID #REQUIRED&gt;  &lt;!ELEMENT HUSBAND EMPTY&gt;  &lt;!ATTLIST HUSBAND IDREF IDREF #REQUIRED&gt;  &lt;!ELEMENT WIFE EMPTY&gt;  &lt;!ATTLIST WIFE IDREF IDREF #REQUIRED&gt;  &lt;!ELEMENT CHILD EMPTY&gt;  &lt;!ATTLIST CHILD IDREF IDREF #REQUIRED&gt;]&gt;&lt;FAMILYTREE&gt;  &lt;PERSON ID="p1"&gt;    &lt;NAME&gt;Domeniquette Celeste Baudean&lt;/NAME&gt;    &lt;BORN&gt;21 Apr 1836&lt;/BORN&gt;    &lt;DIED&gt;Unknown&lt;/DIED&gt;    &lt;SPOUSE IDREF="p2"/&gt;  &lt;/PERSON&gt;  &lt;PERSON ID="p2"&gt;    &lt;NAME&gt;Jean Francois Bellau&lt;/NAME&gt;    &lt;SPOUSE IDREF="p1"/&gt;  &lt;/PERSON&gt;  &lt;PERSON ID="p3" FATHER="p2" MOTHER="p1"&gt;    &lt;NAME&gt;Elodie Bellau&lt;/NAME&gt;    &lt;BORN&gt;11 Feb 1858&lt;/BORN&gt;    &lt;DIED&gt;12 Apr 1898&lt;/DIED&gt;    &lt;SPOUSE IDREF="p4"/&gt;  &lt;/PERSON&gt;  &lt;PERSON ID="p4"&gt;    &lt;NAME&gt;John P. Muller&lt;/NAME&gt;    &lt;SPOUSE IDREF="p3"/&gt;  &lt;/PERSON&gt;  &lt;PERSON ID="p7"&gt;    &lt;NAME&gt;Adolf Eno&lt;/NAME&gt;    &lt;SPOUSE IDREF="p6"/&gt;  &lt;/PERSON&gt;  &lt;PERSON ID="p6" FATHER="p2" MOTHER="p1"&gt;    &lt;NAME&gt;Maria Bellau&lt;/NAME&gt;    &lt;SPOUSE IDREF="p7"/&gt;  &lt;/PERSON&gt;  &lt;PERSON ID="p5" FATHER="p2" MOTHER="p1"&gt;    &lt;NAME&gt;Eugene Bellau&lt;/NAME&gt;  &lt;/PERSON&gt;  &lt;PERSON ID="p8" FATHER="p2" MOTHER="p1"&gt;    &lt;NAME&gt;Louise Pauline Bellau&lt;/NAME&gt;    &lt;BORN&gt;29 Oct 1868&lt;/BORN&gt;    &lt;DIED&gt;3 May 1938&lt;/DIED&gt;    &lt;SPOUSE IDREF="p9"/&gt;  &lt;/PERSON&gt;  &lt;PERSON ID="p9"&gt;    &lt;NAME&gt;Charles Walter Harold&lt;/NAME&gt;    &lt;BORN&gt;about 1861&lt;/BORN&gt;    &lt;DIED&gt;about 1938&lt;/DIED&gt;    &lt;SPOUSE IDREF="p8"/&gt;  &lt;/PERSON&gt;  &lt;PERSON ID="p10" FATHER="p2" MOTHER="p1"&gt;    &lt;NAME&gt;Victor Joseph Bellau&lt;/NAME&gt;    &lt;SPOUSE IDREF="p11"/&gt;  &lt;/PERSON&gt;  &lt;PERSON ID="p11"&gt;    &lt;NAME&gt;Ellen Gilmore&lt;/NAME&gt;    &lt;SPOUSE IDREF="p10"/&gt;  &lt;/PERSON&gt;  &lt;PERSON ID="p12" FATHER="p2" MOTHER="p1"&gt;    &lt;NAME&gt;Honore Bellau&lt;/NAME&gt;  &lt;/PERSON&gt;  &lt;FAMILY ID="f1"&gt;    &lt;HUSBAND IDREF="p2"/&gt;    &lt;WIFE IDREF="p1"/&gt;    &lt;CHILD IDREF="p3"/&gt;    &lt;CHILD IDREF="p5"/&gt;    &lt;CHILD IDREF="p6"/&gt;    &lt;CHILD IDREF="p8"/&gt;    &lt;CHILD IDREF="p10"/&gt;    &lt;CHILD IDREF="p12"/&gt;  &lt;/FAMILY&gt;  &lt;FAMILY ID="f2"&gt;    &lt;HUSBAND IDREF="p7"/&gt;    &lt;WIFE IDREF="p6"/&gt;  &lt;/FAMILY&gt;&lt;/FAMILYTREE&gt;</pre><p>In the sections that follow, this document is assumed to be present at the URL <code>http://www.theharolds.com/genealogy.xml</code>. This isn&#146;t a real URL, but the emphasis here is on selecting individual parts of a document rather than a document as a whole.</p><h2>Location Paths, Steps, and Sets</h2></font><p>Many (though not all) XPointers are <i>location paths</i>. These are the same location paths used by XSLT and discussed in Chapter 15. Consequently, much of the syntax should already be familiar to you.</p><p>Location paths are built from <i>location steps</i>. Each location step specifies a point in the targeted document, always relative to some other well-known point such as the start of the document or the previous location step. This well-known point is called the <i>context node</i>. In general, a location step has three parts: the <i>axis</i>, the <i>node test</i>, and an optional <i>predicate</i>. These are combined in this form:</p><i><pre>axis</i>::<i>node-test</i>[<i>predicate</i>]</pre><p>For example, in the location step <code>child::PERSON[position()=2]</code>, the axis is <code>child</code>, the node-test is <code>PERSON</code>, and the predicate is <code>[position()=2]</code>. This location step selects the second <code>PERSON</code> element along the child axis, starting from the context node or, less formally, the second <code>PERSON</code> child element of the context node. Of course, which element this actually is depends on what the context node is. Consequently, this is what&#146;s referred to as a <i>relative location step</i>. It&#146;s relative to the context node. There are also absolute location steps that do not depend on the context node.</p><p>The axis specifies the direction to search from the context node. For example, an axis can say to look at things that follow the context node, things that precede the context node, things that are children of the context node, things that are attributes of the context node, and so forth.</p><p>The node test indicates which nodes to consider along the axis. The most common node test is simply an element name. However, the node test can also be the asterisk (<code>*</code>) wildcard to indicate that any element is to be matched, or one of several functions for selecting comments, text, attributes, processing instructions, points, and ranges. The group of nodes along the given axis that satisfy the node test forms a <i>location set</i>.</p><p>The predicate is a boolean XPath expression (exactly like the XPath expressions you learned about in XSLT) that tests each node in that set. If that expression returns false, the node is removed from the set.</p><p>Often, after the entire location step&#151;axis, node test, and predicate&#151;has been evaluated, what&#146;s left is a single, unique node. However, not all location steps select exactly one node. In some cases, there may be multiple nodes in the final location set. On occasion, there might be no nodes in the location set; in other words, the location set is the empty set.</p><p>A single location step is often not enough to identify the node you want. Commonly, location steps are strung together, separated by slashes, to form a <i>location path</i>. Each location step&#146;s location set becomes the context node-set for the next step in the path. For example, consider this XPointer:</p><pre>xpointer(/child::FAMILYTREE/child::PERSON[position()=3])</pre><p>The location path of this XPointer is <code>/child::FAMILYTREE/child::PERSON[position()=3]</code>. It is built from two location steps:</p><ul><code><li>/child::FAMILYTREE</li><li>child::PERSON[position()=3]</li></code></ul></font><p>The first location step is an absolute step that selects all child elements of the root node whose name is <code>FAMILYTREE</code>. When applied to Listing 18-1, there&#146;s exactly one such element. The second location step is then applied relative to the <code>FAMILYTREE</code> element returned by the first location step. All of its child nodes are considered. Those that satisfy the node test&#151;that is, elements whose name is <code>PERSON</code>&#151;are returned. There are 12 of these nodes. Each of these 12 nodes is then compared against the predicate to see if its position is equal to 3. This turns out to be true for only one node, Elodie Bellau&#146;s <code>PERSON</code> element, so that is the single node this XPointer points to.</p><p>It is not always the case, however, that an XPointer points to exactly one node. For example, consider this XPointer:</p><pre>xpointer(/child::FAMILYTREE/child::PERSON[position()&gt;3])</pre><p>This is exactly the same as before except that the equals sign has been changed to a greater than sign. Now when each of the 12 <code>PERSON</code> elements are compared, the predicate returns true for 9 of them. Each of these nine is included in the location set that this XPointer returns. This XPointer points to nine nodes, not to one.</p><h2>The Root Node</h2></font><p>Although Listing 18-1 includes ID attributes for most elements, and although they are convenient, they are not required for linking into the document. You can select any element in the document simply by working your way down from the root node. An initial <code>/</code> indicates the root node.</p><p>The root node is not the same as the root element. Rather, it is an abstract node that contains the entire document, including any comments or processing instructions that come before or after the root element, such as <code>xml-stylesheet</code>, and the root element itself. For example, to select the root node of the XML 1.0 specification at <code>http://www.w3.org/TR/REC-xml</code> you can use this URI:</p><pre>http://www.w3.org/TR/REC-xml#xpointer(/)</pre><p>For another example, Domeniquette Celeste Baudean is the first person in Listing 18-1. Therefore, to point at her name, you can get the first element child of the root node (that is, the root element of the document, <code>FAMILYTREE</code>), then count one <code>PERSON</code> down from the root element, and then count one <code>NAME</code> down from that, like this:</p><pre>/child::*/child::PERSON[position()=1]/child::NAME</pre><p>This location path says to find the root node, then find all element children of the root node (which, in a well-formed XML document, will be exactly the root element), then find the first <code>PERSON</code> element that&#146;s an immediate child of that element, and then find its <code>NAME</code> child elements.</p><h2>Axes</h2></font><p>XPath defines 13 axes along which an XPointer can search for nodes, all from the same XPath syntax used for XSLT. These depend on context to determine exactly what they point to. For example, consider this location path:</p><pre>id("p6")/child::NAME</pre><p>It begins with the <code>id()</code> function that returns a node-set containing the element with the ID type attribute whose value is <code>p6</code>. This provides a context node for the following location step along the relative child axis. Other axes include <code>ancestor</code>, <code>descendant</code>, <code>self</code>, <code>ancestor-or-self</code>, <code>descendant-or-self</code>, <code>attribute</code>, and more. Each serves to select a particular subset of the elements in the document. For example, the <code>following</code> axis selects from nodes that come after the context node. The <code>preceding</code> axis selects from nodes that come before the context node. Table 18-1 summarizes the 13 axes.</p><font face="Arial"><p align="CENTER">Table 18-1</p><b><p align="CENTER">Location Step Axes</p></b></font><p align="CENTER"><center><table border cellspacing=1 bordercolor="#808080" width=382><tr><td width="19%" valign="TOP"><p><b><i><font face="Arial" size=1>Axis</b></i></font></td><td width="81%" valign="TOP"><b><i><font face="Arial" size=1><p>Selects From</b></i></font></td></tr><tr><td width="19%" valign="TOP"><code><font face="Arial" size=1><p>child</code></font></td><td width="81%" valign="TOP"><font face="Arial" size=1><p>All nodes contained in the context node, but not contained in any other nodes the context node contains</font></td></tr><tr><td width="19%" valign="TOP"><code><font face="Arial" size=1><p>parent</code></font></td><td width="81%" valign="TOP"><font face="Arial" size=1><p>The unique node that contains the context node but that does not contain any other nodes that also contain the context node</font></td></tr><tr><td width="19%" valign="TOP"><code><font face="Arial" size=1><p>self</code></font></td><td width="81%" valign="TOP"><font face="Arial" size=1><p>The context node</font></td></tr><tr><td width="19%" valign="TOP"><code><font face="Arial" size=1><p>ancestor</code></font></td><td width="81%" valign="TOP"><font face="Arial" size=1><p>The parent of the context node, the parent of the parent of the context node, the parent of the parent of the parent of the context node, and so forth, back to the root node</font></td></tr><tr><td width="19%" valign="TOP"><code><font face="Arial" size=1><p>ancestor-or-self</code></font></td><td width="81%" valign="TOP"><font face="Arial" size=1><p>The ancestors of the context node and the context node itself</font></td></tr><tr><td width="19%" valign="TOP"><code><font face="Arial" size=1><p>attribute</code></font></td><td width="81%" valign="TOP"><font face="Arial" size=1><p>The attributes of the context node</font></td></tr><tr><td width="19%" valign="TOP"><code><font face="Arial" size=1><p>descendant</code></font></td><td width="81%" valign="TOP"><font face="Arial" size=1><p>The children of the context node, the children of the children of the context node, and so forth</font></td></tr><tr><td width="19%" valign="TOP"><code><font face="Arial" size=1><p>descendant-or-self</code></font></td><td width="81%" valign="TOP"><font face="Arial" size=1><p>The context node and its descendants</font></td></tr><tr><td width="19%" valign="TOP"><code><font face="Arial" size=1><p>following</code></font></td><td width="81%" valign="TOP"><font face="Arial" size=1><p>All nodes that start after the end of the context node, excluding attribute and namespace nodes</font></td></tr><tr><td width="19%" valign="TOP"><code><font face="Arial" size=1><p>following-sibling</code></font></td><td width="81%" valign="TOP"><font face="Arial" size=1><p>All nodes that start after the end of the context node and have the same parent as the context node, excluding attribute and namespace nodes</font></td></tr><tr><td width="19%" valign="TOP"><code><font face="Arial" size=1><p>preceding</code></font></td><td width="81%" valign="TOP"><font face="Arial" size=1><p>All nodes that finish before the beginning of the context node, excluding attribute and namespace nodes</font></td></tr><tr><td width="19%" valign="TOP"><code><font face="Helvetica" size=1><p>preceding-sibling</code></font></td><td width="81%" valign="TOP"><font face="Arial" size=1><p>All nodes that start before the beginning of the context node and have the same parent as the context node, excluding attribute and namespace nodes</font></td></tr></table></center></p><b><i><font face="Helvetica"><p align="CENTER">The child axis</p></b></i></font><p>The <code>child</code> axis selects from the children of the context node. For example, consider this XPointer:</p><pre>xpointer(/child::FAMILYTREE/child::PERSON[position()=3]/child::NAME)</pre><p>Reading from right to left, it selects the <code>NAME</code> child elements of the third <code>PERSON</code> element that&#146;s a child of the <code>FAMILYTREE</code> element that&#146;s a child of the root of the document. In this example, there&#146;s only one such element; but if there are more than one, all are returned. For instance, consider this XPointer:</p><pre>xpointer(/child::FAMILYTREE/child::PERSON/child::NAME)</pre><p>This selects all <code>NAME</code> children of <code>PERSON</code> elements that are children of <code>FAMILYTREE</code> elements that are children of the root. There are a dozen of these in Listing 18-1.</p><p>It&#146;s important to note that the <code>child</code> axis only selects from the <i>immediate</i> children of the context node. For example, consider this URI:</p><pre>http://www.theharolds.com/genealogy.xml#xpointer(/child::NAME)</pre><p>This points nowhere because there are no <code>NAME</code> elements in the document that are direct, immediate children of the root node. There are a dozen <code>NAME</code> elements that are indirect children. If you&#146;d like to refer to these, you should use the <code>descendant</code> axis instead of <code>child</code>.</p><p>As in XSLT, the <code>child</code> axis is implied if no explicit axis name is present. For example, the preceding three XPointers would more likely be written in this abbreviated form:</p><pre>xpointer(/FAMILYTREE/PERSON[position()=3]/NAME)xpointer(/FAMILYTREE/PERSON/NAME)xpointer(/NAME)</pre><b><i><font face="Helvetica"><p>The descendant axis</p></b></i></font><p>The <code>descendant</code> axis searches through all the descendants of the context node, not just the immediate children. For example, <code>/descendant::BORN</code> selects all the <code>BORN</code> elements in the document. <code>/descendant::BORN[position()=3]</code> selects the third <code>BORN</code> element encountered in a depth-first search of the document tree. (Depth first is the order you get if you simply read through the XML document from beginning to end.) In Listing 18-1, that selects Louise Pauline Bellau&#146;s birthday, <code>&lt;BORN&gt;29 Oct 1868&lt;/BORN&gt;</code>. There is no abbreviation for <code>descendant</code> axis.</p><b><i><font face="Helvetica"><p>The descendant-or-self axis</p></b></i></font><p>The <code>descendant-or-self</code> axis searches through all the descendants of the context node and the context node itself. For example, <code>id("p11")/descendant-or-self::PERSON</code> refers to all <code>PERSON</code> children of the element with ID <code>p11</code> as well as that element itself, because it is of type <code>PERSON</code>. There is no abbreviation for <code>descendant-or-self</code>.</p><p>The <code>descendant-or-self</code> axis can be abbreviated by using a double slash in place of a single slash. For example, <code>//BORN[position()=3]</code> also selects the third <code>BORN</code> element encountered in a depth-first search of the document tree. <code>//NAME</code> selects all <code>NAME</code> elements in the document. <code>//PERSON/NAME</code> selects all <code>NAME</code> children of <code>PERSON</code> elements.</p><b><i><font face="Helvetica"><p>The parent axis</p></b></i></font><p>The <code>parent</code> axis refers to the node that&#146;s the immediate parent of the context node. For example, <code>/descendant::HUSBAND[position()=1]/parent::*</code> refers to the parent element of the first <code>HUSBAND</code> element in the document. In Listing 18-1, this is the <code>FAMILY</code> element with ID <code>f1</code>.</p><p>Without a node test, the parent axis can be abbreviated by a <code>..</code> as in <code>//HUSBAND[position()=1]/..</code>.</p><b><i><font face="Helvetica"><p>The self axis</p></b></i></font><p>The <code>self</code> axis selects the context node. It&#146;s sometimes useful when making relative links. For example, <code>/self::node()</code> selects the root node of the document (which is not the same as the root element of the document; that would be selected by <code>/child::*</code> or, in this example, <code>/child::FAMILYTREE</code>.) It can be abbreviated by a single period. However, this axis is rarely used in XPointers. It&#146;s more useful for XSLT select expressions.</p><b><i><font face="Helvetica"><p>The ancestor axis</p></b></i></font><p>The <code>ancestor</code> axis selects all nodes that contain the context node, starting with its parent. For example, <code>/descendant::BORN[position()=2]/ancestor::*[position()=1]</code> selects the element that contains the second <code>BORN</code> element. Applied to Listing 18-1, it selects Elodie Bellau's <code>PERSON</code> element. There&#146;s no abbreviation for the <code>ancestor</code> axis.</p><b><i><font face="Helvetica"><p>The ancestor-or-self axis</p></b></i></font><p>The <code>ancestor-or-self</code> axis selects the context node and all nodes that contain it. For example, <code>id("p1")/ancestor-or-self::*</code> identifies a node-set that includes Domeniquette Celeste Baudean&#146;s <code>PERSON</code> element, that has ID <code>p1</code>, and its parent, the <code>FAMILYTREE</code> element, and its parent, the root node. There&#146;s also no abbreviation for the <code>ancestor-or-self</code> axis.</p><b><i><font face="Helvetica"><p>The preceding axis</p></b></i></font><p>The <code>preceding</code> axis selects all nodes that finish before the context node. The first time it encounters an element&#146;s start-tag or empty-element tag, moving backwards from the start of the context node, it counts that element. For example, consider this rule:</p><pre>/descendant::BORN[position()=3]/preceding::*[position()=6]</pre><p>This says go to the third <code>BORN</code> element from the root, Louise Pauline Bellau&#146;s birthday, <code>&lt;BORN&gt;29 Oct 1868&lt;/BORN&gt;</code>, and then move back six elements. This lands on Maria Bellau&#146;s <code>NAME</code> element. There&#146;s no abbreviation for the <code>preceding</code> axis.</p><b><i><font face="Helvetica"><p>The following axis</p></b></i></font><p>The <code>following</code> axis selects all elements that occur after the context node&#146;s closing tag. The first time it encounters an element&#146;s start-tag or empty-element tag, it counts that element. For example, consider this location path:</p><pre>/descendant::BORN[position()=2]/following::*[position()=5]</pre><p>This says go to Elodie Bellau&#146;s birthday, <code>&lt;BORN&gt;11 Feb 1858&lt;/BORN&gt;</code>, and then move forward five elements. This lands on John P. Muller&#146;s <code>SPOUSE</code> element, <code>&lt;SPOUSE IDREF="p3" /&gt;</code>, after passing through Elodie Bellau's <code>DIED</code> element, Elodie Bellau&#146;s <code>SPOUSE</code> element, John P. Muller&#146;s <code>PERSON</code> element, and John P. Muller&#146;s <code>NAME</code> element, in this order. There&#146;s no abbreviation for the <code>following</code> axis.</p><b><i><font face="Helvetica"><p>The preceding-sibling axis</p></b></i></font><p>The <code>preceding-sibling</code> axis selects elements that precede the context node in the same parent element. For example, <code>/descendant::BORN[position()=2]/preceding-sibling::*[position()=1]</code> selects Elodie Bellau&#146;s <code>NAME</code> element, <code>&lt;NAME&gt;Elodie Bellau&lt;/NAME&gt;</code>. <code>/descendant::BORN[position()=2]/preceding-sibling::*[position()=2]</code> doesn&#146;t point to anything, because there&#146;s only one sibling of Elodie Bellau&#146;s <code>BORN</code> element before it. There&#146;s no abbreviation for the <code>preceding-sibling</code> axis.</p><b><i><font face="Helvetica"><p>The following-sibling axis</p></b></i></font><p>The <code>following-sibling</code> axis selects elements that follow the context node in the same parent element. For example, <code>/descendant::BORN[position()=2]/following-sibling::*[position()=1]</code> selects Elodie Bellau&#146;s <code>DIED</code> element, <code>&lt;DIED&gt;12 Apr 1898&lt;/DIED&gt;</code>. <code>/descendant::BORN[position()=2]/following-sibling::*[position()=3]</code> doesn&#146;t point to anything, because there are only two sibling elements following Elodie Bellau&#146;s <code>BORN</code> element. There&#146;s no abbreviation for the <code>following-sibling</code> axis.</p><b><i><font face="Helvetica"><p>The attribute axis</p></b></i></font><p>The <code>attribute</code> axis selects attributes of the context node. For example, the location path <code>/descendant::SPOUSE/attribute::IDREF</code> selects all <code>IDREF</code> attributes of all <code>SPOUSE</code> elements in the document. The <code>attribute</code> axis can be abbreviated by an <code>@</code> sign. Thus, <code>//SPOUSE/@IDREF</code> also selects all <code>IDREF</code> attributes of all <code>SPOUSE</code> elements in the document. <code>@*</code> is a general abbreviation for an attribute with any name. So, <code>//SPOUSE/@*</code> indicates all attributes of all <code>SPOUSE</code> elements.</p><p>For another example, to find all <code>PERSON</code> elements in the document <code>http://www.theharolds.com/genealogy.xml</code> whose <code>FATHER</code> attribute is Jean Francois Bellau (ID p2), you could write <code>//PERSON[@FATHER="p2"]</code>.</p><p>The <code>xmlns</code> and <code>xmlns:<i>prefix</i></code> attributes used to declare namespaces are not attribute nodes. To get information about namespaces, you have to use the <code>namespace</code> axis instead.</p><b><i><font face="Helvetica"><p>The namespace axis</p></b></i></font><p>The <code>namespace</code> axis contains the namespaces in scope on the context node. It only applies to element nodes. There is one namespace node for each prefix that is mapped to a URI on that element (whether the prefix is used or not, and whether the <code>xmlns:<i>prefix</i></code> attribute that created the mapping is on the element itself or one of its ancestors). Furthermore, if the element is in a default, nonprefixed namespace, there is also a namespace node for the default namespace.</p><p>Although the element is the parent of the namespace node, the namespace node is not the child of the element. A simple walk of the tree or asking for the children of the element will not find namespaces. Instead, you have to walk the <code>namespace</code> axis explicitly. The only node tests that apply to namespace nodes are <code>node()</code> and <code>*</code>.</p><p>Fortunately, there&#146;s very little reason to point to a namespace node with an XPointer. This axis is more useful for XSLT and not much used in XPointer.</p><h2>Node Tests</h2></font><p>Most of the time, the node test part of a location step is simply an element or attribute name such as <code>PERSON</code> or <code>IDREF</code>. However, there are nine other possibilities:</p><ul><code><li>*</li></ul><ul><i><li>prefix</i>:*</li><li>node()</li><li>text()</li><li>comment()</li><li>processing-instruction()</li><li>point()</li><li>range()</li></code></ul></font><p>An asterisk stands for any element, except on the attribute axis, where it stands for any attribute, and along the namespace axis, where it stands for any namespace. For example, <code>id("p1")/child::*</code> selects all the child elements of the element with the ID <code>p1</code>, regardless of their type. This does, however, select only element nodes. It omits comment nodes, text nodes, processing instruction nodes, and attribute nodes. If you want to select absolutely any kind of node, use the <code>node()</code> node test instead.</p><p>A prefix followed by an asterisk selects all elements in the namespace that match the prefix. For example, if the <code>svg</code> prefix is mapped to the <code>http://www.w3.org/2000/svg</code> URI, <code>svg:*</code> matches all SVG elements. Similarly, <code>@<i>prefix</i>:*</code> matches all attributes in the specified namespace. For example, if <code>xlink</code> is mapped to the URI <code>http://www.w3.org/1999/xlink</code>, <code>@xlink:*</code> matches all XLink attributes in the document, such as <code>xlink:type</code>, <code>xlink:show</code>, <code>xlink:actuate</code>, <code>xlink:href</code>, <code>xlink:role</code>, and so forth.</p><p>The <code>xmlns:prefix</code> attributes in the document where the XPointer is found do not apply to XPointers in that document (if indeed, the XPointer is even in an XML document and not in an HTML document, painted on the side of a building, or something else). Instead, you prefix the <code>xpointer()</code> part with one or more <code>xmlns(<i>prefix</i>=<i>URI</i>)</code> parts that establish a prefix mapping.</p><p>For example, suppose you want to point at the MathML <code>math</code> element in the document at <code>http://www.example.com/equations.xml</code>. You know that this element is in the <code>http://www.w3.org/1998/Math/MathML</code> namespace, but you don&#146;t know what prefix is used in the document. Regardless of what prefix the target document uses, you can use the prefix <code>mml</code> as long as you use an <code>xmlns(mml=http://www.w3.org/1998/Math/MathML)</code> part to associate it with the right URI, as in the following example:</p><pre>xmlns(mml=http://www.w3.org/1998/Math/MathML)xpointer(//mml:math[1])</pre><p>The <code>text()</code> node test specifically refers to the parsed character data content of an element. It&#146;s most commonly used with mixed content. Despite the parentheses, the <code>text()</code> node test does not actually take any arguments. For example, <code>/descendant::text()</code> refers to all of the text but none of the markup of a document. For another example, consider this <code>CITATION</code> element:</p><pre>  &lt;CITATION CLASS="TURING" ID="C2"&gt;    &lt;AUTHOR&gt;Turing, Alan M.&lt;/AUTHOR&gt;    "&lt;TITLE&gt;On Computable Numbers,      With an Application to the Entscheidungs-problem&lt;/TITLE&gt;"    &lt;JOURNAL&gt;      Proceedings of the London Mathematical Society&lt;/JOURNAL&gt;,    &lt;SERIES&gt;Series 2&lt;/SERIES&gt;,    &lt;VOLUME&gt;42&lt;/VOLUME&gt;    (&lt;YEAR&gt;1936&lt;/YEAR&gt;):    &lt;PAGES&gt;230-65&lt;/PAGES&gt;.  &lt;/CITATION&gt;</pre><p>The following location path refers to the quotation mark before the <code>TITLE</code> element:</p><pre> id("C2")/child::text()[position()=2]</pre><p>The first text node in this fragment is the white space between <code>&lt;CITATION CLASS="TURING" ID="C2"&gt;</code> and <code>&lt;AUTHOR&gt;</code>. Technically, this location path refers to all text between <code>&lt;/AUTHOR&gt;</code> and <code>&lt;TITLE&gt;</code>, including the white space and not just the quotation mark.</p><p>Because character data does not contain any child nodes, you cannot add an additional child, descendant, or attribute relative location step after the first term that selects a text node.</p><p>The <code>comment()</code> node test specifically refers to comments. For example, this XPointer points to the third comment in the document:</p><pre>xpointer(/descendant::comment()[position()=3])</pre><p>Because comments do not contain attributes or elements, you cannot add an additional child, descendant, or attribute relative location step after the first term that selects a comment. Despite the parentheses, the <code>comment()</code> node test does not actually take any arguments.</p><p>Finally, the <code>processing-instruction()</code> node test selects any processing instructions that occur along the chosen axis. You can use it without any arguments to select all processing instructions, or with an argument to specify the targets of the particular processing instructions you want to select. For example, <code>/descendant::processing-instruction()</code> selects all processing instructions in the document, whereas <code>/descendant::processing-instruction('xml-stylesheet')</code> only finds processing instructions that begin <code>&lt;?xml-stylesheet </code>. <code>/descendant::processing-instruction("php")</code> only finds processing instructions intended for PHP. As with comments, because processing instructions do not contain attributes or elements, you cannot add an additional child, descendant, or attribute relative location step after the first step that selects a processing instruction.</p><p>The <code>point()</code> and <code>range()</code> node tests refer to new ways of dividing an XML document that only work in XPointer, not in other standards that use XPath, such as XSLT. They are discussed later in the chapter.</p><h2>Predicates</h2></font><p>Each location step can contain zero or more predicates that further restrict which nodes an XPointer points to. In many cases, a predicate is necessary to pick the one node from a node-set that you want. This uses the same syntax you learned from XSLT in Chapter 15. Each predicate contains an expression in square brackets (<code>[]</code>). This allows an XPointer to select nodes according to many different criteria, such as the following:</p><ul>	<li><p>All elements that have a <code>color</code> attribute</p></li>	<li><p>All elements that have a <code>width</code> attribute with the value <code>100</p></li>	<li></code><p>The first element in the document that contains a <code>LIMIT</code> element</p></li>	<li><p>The second element whose text content includes the word "Gale"</p></li>	<li><p>All elements that are not the first or last children of their parents</p></li>	<li><p>All elements whose value is 42</p></li>	<li><p>All elements whose value is a number greater than 100</p></li></ul><p>These are just a small sampling of the selections that predicates make possible.</p><p>The result of a predicate expression is ultimately converted to a boolean after all calculations are finished. Nonboolean results are converted as follows:</p><ul>	<li><p>A number is compared against the position of the node in the context node list. If it matches, the result is true; otherwise, the result is false. (More about this shortly.)</p></li>	<li><p>An empty node-set is false; all other node-sets are true.</p></li>	<li><p>A zero-length string is false; all other strings are true (including the string "false").</p></li></ul><p>The predicate expression is evaluated for each node in the context node list. Each node for which the expression ultimately evaluates to false is removed from the list. Thus, only those nodes that satisfy the predicate remain. I will not repeat the discussion of the operators and functions available to use expressions here. However, I will show you a few examples of predicates using the expression syntax as it&#146;s likely to be used in XPointers.</p><dir><b><font face="Arial" size=1 color="#000080"><p>Cross-reference</p></b></font><p>Expression syntax is covered in Chapter 15.</p></dir></font><p>Probably the most frequently used function in XPointer predicates is <code>position()</code>. This returns the index of the node in the context node list. This enables you to find the first, second, third, or other indexed node. You can compare positions using the relational operators <code>&lt;</code>, <code>&gt;</code>, <code>=</code>, <code>!=</code>, <code>&gt;=</code>, and <code>&lt;=</code>.</p><p>For example, in Listing 18-1 the root <code>FAMILYTREE</code> element has 14 immediate children, 12 <code>PERSON</code> elements, and 2 <code>FAMILY</code> elements. In order, they are:</p><pre>xpointer(/child::FAMILYTREE/child::*[position()=1])xpointer(/child::FAMILYTREE/child::*[position()=2])xpointer(/child::FAMILYTREE/child::*[position()=3])xpointer(/child::FAMILYTREE/child::*[position()=4])xpointer(/child::FAMILYTREE/child::*[position()=5])xpointer(/child::FAMILYTREE/child::*[position()=6])xpointer(/child::FAMILYTREE/child::*[position()=7])xpointer(/child::FAMILYTREE/child::*[position()=8])xpointer(/child::FAMILYTREE/child::*[position()=9])xpointer(/child::FAMILYTREE/child::*[position()=10])xpointer(/child::FAMILYTREE/child::*[position()=11])xpointer(/child::FAMILYTREE/child::*[position()=12])xpointer(/child::FAMILYTREE/child::*[position()=13])xpointer(/child::FAMILYTREE/child::*[position()=14])</pre><p>In fact, this test is so common that XPath offers a shorthand notation for it. Instead of writing <code>[position=X]</code> where X is a number, you can simply enclose the number or an XPath expression that returns the number in the square brackets, like this:</p><pre>xpointer(/child::FAMILYTREE/child::*[1])xpointer(/child::FAMILYTREE/child::*[2])xpointer(/child::FAMILYTREE/child::*[3])xpointer(/child::FAMILYTREE/child::*[4])xpointer(/child::FAMILYTREE/child::*[5])xpointer(/child::FAMILYTREE/child::*[6])xpointer(/child::FAMILYTREE/child::*[7])xpointer(/child::FAMILYTREE/child::*[8])xpointer(/child::FAMILYTREE/child::*[9])xpointer(/child::FAMILYTREE/child::*[10])xpointer(/child::FAMILYTREE/child::*[11])xpointer(/child::FAMILYTREE/child::*[12])xpointer(/child::FAMILYTREE/child::*[13])xpointer(/child::FAMILYTREE/child::*[14])</pre><p>Greater numbers, such as <code>/child::FAMILYTREE/child::*[15]</code>, don&#146;t point to anything..</p><p>To count all elements in the document, not just the immediate children of the root, you can use the <code>descendant</code> axis instead of <code>child</code>. Table 18-2 shows the first four descendant XPointers for the document element <code>FAMILYTREE</code> of Listing 18-1, and what they point to. Note especially that <code>/child::FAMILYTREE/descendant::*[position()=1]</code> points to the entire first <code>PERSON</code> element, including its children, and not just the <code>&lt;PERSON&gt;</code> start-tag.</p><font face="Arial"><p align="CENTER">Table 18-2</p><b><p align="CENTER">The First Four Descendants of the Document Element</p></b></font><p align="CENTER"><center><table border cellspacing=1 bordercolor="#808080" width=399><tr><td width="49%" valign="TOP"><p><b><i><font face="Arial" size=1>XPointer</b></i></font></td><td width="51%" valign="TOP"><b><i><font face="Arial" size=1><p>Points To</b></i></font></td></tr><tr><td width="49%" valign="TOP"><code><font face="Arial" size=1><p>/child::FAMILYTREE/descendant::*[position()=1]</code></font></td><td width="51%" valign="TOP"><code><font face="Arial" size=1><p>&lt;PERSON ID="p1"&gt;</p><p>&lt;NAME&gt;Domeniquette Celeste Baudean&lt;/NAME&gt;</p><p>&lt;BORN&gt;11 Feb 1858&lt;/BORN&gt;</p><p>&lt;DIED&gt;12 Apr 1898&lt;/DIED&gt;</p><p>&lt;SPOUSE IDREF="p2"/&gt;</p><p>&lt;/PERSON&gt;</code></font></td></tr><tr><td width="49%" valign="TOP"><code><font face="Arial" size=1><p>/child::FAMILYTREE/descendant::*[position()=2]</code></font></td><td width="51%" valign="TOP"><code><font face="Arial" size=1><p>&lt;NAME&gt;Domeniquette Celeste Baudean&lt;/NAME&gt;</code></font></td></tr><tr><td width="49%" valign="TOP"><code><font face="Arial" size=1><p>/child::FAMILYTREE/descendant::*[position()=3]</code></font></td><td width="51%" valign="TOP"><code><font face="Arial" size=1><p>&lt;BORN&gt;21 Apr 1836&lt;/BORN&gt;</code></font></td></tr><tr><td width="49%" valign="TOP"><code><font face="Helvetica" size=1><p>/child::FAMILYTREE/descendant::*[position()=4]</code></font></td><td width="51%" valign="TOP"><code><font face="Helvetica" size=1><p>&lt;DIED&gt;Unknown&lt;/DIED&gt;</code></font></td></tr></table></center></p><b><font face="Helvetica" size=4><p align="CENTER">Functions That Return Node-Sets</p></b></font><p>XPointers are not limited to location paths. In fact, they can use any expression that returns a node-set. In particular, they can use functions that return node-sets. There are three of these:</p><ul>	<li><p><code>id()</code></p></li>	<li><p><code>here()</code></p></li>	<li><p><code>origin()</code></p></li></ul><p>The last two, <code>here()</code> and <code>origin()</code>, are XPointer extensions to XPath that are not available in XSLT.</p><b><i><font face="Helvetica"><p>id()</p></b></i></font><p>The <code>id()</code> function is one of the simplest and most robust means of identifying an element node. It selects the element in the document that has an ID type attribute with a specified value. For example, consider this URI:</p><pre>http://www.theharolds.com/genealogy.xml#xpointer(id("p12"))</pre><p>If you look at Listing 18-1, you find this element:</p><pre>&lt;PERSON ID="p12" FATHER="p2" MOTHER="p1"&gt;  &lt;NAME&gt;Honore Bellau&lt;/NAME&gt;&lt;/PERSON&gt;</pre><p>Because ID type attributes are unique in valid documents, there shouldn&#146;t be any other elements that match this XPointer. Therefore, <code>http://www.theharolds.com/genealogy.xml#xpointer(id("p12"))</code> should refer to Honore Bellau's <code>PERSON</code> element. Note that the XPointer points to the entire element to which it refers, including all its children, not just the start-tag.</p><dir><b><font face="Arial" size=1 color="#000080"><p>Note</p></b></font><p>If the document is invalid and more than one element has the same ID, only the first one in the document is selected.</p></dir></font><p>Because ID pointers are so common and so useful, there&#146;s also a shortcut for this. If all you want to do is point to a particular element with a particular ID, you can skip all the <code>xpointer(id(""))</code> frou-frou and just use the bare ID after the <code>#,</code> like this:</p><pre>http://www.theharolds.com/genealogy.xml#p12</pre><p>This is called a <i>shorthand pointer</i>. You can only use a shorthand pointer if all you want is the particular element with the particular ID. You cannot add additional relative location steps to a URI that uses this shortcut to select children of the element with ID p12 or the third attribute of the element with ID p12. If you want to do that, you have to use the full <code>xpointer(id("p12"))</code> syntax.</p><p>The disadvantage of the <code>id()</code> function and shorthand pointers is that they require assistance from the targeted document. If the element you want to point to does not have an ID type attribute, you&#146;re out of luck. If other elements in the document have ID type attributes, you might be able to point to one of them and use a relative location step to point to the one you really want. Nonetheless, ID type attributes work best when you control both the targeted document and the linking document, so that you can ensure that the IDs match the links even as the documents evolve and change over time.</p><p>If the document does not have a DTD, it cannot have any ID type attributes, although it may have attributes named <code>ID</code>. In this case, you can&#146;t point at anything using the <code>id()</code> function or a shorthand pointer.</p><p>One possibility is to first use an <code>id()</code>-based XPointer, but back it up with an XPointer that looks for the attribute with the specific name anywhere in the document, <code>ID</code> in this example. Simply append the second XPointer to the first, like this:</p><pre>xpointer(id("p12"))xpointer(//*[@ID="p12"])</pre><p>XPointers are evaluated from left to right. The first match found is returned, so the backup is only used if an ID type attribute with the value <code>p12</code> can't be found.</p><b><i><font face="Helvetica"><p>here()</p></b></i></font><p>The second node-set returning function is <code>here()</code>. However, it&#146;s only useful when used in conjunction with one or more relative location steps. In intradocument links, that is, links from one point in a document to another point in the same document, it&#146;s often necessary to refer to "the next element after this one," or "the parent element of this element." The <code>here()</code> function refers to the node that contains the XPointer so that such references are possible.</p><p>Consider Listing 18-2, a simple slide show. In this example, <code>here()/../following::SLIDE[1]</code> refers to the next slide in the show. <code>here()/../preceding::SLIDE[1]</code> refers to the previous slide in the show. Presumably, this would be used in conjunction with a style sheet that showed one slide at a time.</p><font face="Arial"><p>Listing 18-2: A Slide Show</p></font><pre>&lt;?xml version="1.0"?&gt;&lt;SLIDESHOW xmlns:xlink="http://www.w3.org/1999/xlink"&gt;  &lt;SLIDE&gt;    &lt;H1&gt;Welcome to the slide show!&lt;/H1&gt;    &lt;BUTTON xlink:type="simple"            xlink:href="here()/../following::SLIDE[1]"&gt;      Next    &lt;/BUTTON&gt;  &lt;/SLIDE&gt;  &lt;SLIDE&gt;    &lt;H1&gt;This is the second slide&lt;/H1&gt;    &lt;BUTTON xlink:type="simple"            xlink:href="here()/../preceding::SLIDE[1]"&gt;      Previous    &lt;/BUTTON&gt;    &lt;BUTTON xlink:type="simple"            xlink:href="here()/../following::SLIDE[1]"&gt;      Next    &lt;/BUTTON&gt;  &lt;/SLIDE&gt;  &lt;SLIDE&gt;    &lt;H1&gt;This is the third slide&lt;/H1&gt;    &lt;BUTTON xlink:type="simple"            xlink:href="here()/../preceding::SLIDE[1]"&gt;      Previous    &lt;/BUTTON&gt;    &lt;BUTTON xlink:type="simple"            xlink:href="here()/../following::SLIDE[1]"&gt;      Next    &lt;/BUTTON&gt;  &lt;/SLIDE&gt;  ...  &lt;SLIDE&gt;    &lt;H1&gt;This is the last slide&lt;/H1&gt;    &lt;BUTTON xlink:type="simple"            xlink:href="here()/../preceding::SLIDE[1]"&gt;      Previous    &lt;/BUTTON&gt;  &lt;/SLIDE&gt;&lt;/SLIDESHOW&gt;</pre><p>Generally, the <code>here()</code> function is only used in XLinks where the <code>href</code> attribute contains a relative URI pointing to the same document. If any URI part is included, it must be the same as the URI of the current document.</p><b><i><font face="Helvetica"><p>origin()</p></b></i></font><p>The <code>origin()</code> function is much the same as <code>here()</code>; that is, it refers to the source of a link. However, <code>origin()</code> is used in out-of-line links where the link is not actually present in the source document. It points to the element in the source document from which the user activated the link.</p><h2>Points</h2></font><p>Selecting a particular element or node is almost always good enough for pointing into well-formed XML documents. However, on occasion, you might need to point into XML data in which large chunks of non-XML text is embedded via CDATA sections, comments, processing instructions, or some other means. In these cases, you might need to refer to particular ranges of text in the document that don't map onto any particular markup element. Or, you might need to point into non-XML substructure in the text content of particular elements; for example, the month in a <code>BORN</code> element that looks like this:</p><pre>&lt;BORN&gt;11 Feb 1858&lt;/BORN&gt;</pre><p>An XPath expression can identify an element node, an attribute node, a text node, a comment node, or a processing instruction node. However, it can&#146;t indicate the first two characters of the <code>BORN</code> element (the date) or the substring of text between the first space and the last space in the <code>BORN</code> element (the month).</p><p>XPointer generalizes XPath to allow identifiers like this. An XPointer can address points in the document and ranges between points. These may not correspond to any one node. For example, the place between the <i>X</i> and the <i>P</i> in the word <i>XPointer</i> at the beginning of this paragraph is a point. The place between the <i>t</i> and the <i>h</i> in the word <i>this</i> at the end of the first sentence of this paragraph is another point. The text fragment "Pointer generalizes XPath to allow pointers like t" between those two points is a range.</p><p>Every point is either between two nodes or between two characters in the parsed character data of a document. To make sense of this, you have to remember that parsed character data is part of a text node. For example, consider this very simple but well-formed XML document:</p><pre>&lt;GREETING&gt;Hello&lt;/GREETING&gt;</pre><p>There are exactly 3 nodes and 14 distinct points in this document. The nodes are the root node, which contains the <code>GREETING</code> element node, which contains a text node. In order, the points are as follows:</p><ol><li>The point before the root node</li><li>The point before the <code>GREETING</code> element node</li><li>The point before the text node containing the text "Hello" (as well as assorted white space)</li><li>The point before the line break between <code>&lt;GREETING&gt;</code> and <code>Hello</code></li><li>The point before the first <i>H</i> in <code>Hello</code></li><li>The point between the <i>H</i> and the <i>e</i> in <code>Hello</code></li><li>The point between the <i>e</i> and the <i>l</i> in <code>Hello</code></li><li>The point between the <i>l</i> and the <i>l</i> in <code>Hello</code></li><li>The point between the <i>l</i> and the <i>o</i> in <code>Hello</code></li><li>The point after the <i>o</i> in <code>Hello</code></li><li>The point after the line break between <code>Hello</code> and <code>&lt;/GREETING&gt;</code></li><li>The point after the text node containing the text "Hello"</li><li>The point after the <code>GREETING</code> element</li><li>The point after the root node</li></ol><p>Points allow XPointers to indicate arbitrary positions in the parsed character data of a document. They do not, however, enable pointing at a position in the middle of a tag. In essence, what points add is the ability to break up the text content into smaller nodes, one for each character.</p><p>A point is selected by using the <code>string-range()</code> function to select a range, then using the <code>start-point ()</code> or <code>end-point()</code> function to extract the first or last point from the range. For example, this XPointer selects the point immediately before the <i>D</i> in Domeniquette Celeste Baudean&#146;s <code>NAME</code> element:</p><pre>xpointer(start-point(string-range (id('p1')/NAME,"Domeniquette")))</pre><p>This XPointer selects the point after the last <i>e</i> in <i>Domeniquette</i>:</p><pre>xpointer(end-point(string-range(id('p1')/NAME,"Domeniquette")))</pre><p>You can also take the <code>start-point ()</code> or <code>end-point ()</code> of an element, text, comment, processing instruction, or root node to get the first or last point in that node.</p><h2>Ranges</h2></font><p>Some applications need to specify a range across a document rather than a particular point in the document. For example, the selection a user makes with a mouse is not necessarily going to match up with any one element or node. It might start in the middle of one paragraph, extend across a heading and a picture, and then end in the middle of another paragraph two pages down.</p><p>Any such contiguous area of a document can be described with a <i>range</i>. A range begins at one point and continues until another point. The start point and endpoint are each identified by a location path. If the starting path points to a node-set rather than a point, <code>range-to()</code> will return multiple ranges, one starting from the first point of each node in the set.</p><p>To specify a range, you append <code>/range-to(<i>end-point</i>)</code> to a location path specifying the start point of the range. The parentheses contain a location path specifying the endpoint of the range. For example, suppose you want to select everything between the first <code>&lt;PERSON&gt;</code> start-tag and the last<code>&lt;/PERSON&gt;</code> end-tag in Listing 18-1. The following XPointer accomplishes that:</p><pre>xpointer(/child::FAMILYTREE/child::PERSON[position()=1]/range-to(/child::FAMILYTREE/child::PERSON[position()=last()]))</pre><h3>Range functions</h3><p>XPointer includes several functions specifically for working with ranges. Most of these operate on <i>location sets</i>. A location set is just a node-set that can also contain points and ranges, as well as nodes.</p><p>The <code>range(location-set)</code> function returns a location set containing one range for each location in the argument. The range is the minimum range necessary to cover the entire location. In essence, this function converts locations to ranges.</p><p>The <code>range-inside(location-set)</code> function returns a location set containing the interiors of each of the locations in the input. That is, if one of the locations is an element, the location returned is the content of the element (but not including the start- and end-tags). However, if the input location is a range or point, the interior of the location is just the same as the range or point.</p><p>The <code>start-point(location-set)</code> function returns a location set that contains the first point of each location in the input location set. For example, <code>start-point(//PERSON[1])</code> returns the point immediately after the first <code>&lt;PERSON&gt;</code> start-tag in the document. <code>start-point(//PERSON)</code> returns the set of points immediately after each <code>&lt;PERSON&gt;</code> start-tag.</p><p>The <code>end-point(location-set)</code> function acts the same as <code>start-point()</code> except that it returns the points immediately after each location in its input.</p><b><i><font face="Helvetica"><p>String ranges</p></b></i></font><p>XPointer provides some very basic string-matching capabilities through the <code>string-range()</code> function. This function takes as an argument a location set to search and a substring to search for. It returns a location set containing one range for each nonoverlapping, matching substring. You can also provide optional <code>index</code> and <code>length</code> arguments indicating how many characters after the match the range should start and how many characters after the start the range should continue. The basic syntax is as follows:</p><pre>string-range(location-set, substring, index, length)</pre><p>The first argument is an XPath expression that returns a location set specifying which part of the document to search for a matching string. The second substring, argument is the actual string to search for. By default, the range returned starts before the first matched character and encompasses all the matched characters. However, the <code>index</code> argument can give a positive number to start after the beginning of the match. For example, setting it to 2 indicates that the range starts with the second character after the first matched character. The <code>length</code> argument can specify how many characters to include in the range.</p><p>A string range points to an occurrence of a specified string, or a substring of a given string in the text (not markup) of the document. For example, this XPointer finds all occurrences of the string "Harold":</p><pre>xpointer(string-range(/,"Harold"))</pre><p>You can change the first argument to specify what nodes you want to look in. For example, this XPointer finds all occurrences of the string "Harold" in <code>NAME</code> elements:</p><pre>xpointer(string-range(//NAME,"Harold"))</pre><p>String ranges can have predicates. For example, this XPointer finds only the first occurrence of the string "Harold" in the document:</p><pre>xpointer(string-range(/,"Harold")[position()=1])</pre><p>This targets the position immediately preceding the word Harold in Charles Walter Harold&#146;s <code>NAME</code> element. This is not the same as pointing at the entire <code>NAME</code> element as an element-based selector would do.</p><p>A third numeric argument targets a particular position in the string. For example, this targets the point between the <i>l</i> and <i>d</i> in the first occurrence of the string "Harold" because <i>d</i> is the sixth letter:</p><pre>xpointer(string-range(/,"Harold",6)[position()=1])</pre><p>An optional fourth argument specifies the number of characters to select. For example, this URI selects the <i>old</i> from the first occurrence of the entire string "Harold":</p><pre>xpointer(string-range(/,"Harold",4,3)[position()=1])</pre><p>If the first string argument in the node test is the empty string, matching positions in the context node&#146;s text contents are selected. For example, the following XPointer targets the first six characters of the document&#146;s parsed character data:</p><pre>xpointer(string-range(/,""1,6)[position()=1])</pre><p>For another example, suppose that you want to find the year of birth for all people born in the nineteenth century. The following will accomplish that:</p><pre>xpointer(string-range(//BORN, " 18", 2, 4))</pre><p>This says to look in all <code>BORN</code> elements for the string " 18". (The initial space is important to avoid accidentally matching someone born in 1918 or on the 18<sup>th</sup> day of the month.) When it&#146;s found, move one character ahead (to skip the space) and return a range covering the next four characters.</p><p>When you are matching strings, case is considered. Markup characters are ignored.</p><h2>Child Sequences</h2></font><p>The two most common ways to identify an element in an XML document are by ID and by location. Identifying an element by ID is accomplished through the <code>id()</code> function or a shorthand pointer. Identifying an element by location is generally accomplished by counting children down from the root. For example, the following XPointers both point to John P. Muller&#146;s <code>PERSON</code> element when applied to Listing 18-1:</p><pre>xpointer(id("p4"))xpointer(/child::*[position()=1]/child::*[position()=4])</pre><p>A <i>child sequence</i> is a shortcut for XPointers like the second example above&#151;that is, an XPointer that consists of nothing but a series of child location steps counting down from the root node, each of which selects a particular child by position only. The shortcut is to use only the position number and the slashes that separate individual elements from each other, like this:</p><pre>element(/1/4)</pre><p>As with the <code>xpointer()</code> scheme, this becomes the fragment identifier in a URI reference:</p><pre>http://www.theharolds.com/genealogy.xml#element(/1/4)</pre><code><p>/1/4</code> is a child sequence that selects the fourth child element of the first child element of the root. This syntax can be extended for any depth of child elements. For example, these two URIs point to John P. Muller&#146;s <code>NAME</code> and <code>SPOUSE</code> elements, respectively:</p><pre>http://www.theharolds.com/genealogy.xml#element(/1/4/1)http://www.theharolds.com/genealogy.xml#element(/1/4/2)</pre><p>Child sequences might include an initial ID. In that case, the counting begins from the element with that ID rather than from the root. For example, John P. Muller&#146;s <code>PERSON</code> element has an <code>ID</code> attribute with the value <code>p4</code>. Consequently, <code>element(p4/1)</code> points to his <code>NAME</code> element and <code>element(p4/2)</code> points to his <code>SPOUSE</code> element.</p><p>Each child sequence always points to a single element. You cannot use child sequences with any other relative location steps. You cannot use them to select elements of a particular type. You cannot use them to select attributes or strings. You can only use them to select a single element by its relative location in the tree.</p><h2>Summary</h2></font><p>In this chapter, you learned about XPointers. In particular, you learned the following:</p><ul><li>XPointers refer to particular parts of, or locations in, XML documents.</li><li>An XPointer is used as a fragment identifier for URLs that identify XML documents.</li><li>An XPointer is composed of one or more XPointer parts, each of which has the form scheme(scheme data)</li><li>The most expressive XPointer scheme is <code>xpointer</code>. The scheme data for the xpointer scheme is an XPath expression that returns a node-set.</li><li>A shorthand pointer is just the ID of an element. It selects the element with that ID.</li><li>Each location step contains an axis, a node test, and zero or more predicates.</li><li>Location steps can be chained to make location paths.</li><li>Relative location steps select nodes in a document based on their relationship to a context node.</li><li>The <code>self</code> axis points to the context node. It can be abbreviated as a period (<code>.</code>).</li><li>The <code>parent</code> axis points to the node that contains the context node. It can be abbreviated as a double period (<code>..</code>).</li><li>The <code>child</code> axis includes the immediate children of the context node. It can be abbreviated simply by a node test.</li><li>The <code>descendant</code> axis includes all nodes contained in the context node. It can effectively be abbreviated as a double slash (<code>//</code>).</li><li>The <code>descendant-or-self</code> axis includes all nodes contained in the context node, as well as the context node itself.</li><li>The <code>ancestor</code> axis includes all element nodes that contain the context node, as well as the root node.</li><li>The <code>ancestor-or-self</code> axis includes all nodes that contain the context node, as well as the context node itself.</li><li>The <code>precedin</code>g axis includes all nodes that finish before the context node.</li><li>The <code>following</code> axis includes all nodes that start after the context node.</li><li>The <code>preceding-sibling</code> axis selects from nodes that precede the context node with the same parent node as the context node.</li><li>The <code>following-sibling</code> axis selects from nodes that follow the context node with the same parent node as the context node.</li><li>The <code>attribute</code> axis points to attributes of the context node. It can be abbreviated as an <code>@</code> sign.</li><li>The node test of a relative location step is normally an element or attribute name, but can also be the <code>*</code> wildcard to select all elements or one of the keywords <code>comment()</code>, <code>text()</code>, <code>processing-instruction()</code>, <code>node()</code>, <code>point()</code>, or <code>range()</code>.</li><li>The optional predicate of a relative location step is a boolean XPath expression enclosed in square brackets that further narrows the node-set to which the XPointer refers.</li><li>The <code>xmlns(<i>prefix</i>=<i>URI</i>)</code> scheme is used to declare a namespace prefix for use inside an XPointer.</li><li>A point indicates a position preceding or following a node or a character.</li><li>A range identifies the XML text between two points.</li><li>The <code>string-range()</code> function points to a specified block of text.</li><li>A child sequence points to an element by counting children from the root using the <code>element</code> scheme.</li></ul><p>In this chapter, you saw XPointers used in XLinks. In Chapter 19, you&#146;ll see them used in XInclude, the third leg in the XML hypertext tripod. XInclude is an element-based syntax for building large XML documents out of smaller XML documents that are themselves complete, well-formed, possibly valid XML documents. The individual pieces out of which the complete document is built are located via URLs. These URLs can have XPointer parts to indicate that only part of a targeted document should be included in the master document.</p>  <hr />From XML 1.1 Bible, by <a href="http://www.elharo.com/">Elliotte Rusty Harold</a>. &copy; 2004 byWiley Publishing, Inc.  All rights reserved.  Reproduced here by permissionof the publisher.      <hr />      <div style="text-align: center">                [ <a href="../../index.html">Cafe con Leche</a>          | <a href="../index.html">XML Bible Home Page</a>       | Order  from  <a href="http://www.amazon.com/exec/obidos/ASIN/0764549863/ref=nosim/cafeaulaitA/">amazon.com</a>  |  <a href="http://www.wiley.com/WileyCDA/WileyTitle/productCd-0764549863.html">Publisher Page</a> ]         </div></body></html>