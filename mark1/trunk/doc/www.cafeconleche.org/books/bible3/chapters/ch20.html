<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Schemas</title></head><body text="#000000" link="#0000ff" vlink="#800080" bgcolor="#ffffff"> <div style="text-align: center">                [ <a href="../../../index.html">Cafe con Leche</a>          | <a href="../index.html">XML Bible Home Page</a>       | Order  from  <a href="http://www.amazon.com/exec/obidos/ASIN/0764549863/ref=nosim/cafeaulaitA/">amazon.com</a>  |  <a href="http://www.wiley.com/WileyCDA/WileyTitle/productCd-0764549863.html">Publisher Page</a> ]         </div><hr /><h1>Schemas</h1><h2>In This Chapter</h2><ul>	<li><p>What's wrong with DTDs?</p></li>	<li><p>What is a schema?</p></li>	<li><p>The W3C XML Schema Language</p></li>	<li><p>Hello schemas</p></li>	<li><p>Complex types</p></li>	<li><p>Grouping</p></li>	<li><p>Simple types</p></li>	<li><p>Deriving Simple Types</p></li>	<li><p>Empty elements</p></li>	<li><p>Attributes</p></li>	<li><p>Namespaces</p></li>	<li><p>Annotations</p></li></ul><p>Schemas are documents that define the valid contents of particular classes of XML documents. The schema language discussed in this chapter, the W3C XML Schema Language, has a number of useful characteristics, most notably the ability to specify data types for text content and attribute values. For example, a schema can state that a <code>PRICE</code> element has type double or that a <code>YEAR</code> attribute contains a number between 1966 and 2012. However, schemas have a number of other useful characteristics including namespace awareness and the ability to validate complex structures built up out of many different elements of many types.</p><h2>What's Wrong with DTDs?</h2><p>Document type definitions (DTDs) are an outgrowth of XML&#146;s heritage in the Standardized General Markup Language (SGML). SGML was always intended for narrative-style documents: books, reports, technical manuals, brochures, web pages, and the like. DTDs were designed to serve the needs of these sorts of documents, and indeed they serve them very well. DTDs let you state very simply and straightforwardly that every book must have one or more authors, that every song has exactly one title, that every <code>PERSON</code> element has an <code>ID</code> attribute, and so forth. Indeed, for narrative documents that are intended for human beings to read from start to finish, that are more or less composed of words in a row, there&#146;s really no need for anything beyond a DTD. However, XML has gone well beyond the uses envisioned for SGML. XML is being used for object serialization, stock trading, remote procedure calls, vector graphics, and many more things that look nothing like traditional narrative documents; and it is in these new arenas that DTDs are showing some limits.</p><p>The limitation most developers notice first is the almost complete lack of data typing, especially for element content. DTDs can&#146;t say that a <code>PRICE</code> element must contain a number, much less a number that&#146;s greater than zero with two decimal digits of precision and a dollar sign. There&#146;s no way to say that a <code>MONTH</code> element must be an integer between 1 and 12. There&#146;s no way to indicate that a <code>TITLE</code> must contain between 1 and 255 characters. None of these are particularly important things to do for the narrative documents SGML was aimed at; but they&#146;re very common things to want to do with data formats intended for computer-to-computer exchange of information rather than computer-to-human communication. Humans are very good at handling fuzzy systems where expected data is missing, or perhaps is not in quite the right format; computers are not. Computers need to know that when they expect an element to contain an integer between 1 and 12, the element really contains an integer in that range and nothing else.</p><p>The second problem is that DTDs have an unusual non-XML syntax. The same parrsers and APIs that read an XML document can&#146;t read a DTD. For example, consider this common element declaration:</p><pre>&lt;!ELEMENT TITLE (#PCDATA)&gt;</pre><p>This is not a legal XML element. You can&#146;t begin an element name with an exclamation point. <code>TITLE</code> is not an attribute. Neither is <code>(#PCDATA)</code>. This is a very different way of describing information than is used in XML document instances. One would expect that if XML were really powerful enough to live up to all its hype, it would be powerful enough to describe itself. You shouldn&#146;t need two different syntaxes: one for the information and one for the meta-information detailing the structure of the information. XML element and attribute syntax should suffice for both info and meta-info.</p><p>The third problem is that DTDs are only marginally extensible and don&#146;t scale very well. It&#146;s difficult to combine independent DTDs together in a sensible way. You can do this with parameter entity references. Indeed, SMIL 2.0 and modular XHTML are based on this idea. However, the modularized DTDs are very messy and very hard to follow. The largest DTDs in use today are in the ballpark of 10,000 lines of code, and it&#146;s questionable whether much larger XML applications can be defined before the entire DTD becomes completely unmanageable and incomprehensible. By contrast, the largest computer programs in existence today, which are much more intrinsically complex than even the most ambitious DTDs, easily reach sizes of 1,000,000 lines of code or more.</p><p>Perhaps most annoyingly, DTDs are only marginally compatible with namespaces. The first principle of namespaces is that only the URI matters. The prefix does not. The prefix can change as long as the URI remains the same. However, validation of documents that use namespace prefixes works only if the DTD declares the prefixed names. You cannot use namespace URIs in a DTD. You must use the actual prefixes. If you change the prefixes in the document but don&#146;t change the DTD, the document immediately ceases to be valid. There are some tricks that you can perform with parameter entity references to make DTDs less dependent on the actual prefix, but they&#146;re complicated and not well understood in the XML community. And even when they are understood, these tricks simply feel far too much like a dirty hack rather than a clean, maintainable solution.</p><p>Finally, there are a number of annoying minor limitations where DTDs don&#146;t allow you to do things that it really feels like you ought to be able to do. For example, DTDs cannot enforce the order or number of child elements in mixed content. That is, you can&#146;t enforce constraints such as each <code>PARAGRAPH</code> element must begin with exactly one <code>SUMMARY</code> element that is followed by plain text. Similarly, you can&#146;t enforce the number of child elements without also enforcing their order. For example, you cannot easily say that a <code>PERSON</code> element must contain a <code>FIRST_NAME</code> child, a <code>MIDDLE_NAME</code> child, and a <code>LAST_NAME</code> child, but that you don&#146;t care what order they appear in. Again, there are workarounds, but they grow combinatorially complex with the number of possible child elements.</p><p>Schemas are an attempt to solve all these problems by defining a new XML-based syntax for describing the permissible contents of XML documents that includes the following:</p><ul><li>Powerful data typing including range checking</li><li>Namespace-aware validation based on namespace URIs rather than on prefixes</li><li>Extensibility and scalability</li></ul><p>However, schemas are not a be-all and end-all solution. In particular, <em>schemas do not replace DTDs</em>! You can use both schemas and DTDs in the same document. DTDs can do several things that schemas cannot do, most importantly declaring entities. And DTDs still work very well for the classic sort of narrative documents they were originally designed for. Indeed, for these types of documents, a DTD is often considerably easier to write than an equivalent schema. Parsers and other software will continue to support DTDs for as long as they support XML.</p><dir><h4>What Is a Schema?</h4><p>The word <i>schema</i> derives from the Greek word <i>&sigma;&xhi;&eta;&mu;&alpha;</i>, meaning form or shape. It was first popularized in the Western world by Immanuel Kant in the late 1700s. According to the 1933 edition of the <i>Oxford English Dictionary</i>, Kant used the word <i>schema</i> to mean, "Any one of certain forms or rules of the &#145;productive imagination&#146; through which the understanding is able to apply its &#145;categories&#146; to the manifold of sense-perception in the process of realizing knowledge or experience." (And you thought computer science was full of unintelligible technical jargon!)</p><p>Schemas remained the province of philosophers for the next 200 years until the word schema entered computer science, probably through database theory. Here, schema originally meant any document that described the permissible content of a database. More specifically, a schema was a description of all the tables in a database and the fields in the table. A schema also described what type of data each field could contain: CHAR, INT, CHAR[32], BLOB, DATE, and so on.</p><p>The word schema has grown from that source definition to a more generic meaning of any document that describes the permissible contents of other documents, especially if data typing is involved. Thus, you&#146;ll hear about different kinds of schemas from different technologies, including vocabulary schemas, RDF schemas, organizational schemas, X.500 schemas, and of course, XML schemas.</p></dir><dir><h4>You say schemas, I say schemata</h4><p>Probably no single topic has been more controversial in the schema world than the proper plural form of the word <i>schema</i>. The original Greek plural is <i>&sigma;&xhi;&eta;&mu;&alpha;&tau;&alpha;</i>, <i>schemata</i> in Latin transliteration; and this is the form which Kant used and which you&#146;ll find in most dictionaries. This was fine for the 200 years when only people with Ph.D.s in philosophy actually used the word. However, as often happens when words from other languages are adopted into popular English, its plural changed to something that sounds more natural to an anglophone ear. In this case, the plural form, <i>schemata,</i> seems to be rapidly dying out in favor of the simpler <i>schemas</i>. In fact, the three World Wide Web Consortium (W3C) schema specifications all use the plural form <i>schemas</i>. I follow this convention in this book.</p><p>Because schemas is such a generic term, it shouldn&#146;t come as any surprise that there&#146;s more than one schema language for XML. In fact, there are many, each with its own unique advantages and disadvantages. These include Murata Makoto and James Clark&#146;s RELAX NG (<code>http://relaxng.org/</code>), Rick Jelliffe&#146;s Schematron (<code>http://www.ascc.net/xml/resource/schematron/schematron.html</code>), and the W3C&#146;s misleadingly, generically titled XML Schema Language. In addition, traditional XML DTDs can be considered to be simply another schema language.</p><p>This chapter focuses almost exclusively on the W3C XML Schema Language. Nonetheless, RELAX NG and Schematron are definitely worthy of your attention as well. In particular, if you find W3C schemas to be excessively complex (and many people do) and if you want a simpler schema language that still offers a complete set of extensible data types, you should consider RELAX NG. RELAX NG adopts the less controversial data types half of the W3C XML Schema Recommendation, but replaces the much more complex and much less popular structures half with a much simpler language.</p></dir><dir><h4>Note</h4>There are also several dead XML schema languages that have been abandoned by their manufacturers in favor of other languages. These include Document Content Description (DCD), Commerce One&#146;s Schema for Object-Oriented XML (SOX), and Microsoft&#146;s XML-Data Reduced (XDR). None of these is worth your time or investment at this point. They never achieved broad adoption, and their vendors are now moving to the W3C XML Schema Language instead.</p></dir><p>Most schema languages, including W3C schemas, RELAX NG, and DTDs, take the approach that you must carefully specify what is allowed in the document. They are conservative: Everything not permitted is forbidden. If, on the other hand, you&#146;re looking for a less-restrictive schema language in which everything not forbidden is permitted, you should consider Schematron. Schematron is based on XPath, which allows it to make statements none of the other major schema languages can, such as "An <code>a</code> element cannot have another <code>a</code> element as a descendant, even though an <code>a</code> element can contain a <code>strong</code> element that can contain an <code>a</code> element if it itself is not a descendant of an <code>a</code> element." This isn&#146;t a theoretical example. This is a real restriction in XHTML that has to be made in the prose of the specification because neither DTDs nor the W3C XML Schema Language are powerful enough to say it. What it means is that links can&#146;t nest; that is, a link cannot contain another link.</p><p>From this point forward, I will use the unqualified word <i>schema</i> to refer to the W3C&#146;s XML Schema Language; but please keep in mind that alternatives that are equally deserving of the appellation do exist.</p><h2>The W3C XML Schema Language</h2><p>The W3C XML Schema Language was created by the W3C XML Schema Working Group based on many different submissions from a variety of companies and individuals. It is a very large specification designed to handle a broad range of use cases. In fact, the schema specification is considerably larger and more complex than the XML 1.0 specification. It is an open standard, free to be implemented by any interested party. There are no known patent, trademark, or other intellectual property restrictions that would prevent you from doing anything you might reasonably want to do with schemas. (This, unfortunately, is not quite the same thing as saying that there are no known patent, trademark, or other intellectual property restrictions that would prevent you from doing anything you might reasonably want to do. The U.S. Patent Office has been a little out of control lately, granting patents left and right for inventions that really don&#146;t deserve it, including a lot of software and business processes. I would not be surprised to learn of an as yet unnoticed patent that at least claims to cover some or all of the W3C XML Schema Language.)</p><h2>Hello Schemas</h2><p>Let&#146;s begin our exploration of schemas with the ubiquitous Hello World example. Recall, once again, the code from Listing 3-2 (greeting.xml) in Chapter 3. It is shown here:</p><pre>&lt;?xml version="1.0"?&gt;&lt;GREETING&gt;Hello XML!&lt;/GREETING&gt;</pre><p>This XML document contains a single element, <code>GREETING</code>. (Remember that <code>&lt;?xml version="1.0"?&gt;</code> is the XML declaration, not an element.) This element contains parsed character data. A schema for this document has to declare the <code>GREETING</code> element. It may declare other elements too, including ones that aren&#146;t present in this particular document, but it must at least declare the <code>GREETING</code> element.</p><h3>The greeting schema</h3><p>Listing 20-1 is a very simple schema for <code>GREETING</code> elements. By convention it would be stored in a file with the three-letter extension .xsd&#151;greeting.xsd, for example&#151;but that&#146;s not required. It is an XML document, so it has an XML declaration. It can be written and saved in any text editor that knows how to save Unicode files. As always, you can use a different character set if you declare it in an encoding declaration. Schema documents are XML documents and have all the privileges and responsibilities of other XML documents. They can even have DTDs, <code>DOCTYPE</code> declarations, and style sheets if that seems useful to you, although in practice most do not.</p><font face="Arial"><p>Listing 20-1: greeting.xsd</p></font><pre>&lt;?xml version="1.0"?&gt;&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;  &lt;xsd:element name="GREETING" type="xsd:string"/&gt;&lt;/xsd:schema&gt;</pre><p>The root element of this and all other schemas is <code>schema</code>. This must be in the <code>http://www.w3.org/2001/XMLSchema</code> namespace. Normally, this namespace is bound to the prefix <code>xsd</code> or <code>xs</code>, although this can change as long as the URI stays the same. The other common approach is to make this URI the default namespace, although that generally requires a few extra attributes to help separate out the names from the XML application the schema describes from the names of the schema elements themselves. You&#146;ll see this when namespaces are discussed at the end of this chapter.</p><p>Elements are declared using <code>xsd:element</code> elements. Listing 20-1 includes a single such element declaring the <code>GREETING</code> element. The <code>name</code> attribute specifies which element is being declared, <code>GREETING</code> in this example. This <code>xsd:element</code> element also has a <code>type</code> attribute whose value is the data type of the element. In this case the type is <code>xsd:string</code>, a standard type for elements that can contain any amount of text in any form but not child elements. It&#146;s equivalent to a DTD content model of <code>#PCDATA</code>. That is, this <code>xsd:element</code> says that a valid <code>GREETING</code> element must look like this:</p><pre>&lt;GREETING&gt;  various random text but no markup&lt;/GREETING&gt;</pre><p>There&#146;s no restriction on what text the element can contain. It can be zero or more Unicode characters with any meaning. Thus, a <code>GREETING</code> element can also look like this:</p><pre>&lt;GREETING&gt;Hello!&lt;/GREETING&gt;</pre><p>Or even this:</p><pre>&lt;GREETING&gt;&lt;/GREETING&gt;</pre><p>However, a valid <code>GREETING</code> element may not look like this:</p><pre>&lt;GREETING&gt;  &lt;SOME_TAG&gt;various random text&lt;/SOME_TAG&gt;  &lt;SOME_EMPTY_TAG/&gt;&lt;/GREETING&gt;</pre><p>Nor may it look like this:</p><pre>&lt;GREETING&gt;  &lt;GREETING&gt;various random text&lt;/GREETING&gt;&lt;/GREETING&gt;</pre><p>Each <code>GREETING</code> element must consist of nothing more and nothing less than parsed character data between a <code>&lt;GREETING&gt;</code> start-tag and a <code>&lt;/GREETING&gt;</code> end-tag.</p><h3>Validating the document against the schema</h3><p>Before a document can be validated against a DTD, the document itself must contain a document type declaration pointing to the DTD it should be validated against. You cannot easily receive a document from a third party and validate it against your own DTD. You have to validate it against the DTD that the document&#146;s author specified. This is excessively limiting.</p><p>For example, imagine you&#146;re running an e-commerce business that accepts orders for products using SOAP or XML-RPC. Each order comes to you over the Internet as an XML document. Before accepting that order, the first thing you want to do is check that it&#146;s valid against a DTD you&#146;ve defined to make sure that it contains all the necessary information. However, if DTDs are all you have to validate with, there&#146;s nothing to prevent a hacker from sending you a document whose <code>DOCTYPE</code> declaration points to a different DTD. Then your system may report that the document is valid according to the hacked DTD, even though it would be invalid when compared to the correct DTD. If your system accepts the invalid document, it could introduce corrupt data that crashes the system or lets the hacker order goods they haven&#146;t paid for, all because the person authoring the document got to choose which DTD to validate against rather than the person validating the document.</p><p>Schemas are more flexible. The schema specification specifically allows for a variety of different means for associating documents with schemas. For example, one possibility is that both the name of the document to validate and the name of the schema to validate it against could be passed to the validator program on the command line, like this:</p><pre>C:\&gt;validator greeting.xml greeting.xsd</pre><p>Parsers could also let you choose the schema by setting a SAX property or an environment variable. Many other approaches are possible. The schema specification does not mandate any one way of doing this. However, it does define one particular way to associate a document with a schema. As with <code>DOCTYPE</code> declarations and DTDs, this requires modifying the instance document to point to the schema. The difference is that with schemas, unlike with DTDs, this is not the only way to do it. Parser vendors are free to develop other mechanisms if they want to.</p><p>To attach a schema to a document, add an <code>xsi:noNamespaceSchemaLocation</code> attribute to the document&#146;s root element. (You can also add it to the first element in the document that the schema applies to, but most of the time adding it to the root element is simplest.) The <code>xsi</code> prefix is mapped to the <code>http://www.w3.org/2001/XMLSchema-instance</code> URI. As always, the prefix can change as long as the URI stays the same. Listing 20-2 demonstrates.</p><font face="Arial"><p>Listing 20-2: valid_greeting.xml</p></font><pre>&lt;?xml version="1.0"?&gt;&lt;GREETING xsi:noNamespaceSchemaLocation="greeting.xsd"  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;Hello XML!&lt;/GREETING&gt;</pre><p>You can now run the document through any parser that supports schema validation. One such parser is Xerces Java from the XML Apache Project (<code>http://xml.apache.org/xerces2-j/</code>). It includes the a simple command line program named sax.Counter that can validate against schemas as well as DTDs. When you set the <code>-v</code> and <code>-s</code> flags, sax.Counter validates the documents against its schema as specified by the <code>xsi:noNamespaceSchemaLocation</code> attribute. Assuming sax.Counter finds no errors, it simply returns the amount of time that was required to parse the document, as in the following example:</p><pre>C:\XML&gt;java sax.Counter -v -s valid_greeting.xmlvalid_greeting.xml: 701 ms (1 elems, 1 attrs, 0 spaces, 12 chars)</pre><dir><h4>Note</h4>To install sax.Counter, copy the JAR archives bundled with the Xerces distribution into your jre/lib/ext directory. With the latest versions of the JDK, this may actually be named something like j2re1.4.2/lib/ext instead. On Windows with a default installation, you&#146;ll find the appropriate directory in C:\Program Files\Java or perhaps C:\Program Files\Javasoft. (The exact names tend to change from one version of Java to the next.) You will need to have Java 1.2 or later installed. If necessary, you can download the latest version from <code>http://java.sun.com/</code>.</p></dir><p>Now, suppose you have a document that&#146;s not valid, such as Listing 20-3. This document uses a <code>P</code> element that hasn&#146;t been declared in the schema.</p><font face="Arial"><p>Listing 20-3: invalid_greeting.xml</p></font><pre>&lt;?xml version="1.0"?&gt;&lt;GREETING  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  xsi:noNamespaceSchemaLocation="greeting.xsd"&gt;  &lt;P&gt;Hello XML!&lt;/P&gt;&lt;/GREETING&gt;</pre><p>Running it through sax.Counter, you now get this output showing you what the problems are:</p><pre>$ java sax.Counter -s -v invalid_greeting.xml[Error] invalid_greeting.xml:11:12: cvc-type.3.1.2: Element 'GREETING' is a simple type, so it must have no element information item [children].invalid_greeting.xml: 907 ms (2 elems, 1 attrs, 0 spaces, 16 chars)</pre><p>The problem is that the <code>GREETING</code> element is declared to have type <code>xsd:string</code>, one of several "simple" types that cannot have any child elements. However, in this case, the <code>GREETING</code> element does contain a child element: the <code>P</code> element.</p><h2>Complex Types</h2><p>The W3C XML Schema Language divides elements into complex and simple types. A simple type element is one such as <code>GREETING</code> that can only contain text and does not have any attributes. It cannot contain any child elements. It may, however, be more limited in the kind of text it can contain. For example, a schema can say that a simple element contains an integer, a date, or a decimal value between 3.76 and 98.24. Complex type elements can have attributes and can have child elements.</p><p>Most documents need a mix of both complex and simple elements. For example, consider Listing 20-4. This document describes the song "Yes I Am" by Melissa Etheridge. The root element is <code>SONG</code>. This element has a number of child elements giving the title of the song, the composer, the producer, the publisher, the duration of the song, the year it was released, the price, and the artist who sang it. Except for <code>SONG</code> itself, these are all simple elements that can have type <code>xsd:string</code>. You might see documents like this used in CD databases, MP3 players, Gnutella clients, or anything else that needs to store information about songs.</p><font face="Arial"><p>Listing 20-4: yesiam.xml</p></font><pre>&lt;?xml version="1.0"?&gt;&lt;SONG xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"      xsi:noNamespaceSchemaLocation="song.xsd"&gt;  &lt;TITLE&gt;Yes I Am&lt;/TITLE&gt;  &lt;COMPOSER&gt;Melissa Etheridge&lt;/COMPOSER&gt;  &lt;PRODUCER&gt;Hugh Padgham&lt;/PRODUCER&gt;  &lt;PUBLISHER&gt;Island Records&lt;/PUBLISHER&gt;  &lt;LENGTH&gt;4:24&lt;/LENGTH&gt;  &lt;YEAR&gt;1993&lt;/YEAR&gt;  &lt;ARTIST&gt;Melissa Etheridge&lt;/ARTIST&gt;  &lt;PRICE&gt;$1.25&lt;/PRICE&gt;&lt;/SONG&gt;</pre><p>Now you need a schema that describes this and all other reasonable song documents. Listing 20-5 is the first attempt at such a schema.</p><font face="Arial"><p>Listing 20-5: song.xsd</p></font><pre>&lt;?xml version="1.0"?&gt;&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;  &lt;xsd:element name="SONG" type="SongType"/&gt;  &lt;xsd:complexType name="SongType"&gt;    &lt;xsd:sequence&gt;      &lt;xsd:element name="TITLE"     type="xsd:string"/&gt;      &lt;xsd:element name="COMPOSER"  type="xsd:string"/&gt;      &lt;xsd:element name="PRODUCER"  type="xsd:string"/&gt;      &lt;xsd:element name="PUBLISHER" type="xsd:string"/&gt;      &lt;xsd:element name="LENGTH"    type="xsd:string"/&gt;      &lt;xsd:element name="YEAR"      type="xsd:string"/&gt;      &lt;xsd:element name="ARTIST"    type="xsd:string"/&gt;      &lt;xsd:element name="PRICE"     type="xsd:string"/&gt;    &lt;/xsd:sequence&gt;  &lt;/xsd:complexType&gt;&lt;/xsd:schema&gt;</pre><p>The root element of this schema is once again <code>xsd:schema</code>, and once again the prefix <code>xsd</code> is mapped to the namespace URI <code>http://www.w3.org/2001/XMLSchema</code>. This will be the case for all schemas in this chapter, and indeed all schemas that you write.</p><p>This schema declares a single <i>top-level element</i>. That is, there is exactly one element declared in an <code>xsd:element</code> declaration that is an immediate child of the root <code>xsd:schema</code> element. This is the <code>SONG</code> element. Only top-level elements can be the root elements of documents described by this schema, though in general they do not have to be the root element.</p><p>The <code>SONG</code> element is declared to have type <code>SongType</code>. The W3C Schema Working Group wasn&#146;t prescient. They built a lot of common types into the language, but they didn&#146;t know that I was going to need a song type, and they didn&#146;t provide one. Indeed, they could not reasonably have been expected to predict and provide for the numerous types that schema designers around the world were ever going to need. Instead, they provided facilities to allow users to define their own types. <code>SongType</code> is one such user-defined type. In fact, you can tell it&#146;s not a built-in type because it doesn&#146;t begin with the prefix <code>xsd</code>. All built-in types are in the <code>http://www.w3.org/2001/XMLSchema</code> namespace.</p><p>The <code>xsd:complexType</code> element defines a new type. The <code>name</code> attribute of this element names the type being defined. Here that name is <code>SongType</code>, which matches the type previously assigned to the <code>SONG</code> element. Forward references (for example, <code>xsd:element</code> using the <code>SongType</code> type before it&#146;s been defined) are perfectly acceptable in schemas. Circular references are okay, too. Type A can depend on type B, which depends on type A. Schema processors sort all this out without any difficulty.</p><p>The contents of the <code>xsd:complexType</code> element specify what content a <code>SongType</code> element must contain. In this example, the schema says that every <code>SongType</code> element contains a sequence of eight child elements: <code>TITLE</code>, <code>COMPOSER</code>, <code>PRODUCER</code>, <code>PUBLISHER</code>, <code>LENGTH</code>, <code>YEAR</code>, <code>PRICEARTIST</code>, and <code>PRICE</code>. Each of these is declared to have the built-in type <code>xsd:string</code>. Each <code>SongType</code> element must contain exactly one of each of these in exactly that order. The only other content it may contain is insignificant white space between the tags.</p><h3>minOccurs and maxOccurs</h3><p>You can validate Listing 20-4, yesiam.xml, against the song schema, and it does indeed prove valid. Are you done? Is song.xsd now an adequate description of legal song documents? Suppose you instead wanted to validate Listing 20-6, a song document that describes <i>Hot Cop</i> by the Village People. Is it valid according to the schema in Listing 20-5?</p><font face="Arial"><p>Listing 20-6: hotcop.xml</p></font><pre>&lt;?xml version="1.0"?&gt;&lt;SONG xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"      xsi:noNamespaceSchemaLocation="song.xsd"&gt;  &lt;TITLE&gt;Hot Cop&lt;/TITLE&gt;  &lt;COMPOSER&gt;Jacques Morali&lt;/COMPOSER&gt;  &lt;COMPOSER&gt;Henri Belolo&lt;/COMPOSER&gt;  &lt;COMPOSER&gt;Victor Willis&lt;/COMPOSER&gt;  &lt;PRODUCER&gt;Jacques Morali&lt;/PRODUCER&gt;  &lt;PUBLISHER&gt;PolyGram Records&lt;/PUBLISHER&gt;  &lt;LENGTH&gt;6:20&lt;/LENGTH&gt;  &lt;YEAR&gt;1978&lt;/YEAR&gt;  &lt;ARTIST&gt;Village People&lt;/ARTIST&gt;&lt;/SONG&gt;</pre><p>The answer is no, it is not. The reason is that this song was a collaboration between three different composers and the existing schema only allows a single composer. Furthermore, the price is missing. If you looked at other songs, you&#146;d find similar problems with the other child elements. <i>Under Pressure</i> has two artists, David Bowie and Queen. <i>We Are the World</i> has dozens of artists. Many songs have multiple producers. A garage band without a publisher might record a song and post it on Gnutella in the hope of finding one.</p><p>The song schema needs to be adjusted to allow for varying numbers of particular elements. This is done by attaching <code>minOccurs</code> and <code>maxOccurs</code> attributes to each <code>xsd:element</code> element. These attributes specify the minimum and maximum number of instances of the element that may appear at that point in the document. The value of each attribute is an integer greater than or equal to zero. The <code>maxOccurs</code> attribute can also have the value <code>unbounded</code> to indicate that an unlimited number of the particular element may appear. Listing 20-7 demonstrates.</p><font face="Arial"><p>Listing 20-7: minOccurs and maxOccurs</p></font><pre>&lt;?xml version="1.0"?&gt;&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;  &lt;xsd:element name="SONG" type="SongType"/&gt;  &lt;xsd:complexType name="SongType"&gt;    &lt;xsd:sequence&gt;      &lt;xsd:element name="TITLE"     type="xsd:string"                   minOccurs="1"    maxOccurs="1"/&gt;      &lt;xsd:element name="COMPOSER"  type="xsd:string"                   minOccurs="1"    maxOccurs="unbounded"/&gt;      &lt;xsd:element name="PRODUCER"  type="xsd:string"                   minOccurs="0"    maxOccurs="unbounded"/&gt;      &lt;xsd:element name="PUBLISHER" type="xsd:string"                   minOccurs="0"    maxOccurs="1"/&gt;      &lt;xsd:element name="LENGTH"    type="xsd:string"                   minOccurs="1"    maxOccurs="1"/&gt;      &lt;xsd:element name="YEAR"      type="xsd:string"                   minOccurs="1"    maxOccurs="1"/&gt;      &lt;xsd:element name="ARTIST"    type="xsd:string"                   minOccurs="1"    maxOccurs="unbounded"/&gt;      &lt;xsd:element name="PRICE"     type="xsd:string"                   minOccurs="0"    maxOccurs="1"/&gt;    &lt;/xsd:sequence&gt;  &lt;/xsd:complexType&gt;&lt;/xsd:schema&gt;</pre><p>This schema says that every <code>SongType</code> element must have, in order:</p><ol>	<li><p>Exactly one <code>TITLE</code> (<code>minOccurs="1" maxOccurs="1"</code>)</p></li>	<li><p>At least one, and possibly a great many, <code>COMPOSER</code>s (<code>minOccurs="1" maxOccurs="unbounded"</code>)</p></li>	<li><p>Any number of <code>PRODUCER</code>s, although possibly no producer at all (<code>minOccurs="0" maxOccurs="unbounded"</code>)</p></li>	<li><p>Either one <code>PUBLISHER</code> or no <code>PUBLISHER</code> at all (<code>minOccurs="0" maxOccurs="1"</code>)</p></li>	<li><p>Exactly one <code>LENGTH</code> (<code>minOccurs="1" maxOccurs="1"</code>)</p></li>	<li><p>Exactly one <code>YEAR</code> (<code>minOccurs="1" maxOccurs="1"</code>)</p></li>	<li><p>At least one <code>ARTIST</code>, possibly more (<code>minOccurs="1" maxOccurs="unbounded"</code>)</p></li>	<li><p>An optional <code>PRICE</code>, (<code>minOccurs="0" maxOccurs="1"</code>)</p></li></ol><p>This is much more flexible and easier to use than the limited <code>?</code>, <code>*</code>, and <code>+</code> that are available in DTDs. It is very straightforward to say, for example, that you want between four and seven of a given element. Just set <code>minOccurs</code> to 4 and <code>maxOccurs</code> to 7.</p><p>If <code>minOccurs</code> and <code>maxOccurs</code> are not present, the default value of each is 1. Taking advantage of this, the song schema can be written a little more compactly, as shown in Listing 20-8.</p><font face="Arial"><p>Listing 20-8: Taking Advantage of the Default Values of minOccurs and maxOccurs</p></font><pre>&lt;?xml version="1.0"?&gt;&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;  &lt;xsd:element name="SONG" type="SongType"/&gt;  &lt;xsd:complexType name="SongType"&gt;    &lt;xsd:sequence&gt;      &lt;xsd:element name="TITLE"     type="xsd:string"/&gt;      &lt;xsd:element name="COMPOSER"  type="xsd:string"                   maxOccurs="unbounded"/&gt;      &lt;xsd:element name="PRODUCER"  type="xsd:string"                   minOccurs="0"    maxOccurs="unbounded"/&gt;      &lt;xsd:element name="PUBLISHER" type="xsd:string"                   minOccurs="0"/&gt;      &lt;xsd:element name="LENGTH"    type="xsd:string"/&gt;      &lt;xsd:element name="YEAR"      type="xsd:string"/&gt;      &lt;xsd:element name="ARTIST"    type="xsd:string"                   maxOccurs="unbounded"/&gt;      &lt;xsd:element name="PRICE"     type="xsd:string"                   minOccurs="0"/&gt;    &lt;/xsd:sequence&gt;  &lt;/xsd:complexType&gt;&lt;/xsd:schema&gt;</pre><h3>Element content</h3><p>The examples so far have all been relatively flat. That is, a <code>SONG</code> element contained other elements; but those elements only contained character data, not child elements of their own. Suppose, however, that some child elements do contain other elements, as in Listing 20-9. Here the <code>COMPOSER</code> and <code>PRODUCER</code> elements each contain <code>NAME</code> elements.</p><font face="Arial"><p>Listing 20-9: A Deeper Hierarchy</p></font><pre>&lt;?xml version="1.0"?&gt;&lt;SONG xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"      xsi:noNamespaceSchemaLocation="20-10.xsd"&gt;  &lt;TITLE&gt;Hot Cop&lt;/TITLE&gt;  &lt;COMPOSER&gt;    &lt;NAME&gt;Jacques Morali&lt;/NAME&gt;  &lt;/COMPOSER&gt;  &lt;COMPOSER&gt;    &lt;NAME&gt;Henri Belolo&lt;/NAME&gt;  &lt;/COMPOSER&gt;  &lt;COMPOSER&gt;    &lt;NAME&gt;Victor Willis&lt;/NAME&gt;  &lt;/COMPOSER&gt;  &lt;PRODUCER&gt;    &lt;NAME&gt;Jacques Morali&lt;/NAME&gt;  &lt;/PRODUCER&gt;  &lt;PUBLISHER&gt;PolyGram Records&lt;/PUBLISHER&gt;  &lt;LENGTH&gt;6:20&lt;/LENGTH&gt;  &lt;YEAR&gt;1978&lt;/YEAR&gt;  &lt;ARTIST&gt;Village People&lt;/ARTIST&gt;&lt;/SONG&gt;</pre><p>Because the <code>COMPOSER</code> and <code>PRODUCER</code> elements now have complex content, you can no longer use one of the built-in types such as <code>xsd:string</code> to declare them. Instead, you have to define a new <code>ComposerType</code> and <code>ProducerType</code> using top-level <code>xsd:complexType</code> elements. Listing 20-10 demonstrates.</p><font face="Arial"><p>Listing 20-10: Defining Separate ComposerType and ProducerType Types</p></font><pre>&lt;?xml version="1.0"?&gt;&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;  &lt;xsd:element name="SONG" type="SongType"/&gt;  &lt;xsd:complexType name="ComposerType"&gt;    &lt;xsd:sequence&gt;      &lt;xsd:element name="NAME" type="xsd:string"/&gt;    &lt;/xsd:sequence&gt;  &lt;/xsd:complexType&gt;  &lt;xsd:complexType name="ProducerType"&gt;    &lt;xsd:sequence&gt;      &lt;xsd:element name="NAME" type="xsd:string"/&gt;    &lt;/xsd:sequence&gt;  &lt;/xsd:complexType&gt;  &lt;xsd:complexType name="SongType"&gt;    &lt;xsd:sequence&gt;      &lt;xsd:element name="TITLE"     type="xsd:string"/&gt;      &lt;xsd:element name="COMPOSER"  type="ComposerType"                   maxOccurs="unbounded"/&gt;      &lt;xsd:element name="PRODUCER"  type="ProducerType"                   minOccurs="0" maxOccurs="unbounded"/&gt;      &lt;xsd:element name="PUBLISHER" type="xsd:string"                   minOccurs="0"/&gt;      &lt;xsd:element name="LENGTH" type="xsd:string"/&gt;      &lt;xsd:element name="YEAR"   type="xsd:string"/&gt;      &lt;xsd:element name="ARTIST" type="xsd:string"                   maxOccurs="unbounded"/&gt;      &lt;xsd:element name="PRICE" type="xsd:string"                   minOccurs="0"/&gt;    &lt;/xsd:sequence&gt;  &lt;/xsd:complexType&gt;&lt;/xsd:schema&gt;</pre><h3>Sharing content models</h3><p>You may have noticed that <code>PRODUCER</code> and <code>COMPOSER</code> are very similar. Each contains a single <code>NAME</code> child element and nothing else. In a DTD, you&#146;d take advantage of this shared content model via a parameter entity reference. In a schema, it&#146;s much easier. Simply given them the same type. While you could declare that the <code>PRODUCER </font>has <code>ComposerType</code> or vice versa, it&#146;s better to declare that both have a more generic <code>PersonType</code>. Listing 20-11 demonstrates.</p><font face="Arial"><p>Listing 20-11: Using a Single PersonType for Both COMPOSER and PRODUCER</p></font><pre>&lt;?xml version="1.0"?&gt;&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;  &lt;xsd:element name="SONG" type="SongType"/&gt;  &lt;xsd:complexType name="PersonType"&gt;    &lt;xsd:sequence&gt;      &lt;xsd:element name="NAME" type="xsd:string"/&gt;    &lt;/xsd:sequence&gt;  &lt;/xsd:complexType&gt;  &lt;xsd:complexType name="SongType"&gt;    &lt;xsd:sequence&gt;      &lt;xsd:element name="TITLE"     type="xsd:string"/&gt;      &lt;xsd:element name="COMPOSER"  type="PersonType"                   maxOccurs="unbounded"/&gt;      &lt;xsd:element name="PRODUCER"  type="PersonType"                   minOccurs="0" maxOccurs="unbounded"/&gt;      &lt;xsd:element name="PUBLISHER" type="xsd:string"                   minOccurs="0"/&gt;      &lt;xsd:element name="LENGTH" type="xsd:string"/&gt;      &lt;xsd:element name="YEAR"   type="xsd:string"/&gt;      &lt;xsd:element name="ARTIST" type="xsd:string"                   maxOccurs="unbounded"/&gt;      &lt;xsd:element name="PRICE" type="xsd:string"                   minOccurs="0"/&gt;    &lt;/xsd:sequence&gt;  &lt;/xsd:complexType&gt;&lt;/xsd:schema&gt;</pre><h3>Anonymous types</h3><p>Suppose you wanted to divide the <code>NAME</code> elements into separate <code>GIVEN</code> and <code>FAMILY</code> elements like this:</p><pre>&lt;NAME&gt;  &lt;GIVEN&gt;Victor&lt;/GIVEN&gt;  &lt;FAMILY&gt;Willis&lt;/FAMILY&gt;&lt;/NAME&gt;&lt;NAME&gt;  &lt;GIVEN&gt;Jacques&lt;/GIVEN&gt;  &lt;FAMILY&gt;Morali&lt;/FAMILY&gt;&lt;/NAME&gt;</pre><p>To declare this, you could use an <code>xsd:complexType</code> element to define a new <code>NameType</code> element, like this:</p><pre>  &lt;xsd:complexType name="NameType"&gt;    &lt;xsd:sequence&gt;      &lt;xsd:element name="GIVEN"  type="xsd:string"/&gt;      &lt;xsd:element name="FAMILY" type="xsd:string"/&gt;    &lt;/xsd:sequence&gt;  &lt;/xsd:complexType&gt;</pre><p>Then the <code>PersonType</code> would be defined like this:</p><pre>  &lt;xsd:complexType name="PersonType"&gt;    &lt;xsd:sequence&gt;      &lt;xsd:element name="NAME" type="NameType"/&gt;    &lt;/xsd:sequence&gt;  &lt;/xsd:complexType&gt;</pre><p>However, the <code>NAME</code> element is only used inside <code>PersonType</code> elements. Perhaps it shouldn&#146;t be a top-level definition. For example, you might not want to allow <code>NAME</code> elements to be used as root elements, or to be children of things that aren&#146;t <code>PersonType</code> elements. You can prevent this by defining a name with an <i>anonymous type</i>. To do this, instead of assigning the <code>NAME</code> element a type with a <code>type</code> attribute on the corresponding <code>xsd:element</code> element, you give it an <code>xsd:complexType</code> child element to define its type. Listing 20-12 demonstrates.</p><font face="Arial"><p>Listing 20-12: Anonymous Types</p></font><pre>&lt;?xml version="1.0"?&gt;&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;  &lt;xsd:element name="SONG" type="SongType"/&gt;  &lt;xsd:complexType name="PersonType"&gt;    &lt;xsd:sequence&gt;      &lt;xsd:element name="NAME"&gt;        &lt;xsd:complexType&gt;          &lt;xsd:sequence&gt;            &lt;xsd:element name="GIVEN"  type="xsd:string"/&gt;            &lt;xsd:element name="FAMILY" type="xsd:string"/&gt;          &lt;/xsd:sequence&gt;        &lt;/xsd:complexType&gt;      &lt;/xsd:element&gt;    &lt;/xsd:sequence&gt;  &lt;/xsd:complexType&gt;  &lt;xsd:complexType name="SongType"&gt;    &lt;xsd:sequence&gt;      &lt;xsd:element name="TITLE"     type="xsd:string"/&gt;      &lt;xsd:element name="COMPOSER"  type="PersonType"                   maxOccurs="unbounded"/&gt;      &lt;xsd:element name="PRODUCER"  type="PersonType"                   minOccurs="0" maxOccurs="unbounded"/&gt;      &lt;xsd:element name="PUBLISHER" type="xsd:string"                   minOccurs="0"/&gt;      &lt;xsd:element name="LENGTH" type="xsd:string"/&gt;      &lt;xsd:element name="YEAR"   type="xsd:string"/&gt;      &lt;xsd:element name="ARTIST" type="xsd:string"                   maxOccurs="unbounded"/&gt;      &lt;xsd:element name="PRICE" type="xsd:string"                   minOccurs="0"/&gt;    &lt;/xsd:sequence&gt;  &lt;/xsd:complexType&gt;&lt;/xsd:schema&gt;</pre><p>Defining the element types inside the <code>xsd:element</code> elements that are themselves children of <code>xsd:complexType</code> elements is a very powerful technique. Among other things, it enables you to give elements with the same name different types when used in different elements. For example, you can say that the <code>NAME</code> of a <code>PERSON</code> contains <code>GIVEN</code> and <code>FAMILY</code> child elements, while the <code>NAME</code> of a <code>MOVIE</code> contains an <code>xsd:string</code>, and the <code>NAME</code> of a <code>VARIABLE</code> contains a string containing only alphanumeric characters from the ASCII character set.</p><h3>Mixed content</h3><p>Schemas offer much greater control over mixed content than DTDs do. In particular, schemas let you enforce the order and number of elements appearing in mixed content. For example, suppose you wanted to allow extra text to be mixed in with the names to provide middle initials, titles, and the like as shown in Listing 20-13.</p><dir><b><font face="Arial" size=1 color="#000080"><p>Caution</p></b></font><p>The format used here is purely for illustrative purposes. In practice, I&#146;d recommend that you make the middle names and titles separate elements as well.</p></dir> <font face="Arial"><p>Listing 20-13: Mixed Content</p></font><pre>&lt;?xml version="1.0"?&gt;&lt;SONG xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"      xsi:noNamespaceSchemaLocation="20-14.xsd"&gt;  &lt;TITLE&gt;Hot Cop&lt;/TITLE&gt;  &lt;COMPOSER&gt;    &lt;NAME&gt;     Mr. &lt;GIVEN&gt;Jacques&lt;/GIVEN&gt; &lt;FAMILY&gt;Morali&lt;/FAMILY&gt; Esq.    &lt;/NAME&gt;  &lt;/COMPOSER&gt;  &lt;COMPOSER&gt;    &lt;NAME&gt;     Mr. &lt;GIVEN&gt;Henri&lt;/GIVEN&gt; L. &lt;FAMILY&gt;Belolo&lt;/FAMILY&gt;, M.D.    &lt;/NAME&gt;  &lt;/COMPOSER&gt;  &lt;COMPOSER&gt;    &lt;NAME&gt;     Mr. &lt;GIVEN&gt;Victor&lt;/GIVEN&gt; C. &lt;FAMILY&gt;Willis&lt;/FAMILY&gt;    &lt;/NAME&gt;  &lt;/COMPOSER&gt;  &lt;PRODUCER&gt;    &lt;NAME&gt;     Mr. &lt;GIVEN&gt;Jacques&lt;/GIVEN&gt; S. &lt;FAMILY&gt;Morali&lt;/FAMILY&gt;    &lt;/NAME&gt;  &lt;/PRODUCER&gt;  &lt;PUBLISHER&gt;PolyGram Records&lt;/PUBLISHER&gt;  &lt;LENGTH&gt;6:20&lt;/LENGTH&gt;  &lt;YEAR&gt;1978&lt;/YEAR&gt;  &lt;ARTIST&gt;Village People&lt;/ARTIST&gt;&lt;/SONG&gt;</pre><p>It&#146;s very easy to declare that an element has mixed content in schemas. First, set up the <code>xsd:complexType</code> exactly as you would if the element only contained child elements. Then add a <code>mixed</code> attribute to it with the value <code>true</code>. Listing 20-14 demonstrates. It is almost identical to Listing 20-12 except for the addition of the <code>mixed="true"</code> attribute.</p><font face="Arial"><p>Listing 20-14: Declaring Mixed Content in a Schema</p></font><pre>&lt;?xml version="1.0"?&gt;&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;  &lt;xsd:element name="SONG" type="SongType"/&gt;  &lt;xsd:complexType name="PersonType"&gt;    &lt;xsd:sequence&gt;      &lt;xsd:element name="NAME"&gt;        &lt;xsd:complexType mixed="true"&gt;          &lt;xsd:sequence&gt;            &lt;xsd:element name="GIVEN"  type="xsd:string"/&gt;            &lt;xsd:element name="FAMILY" type="xsd:string"/&gt;          &lt;/xsd:sequence&gt;        &lt;/xsd:complexType&gt;    &lt;/xsd:element&gt;  &lt;/xsd:sequence&gt;&lt;/xsd:complexType&gt;  &lt;xsd:complexType name="SongType"&gt;    &lt;xsd:sequence&gt;   &lt;xsd:element name="TITLE"     type="xsd:string"/&gt;      &lt;xsd:element name="COMPOSER"  type="PersonType"                   maxOccurs="unbounded"/&gt;      &lt;xsd:element name="PRODUCER"  type="PersonType"                   minOccurs="0" maxOccurs="unbounded"/&gt;      &lt;xsd:element name="PUBLISHER" type="xsd:string"                   minOccurs="0"/&gt;      &lt;xsd:element name="LENGTH" type="xsd:string"/&gt;      &lt;xsd:element name="YEAR"   type="xsd:string"/&gt;      &lt;xsd:element name="ARTIST" type="xsd:string"/&gt;                   maxOccurs="unbounded"/&gt;      &lt;xsd:element name="PRICE" type="xsd:string"                   minOccurs="0"/&gt;    &lt;/xsd:sequence&gt;  &lt;/xsd:complexType&gt;&lt;/xsd:schema&gt;</pre><h2>Grouping</h2><p>So far, all the schemas you&#146;ve seen have held that order mattered; for example, that it would be wrong to put the <code>COMPOSER</code> before the <code>TITLE</code> or the <code>PRODUCER</code> after the <code>ARTIST</code>. Given these schemas, the document shown in Listing 20-15 is clearly invalid. But should it be? Element order often does matter in narrative documents such as books and web pages. However, it&#146;s not nearly as important in record-like documents such as the examples in this chapter. Do you really care whether the <code>TITLE</code> comes first or not, as long as there is a <code>TITLE</code>? After all, if the document&#146;s going to be shown to a human being, it will probably first be transformed with an XSLT style sheet that can easily place the contents in any order it likes.</p><font face="Arial"><p>Listing 20-15: A Song Document That Places the Elements in a Different Order</p></font><pre>&lt;?xml version="1.0"?&gt;&lt;SONG xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"      xsi:noNamespaceSchemaLocation="song.xsd"&gt;  &lt;ARTIST&gt;Village People&lt;/ARTIST&gt;  &lt;TITLE&gt;Hot Cop&lt;/TITLE&gt;  &lt;COMPOSER&gt;   &lt;NAME&gt;&lt;GIVEN&gt;Jacques&lt;/GIVEN&gt; &lt;FAMILY&gt;Morali&lt;/FAMILY&gt;&lt;/NAME&gt;  &lt;/COMPOSER&gt;  &lt;PUBLISHER&gt;PolyGram Records&lt;/PUBLISHER&gt;  &lt;COMPOSER&gt;   &lt;NAME&gt;&lt;FAMILY&gt;Belolo&lt;/FAMILY&gt; &lt;GIVEN&gt;Henri&lt;/GIVEN&gt;&lt;/NAME&gt;  &lt;/COMPOSER&gt;  &lt;YEAR&gt;1978&lt;/YEAR&gt;  &lt;COMPOSER&gt;   &lt;NAME&gt;&lt;FAMILY&gt;Willis&lt;/FAMILY&gt; &lt;GIVEN&gt;Victor&lt;/GIVEN&gt;&lt;/NAME&gt;  &lt;/COMPOSER&gt;  &lt;PRODUCER&gt;   &lt;NAME&gt;&lt;GIVEN&gt;Jacques&lt;/GIVEN&gt; &lt;FAMILY&gt;Morali&lt;/FAMILY&gt;&lt;/NAME&gt;  &lt;/PRODUCER&gt;  &lt;PRICE&gt;$1.25&lt;/PRICE&gt;&lt;/SONG&gt;</pre><p>The W3C XML Schema Language provides three grouping constructs that specify whether and how ordering of individual elements is important:</p><ul>	<li><p>The <code>xsd:all</code> group requires that each element in the group must occur at most once, but that order is not important.</p></li>	<li><p>The <code>xsd:choice</code> group specifies that any one element from the group should appear. It can also be used to say that between N and M elements from the group should appear in any order.</p></li>	<li><p>The <code>xsd:sequence</code> group requires that each element in the group appear exactly once, in the specified order.</p></li></ul><p>Unfortunately, these constructs are not everything you might desire. In particular, you can&#146;t specify constraints such as those that would be required to really handle Listing 20-14. In particular, you can&#146;t specify that you want a <code>SONG</code> to have exactly one <code>TITLE</code>, one or more <code>COMPOSER</code>s, zero or more <code>PRODUCER</code>s, and one or more <code>ARTIST</code>s, but that you don&#146;t care in what order the individual elements occur.</p><h3>The xsd:all Group</h3><p>You can specify that you want each <code>NAME</code> element to have exactly one <code>GIVEN</code> child and one <code>FAMILY</code> child, but that you don&#146;t care what order they appear in. The <code>xsd:all</code> group accomplishes this, as in the following example:</p><pre>&lt;xsd:complexType name="PersonType"&gt;  &lt;xsd:sequence&gt;    &lt;xsd:element name="NAME"&gt;      &lt;xsd:complexType&gt;        &lt;xsd:all&gt;          &lt;xsd:element name="GIVEN" type="xsd:string"                       minOccurs="1" maxOccurs="1"/&gt;          &lt;xsd:element name="FAMILY" type="xsd:string"                       minOccurs="1" maxOccurs="1"/&gt;        &lt;/xsd:all&gt;      &lt;/xsd:complexType&gt;    &lt;/xsd:element&gt;  &lt;/xsd:sequence&gt;&lt;/xsd:complexType&gt;</pre><p>The extension to handle what you want for Listing 20-15 seems obvious. It would look like this:</p><pre>&lt;xsd:complexType name="SongType"&gt;  &lt;xsd:all&gt;    &lt;xsd:element name="TITLE" type="xsd:string"                 minOccurs="1" maxOccurs="1"/&gt;    &lt;xsd:element name="COMPOSER" type="PersonType"                 minOccurs="1" maxOccurs="unbounded"/&gt;    &lt;xsd:element name="PRODUCER" type="PersonType"                 minOccurs="0" maxOccurs="unbounded"/&gt;    &lt;xsd:element name="PUBLISHER" type="xsd:string"                 minOccurs="0" maxOccurs="1"/&gt;    &lt;xsd:element name="LENGTH" type="xsd:string"                 minOccurs="1" maxOccurs="1"/&gt;    &lt;xsd:element name="YEAR" type="xsd:string"                 minOccurs="1" maxOccurs="1"/&gt;    &lt;xsd:element name="ARTIST" type="xsd:string"                 minOccurs="1" maxOccurs="unbounded"/&gt;    &lt;xsd:element name="PRICE" type="xsd:string"                  minOccurs="0"/&gt;  &lt;/xsd:all&gt;&lt;/xsd:complexType&gt;</pre><p>Unfortunately, the W3C XML Schema Language restricts the use of <code>minOccurs</code> and <code>maxOccurs</code> inside <code>xsd:all</code> elements. In particular, each one&#146;s value must be <code>0</code> or <code>1</code>. You cannot set it to <code>4</code> or <code>7</code> or <code>unbounded</code>. Therefore, the preceding type definition is invalid. Furthermore, <code>xsd:all</code> can only contain individual element declarations. It cannot contain <code>xsd:choice</code> or <code>xsd:sequence</code> elements. <code>xsd:all</code> offers somewhat more expressiveness than DTDs do, but probably not as much as you want.</p><h3>Choices</h3><p>The <code>xsd:choice</code> element is the schema equivalent of the <code>|</code> in DTDs. When <code>xsd:element</code> elements are combined inside an <code>xsd:choice</code>, exactly one of those elements must appear in instance documents. For example, the choice in this <code>xsd:complexType</code> requires either a <code>PRODUCER</code> or a <code>COMPOSER</code>, but not both.</p><pre>&lt;xsd:complexType name="SongType"&gt;  &lt;xsd:sequence&gt;   &lt;xsd:element name="TITLE" type="xsd:string"/&gt;   &lt;xsd:choice&gt;     &lt;xsd:element name="COMPOSER" type="PersonType"/&gt;     &lt;xsd:element name="PRODUCER" type="PersonType"/&gt;   &lt;/xsd:choice&gt;   &lt;xsd:element name="PUBLISHER" type="xsd:string"                minOccurs="0"/&gt;   &lt;xsd:element name="LENGTH" type="xsd:string"/&gt;   &lt;xsd:element name="YEAR"   type="xsd:string"/&gt;   &lt;xsd:element name="ARTIST" type="xsd:string"                maxOccurs="unbounded"/&gt;   &lt;xsd:element name="PRICE" type="xsd:string" minOccurs="0"/&gt;  &lt;/xsd:sequence&gt;&lt;/xsd:complexType&gt;</pre><p>The <code>xsd:choice</code> element itself can have <code>minOccurs</code> and <code>maxOccurs</code> attributes that establish exactly how many selections may be made from the choice. For example, setting <code>minOccurs</code> to 1 and <code>maxOccurs</code> to 6 would indicate that between one and six elements listed in the <code>xsd:choice</code> should appear. Each of these can be any of the elements in the <code>xsd:choice</code>. For example, you could have six different elements, three of the same element and three of another, or up to six of the same element. This next <code>xsd:choice</code> allows for any number of artists, composers, and producers. However, in order to require that there be at least one <code>ARTIST</code> element and at least one <code>COMPOSER</code> element, rather than allowing all spaces to be filled by <code>PRODUCER</code> elements, it&#146;s necessary to place <code>xsd:element</code> declarations for these two outside the choice. This has the unfortunate side effect of locking in more order than is really needed.</p><pre>&lt;xsd:complexType name="SongType"&gt;  &lt;xsd:sequence&gt;    &lt;xsd:element name="TITLE" type="xsd:string"/&gt;    &lt;xsd:element name="COMPOSER" type="PersonType"/&gt;    &lt;xsd:choice minOccurs="0" maxOccurs="unbounded"&gt;      &lt;xsd:element name="PRODUCER" type="PersonType"/&gt;      &lt;xsd:element name="COMPOSER" type="PersonType"/&gt;      &lt;xsd:element name="ARTIST"   type="xsd:string"/&gt;    &lt;/xsd:choice&gt;    &lt;xsd:element name="ARTIST" type="xsd:string"/&gt;    &lt;xsd:element name="PUBLISHER" type="xsd:string"                 minOccurs="0"/&gt;    &lt;xsd:element name="LENGTH" type="xsd:string"/&gt;    &lt;xsd:element name="YEAR"   type="xsd:string"/&gt;    &lt;xsd:element name="PRICE"  type="xsd:string"                  minOccurs="0"/&gt;  &lt;/xsd:sequence&gt;&lt;/xsd:complexType&gt;</pre><h3>Sequences</h3><p>An <code>xsd:sequence</code> element requires each member of the sequence to appear in the same order in the instance document as in the <code>xsd:sequence</code> element. I&#146;ve used this frequently as the basic group for <code>xsd:complexType</code> elements in this chapter so far. The number of times each element is allowed to appear can be controlled by the <code>xsd:element</code>&#146;s <code>minOccurs</code> and <code>maxOccurs</code> attributes. You can add <code>minOccurs</code> and <code>maxOccurs</code> attributes to the <code>xsd:sequence</code> element to specify the number of times the sequence should repeat.</p><h2>Simple Types</h2><p>Until now I&#146;ve focused on writing schemas that validate the element structures in an XML document. However, there&#146;s also a lot of non-XML structure in the song documents. The <code>YEAR</code> element isn&#146;t just a string. It&#146;s an integer, and maybe not just any integer either, but a positive integer with four digits. The <code>PRICE</code> element is some sort of money. The <code>LENGTH</code> element is a duration of time. DTDs have absolutely nothing to say about such non-XML structures that are inside the parsed character data content of elements and attributes. Schemas, however, do let you make all sorts of statements about what forms the text inside elements may take and what it means. Schemas provide much more sophisticated semantics for documents than DTDs do.</p><p>Listing 20-16 is a new schema for song documents. It&#146;s based on Listing 20-8, but read closely and you should notice that a few things have changed.</p><font face="Arial"><p>Listing 20-16: A Schema with Simple Data Types</p></font><pre>&lt;?xml version="1.0"?&gt;&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;  &lt;xsd:element name="SONG" type="SongType"/&gt;  &lt;xsd:complexType name="SongType"&gt;    &lt;xsd:sequence&gt;      &lt;xsd:element name="TITLE"     type="xsd:string"/&gt;      &lt;xsd:element name="COMPOSER"  type="xsd:string"                   maxOccurs="unbounded"/&gt;      &lt;xsd:element name="PRODUCER"  type="xsd:string"                   minOccurs="0"    maxOccurs="unbounded"/&gt;      &lt;xsd:element name="PUBLISHER" type="xsd:string"                   minOccurs="0"/&gt;      &lt;xsd:element name="LENGTH"    type="xsd:duration"/&gt;      &lt;xsd:element name="YEAR"      type="xsd:gYear"/&gt;      &lt;xsd:element name="ARTIST"    type="xsd:string"                   maxOccurs="unbounded"/&gt;      &lt;xsd:element name="PRICE"     type="xsd:string"                   minOccurs="0"/&gt;    &lt;/xsd:sequence&gt;  &lt;/xsd:complexType&gt;&lt;/xsd:schema&gt;</pre><p>Did you spot the changes? The values of the <code>type</code> attributes of the <code>LENGTH</code> and <code>YEAR</code> declarations are no longer <code>xsd:string</code>. Instead, <code>LENGTH</code> has the type <code>xsd:duration</code> and <code>YEAR</code> has the type <code>xsd:gYear</code>. These declarations say that it&#146;s no longer okay for the <code>YEAR</code> and <code>LENGTH</code> elements to contain just any old string of text. Instead, they must contain strings in particular formats. In particular, the <code>YEAR</code> element must contain a year; and the <code>LENGTH</code> element must contain a recognizable length of time. When you check a document against this schema, the validator will check that these elements contain the proper data. It&#146;s not just looking at the elements. It&#146;s looking at the content inside the elements!</p><p>Let&#146;s actually validate hotcop.xml against this schema and see what we get:</p><pre>$ java sax.Counter -s -v hotcop.xml[Error] hotcop.xml:10:24: cvc-datatype-valid.1.2.1: '6:20' is not a valid value for 'duration'.[Error] hotcop.xml:10:24: cvc-type.3.1.3: The value '6:20' of element 'LENGTH' is not valid.hotcop.xml: 897 ms (10 elems, 1 attrs, 0 spaces, 126 chars)</pre><p>That&#146;s unexpected! The problem is that 6:20 is not in the proper format for time durations, at least not the format that the W3C XML Schema Language uses and that schema validators know how to check. Schema validators expect that time types are expressed in the format defined in ISO standard 8601, <i>Representations of dates and times</i> (<code>http://www.iso.ch/iso/en/prods-services/popstds/datesandtime.html</code>). This standard says that time durations should have the form PnYnMnDTnHnMdS, where <i>n</i> is an integer and <i>d</i> is a decimal number. <i>P</i> stands for "period." <i>nY</i> gives the number of years; the first <i>nM</i> gives the number of months; and <i>nD</i> gives the number of days. <i>T</i> separates the date from the time. Following the T, <i>nH</i> gives the number of hours; the second <i>nM</i> gives the number of minutes; and <i>dS</i> gives the number of seconds. If <i>d</i> has a fraction part, the duration can be specified to an arbitrary level of precision.</p><p>In this format, a duration of 6 minutes and 20 seconds should be written as P0Y0M0DT0H6M20S. If you prefer, the zero pieces can be left out, so you can write this more compactly as PT6M20S. Listing 20-17 shows the fixed version of hotcop.xml with the <code>LENGTH</code> in the right format.</p><font face="Arial"><p>Listing 20-17: fixed hotcop.xml</p></font><pre>&lt;?xml version="1.0"?&gt;&lt;SONG xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"      xsi:noNamespaceSchemaLocation="20-16.xsd"&gt;  &lt;TITLE&gt;Hot Cop&lt;/TITLE&gt;  &lt;COMPOSER&gt;Jacques Morali&lt;/COMPOSER&gt;  &lt;COMPOSER&gt;Henri Belolo&lt;/COMPOSER&gt;  &lt;COMPOSER&gt;Victor Willis&lt;/COMPOSER&gt;  &lt;PRODUCER&gt;Jacques Morali&lt;/PRODUCER&gt;  &lt;PUBLISHER&gt;PolyGram Records&lt;/PUBLISHER&gt;  &lt;LENGTH&gt;P0YT6M20S&lt;/LENGTH&gt;  &lt;YEAR&gt;1978&lt;/YEAR&gt;  &lt;ARTIST&gt;Village People&lt;/ARTIST&gt;&lt;/SONG&gt;</pre><p>Admittedly the ISO 8601 format for time durations is a little obtuse, if precise. You may well be asking whether there&#146;s a type that you can specify for the <code>LENGTH</code> that would make lengths such as 6:20 and 4:24 legal. In fact, there&#146;s no such type built in to the W3C XML Schema Language, but you can define one yourself. You&#146;ll learn how to do that soon, but first let&#146;s explore some of the other data types that are built in to the W3C XML Schema Language.</p><p>There are 44 built-in simple types in the W3C XML Schema Language. These can be unofficially divided into seven groups:</p><ul>	<li><p>Numeric types</p></li>	<li><p>Time types</p></li>	<li><p>XML types</p></li>	<li><p>String types</p></li>	<li><p>The boolean type</p></li>	<li><p>The URI reference type</p></li>	<li><p>The binary types</p></li></ul><h3>Numeric data types</h3><p>The most obvious data types, and the ones most familiar to programmers, are the numeric data types. Among computer scientists, there&#146;s quite a bit of disagreement about how numbers should be represented in computer systems. The W3C XML Schema Language tries to make everyone happy by providing almost every numeric type imaginable, including the following:</p><ul>	<li><p>Integer and floating point numbers</p></li>	<li><p>Finite size numbers similar to those in Java and C and infinitely precise, unlimited-size numbers similar to those in Eiffel and Java&#146;s <code>java.math</code> package</p></li>	<li><p>Signed and unsigned numbers</p></li></ul><p>You&#146;ll probably only use a subset of these. For example, you wouldn&#146;t use both the arbitrarily large <code>xsd:integer</code> type and the four-byte-limited <code>xsd:int</code> type. Table 20-1 summarizes the different numeric types.</p><font face="Arial"><p align="CENTER">Table 20-1</p><b><p align="CENTER">Schema Numeric Types</p></b></font><table border cellspacing=1 width=410><tr><td width="31%" valign="TOP"><p><b><i><font face="Arial" size=1>Name</b></i></font></td><td width="30%" valign="TOP"><b><i><font face="Arial" size=1><p>Type</b></i></font></td><td width="39%" valign="TOP"><b><i><font face="Arial" size=1><p>Examples</b></i></font></td></tr><tr><td width="31%" valign="TOP"><code><p>xsd:float</code></td><td width="30%" valign="TOP"><font face="Arial" size=1><p>IEEE 754 32-bit floating point number, or as close as you can get using a base 10 representation; same as Java's <code>float</code><font face="Arial" size=1> type</font></td><td width="39%" valign="TOP"><font face="Arial" size=1><p>-INF, -1E4, -0, 0, 12.78E-2, 12, INF, NaN</font></td></tr><tr><td width="31%" valign="TOP"><code><p>xsd:double</code></td><td width="30%" valign="TOP"><font face="Arial" size=1><p>IEEE 754 64-bit floating-point number, or as close as you can get using a base 10 representation; same as Java's <code>double</code><font face="Arial" size=1> type</font></td><td width="39%" valign="TOP"><font face="Arial" size=1><p>-INF, 1.401E-90, -1E4, -0, 0, 12.78E-2, 12, INF, NaN, 3.4E42</font></td></tr><tr><td width="31%" valign="TOP"><code><p>xsd:decimal</code></td><td width="30%" valign="TOP"><font face="Arial" size=1><p>Arbitrary precision, decimal numbers; same as <code>java.math.BigDecimal</code></td><td width="39%" valign="TOP"><font face="Arial" size=1><p>-2.7E400, 5.7E-444, -3.1415292, 0, 7.8, 90200.76, 3.4E1024</font></td></tr><tr><td width="31%" valign="TOP"><code><p>xsd:integer</code></td><td width="30%" valign="TOP"><font face="Arial" size=1><p>An arbitrarily large or small integer; same as <code>java.math.BigInteger</code></td><td width="39%" valign="TOP"><font face="Arial" size=1><p>-500000000000000000000000, -9223372036854775809, -126789, -1, 0, 1, 5, 23, 42, 126789, 9223372036854775808, 4567349873249832649873624958</font></td></tr><tr><td width="31%" valign="TOP"><code><p>xsd:nonPositiveInteger</code></td><td width="30%" valign="TOP"><font face="Arial" size=1><p>An integer less than or equal to zero</font></td><td width="39%" valign="TOP"><font face="Arial" size=1><p>0, -1, -2, -3, -4, -5, -6, -7, -8, -9, . . .</font></td></tr><tr><td width="31%" valign="TOP"><code><p>xsd:negativeInteger</code></td><td width="30%" valign="TOP"><font face="Arial" size=1><p>An integer strictly less than zero</font></td><td width="39%" valign="TOP"><font face="Arial" size=1><p>-1, -2, -3, -4, -5, -6, -7, -8, -9, . . .</font></td></tr><tr><td width="31%" valign="TOP"><code><p>xsd:long</code></td><td width="30%" valign="TOP"><font face="Arial" size=1><p>An eight-byte, two's complement integer, such as Java's <code>long</code><font face="Arial" size=1> type</font></td><td width="39%" valign="TOP"><font face="Arial" size=1><p>-9223372036854775808, -9223372036854775807, . . . -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, . . ., 2147483645, 2147483646, 2147483647, 2147483648, . . .9223372036854775806, 9223372036854775807</font></td></tr><tr><td width="31%" valign="TOP"><code><p>xsd:int</code></td><td width="30%" valign="TOP"><font face="Arial" size=1><p>An integer that can be represented as a four-byte, two's complement number, such as Java's <code>int</code><font face="Arial" size=1> type</font></td><td width="39%" valign="TOP"><font face="Arial" size=1><p>-2147483648, -2147483647, -2147483646, 2147483645, . . . -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, . . ., 2147483645, 2147483646, 2147483647 </font></td></tr><tr><td width="31%" valign="TOP"><code><p>xsd:short</code></td><td width="30%" valign="TOP"><font face="Arial" size=1><p>An integer that can be represented as a two-byte, two's complement number, such as Java's <code>short</code><font face="Arial" size=1> type</font></td><td width="39%" valign="TOP"><font face="Arial" size=1><p>-32768, -32767, -32766, . . ., -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, . . . 32765, 32766, 32767</font></td></tr><tr><td width="31%" valign="TOP"><code><p>xsd:byte</code></td><td width="30%" valign="TOP"><font face="Arial" size=1><p>An integer that can be represented as a one-byte, two's complement number such as Java's <code>byte</code><font face="Arial" size=1> type</font></td><td width="39%" valign="TOP"><font face="Arial" size=1><p>-128, -127, -126, -125, . . ., -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, . . .121, 122, 123, 124, 125, 126, 127 </font></td></tr><tr><td width="31%" valign="TOP"><code><p>xsd:nonNegativeInteger</code></td><td width="30%" valign="TOP"><font face="Arial" size=1><p>An integer greater than or equal to zero</font></td><td width="39%" valign="TOP"><font face="Arial" size=1><p>0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, . . .. . .</font></td></tr><tr><td width="31%" valign="TOP"><code><p>xsd:unsignedLong</code></td><td width="30%" valign="TOP"><font face="Arial" size=1><p>An eight-byte unsigned integer</font></td><td width="39%" valign="TOP"><font face="Arial" size=1><p>0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, . . .18446744073709551614, 18446744073709551615</font></td></tr><tr><td width="31%" valign="TOP"><code><p>xsd:unsignedInt</code></td><td width="30%" valign="TOP"><font face="Arial" size=1><p>A four-byte unsigned integer</font></td><td width="39%" valign="TOP"><font face="Arial" size=1><p>0, 1, 2, 3, 4, 5, . . .4294967294, 4294967295 </font></td></tr><tr><td width="31%" valign="TOP"><code><p>xsd:unsignedShort</code></td><td width="30%" valign="TOP"><font face="Arial" size=1><p>A two-byte unsigned integer</font></td><td width="39%" valign="TOP"><font face="Arial" size=1><p>0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, . . .65533, 65534, 65535</font></td></tr><tr><td width="31%" valign="TOP"><code><p>xsd:unsignedByte</code></td><td width="30%" valign="TOP"><font face="Arial" size=1><p>A one-byte unsigned integer</font></td><td width="39%" valign="TOP"><font face="Arial" size=1><p>0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, . . . 252, 253, 254, 255</font></td></tr><tr><td width="31%" valign="TOP"><code><p>xsd:positiveInteger</code></td><td width="30%" valign="TOP"><font face="Arial" size=1><p>An integer strictly greater than zero</font></td><td width="39%" valign="TOP"><font face="Arial" size=1><p>1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, . . .</font></td></tr></table><h3>Time data types</h3><p>The next set of simple types the W3C XML Schema Language provides are more familiar to database designers than to procedural programmers; these are the time types. These can represent times of day, dates, or durations of time. The formats, shown in Table 20-2, are all based on the ISO standard 8601, <i>Representations of Dates and Time.</i> Time zones are given as offsets from Coordinated Universal Time (Greenwich Mean Time to lay people) or as the letter Z to indicate Coordinated Universal Time.</p><font face="Arial"><p align="CENTER">Table 20-2</p><b><p align="CENTER">XML Schema Time Types</p></b></font><table border cellspacing=1 width=442><tr><td width="23%" valign="TOP"><p><b><i><font face="Arial" size=1>Name</b></i></font></td><td width="36%" valign="TOP"><b><i><font face="Arial" size=1><p>Type</b></i></font></td><td width="42%" valign="TOP"><b><i><font face="Arial" size=1><p>Examples</b></i></font></td></tr><tr><td width="23%" valign="TOP"><code><p>xsd:dateTime</code></td><td width="36%" valign="TOP"><font face="Arial" size=1><p>A particular moment in Coordinated Universal Time, up to an arbitrarily small fraction of a second</font></td><td width="42%" valign="TOP"><font face="Arial" size=1><p>1999-05-31T13:20:00.000-05:00, 1999-05-31T18:20:00.000Z, 1999-05-31T13:20:00.000, 1999-05-31T13:20:00.000-05:00.321 </font></td></tr><tr><td width="23%" valign="TOP"><code><p>xsd:date</code></td><td width="36%" valign="TOP"><font face="Arial" size=1><p>A specific day in history</font></td><td width="42%" valign="TOP"><font face="Arial" size=1><p>-0044-03-15, 0001-01-01, 1969-06-27, 2000-10-31, 2001-11-17</font></td></tr><tr><td width="23%" valign="TOP"><code><p>xsd:time</code></td><td width="36%" valign="TOP"><font face="Arial" size=1><p>A specific time of day that recurs every day</font></td><td width="42%" valign="TOP"><font face="Arial" size=1><p>14:30:00.000, 09:30:00.000-05:00, 14:30:00.000Z</font></td></tr><tr><td width="23%" valign="TOP"><code><p>xsd:gDay</code></td><td width="36%" valign="TOP"><font face="Arial" size=1><p>A day in no particular month, or rather in every month</font></td><td width="42%" valign="TOP"><font face="Arial" size=1><p>--01, --02, . . . &#150;09, --10, --11, --12, . . ., --28, --29, --30, --31</font></td></tr><tr><td width="23%" valign="TOP"><code><p>xsd:gMonth</code></td><td width="36%" valign="TOP"><font face="Arial" size=1><p>A month in no particular year</font></td><td width="42%" valign="TOP"><font face="Arial" size=1><p>--01--, --02--, --03--, ---04--, . . . --09--, --10--, --11--, --12--</font></td></tr><tr><td width="23%" valign="TOP"><code><p>xsd:gYear</code></td><td width="36%" valign="TOP"><font face="Arial" size=1><p>A given year</font></td><td width="42%" valign="TOP"><font face="Arial" size=1><p>. . . -0002, -0001, 0001, 0002, 0003, . . .1998, 1999, 2000, 2001, 2002, . . .9997, 9998, 9999</font></td></tr><tr><td width="23%" valign="TOP"><code><p>xsd:gYearMonth</code></td><td width="36%" valign="TOP"><font face="Arial" size=1><p>A specific month in a specific year </font></td><td width="42%" valign="TOP"><font face="Arial" size=1><p>1999-12, 2001-04, 1968-07</font></td></tr><tr><td width="23%" valign="TOP"><code><p>xsd:gMonthDay</code></td><td width="36%" valign="TOP"><font face="Arial" size=1><p>A date in no particular year, or rather in every year</font></td><td width="42%" valign="TOP"><font face="Arial" size=1><p>--10-31, --02-28, --02-29</font></td></tr><tr><td width="23%" valign="TOP"><code><p>xsd:duration</code></td><td width="36%" valign="TOP"><font face="Arial" size=1><p>A length of time, without fixed endpoints, to an arbitrary fraction of a second</font></td><td width="42%" valign="TOP"><font face="Arial" size=1><p>P2000Y10M31DT09H32M7.4312S</font></td></tr></table><p>Notice, in particular, that in all the date formats the year comes first, followed by the month, the day, the hour, and so on. The largest unit of time is on the left, and the smallest unit is on the right. This helps avoid questions such as whether 2004&#150;02&#150;11 is February 11, 2004, or November 2, 2004.</p><h3>XML data types</h3><p>The next batch of schema data types should be quite familiar. These are the types related to XML constructs themselves. Most of these types match attribute types in DTDs such as <code>NMTOKENS</code> or <code>IDREF</code>. The difference is that with schemas these types can be applied to both elements and attributes. These also include four new types related to other XML constructs: <code>xsd:language</code>, <code>xsd:Name</code>, <code>xsd:QName</code>, and <code>xsd:NCName</code>. Table 20-3 summarizes the different types.</p><font face="Arial"><p align="CENTER">Table 20-3</p><b><p align="CENTER">XML Schema XML Types</p></b></font><table border cellspacing=1 width=442><tr><td width="23%" valign="TOP"><p><b><i><font face="Arial" size=1>Name</b></i></font></td><td width="38%" valign="TOP"><b><i><font face="Arial" size=1><p>Type</b></i></font></td><td width="40%" valign="TOP"><b><i><font face="Arial" size=1><p>Examples</b></i></font></td></tr><tr><td width="23%" valign="TOP"><code><p>xsd:ID</code></td><td width="38%" valign="TOP"><font face="Arial" size=1><p>XML 1.0 <code>ID</code><font face="Arial" size=1> attribute type; any XML name that's unique among ID type attributes and elements</font></td><td width="40%" valign="TOP"><code><p>p1</code><font face="Arial" size=1>, <code>p2</code><font face="Arial" size=1>, <code>ss120-45-6789</code><font face="Arial" size=1>, <code>_92</code><font face="Arial" size=1>, <code>red</code><font face="Arial" size=1>, <code>green</code><font face="Arial" size=1>, <code>NT-Decl</code><font face="Arial" size=1>, <code>seventeen</code></td></tr><tr><td width="23%" valign="TOP"><code><p>xsd:IDREF</code></td><td width="38%" valign="TOP"><font face="Arial" size=1><p>XML 1.0 <code>IDREF</code><font face="Arial" size=1> attribute type; any XML name that's used as the value of an ID type attribute or element elsewhere in the document</font></td><td width="40%" valign="TOP"><code><p>p1</code><font face="Arial" size=1>, <code>p2</code><font face="Arial" size=1>, <code>ss120-45-6789</code><font face="Arial" size=1>, <code>_92</code><font face="Arial" size=1>, <code>p1</code><font face="Arial" size=1>, <code>p2</code><font face="Arial" size=1>, <code>red</code><font face="Arial" size=1>, <code>green</code><font face="Arial" size=1>, <code>NT-Decl</code><font face="Arial" size=1>, <code>seventeen</code></td></tr><tr><td width="23%" valign="TOP"><code><p>xsd:ENTITY</code></td><td width="38%" valign="TOP"><font face="Arial" size=1><p>XML 1.0 <code>ENTITY</code><font face="Arial" size=1> attribute type; any XML name that's declared as an unparsed entity in the DTD</font></td><td width="40%" valign="TOP"><code><p>PIC1</code><font face="Arial" size=1>, <code>PIC2</code><font face="Arial" size=1>, <code>PIC3</code><font face="Arial" size=1>, <code>cow_movie</code><font face="Arial" size=1>, <code>MonaLisa</code><font face="Arial" size=1>, <code>Warhol</code></td></tr><tr><td width="23%" valign="TOP"><code><p>xsd:NOTATION</code></td><td width="38%" valign="TOP"><font face="Arial" size=1><p>XML 1.0 <code>NOTATION</code><font face="Arial" size=1> attribute type; any XML name that's declared as a notation name in the schema using <code>xsd:notation</code></td><td width="40%" valign="TOP"><code><p>GIF</code><font face="Arial" size=1>, <code>jpeg</code><font face="Arial" size=1>, <code>TIF</code><font face="Arial" size=1>, <code>pdf</code><font face="Arial" size=1>, <code>TeX</code></td></tr><tr><td width="23%" valign="TOP"><code><p>xsd:IDREFS</code></td><td width="38%" valign="TOP"><font face="Arial" size=1><p>XML 1.0 <code>IDREFS</code><font face="Arial" size=1> attribute type; a white space-separated list of XML names that are used as values of ID type attributes or elements elsewhere in the document</font></td><td width="40%" valign="TOP"><code><p>p1 p2</font><font face="Arial" size=1>, <code>ss120-45-6789</code><font face="Arial" size=1> <code>_92</code><font face="Arial" size=1>, <code>red green NT-Decl seventeen</font></td></tr><tr><td width="23%" valign="TOP"><code><p>xsd:ENTITIES</code></td><td width="38%" valign="TOP"><font face="Arial" size=1><p>XML 1.0 <code>ENTITIES</code><font face="Arial" size=1> attribute type; a white space-separated list of <code>ENTITY</code><font face="Arial" size=1> names</font></td><td width="40%" valign="TOP"><code><p>PIC1 PIC2 PIC3</font></td></tr><tr><td width="23%" valign="TOP"><code><p>xsd:NMTOKEN</code></td><td width="38%" valign="TOP"><font face="Arial" size=1><p>XML 1.0 <code>NMTOKEN</code><font face="Arial" size=1> attribute type</font></td><td width="40%" valign="TOP"><code><p>12</code><font face="Arial" size=1> <code>are</code><font face="Arial" size=1> <code>you</code><font face="Arial" size=1> <code>ready</code><font face="Arial" size=1> <code>199</code></td></tr><tr><td width="23%" valign="TOP"><code><p>xsd:NMTOKENS</code></td><td width="38%" valign="TOP"><font face="Arial" size=1><p>XML 1.0 <code>NMTOKENS</code><font face="Arial" size=1> attribute type, a white space-separated list of name tokens</font></td><td width="40%" valign="TOP"><code><p>MI NY LA CA</p><p>p1 p2 p3 p4 p5 p6</p><p>1 2 3 4 5 6</font></td></tr><tr><td width="23%" valign="TOP"><code><p>xsd:language</code></td><td width="38%" valign="TOP"><font face="Arial" size=1><p>Valid values for <code>xml:lang</code><font face="Arial" size=1> as defined in XML 1.0</font></td><td width="40%" valign="TOP"><code><p>en</code><font face="Arial" size=1>, <code>en-GB</code><font face="Arial" size=1>, <code>en-US</code><font face="Arial" size=1>, <code>fr</code><font face="Arial" size=1>, <code>i-lux</code><font face="Arial" size=1>, <code>ama</code><font face="Arial" size=1>, <code>ara</code><font face="Arial" size=1>, <code>ara-EG, x-choctaw</font></td></tr><tr><td width="23%" valign="TOP"><code><p>xsd:Name</code></td><td width="38%" valign="TOP"><font face="Arial" size=1><p>An XML 1.0 Name, with or without colons</font></td><td width="40%" valign="TOP"><code><p>set</code><font face="Arial" size=1>, <code>title</code><font face="Arial" size=1>, <code>rdf</code><font face="Arial" size=1>, <code>math</code><font face="Arial" size=1>, <code>math123</code><font face="Arial" size=1>, <code>xlink:href</code><font face="Arial" size=1>, <code>song:title</code></td></tr><tr><td width="23%" valign="TOP"><code><p>xsd:QName</code></td><td width="38%" valign="TOP"><font face="Arial" size=1><p>A prefixed name</font></td><td width="40%" valign="TOP"><code><p>song:title</code><font face="Arial" size=1>, <code>math:set</code><font face="Arial" size=1>, <code>xsd:element</code></td></tr><tr><td width="23%" valign="TOP"><code><p>xsd:NCName</code></td><td width="38%" valign="TOP"><font face="Arial" size=1><p>A local name without any colons</font></td><td width="40%" valign="TOP"><code><p>set</code><font face="Arial" size=1>, <code>title</code><font face="Arial" size=1>, <code>rdf</code><font face="Arial" size=1>, <code>math</code><font face="Arial" size=1>, <code>tei.2</code><font face="Arial" size=1>, <code>href</code></td></tr></table><dir><b><font face="Arial" size=1 color="#000080"><p>Cross-Reference</p></b></font><p>For more details on the permissible values for elements and attributes declared to have these types, see Chapters 9 and 11.</p></dir><h3>String data types</h3><p>You&#146;ve already encountered the <code>xsd:string</code> type. It&#146;s the most generic simple type. It requires a sequence of Unicode characters of any length, but this is what all XML element content and attribute values are. There are also two very closely related types: <code>xsd:token</code> and <code>xsd:normalizedString</code>. These are the same as <code>xsd:string</code>, except that a schema aware processor may eliminate some white space from the value before reporting it to the client application. Table 20-4 summarizes the string data types.</p><font face="Arial"><p align="CENTER">Table 20-4</p><b><p align="CENTER">XML Schema String Types</p></b></font><table border cellspacing=1 width=442><tr><td width="27%" valign="TOP"><p><b><i><font face="Arial" size=1>Name</b></i></font></td><td width="36%" valign="TOP"><b><i><font face="Arial" size=1><p>Type</b></i></font></td><td width="38%" valign="TOP"><b><i><font face="Arial" size=1><p>Examples</b></i></font></td></tr><tr><td width="27%" valign="TOP"><code><p>xsd:string</code></td><td width="36%" valign="TOP"><font face="Arial" size=1><p>A sequence of zero or more Unicode characters that are allowed in an XML document; essentially the only forbidden characters are most of the C0 controls, surrogates, and the byte-order mark</font></td><td width="38%" valign="TOP"><code><p>p1</code><font face="Arial" size=1>, <code>p2</code><font face="Arial" size=1>, <code>123 45 6789</font><font face="Arial" size=1>, <code>^*&amp;^*&amp;_92</code><font face="Arial" size=1>, <code>red green blue</font><font face="Arial" size=1>, <code>NT-Decl</code><font face="Arial" size=1>, <code>seventeen; Mary had a little lamb</font><font face="Arial" size=1>, <code>The love of money is the root of all Evil.</font><font face="Arial" size=1>, <code>Would you paint the lily?</p><p>Would you gild gold?</font></td></tr><tr><td width="27%" valign="TOP"><code><p>xsd:normalizedString</code></td><td width="36%" valign="TOP"><font face="Arial" size=1><p>A string in which all tabs, carriage returns, and linefeeds are replaced by spaces</font></td><td width="38%" valign="TOP"><code><p>PIC1</code><font face="Arial" size=1>, <code>PIC2</code><font face="Arial" size=1>, <code>PIC3</code><font face="Arial" size=1>, <code>cow_movie</code><font face="Arial" size=1>, <code>MonaLisa</code><font face="Arial" size=1>, <code>Hello World </font><font face="Arial" size=1>, <code>Warhol</code><font face="Arial" size=1>, <code>red green</font></td></tr><tr><td width="27%" valign="TOP"><code><p>xsd:token</code></td><td width="36%" valign="TOP"><font face="Arial" size=1><p>A string in which all tabs, carriage returns, and linefeeds are replaced by spaces, consecutive spaces are compressed to a single space, and leading and trailing white space is trimmed</font></td><td width="38%" valign="TOP"><code><p>p1 p2</font><font face="Arial" size=1>, <code>ss123 45 6789</font><font face="Arial" size=1>, <code>_92</code><font face="Arial" size=1>, <code>red</code><font face="Arial" size=1>, <code>green</code><font face="Arial" size=1>, <code>NT Decl</font><font face="Arial" size=1>, <code>seventeenp1</code><font face="Arial" size=1>, <code>p2</code><font face="Arial" size=1>, <code>123 45 6789</font><font face="Arial" size=1>, <code>^*&amp;^*&amp;_92</code><font face="Arial" size=1>, <code>red green blue</font><font face="Arial" size=1>, <code>NT-Decl</code><font face="Arial" size=1>, <code>seventeen</code><font face="Arial" size=1>; <code>Mary had a little lamb</font><font face="Arial" size=1>, <code>The love of money is the root of all Evil</font><font face="Arial" size=1>.</font></td></tr></table><p>It&#146;s important to note that none of these three types impose any limits on what values may appear in the instance document. Elements with type <code>xsd:strring</code>, <code>xsd:normalizedString</code>, and <code>xsd:token</code> can all contain tabs, linefeeds, consecutive spaces, and so on. The difference is that for <code>xsd:normalizedString</code> and <code>xsd:token</code> the parser may throw away some of this white space, while it won&#146;t for an <code>xsd:string,</code>.</p><h3>Binary types</h3><p>It&#146;s impossible to include arbitrary binary files in XML documents, because they might contain illegal characters such as a form feed or a null that would make the XML document malformed. Therefore, any such data must first be encoded in legal characters. The W3C XML Schema Language supports two such encodings, <code>xsd:base64Binary</code> and <code>xsd:hexBinary</code>.</p><p>Hexadecimal binary encodes each byte of the input as two hexadecimal digits&#151;00, 01, 02, 03, 04, 05, 06, 07, 08, 09, 0A, 0B, 0C, 0D, 0E, 0F, 10, 11, 12, and so on. Thus, an entire file can be encoded using only the digits 0 through 9 and the letters A through F. (Lowercase letters are also allowed, but uppercase letters are customary.) On the other hand, each byte is replaced by at least two bytes, so this encoding at least doubles the size of the data. UTF-16 uses two bytes for each character so it quadruples the size of the data. Clearly, this is not a very efficient encoding. Hexadecimal binary encoded data tends to look like this:</p><pre>A4E345EC54CC8D52198000FFEA6C807F41F332127323432147A89979EEF3</pre><p>Base 64 encoding uses a more complex algorithm and a larger character set, 65 ASCII characters chosen for their ability to pass through almost all gateways, mail relays, and terminal servers intact, as well as their existence with the same code points in ASCII, EBCDIC, and most other common character sets. Base 64 encodes every three bytes as four characters, typically only increasing file size by a third in a character set such as UTF-8, so it&#146;s somewhat more efficient than <code>xsd:hexBinary</code>. Base-64-encoded data tends to look something like this:</p><pre>6jKpNnmkkWeArsn5Oeeg2njcz+nXdk0f9kZI892ddlR8Lg1aMhPeFTYuoq3I6n BjWzuktNZKiXYBfKsSTB8U09dTiJo2ir3HJuY7eW/p89osKMfixPQsp9vQMgzph6Qa lY7j4MB7y5ROJYsTr1/fFwmj/yhkHwpbpzed1LE=</pre><p>XML Digital Signatures use Base 64 encoding to encode the binary signatures before wrapping them in an XML element.</p><dir><b><font face="Arial" size=1 color="#000080"><p>Caution</p></b></font><p>I really discourage you from using either of these if at all possible. If you have binary data, it&#146;s much more efficient and much less obtuse to link to it using XLink or unparsed entities rather than encoding it in Base 64 or hexadecimal binary.</p></dir><h3>Miscellaneous data types</h3><p>There are two types left over that don&#146;t fit neatly into the previous categories: <code>xsd:boolean</code> and <code>xsd:anyURI</code>. The <code>xsd:boolean</code> type represents something similar to C++&#146;s <code>bool</code> data type. It has four legal values: <code>0</code>, <code>1</code>, <code>true</code>, and <code>false</code>. <code>0</code> is considered to be the same as <code>false</code>, and <code>1</code> is considered the same as <code>true</code>.</p><p>The final schema simple type is <code>xsd:anyURI</code>. An element of this type contains a relative or absolute URI, possibly a URL, such as <code>urn:isbn:0764547607</code>, <code>http://www.w3.org/TR/2000/WD-xmlschema-2-20000407/#timeDuration</code>,<code> /javafaq/reports/JCE1.2.1.htm</code>, <code>/TR/2000/WD-xmlschema-2-20000407/</code>, or <code>../index.html</code>.</p><h2>Deriving Simple Types</h2><p>You&#146;re not limited to the 44 simple types that the W3C XML Schema Language defines. As in object-oriented programming languages, you can create new data types by deriving from the existing types. The most common such derivation is to restrict a type to a subset of its normal values. For example, you can define an integer type that only holds numbers between 1 and 20 by deriving from <code>xsd:positiveInteger</code>. You can create enumerated types that only allow a finite list of fixed values. You can create new types that join together the ranges of existing types through a union. For example, you can derive a type that can hold either an <code>xsd:date</code> or an <code>xsd:int</code>.</p><p>New simple types are created by <code>xsd:simpleType</code> elements, just as new complex types are created by <code>xsd:complexType</code> elements. The <code>name</code> attribute of <code>xsd:simpleType</code> assigns a name to the new type by which it can be referred to in <code>xsd:element</code> <code>type</code> attributes. The allowed content of elements and attributes with the new type can be specified by one of three child elements:</p><ul>	<li><p><code>xsd:restriction</code> to select a subset of the values allowed by the base type</p></li>	<li><p><code>xsd:union</code> to combine multiple types</p></li>	<li><p><code>xsd:list</code> to specify a list of elements of an existing simple type</p></li></ul><h3>Deriving by restriction</h3><p>To create a new type by restricting from an existing type, give the <code>xsd:simpleType</code> element an <code>xsd:restriction</code> child element. The <code>base</code> attribute of this element specifies what type you&#146;re restricting. For example, this <code>xsd:simpleType</code> element creates a new type named <code>phonoYear</code> that&#146;s derived from <code>xsd:gYear</code>:</p><pre>&lt;xsd:simpleType name="phonoYear"&gt;  &lt;xsd:restriction base="xsd:gYear"&gt;  &lt;/xsd:restriction&gt;&lt;/xsd:simpleType&gt;</pre><p>With this declaration, any legal <code>xsd:gYear</code> is also a legal <code>phonoYear</code>, and any illegal year is also an illegal <code>phonoYear</code>. You can limit <code>phonoYear</code> to a subset of the normal year values by using <i>facets</i> to specify which values are and are not allowed. For example, the <code>minInclusive</code> facet defines the minimum legal value for a type. This facet is added to a restriction as an <code>xsd:minInclusive</code> child element. The <code>value</code> attribute of the <code>xsd:minInclusive</code> element sets the minimum allowed value for the year:</p><pre>&lt;xsd:simpleType name="phonoYear"&gt;  &lt;xsd:restriction base="xsd:gYear"&gt;    &lt;xsd:minInclusive value="1877"/&gt;  &lt;/xsd:restriction&gt;&lt;/xsd:simpleType&gt;</pre><p>Here the <code>value</code> of <code>xsd:minInclusive</code> is set to 1877, the year Thomas Edison invented the phonograph. Thus, 1877 is a legal <code>phonoYear</code>, 1878 is a legal <code>phonoYear</code>, 2001 is a legal <code>phonoYear</code>, and 3005 is a legal <code>phonoYear</code>. However, 1876, 1875, 1874, and earlier years are not legal <code>phonoYear</code>s, even though they are legal <code>xsd:gYear</code>s.</p><p>After the <code>phonoYear</code> type has been defined, you can use it just like one of the built-in types. For example, in the <code>SONG</code> schema, you&#146;d declare that the <code>year</code> element has the type <code>phonoYear</code>, like this:</p><pre>&lt;xsd:element type="phonoYear"/&gt;</pre><code><p>minInclusive</code> is not the only facet you can apply to <code>xsd:gYear</code>. Other facets of <code>xsd:gYear</code> are as follows:</p><ul>	<li><p><code>xsd:minExclusive</code>&#151;The minimum value that all instances must be strictly greater than</p></li>	<li><p><code>xsd:maxInclusive</code>&#151;The maximum value that all instances must be less than or equal to</p></li>	<li><p><code>xsd:maxExclusive</code>&#151;The maximum value that all instances must be strictly less than</p></li>	<li><p><code>xsd:enumeration</code>&#151;A list of all legal values</p></li>	<li><p><code>xsd:whiteSpace</code>&#151;How white space is treated within the element</p></li>	<li><p><code>xsd:pattern</code>&#151;A regular expression to which the instance is compared</p></li></ul><p>Each facet is represented as an empty element inside an <code>xsd:restriction</code> element. Each facet has a <code>value</code> attribute giving the value of that facet. One restriction can contain more than one facet. For example, this <code>xsd:simpleType</code> element defines a <code>phonoYear</code> as any year between 1877 and 2100, inclusive:</p><pre>&lt;xsd:simpleType name="phonoYear"&gt;  &lt;xsd:restriction base="xsd:gYear"&gt;    &lt;xsd:minInclusive value="1877"/&gt;    &lt;xsd:maxInclusive value="2100"/&gt;  &lt;/xsd:restriction&gt;&lt;/xsd:simpleType&gt;</pre><p>It&#146;s possible that multiple facets may conflict. For example, the <code>minInclusive</code> value could be 2100 and the <code>maxInclusive</code> value could be 1877. While this is probably a design mistake, it is syntactically legal. It would just mean that the set of <code>phonoYear</code>s was the empty set, and <code>phonoYear</code> type elements could not actually be used in instance documents.</p><h3>Facets</h3><p>Facets are shared among many types. For example, the <code>minInclusive</code> facet can constrain essentially any well-ordered type, including not only <code>xsd:gYear</code>, but also <code>xsd:byte</code>, <code>xsd:unsignedByte</code>, <code>xsd:integer</code>, <code>xsd:positiveInteger</code>, <code>xsd:negativeInteger</code>, <code>xsd:nonNegativeInteger</code>, <code>xsd:nonPositiveInteger</code>, <code>xsd:int</code>, <code>xsd:unsignedInt</code>, <code>xsd:long</code>, <code>xsd:unsignedLong</code>, <code>xsd:short</code>, <code>xsd:unsignedShort</code>, <code>xsd:decima</code>l, <code>xsd:float</code>, <code>xsd:double</code>, <code>xsd:time</code>, <code>xsd:dateTime</code>, <code>xsd:duration</code>, <code>xsd:date</code>, <code>xsd:gMonth</code>, <code>xsd:gYearMonth</code>, and <code>xsd:gMonthDay</code>. The complete list of constraining facets that can be applied to different types is as follows:</p><ul><li><code>xsd:minInclusive</code>&#151;The value that all instances must be greater than or equal to</li><li><code>xsd:minExclusive</code>&#151;The value that all instances must be strictly greater than</li><li><code>xsd:maxInclusive</code>&#151;The value that all instances must be less than or equal to</li></ul><ul><li><code>xsd:maxExclusive</code>&#151;The value that all instances must be strictly less than</li><li><code>xsd:enumeration</code>&#151;A list of all legal values</li><li><code>xsd:whiteSpace</code>&#151;How white space is treated within the element</li><li><code>xsd:pattern</code>&#151;A regular expression to which the instance is compared</li><li><code>xsd:length</code>&#151;The exact number of characters a string, items in a list, or bytes in binary data</li><li><code>xsd:minLength</code>&#151;The minimum length</li><li><code>xsd:maxLength</code>&#151;The maximum length</li><li><code>xsd:totalDigits</code>&#151;The maximum number of digits allowed in the element</li><li><code>xsd:fractionDigits</code>&#151;The maximum number of digits allowed in the fractional part of the element</li></ul><p>Not all facets apply to all types. For example, it doesn&#146;t make much sense to talk about the minimum value of an <code>xsd:NMTOKEN</code> or the number of fraction digits in an <code>xsd:gYear</code>. However, when the same facet is shared by different types, it has the same syntax and basic meaning for all the types.</p><h3>Facets for strings: length, minLength, maxLength</h3><p>The three length facets&#151;<code>xsd:length</code>, <code>xsd:minLength</code>, and <code>xsd:maxLengt</code>h&#151;specify the number of units allowed in a value. For <code>xsd:string</code> and its subtypes&#151;<code>xsd:normalizedString</code>, <code>xsd:token</code>, <code>xsd:hexBinary</code>, <code>xsd:base64Binary</code>, <code>xsd:QName</code>, <code>xsd:NCName</code>, <code>xsd:ID</code>, <code>xsd:IDREF</code>, <code>xsd:IDREFS</code>, <code>xsd:language</code>, <code>xsd:anyURI</code>, <code>xsd:ENTITY</code>, <code>xsd:NOTATION</code>, <code>xsd:NOTATIONS</code>, <code>xsd:NMTOKEN</code>, and <code>xsd:NMTOKENS</code>&#151;the units are characters and these facets specify the number of characters allowed in the element or attribute value. For list types&#151;<code>xsd:ENTITIES</code>, <code>xsd:NOTATIONS</code>, and <code>xsd:NMTOKENS</code>&#151;these facets control the number of instances in the list. And finally for the two binary types&#151;<code>xsd:base64Binary</code> and <code>xsd:hexBinary</code>&#151;these control the number of bytes in the decoded value. The <code>value</code> attribute of each of these facets must contain a nonnegative integer. <code>xsd:length</code> sets the exact number of units in the value, whereas <code>xsd:minLength</code> sets the minimum length and <code>xsd:maxLengt</code>h sets the maximum length.</p><p>For example, the schema in Listing 20-18 uses the <code>xsd:minLength</code> and <code>xsd:maxLength</code> facets to derive a new <code>Str255</code> data type from <code>xsd:string</code>. Whereas <code>xsd:string</code> allows strings of any length from zero on up, <code>Str255</code> requires each string to have a minimum length of 1 and a maximum length of 255. The schema then assigns this data type to all the names and titles to indicate that each must contain between 1 and 255 characters.</p><font face="Arial"><p>Listing 20-18: A Schema That Derives a Str255 Data Type from xsd:string</p></font><pre>&lt;?xml version="1.0"?&gt;&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;  &lt;xsd:simpleType name="Str255"&gt;    &lt;xsd:restriction base="xsd:string"&gt;      &lt;xsd:minLength value="1"/&gt;      &lt;xsd:maxLength value="255"/&gt;    &lt;/xsd:restriction&gt;  &lt;/xsd:simpleType&gt;  &lt;xsd:element name="SONG" type="SongType"/&gt;  &lt;xsd:complexType name="SongType"&gt;    &lt;xsd:sequence&gt;      &lt;xsd:element name="TITLE"     type="Str255"/&gt;      &lt;xsd:element name="COMPOSER"  type="Str255"                   maxOccurs="unbounded"/&gt;      &lt;xsd:element name="PRODUCER"  type="Str255"                   minOccurs="0"    maxOccurs="unbounded"/&gt;      &lt;xsd:element name="PUBLISHER" type="Str255"                   minOccurs="0"/&gt;      &lt;xsd:element name="LENGTH"    type="xsd:duration"/&gt;      &lt;xsd:element name="YEAR"      type="xsd:gYear"/&gt;      &lt;xsd:element name="ARTIST"    type="Str255"                   maxOccurs="unbounded"/&gt;      &lt;xsd:element name="PRICE"     type="xsd:string"                   minOccurs="0"/&gt;    &lt;/xsd:sequence&gt;  &lt;/xsd:complexType&gt;&lt;/xsd:schema&gt;</pre><h3>The whiteSpace facet</h3><p>The <code>whiteSpace</code> facet is unusual. Unlike the other 11 facets, <code>xsd:whiteSpace</code> does not in any way constrain the allowed content of elements. Instead, it suggests what the application should do with any white space that it finds in the instance document. It says how significant that white space is. However, it does not say that any particular kind of white space is legal or illegal.</p><p>The <code>xsd:whiteSpace</code> facet has three possible values:</p><ul>	<li><p><code>preserve</code>&#151;The white space in the input document is unchanged.</p></li>	<li><p><code>replace</code>&#151;Each tab, carriage return, and linefeed is replaced with a single space.</p></li>	<li><p><code>collapse</code>&#151;Each tab, carriage return, and linefeed is replaced with a single space. Furthermore, after this replacement is performed, all runs of multiple spaces are condensed to a single space. Leading and trailing white space is deleted.</p></li></ul><p>Again, these are all just hints to the application. None of them have any effect on validation.</p><p>The <code>whiteSpace</code> facet can only be applied to <code>xsd:string</code>, <code>xsd:normalizedString</code>, and <code>xsd:token</code> types. Furthermore, it only fully applies to elements. XML 1.0 requires that parsers replace all white space in attributes, and collapse white space in attributes whose DTD type is anything other than CDATA, regardless of what the schema says.</p><p>The schema in Listing 20-19 uses the <code>xsd:whiteSpace</code> facets to derive a new <code>CollapsedString</code> data type from <code>xsd:string</code>. Then it assigns this data type to all the names and titles to indicate that white space should be collapsed in these elements.</p><font face="Arial"><p>Listing 20-19: A Schema That Suggests Collapsing White Space in Elements</p></font><pre>&lt;?xml version="1.0"?&gt;&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;  &lt;xsd:element name="SONG" type="SongType"/&gt;  &lt;xsd:simpleType name="CollapsedString"&gt;    &lt;xsd:restriction base="xsd:string"&gt;       &lt;xsd:whiteSpace value="collapse"/&gt;    &lt;/xsd:restriction&gt;  &lt;/xsd:simpleType&gt;  &lt;xsd:complexType name="SongType"&gt;    &lt;xsd:sequence&gt;      &lt;xsd:element name="TITLE"     type="CollapsedString"/&gt;      &lt;xsd:element name="COMPOSER"  type="CollapsedString"        maxOccurs="unbounded"/&gt;      &lt;xsd:element name="PRODUCER"  type="CollapsedString"        minOccurs="0" maxOccurs="unbounded"/&gt;      &lt;xsd:element name="PUBLISHER" type="CollapsedString"        minOccurs="0"/&gt;      &lt;xsd:element name="LENGTH"    type="xsd:duration"/&gt;      &lt;xsd:element name="YEAR"      type="xsd:gYear"/&gt;      &lt;xsd:element name="ARTIST"    type="CollapsedString"        maxOccurs="unbounded"/&gt;      &lt;xsd:element name="PRICE"     type="xsd:string"                   minOccurs="0"/&gt;    &lt;/xsd:sequence&gt;  &lt;/xsd:complexType&gt;&lt;/xsd:schema&gt;</pre><h3>Facets for decimal numbers: totalDigits and fractionDigits</h3><p>When you are formatting numbers, it&#146;s useful to be able to specify how many digits should be used in the entire number, the integer parts, and the fraction parts. Schemas don&#146;t go as far in this regard as the <code>printf()</code> function in C or the <code>java.text.DecimalFormat</code> class in Java, but they do offer you some control.</p><p>The <code>xsd:totalDigits</code> facet specifies the maximum number of decimal digits in a number. It applies to most numeric types including <code>xsd:byte</code>, <code>xsd:unsignedByte</code>, <code>xsd:integer</code>, <code>xsd:positiveInteger</code>, <code>xsd:negativeInteger</code>, <code>xsd:nonNegativeInteger</code>, <code>xsd:nonPositiveInteger</code>, <code>xsd:int</code>, <code>xsd:unsignedInt</code>, <code>xsd:long</code>, <code>xsd:unsignedLong</code>, <code>xsd:short</code>, <code>xsd:unsignedShort</code>, and <code>xsd:decima</code>l. The only exceptions are the IEEE 754 types that occupy a fixed number of bytes; that is, <code>xsd:float</code> and <code>xsd:double</code>. The value of this facet must be a positive integer.</p><p>The <code>xsd:fractionDigits</code> facet specifies the maximum number of decimal digits to the right of the decimal point. (There is no facet that allows you to specify the minimum number of digits or fraction digits.) This only really applies to <code>xsd:decimal</code>. Technically, it applies to all the integer types too, but for those types it&#146;s fixed to the value zero; that is, no fraction digits at all. You&#146;re only allowed to change it for <code>xsd:decimal</code>. The value of this facet must be a nonnegative integer.</p><h3>The enumeration facet</h3><p>Rather than setting some sort of range on legal values, the <code>xsd:enumeration</code> facet simply lists all allowed values. It applies to every simple type except <code>xsd:boolean</code>. The syntax is a little unusual. Each possible value gets its own <code>xsd:enumeration</code> element as a child of the <code>xsd:restriction</code> element.</p><p>Listing 20-20 uses an enumeration to derive a <code>PublisherType</code> from <code>xsd:string</code>. It requires that the publisher be one of the oligopoly that controls 90 percent of all U.S. music. (Warner-Elektra-Atlantic, Universal Music Group, Sony Music Entertainment, Inc., Capitol Records, Inc., and BMG Music).</p><font face="Arial"><p>Listing 20-20: A Schema That Uses an Enumeration to Derive a Type from xsd:string</p></font><pre>&lt;?xml version="1.0"?&gt;&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;  &lt;xsd:element name="SONG" type="songType"/&gt;  &lt;xsd:simpleType name="PublisherType"&gt;    &lt;xsd:restriction base="xsd:string"&gt;     &lt;xsd:enumeration value="Warner-Elektra-Atlantic"/&gt;     &lt;xsd:enumeration value="Universal Music Group"/&gt;     &lt;xsd:enumeration value="Sony Music Entertainment, Inc."/&gt;     &lt;xsd:enumeration value="Capitol Records, Inc."/&gt;     &lt;xsd:enumeration value="BMG Music"/&gt;    &lt;/xsd:restriction&gt;  &lt;/xsd:simpleType&gt;  &lt;xsd:complexType name="songType"&gt;    &lt;xsd:sequence&gt;      &lt;xsd:element name="TITLE"     type="xsd:string"/&gt;      &lt;xsd:element name="COMPOSER"  type="xsd:string"        maxOccurs="unbounded"/&gt;      &lt;xsd:element name="PRODUCER"  type="xsd:string"        minOccurs="0" maxOccurs="unbounded"/&gt;      &lt;xsd:element name="PUBLISHER" type="PublisherType"        minOccurs="0"/&gt;      &lt;xsd:element name="LENGTH"    type="xsd:duration"/&gt;      &lt;xsd:element name="YEAR"      type="xsd:gYear"/&gt;      &lt;xsd:element name="ARTIST"    type="xsd:string"        maxOccurs="unbounded"/&gt;      &lt;xsd:element name="PRICE"     type="xsd:string"                   minOccurs="0"/&gt;    &lt;/xsd:sequence&gt;  &lt;/xsd:complexType&gt;&lt;/xsd:schema&gt;</pre><code><p>xsd:string</code> is far from the only type you can derive from via enumeration. You can derive from <code>xsd:int</code>, <code>xsd:NMTOKEN</code>, <code>xsd:date</code>, and, indeed, from all simple types except <code>xsd:boolean</code>. Of course, the enumerated values all have to be legal instances of the base type.</p><h3>The pattern facet</h3><p>There&#146;s one element in the song examples that clearly deserves a data type, but so far doesn&#146;t have one&#151;<code>PRICE</code>. However none of the built-in data types really match the format for prices. Recall that <code>PRICE</code> elements look like this:</p><pre>&lt;PRICE&gt;$1.25&lt;/PRICE&gt;</pre><p>This isn&#146;t an integer of any kind, because it has a decimal point. It could be a floating-point number, but that wouldn&#146;t account for the currency sign. You could drop off the currency sign, like this:</p><pre>&lt;PRICE&gt;1.25&lt;/PRICE&gt;</pre><p>However, then you&#146;d have to assume you were working in dollars. What if you wanted to sell songs priced in pounds or yen or euros? Perhaps you could make the currency sign part of a separate element, like this:</p><pre>&lt;PRICE&gt;  &lt;CURRENCY&gt;$&lt;/CURRENCY&gt;  &lt;AMOUNT&gt;1.25&lt;/AMOUNT&gt;&lt;/PRICE&gt;</pre><code><p>AMOUNT</code> could be an <code>xsd:float</code>, and <code>CURRENCY</code> could be an <code>xsd:string</code>. However, this still isn&#146;t perfect. You want to limit the <code>CURRENCY</code> to exactly one character, and that character must be a currency sign. You don&#146;t want to allow it to contain any arbitrary string. Furthermore, you&#146;d like to limit the precision of the <code>AMOUNT</code> to exactly two decimal places. You probably don&#146;t want to sell songs that cost $1.1 or $1.99999.</p><p>The solution to this problem, and to many similar problems where the values you want to allow don&#146;t quite fit any of the existing types, is to use the <code>xsd:pattern</code> facet whose <code>value</code> attribute contains a regular expression that matches all legal values and doesn&#146;t match any illegal values.</p><p>The regular expressions used in schemas are similar to the regular expressions you might be familiar with from Perl, grep, or other languages. You use statements like [A-Z]+ to mean "a string containing one more of the capital letters from A to Z" or (club)* to mean "a string composed of zero or more repetitions of the word club."</p><p>Table 20-5 summarizes the grammar of XML schema regular expressions. In this table <i>A</i> and <i>B</i> represent some string or another regular expression particle from elsewhere in the table; that is, they will be replaced by something else when actually used in a regular expression. <i>n</i> and <i>m</i> represent some integer that will be replaced by a specific number.</p><font face="Arial"><p align="CENTER">Table 20-5</p><b><p align="CENTER">Regular Expression Symbols for XML Schema</p></b></font><table border cellspacing=1 width=442><tr><td width="16%" valign="TOP"><p><b><i><font face="Arial" size=1>Symbol</b></i></font></td><td width="84%" valign="TOP"><b><i><font face="Arial" size=1><p>Meaning</b></i></font></td></tr><tr><td width="16%" valign="TOP"><code><p>A?</code></td><td width="84%" valign="TOP"><font face="Arial" size=1><p>Zero or one occurrences of <i>A</i></font></td></tr><tr><td width="16%" valign="TOP"><code><p>A*</code></td><td width="84%" valign="TOP"><font face="Arial" size=1><p>Zero or more occurrences of <i>A</i></font></td></tr><tr><td width="16%" valign="TOP"><code><p>A+</code></td><td width="84%" valign="TOP"><font face="Arial" size=1><p>One or more occurrences of <i>A</i></font></td></tr><tr><td width="16%" valign="TOP"><code><p>A{n,m}</code></td><td width="84%" valign="TOP"><font face="Arial" size=1><p>Between <i>n</i> and <i>m</i> occurrences of <i>A</i></font></td></tr><tr><td width="16%" valign="TOP"><code><p>A{n}</code></td><td width="84%" valign="TOP"><font face="Arial" size=1><p>Exactly <i>n</i> occurrences of <i>A</i></font></td></tr><tr><td width="16%" valign="TOP"><code><p>A{n,}</code></td><td width="84%" valign="TOP"><font face="Arial" size=1><p>At least <i>n</i> occurrences of <i>A</i></font></td></tr><tr><td width="16%" valign="TOP"><code><p>A|B</code></td><td width="84%" valign="TOP"><font face="Arial" size=1><p>Either <i>A</i> or <i>B</i></font></td></tr><tr><td width="16%" valign="TOP"><code><p>AB</code></td><td width="84%" valign="TOP"><i><font face="Arial" size=1><p>A</i> followed by <i>B</i></font></td></tr><tr><td width="16%" valign="TOP"><code><p>.</code></td><td width="84%" valign="TOP"><font face="Arial" size=1><p>Any one character</font></td></tr><tr><td width="16%" valign="TOP"><font size=2><p><code>\p{A}</code></td><td width="84%" valign="TOP"><font face="Arial" size=1><p>One character from Unicode character class <i>A</i></font></td></tr><tr><td width="16%" valign="TOP"><code><p>[abcdefg]</code></td><td width="84%" valign="TOP"><font face="Arial" size=1><p>A single occurrence of any of the characters contained in the brackets</font></td></tr><tr><td width="16%" valign="TOP"><code><p>[^abcdefg]</code></td><td width="84%" valign="TOP"><font face="Arial" size=1><p>A single occurrence of any of the characters <i>not</i> contained in the brackets</font></td></tr><tr><td width="16%" valign="TOP"><code><p>[a-z]</code></td><td width="84%" valign="TOP"><font face="Arial" size=1><p>A single occurrence of any character from <i>a</i> to <i>z</i> inclusive</font></td></tr><tr><td width="16%" valign="TOP"><code><p>[^a-z]</code></td><td width="84%" valign="TOP"><font face="Arial" size=1><p>A single occurrence of any of character <i>except</i> those from <i>a</i> to <i>z</i> inclusive</font></td></tr><tr><td width="16%" valign="TOP"><font size=2><p><code>\n</code></td><td width="84%" valign="TOP"><font face="Arial" size=1><p>Linefeed</font></td></tr><tr><td width="16%" valign="TOP"><font size=2><p><code>\r</code></td><td width="84%" valign="TOP"><font face="Arial" size=1><p>Carriage return</font></td></tr><tr><td width="16%" valign="TOP"><font size=2><p><code>\t</code></td><td width="84%" valign="TOP"><font face="Arial" size=1><p>Tab</font></td></tr><tr><td width="16%" valign="TOP"><font size=2><p>\\</font></td><td width="84%" valign="TOP"><font face="Arial" size=1><p>Backward slash \</font></td></tr><tr><td width="16%" valign="TOP"><font size=2><p><code>\|</code></td><td width="84%" valign="TOP"><font face="Arial" size=1><p>Vertical bar |</font></td></tr><tr><td width="16%" valign="TOP"><font size=2><p><code>\.</code></td><td width="84%" valign="TOP"><font face="Arial" size=1><p>Period .</font></td></tr><tr><td width="16%" valign="TOP"><font size=2><p><code>\-</code></td><td width="84%" valign="TOP"><font face="Arial" size=1><p>Hyphen -</font></td></tr><tr><td width="16%" valign="TOP"><font size=2><p><code>\^</code></td><td width="84%" valign="TOP"><font face="Arial" size=1><p>Caret ^</font></td></tr><tr><td width="16%" valign="TOP"><font size=2><p><code>\?</code></td><td width="84%" valign="TOP"><font face="Arial" size=1><p>Question mark ?</font></td></tr><tr><td width="16%" valign="TOP"><font size=2><p><code>\*</code></td><td width="84%" valign="TOP"><font face="Arial" size=1><p>Asterisk *</font></td></tr><tr><td width="16%" valign="TOP"><font size=2><p><code>\+</code></td><td width="84%" valign="TOP"><font face="Arial" size=1><p>Plus sign +</font></td></tr><tr><td width="16%" valign="TOP"><font size=2><p>\{</font></td><td width="84%" valign="TOP"><font face="Arial" size=1><p>Open brace {</font></td></tr><tr><td width="16%" valign="TOP"><font size=2><p>\}</font></td><td width="84%" valign="TOP"><font face="Arial" size=1><p>Closing brace }</font></td></tr><tr><td width="16%" valign="TOP"><font size=2><p><code>\(</code></td><td width="84%" valign="TOP"><font face="Arial" size=1><p>Open parenthesis (</font></td></tr><tr><td width="16%" valign="TOP"><font size=2><p><code>\)</code></td><td width="84%" valign="TOP"><font face="Arial" size=1><p>Closing parenthesis )</font></td></tr><tr><td width="16%" valign="TOP"><font size=2><p><code>\[</code></td><td width="84%" valign="TOP"><font face="Arial" size=1><p>Open bracket [</font></td></tr><tr><td width="16%" valign="TOP"><font size=2><p><code>\]</code></td><td width="84%" valign="TOP"><font face="Arial" size=1><p>Closing bracket ]</font></td></tr></table><p>For the most part, these symbols have exactly the same meanings that they have in Perl. The schema regular expression syntax is somewhat weaker than Perl&#146;s, but then whose isn&#146;t? In any case, this should be sufficient power to meet any reasonable needs that schemas have.</p><p>Schema regular expressions do have one important feature that isn&#146;t available prior to Perl 5.6 and is unfamiliar to most developers&#151;you can use <code>\p{}</code> to stand in for a character in a particular Unicode character class. For example, <code>N</code> is the Unicode character class for numbers. This doesn&#146;t just include the European digits 0 through 9, but also the Arabic-Indic digits, the Devanagari digits, the Thai digits, and many more besides. Therefore, <code>\p{N}</code> represents any digit defined anywhere in Unicode. <code>\p{N}+</code> represents a string consisting of one or more Unicode digits. Table 20-6 lists the various Unicode character classes you can take advantage of in regular expressions. For the money regular expression, you need the <code>Sc</code> class for currency indicators and the <code>Nd</code> class for decimal digits. This is a little more restrictive than the N class, which includes nondecimal digits, such as the Roman numerals and the Han ideograph representing 100,000,000.</p><font face="Arial"><p align="CENTER">Table 20-6</p><b><p align="CENTER">Unicode Character Classes</p></b></font><table border cellspacing=1 width=442><tr><td width="18%" valign="TOP"><p><b><i><font face="Arial" size=1>Abbreviation</b></i></font></td><td width="49%" valign="TOP"><b><i><font face="Arial" size=1><p>Includes</b></i></font></td><td width="33%" valign="TOP"><b><i><font face="Arial" size=1><p>Examples</b></i></font></td></tr><tr><td valign="TOP" colspan=3><b><i><font face="Arial" size=1><p>Letters</b></i></font></td></tr><tr><td width="18%" valign="TOP"><font face="Arial" size=1><p>L</font></td><td width="49%" valign="TOP"><font face="Arial" size=1><p>All letters</font></td><td width="33%" valign="TOP"><font face="Arial" size=1><p>a, b, c, A, B, C, &uuml;, &Uuml;, &ccedil;, &Ccedil;, ζ, θ, Ζ, Θ, а, б, в, А, Б, В, </font><font size=1>א</font><font face="Arial" size=1>, </font><font size=1>ב</font><font face="Arial" size=1>, </font><font size=1>ג</font><font face="Arial" size=1>, dz, Dz, DZ</font></td></tr><tr><td width="18%" valign="TOP"><font face="Arial" size=1><p>Lu</font></td><td width="49%" valign="TOP"><font face="Arial" size=1><p>Uppercase letters</font></td><td width="33%" valign="TOP"><font face="Arial" size=1><p>A, B, C, &Uuml;, &Ccedil;, Ζ, Θ, А, Б, В, DZ</font></td></tr><tr><td width="18%" valign="TOP"><font face="Arial" size=1><p>Ll</font></td><td width="49%" valign="TOP"><font face="Arial" size=1><p>Lowercase letters</font></td><td width="33%" valign="TOP"><font face="Arial" size=1><p>a, b, c, &uuml;, &ccedil;, ζ, θ, а, б, в, dz</font></td></tr><tr><td width="18%" valign="TOP"><font face="Arial" size=1><p>Lt</font></td><td width="49%" valign="TOP"><font face="Arial" size=1><p>Title case letters</font></td><td width="33%" valign="TOP"><font face="Arial" size=1><p>Dz</font></td></tr><tr><td width="18%" valign="TOP"><font face="Arial" size=1><p>Lm</font></td><td width="49%" valign="TOP"><font face="Arial" size=1><p>Modifier letters; letters that are attached to the previous characters somehow</font></td><td width="33%" valign="TOP"><sup><font face="Arial" size=1><p>h</sup>, <sup>j</sup>, <sup>r</sup>, <sup>w</sup></font></td></tr><tr><td width="18%" valign="TOP"><font face="Arial" size=1><p>Lo</font></td><td width="49%" valign="TOP"><font face="Arial" size=1><p>Other letters; typically ones from languages that don&#146;t distinguish upper- and lowercase</font></td><td width="33%" valign="TOP"><font size=1><p>א</font><font face="Arial" size=1>, </font><font size=1>ב</font><font face="Arial" size=1>, </font><font size=1>ג</font><font face="Arial" size=1>, Japanese Katakana and Hiragana, most Han ideographs</font></td></tr><tr><td valign="TOP" colspan=3><b><i><font face="Arial" size=1><p>Marks</b></i></font></td></tr><tr><td width="18%" valign="TOP"><font face="Arial" size=1><p>M</font></td><td width="49%" valign="TOP"><font face="Arial" size=1><p>All marks</font></td><td width="33%" valign="TOP"><p>&nbsp;</td></tr><tr><td width="18%" valign="TOP"><font face="Arial" size=1><p>Mn</font></td><td width="49%" valign="TOP"><font face="Arial" size=1><p>Nonspacing marks; mostly accent marks that are attached to the previous character on the top or bottom, and thus do not change the amount of space the character occupies</font></td><td width="33%" valign="TOP"><font face="Arial" size=1><p>`, ', &#168;, &#175;</font></td></tr><tr><td width="18%" valign="TOP"><font face="Arial" size=1><p>Mc</font></td><td width="49%" valign="TOP"><font face="Arial" size=1><p>Spacing combining marks; accent marks that are attached to the previous character on the left or right, and thus do change the amount of space the character occupies</font></td><td width="33%" valign="TOP"><sup><font face="Arial" size=1><p>T</sup>, Gurmukhi vowel sign AA</font></td></tr><tr><td width="18%" valign="TOP"><font face="Arial" size=1><p>Me</font></td><td width="49%" valign="TOP"><font face="Arial" size=1><p>Enclosing marks that completely surround a character</font></td><td width="33%" valign="TOP"><font face="Arial" size=1><p>The Cyrillic hundred-thousands and millions signs</font></td></tr><tr><td valign="TOP" colspan=3><b><i><font face="Arial" size=1><p>Numbers</b></i></font></td></tr><tr><td width="18%" valign="TOP"><font face="Arial" size=1><p>N </font></td><td width="49%" valign="TOP"><font face="Arial" size=1><p>All numbers</font></td><td width="33%" valign="TOP"><font face="Arial" size=1><p>0, 1, 2, 3, _, _, _, _, </font><font size=1>٠</font><font face="Arial" size=1>, </font><font size=1>٩</font><font face="Arial" size=1>, I, II, III, IV, V, </font><font face="MingLiU,Times" lang="ZH-TW" size=1>〡</font><font face="Arial" size=1>, </font><font face="MingLiU,Times" lang="ZH-TW" size=1>〢</font><font face="Arial" size=1>, </font><font face="MingLiU,Times" lang="ZH-TW" size=1>〣</font><font face="Arial" size=1>, </font><font face="MingLiU,Times" lang="ZH-TW" size=1>〤</font></td></tr><tr><td width="18%" valign="TOP"><font face="Arial" size=1><p>Nd </font></td><td width="49%" valign="TOP"><font face="Arial" size=1><p>Decimal digits; characters that represent one of the numbers 0 through 9</font></td><td width="33%" valign="TOP"><font face="Arial" size=1><p>0, 1, 2, 3, </font><font size=1>٠</font><font face="Arial" size=1>, </font><font size=1>٩</font></td></tr><tr><td width="18%" valign="TOP"><font face="Arial" size=1><p>Nl</font></td><td width="49%" valign="TOP"><font face="Arial" size=1><p>Numbers based on letters</font></td><td width="33%" valign="TOP"><font face="Arial" size=1><p>I, II, III, IV </font><font face="MingLiU,Times" lang="ZH-TW" size=1>〡</font><font face="Arial" size=1>, </font><font face="MingLiU,Times" lang="ZH-TW" size=1>〢</font><font face="Arial" size=1>, </font><font face="MingLiU,Times" lang="ZH-TW" size=1>〣</font><font face="Arial" size=1>, </font><font face="MingLiU,Times" lang="ZH-TW" size=1>〤</font></td></tr><tr><td width="18%" valign="TOP"><font face="Arial" size=1><p>No</font></td><td width="49%" valign="TOP"><font face="Arial" size=1><p>Other numbers</font></td><td width="33%" valign="TOP"><font face="Arial" size=1><p>_, _, _, _</font></td></tr><tr><td valign="TOP" colspan=3><b><i><font face="Arial" size=1><p>Punctuation</b></i></font></td></tr><tr><td width="18%" valign="TOP"><font face="Arial" size=1><p>P</font></td><td width="49%" valign="TOP"><font face="Arial" size=1><p>All punctuation</font></td><td width="33%" valign="TOP"><font face="Arial" size=1><p>-, _, </font><font face="MS Mincho,Times" lang="JA" size=1>・</font><font face="Arial" size=1>, (, [, {, ), ], }, &#145;, ", &#180;, &#146;, ", &#170;, !, ?, @, *, &#161;, &#191;, &#183;</font></td></tr><tr><td width="18%" valign="TOP"><font face="Arial" size=1><p>Pc</font></td><td width="49%" valign="TOP"><font face="Arial" size=1><p>Connectors</font></td><td width="33%" valign="TOP"><font face="Arial" size=1><p>_, </font><font face="MS Mincho,Times" lang="JA" size=1>・</font></td></tr><tr><td width="18%" valign="TOP"><font face="Arial" size=1><p>Pd</font></td><td width="49%" valign="TOP"><font face="Arial" size=1><p>Dashes</font></td><td width="33%" valign="TOP"><font face="Arial" size=1><p>Hyphens, soft hyphens, em dashes, en dashes, etc. </font></td></tr><tr><td width="18%" valign="TOP"><font face="Arial" size=1><p>Ps</font></td><td width="49%" valign="TOP"><font face="Arial" size=1><p>Opening punctuation</font></td><td width="33%" valign="TOP"><font face="Arial" size=1><p>(, [, {</font></td></tr><tr><td width="18%" valign="TOP"><font face="Arial" size=1><p>Pe</font></td><td width="49%" valign="TOP"><font face="Arial" size=1><p>Closing punctuation</font></td><td width="33%" valign="TOP"><font face="Arial" size=1><p>), ], }</font></td></tr><tr><td width="18%" valign="TOP"><font face="Arial" size=1><p>Pi</font></td><td width="49%" valign="TOP"><font face="Arial" size=1><p>Initial quote marks</font></td><td width="33%" valign="TOP"><font face="Arial" size=1><p>&#145;, ", &#180;</font></td></tr><tr><td width="18%" valign="TOP"><font face="Arial" size=1><p>Pf</font></td><td width="49%" valign="TOP"><font face="Arial" size=1><p>Final quote marks</font></td><td width="33%" valign="TOP"><font face="Arial" size=1><p>&#146;, ", &#170;</font></td></tr><tr><td width="18%" valign="TOP"><font face="Arial" size=1><p>Po</font></td><td width="49%" valign="TOP"><font face="Arial" size=1><p>Other punctuation marks</font></td><td width="33%" valign="TOP"><font face="Arial" size=1><p>!, ?, @, *, &#161;, &#191;, &#183;</font></td></tr><tr><td valign="TOP" colspan=3><b><i><font face="Arial" size=1><p>Separators </b></i></font></td></tr><tr><td width="18%" valign="TOP"><font face="Arial" size=1><p>Z</font></td><td width="49%" valign="TOP"><font face="Arial" size=1><p>All separators</font></td><td width="33%" valign="TOP"><p>&nbsp;</td></tr><tr><td width="18%" valign="TOP"><font face="Arial" size=1><p>Zs</font></td><td width="49%" valign="TOP"><font face="Arial" size=1><p>Space</font></td><td width="33%" valign="TOP"><font face="Arial" size=1><p>Space, nonbreaking space, en space, em space</font></td></tr><tr><td width="18%" valign="TOP"><font face="Arial" size=1><p>Zl</font></td><td width="49%" valign="TOP"><font face="Arial" size=1><p>Line separators</font></td><td width="33%" valign="TOP"><font face="Arial" size=1><p>Unicode character 2028, the line separator</font></td></tr><tr><td width="18%" valign="TOP"><font face="Arial" size=1><p>Zp</font></td><td width="49%" valign="TOP"><font face="Arial" size=1><p>Paragraph separators</font></td><td width="33%" valign="TOP"><font face="Arial" size=1><p>Unicode character 2029, the paragraph separator</font></td></tr><tr><td valign="TOP" colspan=3><b><i><font face="Arial" size=1><p>Symbols</b></i></font></td></tr><tr><td width="18%" valign="TOP"><font face="Arial" size=1><p>S</font></td><td width="49%" valign="TOP"><font face="Arial" size=1><p>All symbols</font></td><td width="33%" valign="TOP"><font face="Arial" size=1><p>∂, ∆, <font face="Symbol">&#112;</font>, $, &#165;, �, ~, &#175;, &#168;, &copy;, &reg;, &#176;, ╟▲, ☺</font></td></tr><tr><td width="18%" valign="TOP"><font face="Arial" size=1><p>Sm</font></td><td width="49%" valign="TOP"><font face="Arial" size=1><p>Mathematical symbols</font></td><td width="33%" valign="TOP"><font face="Arial" size=1><p>∂, ∆, <font face="Symbol">&#112;</font>, ∑, √, ≠, ≤, ≥, ≈</font></td></tr><tr><td width="18%" valign="TOP"><font face="Arial" size=1><p>Sc</font></td><td width="49%" valign="TOP"><font face="Arial" size=1><p>Currency signs</font></td><td width="33%" valign="TOP"><font face="Arial" size=1><p>$, &#165;, �, &#164;, €, ₣, ₤, ₧, ₪, ₫</font></td></tr><tr><td width="18%" valign="TOP"><font face="Arial" size=1><p>Sk</font></td><td width="49%" valign="TOP"><font face="Arial" size=1><p>Modifier symbols</font></td><td width="33%" valign="TOP"><font face="Arial" size=1><p>~, &#175;, &#168;</font></td></tr><tr><td width="18%" valign="TOP"><font face="Arial" size=1><p>So</font></td><td width="49%" valign="TOP"><font face="Arial" size=1><p>Other symbols</font></td><td width="33%" valign="TOP"><p>&copy;, &reg;, &#176;, &#167;, &#182;, ↔, ℅, ℓ,  ╓, ╗,╟▲, ☺, ♀, ♂, ♠, ♪, Braille, Han radicals</td></tr><tr><td valign="TOP" colspan=3><b><i><font face="Arial" size=1><p>Other</b></i></font></td></tr><tr><td width="18%" valign="TOP"><font face="Arial" size=1><p>C</font></td><td width="49%" valign="TOP"><font face="Arial" size=1><p>All others</font></td><td width="33%" valign="TOP"><p>&nbsp;</td></tr><tr><td width="18%" valign="TOP"><font face="Arial" size=1><p>Cc</font></td><td width="49%" valign="TOP"><font face="Arial" size=1><p>Control characters</font></td><td width="33%" valign="TOP"><font face="Arial" size=1><p>Carriage return, linefeed, tab and the C1 controls</font></td></tr><tr><td width="18%" valign="TOP"><font face="Arial" size=1><p>Cf</font></td><td width="49%" valign="TOP"><font face="Arial" size=1><p>Format characters</font></td><td width="33%" valign="TOP"><font face="Arial" size=1><p>The left-to-right and right-to-left marks used to indicate change of direction in bidirectional text</font></td></tr><tr><td width="18%" valign="TOP"><font face="Arial" size=1><p>Co</font></td><td width="49%" valign="TOP"><font face="Arial" size=1><p>Private use characters; code points that may be used for a program's internal purposes</font></td><td width="33%" valign="TOP"><p>&nbsp;</td></tr><tr><td width="18%" valign="TOP"><font face="Arial" size=1><p>Cn</font></td><td width="49%" valign="TOP"><font face="Arial" size=1><p>Unassigned; code points that, while legal in XML, the Unicode specification has not yet assigned a character to</font></td><td width="33%" valign="TOP"><p>&nbsp;</td></tr></table><p>You&#146;re now ready to put together a regular expression that describes money strings such as $1.25. What you want to say is that each such string contains the following:</p><ul>	<li><p>A currency symbol</p></li>	<li><p>One or more decimal digits</p></li>	<li><p>An optional fractional part, which, if present at all, consists of a decimal point and two decimal digits</p></li></ul><p>Here&#146;s the regular expression that says that</p><pre>\p{Sc}\p{Nd}+(\.\p{Nd}\p{Nd})?</pre><p>It begins with <code>\p{Sc}</code> to indicate a currency symbol such as $, @@yen, @@bp, or &euro;.</p><p>This is followed by <code>\p{Nd}+</code>. <code>\p{Nd}</code> represents any decimal digit character. The <code>+</code> indicates one or more of these characters.</p><p>Next there&#146;s a parenthesized expression followed by a question mark, <code>(\.\p{Nd}\p{Nd})?</code>. The question mark indicates the parenthesized expression is optional. However, if it does appear, its entire contents must be present, not just part. In other words, the question mark stands for zero or one, just as it does in DTDs. The contents of the parentheses are <code>\.\p{Nd}\p{Nd}</code>, which represents a period followed by two decimal digits, for example .35. Normally a period in a regular expression means any character at all, so here it&#146;s escaped with a preceding backslash to indicate that we really do want the actual period character.</p><p>Now that you have a regular expression that represents money, you&#146;re ready to define a money type. As for the other facets, this is done with the <code>xsd:simpleType</code> and <code>xsd:restriction</code> elements. Putting these together with the regular expression produces this type definition:</p><pre>&lt;xsd:simpleType name="money"&gt;  &lt;xsd:restriction base="xsd:string"&gt;    &lt;xsd:pattern value="\p{Sc}\p{Nd}+(\.\p{Nd}\p{Nd})?"/&gt;  &lt;/xsd:restriction&gt;&lt;/xsd:simpleType&gt;</pre><p>Listing 20-21 provides the complete song schema, including this type definition. Take special note of the XML comment used to elucidate the regular expression. Regular expressions can be quite opaque, and a comment like this one can go a long way toward making the schema more comprehensible.</p><font face="Arial" size=2><p>Listing 20-21: A Schema That Defines a Custom Money Type</p></font><pre>&lt;?xml version="1.0"?&gt;&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;  &lt;xsd:element name="SONG" type="SongType"/&gt;  &lt;xsd:simpleType name="money"&gt;    &lt;xsd:restriction base="xsd:string"&gt;      &lt;xsd:pattern value="\p{Sc}\p{Nd}+(\.\p{Nd}\p{Nd})?"/&gt;      &lt;!--         Regular Expression:         \p{Sc}            Any Unicode currency indicator;                           e.g., $, &amp;#xA5, &amp;#xA3, &amp;#A4, etc.         \p{Nd}            A Unicode decimal digit character         \p{Nd}+           One or more Unicode decimal digits         \.                The period character         (\.\p{Nd}\p{Nd})         (\.\p{Nd}\p{Nd})? Zero or one strings of the form .35         This works for any decimalized currency.      --&gt;    &lt;/xsd:restriction&gt;  &lt;/xsd:simpleType&gt;  &lt;xsd:complexType name="SongType"&gt;    &lt;xsd:sequence&gt;      &lt;xsd:element name="TITLE"     type="xsd:string"/&gt;      &lt;xsd:element name="COMPOSER"  type="PersonType"                   maxOccurs="unbounded"/&gt;      &lt;xsd:element name="PRODUCER"  type="PersonType"                   minOccurs="0" maxOccurs="unbounded"/&gt;      &lt;xsd:element name="PUBLISHER" type="xsd:string"                   minOccurs="0"/&gt;      &lt;xsd:element name="LENGTH"    type="xsd:duration"/&gt;      &lt;xsd:element name="YEAR"      type="xsd:gYear"/&gt;      &lt;xsd:element name="ARTIST"    type="xsd:string"                   maxOccurs="unbounded"/&gt;      &lt;xsd:element name="PRICE" type="money" maxOccurs="1"/&gt;    &lt;/xsd:sequence&gt;  &lt;/xsd:complexType&gt;  &lt;xsd:complexType name="PersonType"&gt;    &lt;xsd:sequence&gt;      &lt;xsd:element name="NAME"&gt;        &lt;xsd:complexType&gt;          &lt;xsd:all&gt;            &lt;xsd:element name="GIVEN"  type="xsd:string"/&gt;            &lt;xsd:element name="FAMILY" type="xsd:string"/&gt;          &lt;/xsd:all&gt;        &lt;/xsd:complexType&gt;      &lt;/xsd:element&gt;    &lt;/xsd:sequence&gt;  &lt;/xsd:complexType&gt;&lt;/xsd:schema&gt;</pre><h3>Unions</h3><p>Restriction is not the only way to create a new simple type, although it is the most common way. You can also combine types using unions. For example, you could combine the built-in <code>xsd:decimal</code> type with the <code>money</code> type just defined to create a type that could contain either a decimal or a money value. To do this, give the <code>xsd:simpleType</code> element an <code>xsd:union</code> child element instead of an <code>xsd:restriction</code> child element. The <code>xsd:union</code> element contains more <code>xsd:simpleType</code> elements identifying the types you&#146;re combining in the union. For example, this is the previously described <code>money</code>/<code>xsd:decimal</code> combined type:</p><pre>&lt;xsd:simpleType name="MoneyOrDecimal"&gt;  &lt;xsd:union&gt;    &lt;xsd:simpleType&gt;      &lt;xsd:restriction base="xsd:decimal"&gt;      &lt;/xsd:restriction&gt;    &lt;/xsd:simpleType&gt;    &lt;xsd:simpleType&gt;      &lt;xsd:restriction base="xsd:string"&gt;        &lt;xsd:pattern value="\p{Sc}\p{Nd}+(\.\p{Nd}\p{Nd})?"/&gt;      &lt;/xsd:restriction&gt;    &lt;/xsd:simpleType&gt;  &lt;/xsd:union&gt;&lt;/xsd:simpleType&gt;</pre><h3>Lists</h3><p>Schemas can also specify that an element or attribute contains a list of a particular simple type. For example, this <code>YEARS</code> element contains a list of years:</p><pre>&lt;YEARS&gt;1987 1999 1992   2002&lt;/YEARS&gt;</pre><p>Elements such as this can be specified using an <code>xsd:list</code> in the <code>xsd:simpleType</code>. The <code>itemType</code> attribute says what type of strings may appear in the list, as in the following example:</p><pre>&lt;xsd:simpleType name="YearList"&gt;  &lt;xsd:list itemType="xsd:gYear"/&gt;&lt;/xsd:simpleType&gt;</pre><p>This requires that elements with type <code>YearList</code> contain a white space-separated list of legal <code>xsd:gYear</code> values.</p><dir><b><font face="Arial" size=1 color="#000080"><p>Caution</p></b></font><p>I must admit that I&#146;m not very fond of list types, especially for elements. It seems to me that if you&#146;re going to have a list of different items, each of those items should be a separate element, possibly a child element of some parent element, but still its own element. Lists make a little more sense for attributes, but if there&#146;s a lot of substructure in the text, you should probably be using an element instead of an attribute anyway.</p></dir><p>You can derive another list type from an existing list type. When so doing, you can restrict it according to the <code>length</code>, <code>minLength</code>, <code>maxLength</code>, and <code>enumeration</code> facets. In this case, the values of the three length facets refer to the number of items in the list rather than the number of characters in the content. For example, this <code>xsd:simpleType</code> element derives a <code>DoubleYear</code> list type that must hold exactly two years from the <code>YearList</code> type previously defined:</p><pre>&lt;xsd:simpleType name="DoubleYear"&gt;  &lt;xsd:restriction base="YearList"&gt;    &lt;xsd:length value="2"/&gt;  &lt;/xsd:restriction&gt;&lt;/xsd:simpleType&gt;</pre><h2>Empty Elements</h2><p>Empty elements are those that cannot contain any child elements or parsed character data. This is the same as using the <code>EMPTY</code> content model in a DTD. As an example of this technique, I&#146;ll define an empty <code>PHOTO</code> element. This will be used in the next section when attributes are introduced.</p><p>To create an empty element, you define it as a type but don&#146;t give it an <code>xsd:sequence</code>, <code>xsd:all</code>, or <code>xsd:choice</code> child. Thus, you don&#146;t actually provide any child elements. For example:</p><pre>  &lt;!-- An empty element --&gt;  &lt;xsd:complexType name="PhotoType"&gt;  &lt;/xsd:complexType&gt;</pre><dir><b><font face="Arial" size=1 color="#000080"><p>Caution</p></b></font><p>This does not require the <code>PHOTO</code> element to be defined with an empty-element tag such as <code>&lt;PHOTO/&gt;</code>. The start-tag-end-tag pair <code>&lt;PHOTO&gt;&lt;/PHOTO&gt;</code> is also acceptable. In fact, the XML 1.0 specification says these two forms are equivalent. Schemas change nothing about XML 1.0. An XML 1.0 parser that knows nothing about schemas will have no trouble reading a document that uses schemas.</p></dir><h2>Attributes</h2><p>In the examples so far, two XML constructs have been conspicuous by their absence: entities and attributes. The omission of entities was quite deliberate. Schemas cannot declare entities. If you need entities, you must use a DTD. (Of course, you can use a schema as well as the DTD.) However, schemas are fully capable of declaring attributes. Indeed, they do a much better job of it than DTDs do because schemas can use the full set of data types like <code>xsd:float</code> and <code>xsd:anyURI</code>.</p><dir><h4>Note</h4>You may not have noticed my avoidance of attributes, because the examples all used <code>xmlns:xsi</code> and <code>xsi:noNamespaceSchemaLocation</code> attributes on the root element. However, as far as a schema validator is concerned, attributes used to declare namespaces, or to attach documents to schemas, "don't count." You do not have to, and indeed should not, declare these attributes. However, you do have to declare all the other attributes you use.</p></dir><p>As a concrete example, let&#146;s consider how you might add an empty <code>PHOTO</code> element to the <code>SONG</code> documents. This element would be similar to the <code>IMG</code> element in HTML and would have an <code>SRC</code> attribute that contained a URL pointing to the photo&#146;s location, an <code>ALT</code> attribute containing some text in the event that the <code>PHOTO</code> can&#146;t be displayed, and <code>WIDTH</code> and <code>HEIGHT</code> attributes that together give the size of the image in pixels. Listing 20-22 demonstrates.</p><font face="Arial" size=2><p>Listing 20-22: The PHOTO Element Has Several Attributes of Different Types</p></font><pre>&lt;?xml version="1.0"?&gt;&lt;SONG xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"      xsi:noNamespaceSchemaLocation="20-23.xsd"&gt;  &lt;TITLE&gt;Yes I Am&lt;/TITLE&gt;  &lt;PHOTO ALT="Melissa Etheridge holding a guitar"         WIDTH="100" HEIGHT="300"         SRC="guitar.jpg"/&gt;  &lt;COMPOSER&gt;    &lt;NAME&gt;      &lt;GIVEN&gt;Melissa&lt;/GIVEN&gt;      &lt;FAMILY&gt;Etheridge&lt;/FAMILY&gt;    &lt;/NAME&gt;  &lt;/COMPOSER&gt;  &lt;PRODUCER&gt;    &lt;NAME&gt;      &lt;GIVEN&gt;Hugh&lt;/GIVEN&gt;      &lt;FAMILY&gt;Padgham&lt;/FAMILY&gt;    &lt;/NAME&gt;  &lt;/PRODUCER&gt;  &lt;PRODUCER&gt;    &lt;NAME&gt;      &lt;GIVEN&gt;Melissa&lt;/GIVEN&gt;      &lt;FAMILY&gt;Etheridge&lt;/FAMILY&gt;    &lt;/NAME&gt;  &lt;/PRODUCER&gt;  &lt;PUBLISHER&gt;Island Records&lt;/PUBLISHER&gt;  &lt;LENGTH&gt;P0YT4M24S&lt;/LENGTH&gt;  &lt;YEAR&gt;1993&lt;/YEAR&gt;  &lt;ARTIST&gt;Melissa Etheridge&lt;/ARTIST&gt;  &lt;PRICE&gt;$1.25&lt;/PRICE&gt;&lt;/SONG&gt;</pre><p>Even though the <code>PHOTO</code> element is empty, because it has attributes, it has a complex type. You define a <code>PhotoType</code> just as you previously defined a <code>PersonType</code> and a <code>SongType</code>. However, where those types used <code>xsd:element</code> to declare child elements, this type will use <code>xsd:attribute</code> to declare attributes.</p><pre>  &lt;xsd:complexType name="PhotoType"&gt;    &lt;xsd:attribute name="SRC"    type="xsd:anyURI"/&gt;    &lt;xsd:attribute name="WIDTH"  type="xsd:positiveInteger"/&gt;    &lt;xsd:attribute name="HEIGHT" type="xsd:positiveInteger"/&gt;    &lt;xsd:attribute name="ALT"    type="xsd:string"/&gt;  &lt;/xsd:complexType&gt;</pre><p>Because the <code>SRC</code> attribute should contain a URL, it&#146;s been given the type <code>xsd:anyURI</code>. Because the <code>HEIGHT</code> and <code>WIDTH</code> attributes should each be an integer greater than zero, they&#146;re given the type <code>xsd:positiveInteger</code>. Finally, because the <code>ALT</code> attribute can contain essentially any string of text of any length, it&#146;s set to the most general type, <code>xsd:string</code>.</p><p>In this particular example, all the elements either have child elements or attributes, not both. However, that&#146;s certainly not required. In general, elements can have both child elements and attributes. Just use both <code>xsd:element</code> and <code>xsd:attribute</code> in the same <code>xsd:complexType</code> element. The <code>xsd:attribute</code> elements must come after the <code>xsd:sequence</code>, <code>xsd:choice</code>, or <code>xsd:all</code> group that forms the body of the element. For example, this <code>xsd:element</code> says that a <code>PERSON</code> element can have an optional attribute named <code>ID</code> with type ID:</p><pre>  &lt;xsd:complexType name="PersonType"&gt;    &lt;xsd:sequence&gt;      &lt;xsd:element name="NAME"&gt;        &lt;xsd:complexType&gt;          &lt;xsd:all&gt;            &lt;xsd:element name="GIVEN"  type="xsd:string"/&gt;            &lt;xsd:element name="FAMILY" type="xsd:string"/&gt;          &lt;/xsd:all&gt;        &lt;/xsd:complexType&gt;      &lt;/xsd:element&gt;    &lt;/xsd:sequence&gt;    &lt;xsd:attribute name="ID" type="xsd:ID"/&gt;  &lt;/xsd:complexType&gt;</pre><p>Attributes can also be attached to elements that can only contain text such as an <code>xsd:string</code> or an <code>xsd:gYear</code>. The details are a little more complex, because an element with attributes by definition has a complex type. To make this work, you derive a new complex type from a simple type by giving the <code>xsd:complexType</code> element an <code>xsd:simpleContent</code> child element instead of an <code>xsd:sequence</code>, <code>xsd:choice</code>, or <code>xsd:all</code>. The <code>xsd:simpleContent</code> element itself has an <code>xsd:extension</code> child element whose <code>base</code> attribute identifies the simple type to extend such as <code>xsd:string</code>. The <code>xsd:attribute</code> elements are placed inside the <code>xsd:extension</code> element.</p><p>For example, suppose you want to allow the <code>TITLE</code> elements to have <code>ID</code> attributes, like this:</p><pre>&lt;TITLE ID="test"&gt;Yes I Am&lt;/TITLE&gt;</pre><p>Previously, <code>TITLE</code> was defined with type <code>xsd:string</code>. Instead, let&#146;s derive a new type called <code>StringWithID</code> from <code>xsd:string</code>, like this:</p><pre>&lt;xsd:complexType name="StringWithID"&gt;  &lt;xsd:simpleContent&gt;    &lt;xsd:extension base="xsd:string"&gt;      &lt;xsd:attribute name="ID" type="xsd:ID"/&gt;    &lt;/xsd:extension&gt;  &lt;/xsd:simpleContent&gt;&lt;/xsd:complexType&gt;</pre><p>The <code>StringWithID</code> type can then be applied to the <code>TITLE</code> element in the usual way, like this:</p><pre>&lt;xsd:element name="TITLE" type="StringWithID"/&gt;</pre><p>By default, attributes declared in schemas are optional (<code>#IMPLIED</code> in DTD terminology). However, an <code>xsd:attribute</code> can have a <code>use</code> attribute with the value <code>required</code> to indicate that the element must occur. In this case, you probably do want to insist that each of the four attributes be present. Therefore, the declaration of <code>PhotoType</code> becomes this:</p><pre>  &lt;xsd:complexType name="PhotoType"&gt;    &lt;xsd:attribute name="SRC"    type="xsd:anyURI"                   use="required" /&gt;    &lt;xsd:attribute name="WIDTH"  type="xsd:positiveInteger"                   use="required" /&gt;    &lt;xsd:attribute name="HEIGHT" type="xsd:positiveInteger"                   use="required" /&gt;    &lt;xsd:attribute name="ALT"    type="xsd:string"                   use="required" /&gt;  &lt;/xsd:complexType&gt;</pre><p>The <code>use</code> attribute can also have the value <code>optional</code> to indicate that it may or may not be present. (This is also the default if there is no <code>use</code> attribute.) If <code>optional</code>, <code>xsd:attribute</code> may also have a <code>default</code> attribute giving the value the parser will provide if it doesn&#146;t find one in the instance document. If there is no default attribute, this is the same as <code>#IMPLIED</code> in <code>ATTLIST</code> declarations in DTDs. Instead of a <code>use</code> attribute, <code>xsd:attribute</code> can have a <code>fixed</code> attribute whose value is the constant value for the attribute, whether present in the instance document or not. This has the same effect as <code>#FIXED</code> in DTDs. Listing 20-23 puts this all together in a complete schema for songs, including a <code>PHOTO</code> element with several required attributes.</p></font><font face="Arial" size=2><p>Listing 20-23: A SONG Schema That Declares Attributes</p></font><pre>&lt;?xml version="1.0"?&gt;&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;  &lt;xsd:element name="SONG" type="SongType"/&gt;  &lt;xsd:complexType name="PhotoType"&gt;    &lt;xsd:attribute name="SRC"    type="xsd:anyURI"                   use="required" /&gt;    &lt;xsd:attribute name="WIDTH"  type="xsd:positiveInteger"                   use="required" /&gt;    &lt;xsd:attribute name="HEIGHT" type="xsd:positiveInteger"                   use="required" /&gt;    &lt;xsd:attribute name="ALT"    type="xsd:string"                   use="required" /&gt;  &lt;/xsd:complexType&gt;  &lt;xsd:complexType name="SongType"&gt;    &lt;xsd:sequence&gt;      &lt;xsd:element name="TITLE"     type="xsd:string"/&gt;      &lt;xsd:element name="PHOTO"     type="PhotoType"/&gt;      &lt;xsd:element name="COMPOSER"  type="PersonType"                   maxOccurs="unbounded"/&gt;      &lt;xsd:element name="PRODUCER"  type="PersonType"                   minOccurs="0" maxOccurs="unbounded"/&gt;      &lt;xsd:element name="PUBLISHER" type="xsd:string"                   minOccurs="0"/&gt;      &lt;xsd:element name="LENGTH"    type="xsd:duration"/&gt;      &lt;xsd:element name="YEAR"      type="xsd:gYear"/&gt;      &lt;xsd:element name="ARTIST"    type="xsd:string"                   maxOccurs="unbounded"/&gt;      &lt;xsd:element name="PRICE" type="money"/&gt;    &lt;/xsd:sequence&gt;  &lt;/xsd:complexType&gt;  &lt;xsd:simpleType name="money"&gt;    &lt;xsd:restriction base="xsd:string"&gt;      &lt;xsd:pattern value="\p{Sc}\p{Nd}+(\.\p{Nd}\p{Nd})?"/&gt;      &lt;!--         Regular Expression:         \p{Sc}            Any Unicode currency indicator;                           e.g., $, &amp;#xA5, &amp;#xA3, &amp;#A4, etc.         \p{Nd}            A Unicode decimal digit character         \p{Nd}+           One or more Unicode decimal digits         \.                The period character         (\.\p{Nd}\p{Nd})         (\.\p{Nd}\p{Nd})?  Zero or one strings of the form .35         This works for any decimalized currency.      --&gt;    &lt;/xsd:restriction&gt;  &lt;/xsd:simpleType&gt;  &lt;xsd:complexType name="PersonType"&gt;    &lt;xsd:sequence&gt;      &lt;xsd:element name="NAME"&gt;        &lt;xsd:complexType&gt;          &lt;xsd:all&gt;            &lt;xsd:element name="GIVEN"  type="xsd:string"/&gt;            &lt;xsd:element name="FAMILY" type="xsd:string"/&gt;          &lt;/xsd:all&gt;        &lt;/xsd:complexType&gt;      &lt;/xsd:element&gt;    &lt;/xsd:sequence&gt;  &lt;/xsd:complexType&gt;&lt;/xsd:schema&gt;</pre><h2>Namespaces</h2><p>So far, the example song documents have been blissfully namespace-free. Adding namespaces to the documents and designing a schema that applies to the namespace-qualified documents is not particularly difficult. Namespaces add some important features, such as the ability to write schemas and validate documents that use elements and attributes from multiple XML applications. However, the terminology is a little confusing. Some words, such as <i>qualified</i>, don&#146;t mean quite the same thing in schemas as they do in other XML technologies, so you do need to pay close attention and read what follows carefully.</p><h3>Schemas for default namespaces</h3></code><p>Let&#146;s begin with a simple example in which the XML application described by the schema uses a single default, nonprefixed namespace. Most of the time each namespace URI maps to exactly one schema (though later you&#146;ll learn several techniques to break large schemas into parts using <code>xsd:import</code> and <code>xsd:include</code>).</p><p>The schema for elements that are not in any namespace is identified by an <code>xsi:noNamespaceSchemaLocation</code> attribute. The schemas for elements that are in namespaces are identified by an <code>xsi:schemaLocation</code> attribute. This attribute contains a list of namespace URI/schema URI pairs. Each namespace URI is followed by one schema URI. The namespace URI is almost always absolute, but the schema URI is almost always a URL and often a relative URL.</p><p>Listing 20-24 demonstrates. This is the familiar hotcop.xml document that you&#146;ve seen several times already, though it&#146;s been simplified a bit to keep the examples smaller. All the elements in this document are in the <code>http://ns.cafeconleche.org/song</code> namespace defined by the <code>xmlns</code> attribute on the root element. The attributes in this document are not in any namespace because they don&#146;t have prefixes. There are two things you need to remember here:</p><p>Attributes without prefixes are never in any namespace, no matter what namespace their parent element is in, and no matter what default namespace the document uses.</p><p>For purposes of schema validation, namespace declaration attributes, such as <code>xmlns</code> and <code>xmlns:xsi</code>, and schema attachment attributes, such as <code>xsi:schemaLocation</code>, don&#146;t count. You do not need to declare these in your schema.</p><p>In this case, all the elements are in the <code>http://ns.cafeconleche.org/song</code> namespace, so an <code>xsi:schemaLocation</code> attribute is needed to associate this namespace with a URL where the schema can be found, <code>namespace_song.xsd</code> for this example.</p></font><font face="Arial" size=2><p>Listing 20-24: A SONG Document in the http://ns.cafeconleche.org/song Namespace</p></font><pre>&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;&lt;SONG xmlns="http://ns.cafeconleche.org/song"      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"      xsi:schemaLocation =       "http://ns.cafeconleche.org/song        namespace_song.xsd"&gt;  &lt;TITLE&gt;Hot Cop&lt;/TITLE&gt;  &lt;!-- I've temporarily dropped the SRC attribute on this       element. I'm going to replace it with XLinks shortly.    --&gt;  &lt;PHOTO ALT="Victor Willis in Cop Outfit" WIDTH="100"         HEIGHT="200"/&gt;  &lt;COMPOSER&gt;Jacques Morali&lt;/COMPOSER&gt;  &lt;COMPOSER&gt;Henri Belolo&lt;/COMPOSER&gt;  &lt;COMPOSER&gt;Victor Willis&lt;/COMPOSER&gt;  &lt;PRODUCER&gt;Jacques Morali&lt;/PRODUCER&gt;  &lt;PUBLISHER&gt;PolyGram Records&lt;/PUBLISHER&gt;  &lt;LENGTH&gt;P0YT6M20S&lt;/LENGTH&gt;  &lt;YEAR&gt;1978&lt;/YEAR&gt;  &lt;ARTIST&gt;Village People&lt;/ARTIST&gt;&lt;/SONG&gt;</pre><p>What does namespace_song.xsd look like? Listing 20-25 shows you. It&#146;s much the same schema as before, although I&#146;ve dropped the <code>MoneyType</code> and <code>PersonType</code> to save a little room.</p></font><font face="Arial" size=2><p>Listing 20-25: A Schema for SONG Documents in the http://ns.cafeconleche.org/song Namespace</p></font><pre>&lt;?xml version="1.0"?&gt;&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"  xmlns="http://ns.cafeconleche.org/song"  targetNamespace="http://ns.cafeconleche.org/song"  elementFormDefault="qualified"  attributeFormDefault="unqualified"&gt;  &lt;xsd:element name="SONG" type="SongType"/&gt;  &lt;xsd:complexType name="PhotoType"&gt;    &lt;xsd:attribute name="WIDTH"  type="xsd:positiveInteger"                   use="required" /&gt;    &lt;xsd:attribute name="HEIGHT" type="xsd:positiveInteger"                   use="required" /&gt;    &lt;xsd:attribute name="ALT"    type="xsd:string"                   use="required" /&gt;  &lt;/xsd:complexType&gt;  &lt;xsd:complexType name="SongType"&gt;    &lt;xsd:sequence&gt;      &lt;xsd:element name="TITLE"     type="xsd:string"/&gt;      &lt;xsd:element name="PHOTO"     type="PhotoType"/&gt;      &lt;xsd:element name="COMPOSER"  type="xsd:string"                   maxOccurs="unbounded"/&gt;      &lt;xsd:element name="PRODUCER"  type="xsd:string"                   minOccurs="0" maxOccurs="unbounded"/&gt;      &lt;xsd:element name="PUBLISHER" type="xsd:string"                   minOccurs="0"/&gt;      &lt;xsd:element name="LENGTH"    type="xsd:duration"/&gt;      &lt;xsd:element name="YEAR"      type="xsd:gYear"/&gt;      &lt;xsd:element name="ARTIST"    type="xsd:string"                   maxOccurs="unbounded"/&gt;    &lt;/xsd:sequence&gt;  &lt;/xsd:complexType&gt;&lt;/xsd:schema&gt;</pre><p>The main body of the schema is much the same as before. However, the <code>xsd:schema</code> start-tag has several new attributes. It looks like this:</p><pre>&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"  xmlns="http://ns.cafeconleche.org/song"  targetNamespace="http://ns.cafeconleche.org/song"  elementFormDefault="qualified"  attributeFormDefault="unqualified"&gt;</pre><p>The first <code>xmlns</code> attribute establishes the default namespace for this schema, which is, after all, an XML document itself. It sets the namespace to <code>http://ns.cafeconleche.org/song</code>, the same as in the instance documents you&#146;re trying to model. This says that the unprefixed element names used in this schema such as <code>PhotoType</code> are in the <code>http://ns.cafeconleche.org/song</code> namespace.</p><p>The second attribute says that this schema applies to documents in the <code>http://ns.cafeconleche.org/song</code> namespace; that is, the elements identified by <code>name</code> attributes such as <code>SONG</code>, <code>PHOTO</code>, and <code>TITLE</code> are in the <code>http://ns.cafeconleche.org/song</code> namespace.</p><p>The third attribute, <code>elementFormDefault</code>, has the value <code>qualified</code>. This means that the elements being described in this document are in fact in a namespace; specifically, they&#146;re in the target namespace given by the <code>targetNamespace</code> attribute. This does not mean that the elements being modeled necessarily have prefixes, merely that they are in some namespace.</p><p>Finally, the fourth attribute, <code>attributeFormDefault</code>, has the value <code>unqualified</code>. This means that the attributes described by this schema are not in a namespace.</p><p>Schemas have one major advantage over DTDs when you are working with documents with namespaces. They validate against the local name and the namespace URIs of the elements and attributes, not the prefix and the local name like DTDs do. This means the prefixes do not have to match in the schema and in the instance documents. Indeed, one might use prefixes and the other might use the default namespace.</p><p>For example, consider Listing 20-26. This is the same as Listing 20-24 except that it uses the <code>song</code> prefix rather than the default namespace to indicate the <code>http://ns.cafeconleche.org/song</code> namespace. However, it can use the <i>exact same schema</i>! The schema does not need to change just because the prefix (or lack thereof) has changed. As long as the namespace URI stays the same, the schema is happy.</p></font><font face="Arial" size=2><p>Listing 20-26: A SONG Document in the http://ns.cafeconleche.org/song Namespace with Prefixes</p></font><pre>&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;&lt;song:SONG      xmlns:song="http://ns.cafeconleche.org/song"      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"      xsi:schemaLocation =       "http://ns.cafeconleche.org/song        namespace_song.xsd"&gt;  &lt;song:TITLE&gt;Hot Cop&lt;/song:TITLE&gt;  &lt;!-- I've temporarily dropped the SRC attribute on this       element. I'm going to replace it with XLinks shortly.    --&gt;  &lt;song:PHOTO ALT="Victor Willis in Cop Outfit" WIDTH="100"         HEIGHT="200"/&gt;  &lt;song:COMPOSER&gt;Jacques Morali&lt;/song:COMPOSER&gt;  &lt;song:COMPOSER&gt;Henri Belolo&lt;/song:COMPOSER&gt;  &lt;song:COMPOSER&gt;Victor Willis&lt;/song:COMPOSER&gt;  &lt;song:PRODUCER&gt;Jacques Morali&lt;/song:PRODUCER&gt;  &lt;song:PUBLISHER&gt;PolyGram Records&lt;/song:PUBLISHER&gt;  &lt;song:LENGTH&gt;P0YT6M20S&lt;/song:LENGTH&gt;  &lt;song:YEAR&gt;1978&lt;/song:YEAR&gt;  &lt;song:ARTIST&gt;Village People&lt;/song:ARTIST&gt;&lt;/song:SONG&gt;</pre><h3>Multiple namespaces, multiple schemas</h3></code><p>Now, consider the case in which one document mixes markup from different vocabularies. In particular, suppose that you want to use XLink to connect the <code>PHOTO</code> element to the actual JPEG image rather than application-specific markup such as <code>SRC</code>. You need to set <code>xlink:type</code>, <code>xlink:href</code>, <code>xlink:show</code>, and <code>xlink:actuate</code> attributes on the <code>PHOTO</code> element to give it the proper meaning and behavior, like this:</p><pre>&lt;PHOTO xlink:type="simple" xlink:href="hotcop.jpg"       xlink:show="embed"  xlink:actuate="onLoad"       ALT="Victor Willis in Cop Outfit"       WIDTH="100" HEIGHT="200"/&gt;</pre><b><font face="Arial" size=1 color="#000080"><p>Cross-Reference</p></b></font><p>XLinks are discussed in Chapter 17.</p><p>Now the document uses two main namespaces, the <code>http://ns.cafeconleche.org/song</code> namespace for songs and the <code>http://www.w3.org/1999/xlink</code> namespace for XLinks. Thus, it needs two schemas. However, because the root element can have only one <code>xsi:schemaLocation</code> attribute, it has to serve double duty and declare both. Listing 20-27 demonstrates.</p><font face="Arial" size=2><p>Listing 20-27: A SONG Document That Uses XLink to Embed Photos</p></font><pre>&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;&lt;SONG xmlns="http://ns.cafeconleche.org/song"      xmlns:xlink="http://www.w3.org/1999/xlink"      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"      xsi:schemaLocation =      "http://ns.cafeconleche.org/song 20-29.xsd       http://www.w3.org/1999/xlink xlink.xsd"&gt;  &lt;TITLE&gt;Hot Cop&lt;/TITLE&gt;  &lt;PHOTO xlink:type="simple" xlink:href="hotcop.jpg"         xlink:show="embed"  xlink:actuate="onLoad"         ALT="Victor Willis in Cop Outfit"         WIDTH="100" HEIGHT="200"/&gt;  &lt;COMPOSER&gt;Jacques Morali&lt;/COMPOSER&gt;  &lt;COMPOSER&gt;Henri Belolo&lt;/COMPOSER&gt;  &lt;COMPOSER&gt;Victor Willis&lt;/COMPOSER&gt;  &lt;PRODUCER&gt;Jacques Morali&lt;/PRODUCER&gt;  &lt;PUBLISHER&gt;PolyGram Records&lt;/PUBLISHER&gt;  &lt;LENGTH&gt;P0YT6M20S&lt;/LENGTH&gt;  &lt;YEAR&gt;1978&lt;/YEAR&gt;  &lt;ARTIST&gt;Village People&lt;/ARTIST&gt;&lt;/SONG&gt;</pre><p>Listing 20-28 shows the XLink schema. It only declares attributes, no elements at all. You haven&#146;t seen an example of this yet, but it&#146;s not hard. Just use <code>xsd:attribute</code> elements at the top level, that is, as direct children of the <code>xsd:schema</code> element. The other difference between these top-level <code>xsd:attribute</code> elements and the ones you&#146;ve seen before is that three of the attributes have fixed values and don&#146;t even need to be explicitly included in the instance document. Only the <code>xlink:href</code> attribute asks the author to supply a value. However, this is rather specific to this particular use of XLink. Almost anything else you&#146;d do with an XLink other than embedding an image or other non-XML content into the document would require a different schema that used different defaults.</p><font face="Arial" size=2><p>Listing 20-28: xlink.xsd: An XLink Schema</p></font><pre>&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"  xmlns="http://www.w3.org/1999/xlink"  targetNamespace="http://www.w3.org/1999/xlink"  attributeFormDefault="unqualified"&gt;  &lt;xsd:attribute name="type"    type="xsd:string"                 fixed="simple"/&gt;  &lt;xsd:attribute name="href"    type="xsd:anyURI"/&gt;  &lt;xsd:attribute name="actuate" type="xsd:string"                 fixed="onLoad"/&gt;  &lt;xsd:attribute name="show"    type="xsd:string"                 fixed="embed"/&gt;&lt;/xsd:schema&gt;</pre><p>This schema doesn&#146;t actually apply these attributes to any elements. Therefore, the schema that does describe the <code>PHOTO</code> element needs to import xlink.xsd in order to reference these declarations. This is done with an <code>xsd:import</code> element. The <code>xsd:import</code>'s <code>schemaLocation</code> attribute tells the processor where to find the schema to import. The <code>namespace</code> attribute says which elements and attributes the schema declares. After this schema has been imported, you can add those attributes to any <code>xsd:complexType</code> by giving it an <code>xsd:attribute</code> child whose <code>ref</code> attribute identifies the attribute to be attached. Listing 20-29 demonstrates.</p><font face="Arial" size=2><p>Listing 20-29: A SONG Schema That Imports the XLink Schema</p></font><pre>&lt;?xml version="1.0"?&gt;&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"  xmlns="http://ns.cafeconleche.org/song"  xmlns:xlink="http://www.w3.org/1999/xlink"  targetNamespace="http://ns.cafeconleche.org/song"  elementFormDefault="qualified"  attributeFormDefault="unqualified"&gt;  &lt;xsd:import namespace="http://www.w3.org/1999/xlink"              schemaLocation="xlink.xsd"/&gt;  &lt;xsd:element name="SONG" type="SongType"/&gt;  &lt;xsd:complexType name="PhotoType"&gt;    &lt;xsd:attribute name="WIDTH"  type="xsd:positiveInteger"                   use="required" /&gt;    &lt;xsd:attribute name="HEIGHT" type="xsd:positiveInteger"                   use="required" /&gt;    &lt;xsd:attribute name="ALT"    type="xsd:string"                   use="required" /&gt;    &lt;xsd:attribute ref="xlink:type"/&gt;    &lt;xsd:attribute ref="xlink:href" use="required"/&gt;    &lt;xsd:attribute ref="xlink:actuate"/&gt;    &lt;xsd:attribute ref="xlink:show"/&gt;  &lt;/xsd:complexType&gt;  &lt;xsd:complexType name="SongType"&gt;    &lt;xsd:sequence&gt;      &lt;xsd:element name="TITLE"     type="xsd:string"/&gt;      &lt;xsd:element name="PHOTO"     type="PhotoType"/&gt;      &lt;xsd:element name="COMPOSER"  type="xsd:string"                   maxOccurs="unbounded"/&gt;      &lt;xsd:element name="PRODUCER"  type="xsd:string"                   minOccurs="0" maxOccurs="unbounded"/&gt;      &lt;xsd:element name="PUBLISHER" type="xsd:string"                   minOccurs="0"/&gt;      &lt;xsd:element name="LENGTH"    type="xsd:duration"/&gt;      &lt;xsd:element name="YEAR"      type="xsd:gYear"/&gt;      &lt;xsd:element name="ARTIST"    type="xsd:string"                   maxOccurs="unbounded"/&gt;    &lt;/xsd:sequence&gt;  &lt;/xsd:complexType&gt;&lt;/xsd:schema&gt;</pre><h2>Annotations</h2><p>At some point in this chapter, it&#146;s likely to have occurred to you that schemas can get rather large and complex. If that hasn&#146;t occurred to you yet, just imagine a schema not for the very small and simple song documents demonstrated in this chapter, but for much larger XML applications such as Scalable Vector Graphics or XHTML.</p><p>You can certainly use regular XML comments to describe schemas, and I encourage you to do so, especially when you&#146;re doing something less than obvious in the schema. The W3C XML Schema Language also provides a more formal mechanism for annotating schemas. Both the top-level <code>xsd:schema</code> element itself and the various other schema elements (<code>xsd:complexType</code>, <code>xsd:all</code>, <code>xsd:element</code>, <code>xsd:attribute</code>, and so on) can contain <code>xsd:annotation</code> child elements that describe that part of the schema for human readers or for other computer programs. This element has two kinds of child elements:</p><ul>	<li><p>The <code>xsd:documentation</code> child element describes the schema for human readers. It often contains copyright and similar information.</p></li>	<li><p>The <code>xsd:appInfo</code> child element describes the schema for computer programs. For example, it might contain instructions about what style sheets to apply to the schema.</p></li></ul><p>Each <code>xsd:annotation</code> element can contain any number of either of these. However, no special syntax has been defined for the content of these elements. You can put anything in there you find convenient, including other XML markup, subject only to the usual well-formedness constraints. Thus, an <code>xsd:documentation</code> element might contain XHTML, and an <code>xsd:appInfo</code> element might contain XSLT. Then again, either or both might simply contain plain, unmarked-up text. For example, this annotation could be added to the song schemas developed in this chapter:</p><pre>  &lt;xsd:annotation&gt;   &lt;xsd:documentation&gt;    Song schema for Chapter 20 of the XML Bible, 3rd Edition    Copyright 2004 Elliotte Rusty Harold.    elharo@metalab.unc.edu   &lt;/xsd:documentation&gt;  &lt;/xsd:annotation&gt;</pre><h2>Summary</h2></code><p>In this chapter, you learned the following:</p><ul><li>Schemas address a number of perceived limitations of DTDs, including a strange, non-XML syntax, namespace incompatibility, lack of data typing, and limited extensibility and scalability.</li><li>There are multiple XML schema languages, including RELAX NG and the W3C XML Schema Language (described in this chapter).</li><li>An XML document can indicate the schema that applies to its non-namespace-qualified elements via an <code>xsi:noNamespaceSchemaLocation</code> attribute, which is normally placed on the root element.</li><li>An XML document can indicate the schema that applies to its namespace qualified elements via an <code>xsi:schemaLocation</code> attribute, which is normally placed on the root element.</li><li>Schemas declare elements with <code>xsd:element</code> elements.</li><li>The <code>type</code> attribute of <code>xsd:element</code> specifies the data type of that element.</li><li>Elements with complex types can have attributes and child elements.</li><li>Elements with simple types only contain character data.</li><li>The <code>xsd:complexType</code> element defines a new type for an element that can contain child elements, attributes, and/or mixed content.</li><li>The <code>xsd:group</code>, <code>xsd:all</code>, <code>xsd:choice</code>, and <code>xsd:sequence</code> elements let you specify particular combinations of elements in an element&#146;s content model.</li><li>The <code>minOccurs</code> and <code>maxOccurs</code> attributes of <code>xsd:element</code> determine how many of a given element are allowed in the instance document at that point. The default for each is 1. <code>maxOccurs</code> can be set to <code>unbounded</code> to indicate that any number of the element may appear.</li><li>There are 44 built-in simple types, including many numeric, string, time, binary, URI, and XML types.</li><li>The <code>xsd:simpleType</code> element defines a new type for an element or attribute that can only contain character data.</li><li>You can define your own simple types by restricting an existing type such as <code>xsd:string</code> with the <code>xsd:restriction</code> element. The <code>base</code> attribute of the <code>xsd:restriction</code> child specifies what type you&#146;re deriving from.</li><li>Each <code>xsd:restriction</code> element contains one or more child elements representing facets: <code>xsd:minInclusive</code>, <code>xsd:minExclusive</code>, <code>xsd:maxInclusive</code>, <code>xsd:maxExclusive</code>, <code>xsd:enumeration</code>, <code>xsd:whiteSpace</code>, <code>xsd:pattern</code>, <code>xsd:length</code>, <code>xsd:minLength</code>, <code>xsd:maxLength, xsd:totalDigits</code>, and/or <code>xsd:fractionDigits</code>.</li><li>An <code>xsd:simpleType</code> element can create a new type by unifying the value spaces of existing types. Each existing type combined into the new type is identified by an <code>xsd:union</code> child element.</li><li>A list type can hold one or more white-space-separated instances of an existing type. Such a type is defined by the <code>xsd:list</code> child of an <code>xsd:simpleType</code> element.</li><li>Schemas declare attributes with <code>xsd:attribute</code> elements.</li><li>The <code>xsd:import</code> element imports declarations for elements and attributes in a different namespace from another schema document.</li><li>The <code>xsd:include</code> element imports declarations for elements and attributes in the same namespace from another schema document.</li><li>Adding <code>xsd:annotation</code> elements helps make your schemas more readable.</li><li>The <code>xsd:documentation</code> child of an <code>xsd:annotation</code> element provides information for human readers.</li><li>The <code>xsd:appInfo</code> child of an <code>xsd:annotation</code> element provides information for software programs reading the schema, though schema validators ignore it.</li></ul><p>This completes your training in core XML technologies. The next part begins several case studies of different XML applications in different vertical domains. First out the gate is the Extensible Hypertext Markup Language (XHTML). XHTML 1.0 is an XMLized form of HTML. XHTML 1.1 is a modularized form of XHTML 1.0 that can be mixed with other XML applications.</p>     <hr />From XML 1.1 Bible, by Elliotte Rusty Harold. &copy; 2004 byWiley Publishing, Inc.  All rights reserved.  Reproduced here by permissionof the publisher.      <hr />      <div style="text-align: center">                [ <a href="../../index.html">Cafe con Leche</a>          | <a href="../index.html">XML Bible Home Page</a>       | Order  from  <a href="http://www.amazon.com/exec/obidos/ASIN/0764549863/ref=nosim/cafeaulaitA/">amazon.com</a>  |  <a href="http://www.wiley.com/WileyCDA/WileyTitle/productCd-0764549863.html">Publisher Page</a> ]         </div></body></html>