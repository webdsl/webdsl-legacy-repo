module twiki-to-markdown

imports libstrategolib 
	xml-info
	site-specific

signature
  constructors
    EntityRef : String -> CharData
    Literal   : String -> CharData

overlays

  Elem(tag, attrs, elems) = Element(Name(_ None(), tag), attrs, elems)

  Attr(name, value) = Attribute(Name(_ None(), name), value)

  H(tag, elems) = Elem(tag, [], elems)

  Anchor() = Elem("a", [Attr("name", _ ""), Attr("id", _ "")], [])

strategies

  main = 
    input-wrap(
      alltd(?Element(Name(_,"body"),_,<map(convert)>))
    )

  print-strings =
   <fprint>(stdout(), <id>)

  convert =
    ignore-element
    <+ site-specific-element
    <+ special-element
    <+ convert-element
    <+ debug(!"unknown-element: ")

  site-specific-element =
    fail

strategies // default: copy xhtml elements literally

  convert-element =
    ?Element(Name(_, tag), attr*, elem*)
    ; <print-strings> ["<", tag]
    ; <map(print-attribute)> attr*
    ; <printstring> ">"
    ; <map(convert)> elem*
    ; <print-strings> ["</", tag, ">"]

  print-attribute =
    ?Attribute(Name(_, aname), aval)
    ; <print-strings>[" ", aname, "=\"", <escape-text> aval, "\""]

strategies // default: copy element text literally 

  convert-element =
    ?Text(txt)
    ; where(<is-string> txt)
    ; <convert-text-string> txt

  convert-element =
    ?Text(txt)
    ; where(<is-list> txt)
    ; <map(convert-text-string)> txt

  convert-text-string =
    is-string
    ; string-tokenize-keep-empty(|['\n'])
    ; if not(?["" | _]) then
        where(Hd; escape-text; <print-strings>[<id>, " "])
        ; Tl
      end
    ; map(trim-leading-whitespace; escape-text; <print-strings>[<id>, " "])

    // problem: <p><a href="...">foo</a> bar</p>

  convert-text-string =
    ?Literal(<is-string>)
    ; escape-text
    ; printstring

  convert-text-string =
    ?EntityRef(ref)
    ; if not("nbsp" := ref) then
        <print-strings>["&", ref, ";"]
      end

  escape-text = 
    string-as-chars(escape-chars(Escape <+ Escape-single-quote))

strategies // elements to ignore

  ignore-element =
    ? Element(
            Name(_, "a")
          , [ Attribute(Name(None(), "name"), "PageTop")
            , Attribute(Name(None(), "id"), "PageTop")
            ]
          , []
          )

  ignore-element =
    ?Element(Name(_, "a")
          , [ Attribute(Name(None(), "name"), "PageBottom")
            , Attribute(Name(None(), "id"), "PageBottom")
            ]
          , []
          )

  ignore-element =
    ?Element(Name(_, "a")
            , [ Attribute(Name(None(), "name"), _)
              , Attribute(Name(None(), "id"), _) ]
            , [])

  ignore-element =
    ?Elem("font", _, elems)
    ; <map(convert-element)> elems

strategies // structural markup

  special-element =
    ?Elem("p", [], [])
    ; <printstring> "\n\n"

  special-element =
    convert-header(|"h1", "#")
    <+ convert-header(|"h2", "##")
    <+ convert-header(|"h3", "###")
    <+ convert-header(|"h4", "####")
    <+ convert-header(|"h5", "#####")

  convert-header(|h, hashes) =
    ?Elem(h, [], elems)
    ; <print-strings>[hashes, " "]
    ; <map(convert)> elems
    //; <print-strings>["\n"]
    
  special-element =
    ?Element(Name(_, "p"), [], elem*)
    ; <printstring> "\n\n"
    ; <map(convert)> elem*
    //; <printstring> "\n"

  special-element =
    ?Element(Name(_,"em"), [], [Text(txt)])
    ; <print-strings>["_", <escape-text>txt, "_"]

strategies // lists

  special-element =
    ?Elem("ul", [], elems)
    ; {| ListIndent
       : rules( 
           ListIndent  := <concat-strings>["   ", <ListIndent <+ !"">] 
           OrderedList :- _
         )
       ; <map(convert)> elems
       |}
    //; <print-strings>["\n"]

  special-element =
    ?Elem("ol", [], elems)
    ; {| ListIndent, OL 
       : rules( 
           ListIndent  := <concat-strings>["   ", <ListIndent <+ !"">] 
           OrderedList : _ 
         )
       ; <map(convert)> elems
       |}
    //; <print-strings>["\n"]

  special-element =
    ?Elem("li", [], elems)
    ; <print-strings>[
        "\n", 
        <ListIndent <+ !"">, 
        <if OrderedList then !"1. " else !"- " end>]
    ; <map(convert)> elems

strategies // tables

  special-element =
    ?Elem("table", _, elems)
    ; <print-strings>["\n<table>"]
    ; <map(convert)> elems
    ; <print-strings>["\n</table>"]

  special-element =
    ?Elem("tr", _, elems)
    ; <print-strings>["\n<tr>"]
    ; <map(convert)> elems
    ; <print-strings>["\n</tr>"]

  special-element =
    ?Elem("th", _, elems)
    ; <print-strings>["\n<th>"]
    ; <map(convert)> elems
    ; <print-strings>[" </th>"]

  special-element =
    ?Elem("td", _, elems)
    ; <print-strings>["\n <td>"]
    ; <map(convert)> elems
    ; <print-strings>[" </td>"]

strategies

  special-element =
    ?Elem("div", [Attr("class", "twikiToc")], _)
    //; <print-strings>["\n%TOC%\n"]

  special-element =
    ?Elem("span"
	 , [ Attr("class", "twikiNewLink") | _ ]
         , [ Elem("font", _, [Text(txt)] ) | _ ] )
    ; <print-strings>[<escape-text>txt]

strategies // links

  special-element =
    internal-link
    <+ external-link

  internal-link =
    ?Elem("a", [ Attribute(Name(_, "class"), "twikiLink")
               , Attribute(Name(_, "href"), url1)]
             , [Text(anchor)])
    ; url2 := <convert-internal-url> url1
    ; <print-strings>["[[", url2, "|", <escape-text>anchor, "]]"]

  external-link =
    ?Element(Name(_, "a"), 
      <fetch(?Attribute(Name(_, "href"), url))>
      , [Text(anchor)])
    ; <print-strings>["[", <escape-text>anchor, "](", url, ")"]

  convert-internal-url =
    <string-tokenize>(['/'], <id>)
    ; debug(!"internal url: ")
    ; if ?["http:", site, web, topic] then
        <concat-strings> ["twikiPage(", web, "/", topic, ")"]
      else if ?[web, topic] then
        <concat-strings> ["twikiPage(", web, "/", topic, ")"]
      else 
        debug(!"unparseable internal link: "); fail 
      end end

strategies // literal code

  special-element =
    ?Elem("pre"
         ,[Attr("space", "preserve")]
         ,[Text(txt)])
    ; <string-tokenize(|['\n'])> txt
    ; map(where(<printstring>"\n    "); escape-text; printstring)

    //; <indent-text(|4); debug(!"code: ");  escape-text; debug(!"code escaped: "); printstring> txt

  special-element =
    ?Elem("code", _, [Text(txt)])
    ; <print-strings>["`", <escape-text>txt, "`"]

/* 

TODO

x escape ' in text

- replace \n in text by space to avoid spurious newlines
  x space after links, emphasis

- internal links
  - Main/UserName -> [[user(UserName)]]

x leave out table of contents

x ordered lists (<ol>)

- link syntax
  - links in headers and tables not processed

- tables

  - at least pretty-print html syntax
  - remove annotations/attributes
  - extend markdown with twiki-like table syntax?

- markdown bug: empty line in code fragment

   http://localhost:8080/strategoxt/twikiPage/Stratego/DynamicRulesRethought

- markdown / preprocessor bug:

Notice that in this example the result is not <code>Plus(5, 6){\"a\", \"b\", \"c\"}</code>. The Plus term
will have just one annotation, which is the list <code>[\"a\", \"b\", \"c\"]</code>. You can use [[twikiPage(Stratego/ListMatching)|ListMatching]] to solve 
this problem:

x AutoXT: <code>...</code>

- Stratego/BuildingProgramOptimizersWithRewritingStrategies

  - remove indentation from body text

*/
