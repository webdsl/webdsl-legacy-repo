module normalize

imports
  libstratego-lib
  libstratego-xtc
  libwebdsl-front
  remove-annos

strategies

  main =
    xtc-io-wrap(
        webdslc-options
      , webdslc-usage
      , webdslc-about
      , ![] // xtc dependencies
      , xtc-normalize
    )

  xtc-normalize = id
    ; set-appname
    ; set-default-config
    ; xtc-parse-webdsl
    ; derive
    ; remove-position-annos
    ; output-webdsl

strategies

  declare =
    ?|[ entity x_type { prop * } ]|
    ; rules(
        all-properties : x_type -> prop*
      )

  declare =

  all-properties : entity -> properties

  type-of : var -> type


rules // editPage

  desugar-derive : 
    elem|[ derive editPage from e ]| -> 
    elem|[ derive editPage from e for (dprop*) ]|
    with  SimpleSort(t) := <type-of> e
        ; dprop* := <all-properties; filter(
               \Property(name,_,_,_) -> DeriveDefault(name) \ 
            <+ \PropertyNoAnno(name,_,_) -> DeriveDefault(name)\ 
          )> t
  
  derive-page : 
    elem|[ derive editPage from e for (dprop*) ]| -> 
    elem|[ 
      dummy() {
        header{"Edit " text(e.name) }
        form { 
          group("Details") { 
            derive editRows from e for (dprop*)
          } 
          group() {
            action("Save", save())
          }
        }
        action save() { 
          e.save(); 
          return x_view(e); 
        }
      }
    ]| 
    with  SimpleSort(srt) := <type-of> e
        ; x_view := <decapitalize-string> srt 

rules // edit rows

  derive-edit-rows :
    elem|[ derive editRows from e for (dprop*) ]| -> elem|[ dummy() { elem* } ]| 
    with  elem* := <filter-warn(derive-edit-row(|e )|"not a valid mode for edit row")> dprop*

  derive-edit-row(|e) : 
    DeriveDefault(y) -> <derive-edit-row(|e)> DeriveMode("edit", y)
    
  derive-edit-row(|e ) : 
    DeriveMode("edit", y) -> elem|[ groupitem { label(str){ input(e.y){} } } ]| 
    with str := <concat-strings> [<make-human-readable> y , ": "]
    
  derive-edit-row(|e ) : 
    DeriveMode("view", y) -> elem|[ groupitem { label(str){ output(e.y){} } } ]| 
    with str := <concat-strings> [<make-human-readable> y , ": "]
