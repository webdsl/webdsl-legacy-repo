--------------------------------------------------------------------
TODO
--------------------------------------------------------------------

* SQL queries in the DSL

  - developer-defined queries in the DSL

  - user-defined queries in the webapp (e.g., in a wiki page)

  - StringBorg in DSL and in generated code
  
* Iteration over data other than by dataTable

  - see http://forum.java.sun.com/thread.jspa?threadID=715195&messageID=4133407
  
  - see dataList
  
  - see http://myfaces.apache.org/tomahawk/
  
  - generalized iteration constructs
  
     table ( pub : Publication ) { 
       row{ text(pub.name) ... } 
     }
     
     list ( pub : Publication in person.publications ) {
       listitem { 
         text( p : Person in pub.authors ) { p.name } // seperated by comma's!
         text( pub.title ) "."
         text( pub.year )
       } 
     }
     
     for ( unique year : Int in person.publications.year order descending ) {
       section{ 
         header{ year }
         list ( pub : Publication in person.publications where pub.year = year ) {
           showPublication(pub)
         }
       }
     }
     
* Derived properties

  - e.g., editing associations
  
  - properties defined in terms of a query, e.g. Publications of a Person
  
* Type-specific input fields

  - textarea, secret, etc.
  
  - proper sizes for input boxes
  
* Better interaction for selection menus

  - use value change listener instead of button?

* Validation / decoration / error messages

* Variable scopes

  - page scoped variables (as opposed to parameter
    variables) (become bean variables) (done)
  
  - session and conversation scoped variables
    - session.user
    - conversation.cart

* Entities

  - default values for entity fields (java-entity) (done)
  
  - creating new objects (done)
  
  - deleting objects
  
  - composite associations should not be cyclic
  
* Back view

  - maintain a stack of pages; go back to last view page
    on cancel

* Conditional page elements

  - make presentation of page elements conditional on
    state (for instance on session.user)

* User interface

  - have edit page of an object as a tab of its view?

    --------------------------------------
    | View | Discuss | Edit | Properties |
    ---------------------------------------------
    |                                           |

    View provides the presentation of the object, Discuss is the page for
    discussions of the content of the page, in Edit the object
    data can be modified, and Properties gives meta-data about the
    object (e.g., history, authors, permissions, etc. (This is probably
    inspired by mediawiki.)

    Of course, these tabs should only be enabled for those with the
    right permissions. 

  - table based presentations are ok for edit forms, but too limited
    for view pages

  - choosing good default values for sizes of form elements (e.g.,
    textarea)

  - what is a good style for CSS

  - figure out skinnability features of ajax4jsf (?)

  - It would be attractive to compose the userinterface from
    components that represent a particular object view or edit.
    Then it would be straightforward to compose more complex
    UI windows from such components.
    
* Defaults

  - generate default main template when not defined in app

* Order of Lists

  - order of authors of paper is relevant, mysql seems to
    mess that up (when the order is changed via a sequence
    of deletions and additions?)
    
* Database migration

  - aka data conversion, data migration
  - aka Extract, Transform and Load (ETL)
  - http://www.talend.com/ open source tool with gui for data migration
  - http://dataconv.org
  - www.adeptia.com  
  - http://www.adeptia.com/products/data_transformation.html?gclid=CI6-zYjOwowCFQHdlAodIWDrWg

* Generate class diagram

  - using dot
    
* Good URLs

  - allow wiki style URLS
  
       /serg/person/EelcoVisser
    
    or even
    
       /serg/EelcoVisser (person homepage)
    
    and
    
       /serg/MoDSE (project)
    
    and
    
       /serg/ModelDrivenSoftwareEvolution (publication)
    
  - maybe this should be considered orthogonally to datatypes and
    left to the user:
    
      url "EelcoVisser" -> /serg/viewPerson(person=3)
    
    which results in a mapping (url rewriting) from names to page
    definitions with appropriate parameters.
    
  - there could be generic mappings:
  
      /person/x -> /viewPerson(person=xId) where Person(xId).urlref
    
    here urlref should be a primary key of Person that also works well
    as a reference (no spaces/strange symbols)
  
* wiki links 

  - this may be irrelevant considering the ideas about 'good urls'

  - in wiki text (FormattedText) it should be possible to link to
    other objects/pages in the application, there are several
    options for doing this

  - [[Person:fullname:Eelco Visser][Eelco Visser]] would be a link to the
    Person object with fullname 'Eelco Visser', this would work if fullname
    is a primary key (which it might not be in this particular case). Still
    it would be ambiguous to what view of this object we want to link.

  - [[Person:id:1][Eelco Visser]] use the entity identifier. This might be
    fragile, but maybe not (how stable are db identifiers?). But at least,
    such keys are difficult to come up with (what is the identifier of an
    object?). This relates to the problem of bookmarking pages.

  - [[Person:id:1:view][Eelco Visser]] explicitly indicates to what page
    to link, i.e., the view page in this case.
    
* CSS (modeling in DSL?)

  - better abstractions for styles could be useful, now there is
    a lot of code duplication
    
* module system

  - a module system for web applications
  
  - libraries of common features (data + templates)
  
  - separate compilation?
  
  - at least separate typechecking
  
* Name mangling / Refactor name generation

  - currently names are generated by explicit string
    concatenation in where clauses; this is rather syntactically
    heavy; we could use a more concise notation for string
    manipulation.
    
  - it would be cool to express these name constructions using
    some sort of lightweight antiquotation
    public t `get(x_prop)() { return x_prop; }
    this suggests that get is a function
    so ~<get>x_prop but that doesn't look right

  - but at least the name generators should be factored out, not in the
    least to guarantee a consistent naming convention, and even to make it
    configurable
    
* Java-front/Dryad: Extend Java with properties

  - writing templates that generate properties (getters
    and setters) is becoming tedious; make an extension
    of Java with
    
      property t x;
      
    that is desugared to the obvious code. Annotations
    on the property should be transferred to the variable
    declaration.
    
* Java-front: quotation and antiquotation

  - Quotation for list of MethodDec modifiers
    currently not possible to create list of annotations
    mod*|[ @ManyToOne @ColumnName(...) ]|  
  
  - antiquotation for package name
      
* Collect code elements in single traversal of the tree

  - similar to fragments stratego compiler

* Extensible special types / java code linking

  - make DSL definition and generator extensible for special types;
    for example, Email, URL, should be defined via an extension of
    the basic DSL (maybe even String and Int);
    
  - an extension module defines extension of 
    - typechecker
    - desugarer
    - presentation layer elements (input, output)
    
  - requires extensible model for strategies, i.e., a hook
    that can be redefined, which is applied before the default
    case
      
* Libraries

  - create libwebdsl-syntax
  
  - create libwebdsl-generator
    - framework for complete generator
    - extensible with actual typechecking and code generation
    
  - create reusable framework for setting up a code generator
    with as parameters the syntax (parse table, pretty-print table)
    and support for multiple output files
    
* Deployment

  - generate complete seam application template
  
  - generation of boilerplate files (webdsl.css)
  
  - there may be a bit of application-specific stuff in these files;
    should be abstracted over
  
  - include invocation of java compiler and activation of server (nix)
  
* access control and authorization

  - basic version: simple user/password based authorization + 
    simple roles for access control
    
  - advanced: design a policy language and define policy as
    a separate concern (with Danny Groenewegen)
    
--------------------------------------------------------------------
DONE
--------------------------------------------------------------------

* make URL and Email builtin types

* refactor generator modules to a module per generated file

* initialize the database via statements in the DSL

  - import and export of data to/from XML (?)

* how should references to non primitive types be handled?

* deal with collection types

* generate code for the backing bean

* properties should refer to fields of persistent entity through backing bean
  
* each entity should have a name (to refer to objects);
  this might be a derived property, e.g., 
  
     name : String = firstname + lastname
  
  such a property would only have a getter, not a setter
  and thus shows up only in views and references to views

* support viewing and editing of associations

  - start with viewing of reference types, collections of
    value, composite, and reference types

  - when editing an object provide choice box for selecting
    objects for reference types; for example, to add
    authors to a publication, choose from existing Persons
    in the database; also provide an option to create a new
    object for the association, returning to the original
    edit afterwards (or at least making the association with
    the original object)

  - code for inline editing of value lists; generate a matrix
    with inputText fields; update the elements from this matrix
    (in first experiments it wasn't clear to me how to get this
    done using dataTable; the JSF book provides an example, but
    that requires actually programming the components in Java;
    it would seem that the DataModel(Selection) constructs of
    Seam should provide a solution for this (using 
    valueChangedListener on the input fields); one issue I
    encountered here is that it seems not possible to provide
    both a DataModelSelection and a DataModelSelectionIndex
    for the same DataModel)

* embed composite associations?

  - perform an analysis of entity declarations and find out
    which entities are always used in composites
    does hibernate support selective embedded entities?
    (that would mean that some objects for the type are in
     separate table and others are embedded in the rows
     of the parent objects)

* consider special syntax for special value types such
  as URLs and dates
  
  - but how important are constant values in application
    definitions?

* it would be interesting to have some form of reflection
  to get all code generator strategies automatically
  
  - this remark applied to the case where there were a large number
    of 'top-level' templates
      
* Refactoring

  - throw away old 'direct generation' code
    (but save a copy for reference)
    
  - integrate WebDSL parser
  
  - integrate WebDSL pretty-printer
  
  - options to control what is done
    -- desugar
    -- expand
    etc.
    
  - use appropriate logging strategies so that debugging output is turned off
    by default
    
  - get rid of dsl-desugar executable
  
* Dropdown menus
  
    - http://www.seoconsultants.com/css/menus/horizontal/
    
    - http://www.seoconsultants.com/css/menus/vertical/
    
    - http://www.xs4all.nl/~peterned/csshover.html
    
    - layout can still be improved
    
* Refactor entity class generation

  - one rule to generate property + getter + setter
  
  - separate rules to compute annotations  
  
  - there is some redundancy here; at some point it will be worthwhile to
    factor out annotations for property
    the advantage of this style is that one gets quite a good impression of
    the generated code
    
* Avoid java keywords

  - properties with as name a Java keyword or reserved
    word are a problem for code generation. Sander 
    prefixes all member variables (?) with an underscore
    to avoid this problem. All other manifestations of
    the names are not a problem (getAbstract, setAbstract,
    etc.)
    
  - what is the impact on property mapping by Hibernate?
    -> put annotations on getter
    
  - java reserved words cannot be used as names of properties, but that
    may conflict with the desire to allow natural words in the application, for
    instance to generate captions and field labels; this might be solved by always
    using functions to lookup the name of a property, or to convert it to a java
    name vs a display name    
    
* Import / export of data from database

  - is there such a facility built-in to mysql?
  
  - yes:
  
    mysqldump --user=visser --password=dsl serg > db.sql
    
    produces an sql script that restore the database by
    reading back in 
    
  - of course, if the database schema changes the script
    needs to be adapted; is it an idea to generate
    evolution transformations that transform this database
    script? maybe better to do migration on the database
    itself
    
--------------------------------------------------------------------
--------------------------------------------------------------------

	// new homepage

	private String newHomepage = "";

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.webdsl.serg.domain.EditPerson#getNewHomepage()
	 */
	public String getNewHomepage() {
		return newHomepage;
	}

	public void setNewHomepage(String newHomepage) {
		this.newHomepage = newHomepage;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.webdsl.serg.domain.EditPerson#addHomepage()
	 */
	public void addHomepage() {
		x_class.addHomepages(getNewHomepage());
	}

	// delete existing homepage

	public void deleteHomepage() {
		if (getHomepages() == null)
			log.info("deleting homepage " + currentHomepage
					+ " but homepages list is empty");
		else
			getHomepages().remove(currentHomepage);
	}

	// change a homepage

	public void homepageChanged() {
		int i = getHomepages().indexOf(currentHomepage);
		getHomepages().remove(currentHomepage);
		getHomepages().add(i, currentHomepage);
	}

	@DataModel("homepages")
	public List<String> getHomepages() {
		return x_class == null || x_class.getHomepages() == null ? null
				: new ArrayList<String>(x_class.getHomepages());
	}

	@DataModelSelection(value = "homepages")
	String currentHomepage;

	// @DataModelSelectionIndex(value="homepages")
	// int currentHomepageIndex;
