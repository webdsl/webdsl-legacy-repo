module org/webdsl/dsl/languages/action/for-stmt

imports
  libstrategolib

imports
  libwebdsl-front

rules

  rename-action :
    ForStmt(x, srt, e1, f1, b1) -> ForStmt(y, srt2, e2, f2, b2)
    with e2 := <rename-all> e1
       ; {| Rename
          : srt2 := <rename-all> srt
          ; y := <rename-bound(|srt2)> x
          ; f2 := <rename-all> f1
          ; b2 := <rename-all> b1
          |}

  rename-action :
    ForStmtNoFilter(x, srt, e1, b1) -> ForStmtNoFilter(y, srt2, e2, b2)
    with e2 := <rename-all> e1
       ; {| Rename
          : srt2 := <rename-all> srt
          ; y := <rename-bound(|srt2)> x
          ; b2 := <rename-all> b1
          |}

  rename-action :
    ForAllStmt(x, srt, f1, b1) -> ForAllStmt(y, srt2, f2, b2)
    with {| Rename
          : srt2 := <rename-all> srt
          ; y := <rename-bound(|srt2)> x
          ; f2 := <rename-all> f1
          ; b2 := <rename-all> b1
          |}

  rename-action :
    ForAllStmtNoFilter(x, srt, b1) -> ForAllStmtNoFilter(y, srt2, b2)
    with {| Rename
          : srt2 := <rename-all> srt
          ; y := <rename-bound(|srt2)> x
          ; b2 := <rename-all> b1
          |}

  rename-action :
    ForCountStmt(x, e1, e2, b1) -> ForCountStmt(y, e3, e4, b2)
    with e3 := <rename-all> e1
       ; e4 := <rename-all> e2
       ; {| Rename
          : y := <rename-bound(|SimpleSort("Int"))> x
          ; b2 := <rename-all> b1
          |}

rules

  constraint-error-action :
    ForCountStmt(x, e1, e2, b) -> <add-error(|["Expression ", e1, " is not of type Int"])>
    where not(<type-compatible> (SimpleSort("Int"), <type-of> e1))

  constraint-error-action :
    ForCountStmt(x, e1, e2, b) -> <add-error(|["Expression ", e2, " is not of type Int"])>
    where not(<type-compatible> (SimpleSort("Int"), <type-of> e2))

  // check for expression
  constraint-error-action =
    (    ?ForStmt(_, s, e, _, _)
      <+ ?ForStmtNoFilter(_, s, e, _) )
    ; not(GenericSort(_, [<sort-literal> s]) := <type-of> e)
    ; add-error(|["expression ", <pp-webdsl> e, " should be of type [SomeGenericType]<", <pp-webdsl> s, ">"]) 
  
  sort-literal :
    SimpleSort(x) -> x

  // check where-expression in filter
  constraint-error-action =
    (    ?ForStmt(_, _, _, Filter(we, _, _), _)
      <+ ?ForStmt(_, _, _, FilterNoOrderBy(we, _), _) 
      <+ ?ForStmt(_, _, _, FilterNoOrderByNoLimit(we), _) )
    ; not(SimpleSort("Bool") := <type-of> we)
    ; add-error(|["where clause should return a boolean: ", <pp-webdsl> we])
