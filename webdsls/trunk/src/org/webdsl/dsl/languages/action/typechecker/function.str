module org/webdsl/dsl/languages/action/typechecker/function

imports
  libstrategolib
  Java-15 
  libjava-front

imports
  libwebdsl-front

rules // generalize constraints for all function types

  constraint-error-action =
  	(
  			?Function(f, args, _, body)
  	<+	?FunctionNoReturn(f, args, body)
  	)
  	; constraint-error-function(|f,args,body)
  	
rules
  // checks for returns within a FunctionNoReturn
  constraint-error-action =
    ?FunctionNoReturn(f, _, body) 
    ; where (
        not([] := <collect(?Return(_))> body)
        ; add-error(|["function ", <pp-webdsl> f, " has no return type but tries to return a variable"])
      )

  // checks the return type of functions
  constraint-error-action :
    Function(f, args, sort, body1) -> <add-error(|["The return statement in function ", f, " should have type ", <pp-webdsl> sort])>
    where returns := <collect(?Return(_))> body1
        ; wrongreturns := <filter(\ Return(e) -> Return(e) where not(<type-compatible> (sort,<type-of> e)) \)> returns
        ; not([] := wrongreturns)
  
  // checks for at least one return inside a normal function
  constraint-error-action :
    Function(f, args, rt, body) -> <add-error(|["Return statement missing in function ", <pp-webdsl> f])>
    where not(SimpleSort("Void") := rt)
        ; [] := <collect(?Return(_))> body
        

/* doesn't work yet... later
  // checks types of arguments
  constraint-error-action :
    Function(f, args, _, _) -> <add-error(|["Argument evaluates to non-existing entity in function ", <pp-webdsl> f])>
    where not(<map(type-of; type-exists)> args)
    
  // checks types of arguments
  constraint-error-action :
    FunctionNoReturn(f, args, _, _) -> <add-error(|["Argument evaluates to non-existing entity in function ", <pp-webdsl> f])>
    where not(<map(type-of; type-exists)> args)*/

rules //reserved functions

  register-reserved-function :
    (name,argcount) -> (name,argcount)
    where rules ( ReservedFunctions :+= (name,argcount) )
    
  constraint-error-function(|f,args,body) =
    	where(argcount := <length> args)
    ; where(<fetch(?(f,argcount))> <bagof-ReservedFunctions>)
    ; error-message-generated-function(|f,argcount)
        
  error-message-generated-function(|f,argcount) = 
    add-error(|["Function with name '", f, "' and ", argcount," argument(s) collides with a generated function that you are not allowed to overwrite"])
  
rules // forbidden elements

	constraint-error-function(|f,args,body) =
		<alltd(check-forbidden-in-function)> body
		; fail
	
	check-forbidden-in-function =
		?GoTo(_); add-error(|["Goto can only be used inside an action."])

rules // global functions

  constraint-error-action :
    Application(nm, sections) -> <fail>
    where // get *top-level* functions
    			funcs := <collect-om(?Section(_,<id>); filter(?Function(_,_,_,_) <+ ?FunctionNoReturn(_,_,_))); flatten-list> sections
    		; efuncs := <collect-om(?Section(_,<id>); filter(?ExtendFunction(_))); flatten-list> sections
        ; <try(constraint-error-global-funcs(|efuncs))> funcs
    		; entities := <collect-om(?Section(_,<id>); filter(get-entity-def; ?(<id>,_))); flatten-list> sections
    		; <try(constraint-error-global-funcs-entities(|entities))> funcs

rules // redefined global functions
    	
  constraint-error-global-funcs(|efuncs): funcs -> <fail>
  	with	doubledefinesigs := <map(extract-function-sig; sig-to-lower); find-doubles> funcs
    		; <map(try(constraint-error-func-sigs(|doubledefinesigs)))> funcs
    		  
  constraint-error-func-sigs(|doublefuncsigs):
  	func -> <add-error(|["Global function with signature ", prettysig, " is defined multiple times."])> 
    where matchsig := <extract-function-sig; sig-to-lower> func
        ; <fetch(?matchsig)> doublefuncsigs  
        ; prettysig := <extract-function-sig; pp-func-sig> func

rules // global functions overlapping with entities
	
	constraint-error-global-funcs-entities(|entitynames): funcs -> <fail>
		with	funcnames := <map(extract-function-sig; ?(<id>, _))> funcs
				; doubles := <flatten-list; find-doubles> [<make-set> funcnames, <make-set> entitynames]
				; <map(try(constraint-error-global-func-entity(|doubles)))> funcs
				  
	constraint-error-global-func-entity(|doubles):
		func -> <add-error(|["Global function '",name,"' has the same name as an entity."])>
		where name := <extract-function-sig; ?(<id>,_)> func
				; lower := <lower-case> name
				; <fetch(?lower)> doubles

rules // extend function which extends nothing
  
  constraint-error-global-funcs(|efuncs): funcs -> <fail>
    with sigs := <map(extract-function-sig)> funcs
       ; <filter(match-extend-function-to-function(|sigs))> efuncs
  
  match-extend-function-to-function(|sigs):
    ExtendFunction(f) -> <add-error(|["Extend function with signature ",prettysig," extends a non-existing function."])>
    where esig := <extract-function-sig> f
        ; <not(fetch(\ fsig -> <eq> (esig, fsig) \))> sigs  
        ; prettysig := <pp-func-sig> esig
  