module org/webdsl/dsl/languages/action/typechecker/function

imports
  libstrategolib
  libjava-front

imports
  libwebdsl-front

rules // generalize constraints for all function types

  constraint-error-action =
  	(
  			?Function(f, args, _, body)
  	<+	?FunctionNoReturn(f, args, body)
  	)
  	; constraint-error-function(|f,args,body)
  	
rules
  // checks for returns within a FunctionNoReturn
  constraint-error-action =
    ?FunctionNoReturn(f, _, body) 
    ; where (
        not([] := <collect(?Return(_))> body)
        ; add-error(|["function ", <pp-webdsl> f, " has no return type but tries to return a variable"])
      )

  // checks the return type of functions
  constraint-error-action :
    Function(f, args, sort, body1) -> <add-error(|["The return statement in function ", f, " should have type ", <pp-webdsl> sort])>
    where returns := <collect(?Return(_))> body1
        ; wrongreturns := <filter(\ Return(e) -> Return(e) where not(<type-compatible> (sort,<type-of> e)) \)> returns
        ; not([] := wrongreturns)
  
  // checks for at least one return inside a normal function
  constraint-error-action :
    Function(f, args, rt, body) -> <add-error(|["Return statement missing in function ", <pp-webdsl> f])>
    where not(SimpleSort("Void") := rt)
        ; [] := <collect(?Return(_))> body
        

/* doesn't work yet... later
  // checks types of arguments
  constraint-error-action :
    Function(f, args, _, _) -> <add-error(|["Argument evaluates to non-existing entity in function ", <pp-webdsl> f])>
    where not(<map(type-of; type-exists)> args)
    
  // checks types of arguments
  constraint-error-action :
    FunctionNoReturn(f, args, _, _) -> <add-error(|["Argument evaluates to non-existing entity in function ", <pp-webdsl> f])>
    where not(<map(type-of; type-exists)> args)*/

rules //reserved functions

  register-reserved-function :
    (name,argcount) -> (name,argcount)
    where rules ( IsReservedFunction : (name,argcount) )
    
  constraint-error-function(|f,args,body) =
    	where(argcount := <length> args)
    ; where(<IsReservedFunction> (f, argcount))
    ; error-message-generated-function(|f,argcount)
        
  error-message-generated-function(|f,argcount) = 
    add-error(|["Function with name '", f, "' and ", argcount," argument(s) collides with a generated function that you are not allowed to overwrite"])
  
rules // forbidden elements

	constraint-error-function(|f,args,body) =
		<alltd(check-forbidden-in-function)> body
		; fail
	
	check-forbidden-in-function =
		?GoTo(_); add-error(|["Goto can only be used inside an action."])

rules // global functions

  is-reserved-function =
      extract-function-sig => (name, args)
    ; <IsReservedFunction> (name, <length> args)
    
  constraint-error-global =
      all-keys-FunctionDecl
    ; map(bagof-FunctionDecl); concat
    ; remove-all(is-reserved-function)
    ; constraint-double-decls(
          extract-function-sig; sig-to-lower
        ,{prettysig:  
            Snd; extract-function-sig; pp-func-sig => prettysig
          ; <concat-strings> ["Global function with signature ",prettysig," is defined multiple times."]
         }
      )
    ; fail

/*
  constraint-error-global =
      funcs := <all-keys-FunctionDecl; map(FunctionDecl)>
    ; ents := <all-keys-EntDecl; map(EntDecl)>
    ; funcname* := <all-keys-FunctionDecl; map(Fst)>
    ; entname* := <all-keys-EntDecl>
    ; allnames := <concat; map(lower-case)> [<uniq> funcname*, <uniq> entname*]
    ; !funcs
    ; constraint-double-decls(
             extract-function-sig; Fst; lower-case
        , {  Snd; extract-function-sig; Fst => name
          ; <concat-strings> ["Global function '",name,"' has the same name as an entity."]
         }
        | allnames
      )
    ; fail
*/

rules // extend function which extends nothing
  
  constraint-error-global =
      bagof-ExtendGlobalFunctions
    ; filter(constraint-extend-global-function)
      // cleanup dr
    ; dr-end-scope(|"ExtendGlobalFunctions")
    ; fail
  
  constraint-extend-global-function: ef@ExtendFunction(f) -> <add-error(|["Extend function with signature ",prettysig," extends a non-existing function."])>
    with  esig := <extract-function-sig> f
        ; globalsigs := <all-keys-FunctionDecl; strip-annos> // remove {DR_DUMMY}
        ; prettysig := <pp-func-sig> esig
    where not(<fetch-elem(?esig)> globalsigs)
