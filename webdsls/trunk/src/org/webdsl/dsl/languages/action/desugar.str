module org/webdsl/dsl/languages/action/desugar

rules

  desugar-action :
    ExtendFunction(Function(fun, fargs, _, Block(stats))) -> RemoveMe()
    where <IsGlobalFunctionSignature> (fun,<map(?Arg(_,<id>))> fargs)
    with rules (
           ExtendFunction :+
             Function(fun, fargs2, SimpleSort("Void"), Block(stats2)) -> Function(fun, fargs2, SimpleSort("Void"), Block(newstats))
             with  newstats := <rename-vars-in-added-stmts-with-fargs> (fargs,fargs2,stats,stats2)
         )

  desugar-action = once-ExtendFunction

  desugar-action = once-ExtendEntity
  
  desugar-action :
    ExtendEntity(ident, props, funcs) -> RemoveMe()
    with rules (
        ExtendEntity :+
          EntityNoSuper(ident, props2, funcs2) -> EntityNoSuper(ident, <concat> [props, props2], <concat> [funcs, funcs2])
          with rules ( ExtendEntity :- Entity(ident, s, props2, funcs2)
                       ExtendEntity :- SessionEntity(ident, props2, funcs2) ) // Remove the other two
                       
        // @TODO: normalize EntityNoSuper to Entity extends Object
        
        ExtendEntity :+
          Entity(ident, s, props2, funcs2) -> Entity(ident, s, <concat> [props, props2], <concat> [funcs, funcs2])
          with rules ( ExtendEntity :- EntityNoSuper(ident, props2, funcs2)
                       ExtendEntity :- SessionEntity(ident, props2, funcs2) )

        ExtendEntity :+
          SessionEntity(ident, props2, funcs2) -> SessionEntity(ident, <concat> [props, props2], <concat> [funcs, funcs2])
          with rules ( ExtendEntity :- Entity(ident, s, props2, funcs2)
                       ExtendEntity :- EntityNoSuper(ident, props2, funcs2) )
                       
          // @TODO: move to extend session entity case below
      )
      // this approach causes rules to be created which will not be used
      // invariant should be to consume all rules applied with once- (?)
      
      // desugar all entities to inherit from Object?

  desugar-action :
    fe@ForExp(oe, x, s, ie, fltr) -> ThisCall($fun, params)
    where $fun := <newname> "listCompr"
        ; {| Param, IgnoreVars
           : <alltd(find-params)> fe
           ; params := <bagof-Param>
           |}
        ; {| RewriteFieldAccessToFarg
           : farg* := <map(forexp-function-param-to-farg)> params
          |}
        // finding parameters = finding free variables?
        // @TODO: turn into reusable strategy; with built-in scope; should not be part of caller
        
        ; srt2 := <type-of> ie
        ; GenericSort(_, [srt]) := srt2
        ; srt3 := <type-of> oe
        ; e3 := ie                                                 // alias
        ; e4 := oe                                                 // alias
        //; newnm := <new-forexp-name>
        ; if <?GenericSort("List",_)> srt2 then  
            srt4 := GenericSort("List", [srt3])  
            ; e5 := |[ List<srt3>() ]|           
          else // Set
            srt4 := GenericSort("Set", [srt3])   
            ; e5 := |[ Set<srt3>() ]|            
          end
        ; if <?FieldAccess(Var("this"),_)> e3 then e7 := True() else e7 := <add-not-null-checks> NotEq(e3,Null()) end
        ; <fix-forexp-in-entity-function;emit-webdsl-code> def|[
            globals { 
              function $fun (farg*) : srt4 {
                var l : srt4;
                l := e5;
                if(e7) {
                  for(x : srt in e3 fltr) {
                    l.add(e4);
                  }
                } else {}
                return l;
              }
            }
          ]|

  /* @REFACTOR: This must be turned into AndForExp(oe, x, s, ie, fltr) ... */
  desugar-action :
    AndForExp(fe@ForExp(oe, x, s, ie, fltr)) -> ThisCall($fun, params)
    where $fun := <newname> "listCompr"
        ; {| Param, IgnoreVars
           : <alltd(find-params)> fe
           ; params := <bagof-Param>
           |}
        ; {| RewriteFieldAccessToFarg
           : farg* := <map(forexp-function-param-to-farg)> params
          |}
        //
        ; GenericSort(_, [srt]) := <type-of> ie
        ; e3 := ie
        ; e4 := oe
        ; if <?FieldAccess(Var("this"),_)> e3 then e7 := True() else e7 := <add-not-null-checks> NotEq(e3,Null()) end
        ; <fix-forexp-in-entity-function;emit-webdsl-code> def|[
            globals {
              function $fun (farg*) : Bool {
                if(e7) {
                  for(x : srt in e3 fltr) {
                    if(!e4) {
                      return false;
                    } else {}
                  }
                } else {}
                return true;
              }
            }
          ]|

  /* @REFACTOR: This must be turned into OrForExp(oe, x, s, ie, fltr) ... */
  desugar-action :
    OrForExp(fe@ForExp(oe, x, s, ie, fltr)) -> ThisCall($fun, params)
    where $fun := <newname> "listCompr"
        ; {| Param, IgnoreVars
           : <alltd(find-params)> fe
           ; params := <bagof-Param>
           |}
        ; {| RewriteFieldAccessToFarg
           : farg* := <map(forexp-function-param-to-farg)> params
          |}
        //
        ; GenericSort(_, [srt]) := <type-of> ie
        ; e3 := ie
        ; e4 := oe
        ; if <?FieldAccess(Var("this"),_)> e3 then e7 := True() else e7 := <add-not-null-checks> NotEq(e3,Null()) end
        ; <fix-forexp-in-entity-function;emit-webdsl-code> def|[
            globals {
              function $fun (farg*) : Bool {
                if(e7) {
                  for(x : srt in e3 fltr) {
                    if(e4) {
                      return true;
                    } else {}
                  }
                } else {}
                return false;
              }
            }
          ]|

  //nice bunch of code duplication below....

  desugar-action :
    TypedListCreation(srt1, e1*) -> ThisCall($fun, params)
    where not([] := e1*)
        ; $fun := <newname> "typedlistCr"
        ; {| Param, IgnoreVars
           : <alltd(find-params)> e1*
           ; params := <bagof-Param>
           |}
        ; debug(!"TYPED LIST CREATEION")   
        ; {| RewriteFieldAccessToFarg
           : farg* := <map(forexp-function-param-to-farg)> params
          |}
        ; <debug(!" PARAMS, FARG ")> [ params, " ---- ", farg* ]
        ; srt2 := GenericSort("List", [srt1])
        ; stat* := <map(\ e -> |[ l.add(e); ]| \)> e1*
        ; debug(!"statements")
        ; <emit-webdsl-code> def|[
            globals {
              function $fun (farg*) : srt2 {
                var l : srt2 := List<srt1>();
                stat*
                return l;
              }
            }
          ]|

  desugar-action :
    TypedSetCreation(srt1, e1*) -> ThisCall($fun, params)
    where not([] := e1*)
        ; $fun := <newname> "typedsetCr"
        ; {| Param, IgnoreVars
           : <alltd(find-params)> e1*
           ; params := <bagof-Param>
           |}
        ; {| RewriteFieldAccessToFarg
           : farg* := <map(forexp-function-param-to-farg)> params
          |}
        ; srt2 := GenericSort("Set", [srt1])
        ; stat* := <map(\ e -> |[ l.add(e); ]| \)> e1*
        ; <emit-webdsl-code> def|[
            globals {
              function $fun (farg*) : srt2 {
                var l : srt2 := Set<srt1>();
                stat*
                return l;
              }
            }
          ]|

  desugar-action :
    ListCreation([e1|e1*]) -> ThisCall($fun, params)
    where $fun := <newname> "listCr"
        ; {| Param, IgnoreVars
           : <alltd(find-params)> [e1|e1*]
           ; params := <bagof-Param>
           |}
        ; {| RewriteFieldAccessToFarg
           : farg* := <map(forexp-function-param-to-farg)> params
          |}
        ; srt1 := <type-of> e1
        ; srt2 := GenericSort("List", [srt1])
        ; stat* := <map(\ e -> |[ l.add(e); ]| \)> [e1|e1*]
        ; <emit-webdsl-code> def|[
            globals {
              function $fun (farg*) : srt2 {
                var l : srt2 := List<srt1>();
                stat*
                return l;
              }
            }
          ]|

  desugar-action :
    SetCreation([e1|e1*]) -> ThisCall($fun, params)
    where $fun := <newname> "setCr"
        ; {| Param, IgnoreVars
           : <alltd(find-params)> [e1|e1*]
           ; params := <bagof-Param>
           |}
        ; {| RewriteFieldAccessToFarg
           : farg* := <map(forexp-function-param-to-farg)> params
          |}
        ; srt1 := <type-of> e1
        ; srt2 := GenericSort("Set", [srt1])
        ; stat* := <map(\ e -> |[ l.add(e); ]| \)> [e1|e1*]
        ; <emit-webdsl-code> def|[
            globals {
              function $fun (farg*) : srt2 {
                var l : srt2 := Set<srt1>();
                stat*
                return l;
              }
            }
          ]|

  desugar-action :
    VarDeclInitInferred(x, e) -> VarDeclInit(x, <type-of> e, e)

rules

  desugar-action :
    |[ e.list() ]| -> |[ List<srt>().addAll(e) ]| //assumes addAll returns the collection
    where GenericSort("Set", [srt]) := <type-of> e

  desugar-action :
    |[ e.set() ]| -> |[ Set<srt>().addAll(e) ]| //assumes addAll returns the collection
    where GenericSort("List", [srt]) := <type-of> e
    
