module org/webdsl/dsl/languages/action/function

imports
  libstrategolib
  libjava-front

imports
  libwebdsl-front
  org/webdsl/dsl/generation/webdsl-generator

strategies

	/*
		Care has to be taken to rename all cases: global function calls can be inside entity functions,
			and entity function calls can be inside global functions.
		Also, entity functions and global functions can have the same name, but not all may have to be renamed.
	*/ 

  // @TODO: Rename this strategy
  aggregate-and-combine-functions =
    ?app@Application(qid, sections)
    ; globalfuncs := <collect(\ Section(_,defs) -> <filter(?Function(_, _, _, _))> defs \) ;concat> sections
    ; overloadedentityfuncs := <collect(find-entity-functions);concat> sections
    ; rules ( RenamedEntityFunctions := overloadedentityfuncs )
    ; overloadedglobalfuncs := <map(\ Function(nm, _, _, _) -> nm \); find-doubles; make-set> globalfuncs
    ; sections2 := <rename-all-overloaded-functions(|overloadedglobalfuncs,overloadedentityfuncs)> sections
    ; !Application(qid, sections2)
      
  rename-all-overloaded-functions(|globalnames,entitynames) =
  		alltd(rename-overloaded-global-function(|globalnames,entitynames) <+ rename-overloaded-entity-function(|globalnames,entitynames)) 

  find-entity-root =
    ?srt
    ; Extends
    ; if ?"Entity" then
        !srt
      else
        find-entity-root
      end

  find-entity-root =
    ?srt
    ; not(Extends)

  find-entity-functions :
    Entity(ent, _, entbodydecs) -> result
    with result := <filter(\ Function(nm, _, _, _) -> (<find-entity-root> ent, nm) \); find-doubles> entbodydecs

  find-entity-functions :
    EntityNoSuper(ent, entbodydecs) -> result
    with result := <filter(\ Function(nm, _, _, _) -> (ent, nm) \); find-doubles> entbodydecs

rules	// rename entity functions (keep looking for global calls inside the entity and its functions)

  rename-overloaded-entity-function(|torename_global,torename_entity) :
    Entity(ent, s, entbodydecs) -> Entity(ent, s, [prop1*,fun2*])
    with  fun1*  := <filter(is-function-cons)> entbodydecs
        ; prop1* := <filter(is-property-cons)> entbodydecs
        ; {| ThisEntity
          : rules( ThisEntity := ent )
          ; fun2* := <with-toplevel-name(rename-all-overloaded-functions(|torename_global,torename_entity))> fun1*
          |}

  rename-overloaded-entity-function(|torename_global,torename_entity) :
    EntityNoSuper(ent, entbodydecs) -> EntityNoSuper(ent, [prop1*,fun2*])
    with  fun1*  := <filter(is-function-cons)> entbodydecs
        ; prop1* := <filter(is-property-cons)> entbodydecs
        ; {| ThisEntity
          : rules( ThisEntity := ent )
          ; fun2* := <with-toplevel-name(rename-all-overloaded-functions(|torename_global,torename_entity))> fun1*
          |}

  rename-overloaded-entity-function(|torename_global,torename_entity) :
    Function(nm, farg*, rt, b){anno*} -> fun
    where <elem> ((<ThisEntity; find-entity-root>, nm), torename_entity)
    with nm2 := <new-function-name> (nm, <map(\ Arg(_, srt) -> srt \)> farg*)
       ; b2 := <rename-all-overloaded-functions(|torename_global,torename_entity)> b
       ; fun := Function(nm2, farg*, rt, b2){anno*}
       ; <declare-function(|<ThisEntity>)> fun

  rename-overloaded-entity-function(|torename_global,torename_entity) :
    Call(e, nm, arg*){anno*} -> Call(e, nm2, arg*){anno*}
    where SimpleSort(ent) := <type-of> e
        ; <elem> ((<find-entity-root> ent, nm), torename_entity)
    with nm2 := <new-function-name> (nm, <map(type-of)> arg*)

  rename-overloaded-entity-function(|torename_global,torename_entity) :
    ThisCall(nm, arg*) -> result
    where ent := <ThisEntity>
        ; <CheckFunctionSignature> (SimpleSort(ent), nm, <map(type-of)> arg*) // is call to member function of this entity
        ; <elem> ((<find-entity-root> ent, nm), torename_entity)
    with  nm2 := <new-function-name> (nm, <map(type-of)> arg*)
        ; {| Rename:
            <rename-bound(|SimpleSort(ent))> "this"
          ; result := Call(<rename-all> Var("this"),nm2,arg*)
          |}

rules // rename overloaded global functions

  rename-overloaded-global-function(|torename_global,torename_entity) :
    Function(nm, farg*, rt, b){anno*} -> fun
    where <elem> (nm, torename_global)
    		; not(ThisEntity)		// don't rename entity function, even when global variant is overloaded 
    with nm2 := <new-function-name> (nm, <map(\ Arg(_, srt) -> srt \)> farg*)
       ; b2 := <rename-all-overloaded-functions(|torename_global,torename_entity)> b
       ; fun := Function(nm2, farg*, rt, b2){anno*}
       ; <declare-global-func> fun

  rename-overloaded-global-function(|torename_global,torename_entity) :
    tc@ThisCall(nm, arg*){anno*} -> ThisCall(nm2, arg*){anno*}
    where <elem> (nm, torename_global)
    			// is not an entity function call
    		; not(<CheckFunctionSignature> (SimpleSort(<ThisEntity>), nm, <map(type-of)> arg*))
    with t_arg* := <map(type-of)> arg*  
        ; if listof-t_arg* := <bagof-CheckGlobalFunctionSignatureArgumentTypes> (None(), nm, t_arg*)
          then t_argnew* := <find-most-specific-signature(|t_arg*,nm)> listof-t_arg*
          else t_argnew* := t_arg* // fall back to basic lookup for now when specific search fails, need to have a clear definition of compatible types vs inheritance
          end
        ; nm2 := <new-function-name> (nm, t_argnew*)
       
  new-function-name :
    (nm, argtypes) -> nm2
    with extra := <map(sort-to-string)> argtypes
         ; nm2 := <concat-strings> [nm, "__", <separate-by(|"__"); concat-strings> extra]

	// also allow new-function-name on formal arguments
	sort-to-string :
		Arg(_, srt) -> <sort-to-string> srt

  sort-to-string :
    SimpleSort(x) -> x

  sort-to-string :
    GenericSort(t, [t2]) -> <concat-strings> [t, "_", <sort-to-string> t2]

rules

	get-toplevel-name = ?Function(<id>, _, _, _)
	get-toplevel-name = ?FunctionNoReturn(<id>, _, _)
