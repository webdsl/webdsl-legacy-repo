module org/webdsl/dsl/languages/action/function

imports
  libstrategolib
  Java-15
  libjava-front

imports
  libwebdsl-front

strategies

  // @TODO: Rename this strategy
  aggregate-and-combine-functions =
    ?app@Application(qid, sections)
    ; globalfuncs := <filter(\ Section(_,defs) -> <filter(?Function(_, _, _, _))> defs \) ;concat> sections
    ; overloadedentityfuncs := <collect(find-entity-functions);concat> sections
    ; rules ( RenamedEntityFunctions := overloadedentityfuncs )
    ; overloadedglobalfuncs := <map(\ Function(nm, _, _, _) -> nm \); find-doubles; make-set> globalfuncs
    ; sections2 := <alltd(rename-overloaded-global-function(|overloadedglobalfuncs) <+ rename-overloaded-entity-function(|overloadedentityfuncs))> sections
    ; globalfuncs2 := <collect(\ Section(_,defs) -> <filter(?Function(_, _, _, _))> defs \);concat> sections2
    ; globalfuncs3 := <remove-all(has-untranslated-generics)> globalfuncs2
    ; rules ( AllGlobalFunctions := globalfuncs3 )
    ; !Application(qid, sections2)

  find-entity-root =
    ?srt
    ; Extends
    ; if ?"Object" then
        !srt
      else
        find-entity-root
      end

  find-entity-root =
    ?srt
    ; not(Extends)

  find-entity-functions :
    Entity(ent, _, _, funcs) -> <map(\ Function(nm, _, _, _) -> (<find-entity-root> ent, nm) \); find-doubles> funcs

  find-entity-functions :
    EntityNoSuper(ent, _, funcs) -> <map(\ Function(nm, _, _, _) -> (ent, nm) \); find-doubles> funcs

  rename-overloaded-entity-function(|torename) :
    Entity(ent, s, prop*, fun*) -> Entity(ent, s, prop*, fun2*)
    with {| ThisEntity
          : rules( ThisEntity := ent )
          ; fun2* := <alltd(rename-overloaded-entity-function(|torename))> fun*
          |}

  rename-overloaded-entity-function(|torename) :
    EntityNoSuper(ent, prop*, fun*) -> EntityNoSuper(ent, prop*, fun2*)
    with {| ThisEntity
          : rules( ThisEntity := ent )
          ; fun2* := <alltd(rename-overloaded-entity-function(|torename))> fun*
          |}

  rename-overloaded-entity-function(|torename) :
    Function(nm, farg*, rt, b) -> fun
    where <elem> ((<ThisEntity; find-entity-root>, nm), torename)
    with nm2 := <new-function-name> (nm, <map(\ Arg(_, srt) -> srt \)> farg*)
       ; b2 := <alltd(rename-overloaded-entity-function(|torename))> b
       ; fun := Function(nm2, farg*, rt, b2)
       ; <declare-function(|<ThisEntity>)> fun

  rename-overloaded-entity-function(|torename) :
    Call(e, nm, arg*) -> Call(e, nm2, arg*)
    where SimpleSort(ent) := <type-of> e
        ; <elem> ((<find-entity-root> ent, nm), torename)
    with nm2 := <new-function-name> (nm, <map(type-of)> arg*)

  rename-overloaded-global-function(|torename) :
    Function(nm, farg*, rt, b) -> fun
    where <elem> (nm, torename)
    with nm2 := <new-function-name> (nm, <map(\ Arg(_, srt) -> srt \)> farg*)
       ; fun := Function(nm2, farg*, rt, b)
       ; <declare-global-func> fun

  rename-overloaded-global-function(|torename) :
    ThisCall(nm, arg*) -> ThisCall(nm2, arg*)
    where <elem> (nm, torename)
    with t_arg* := <map(type-of)> arg*  
        ; if listof-t_arg* := <bagof-CheckGlobalFunctionSignatureArgumentTypes> (None(), nm, t_arg*)
          then t_argnew* := <find-most-specific-signature(|t_arg*)> listof-t_arg*
          else t_argnew* := t_arg* // fall back to basic lookup for now when specific search fails, need to have a clear definition of compatible types vs inheritance
          end
        ; nm2 := <new-function-name> (nm, t_argnew*)
        
  new-function-name :
    (nm, argtypes) -> nm2
    with extra := <map(sort-to-string)> argtypes
         ; nm2 := <concat-strings> [nm, "__", <separate-by(|"__"); concat-strings> extra]

  sort-to-string :
    SimpleSort(x) -> x

  sort-to-string :
    GenericSort(t, [t2]) -> <concat-strings> [t, "_", <sort-to-string> t2]
 
rules //overloading resolution for global functions
//assumes options have the same name (wrong arity is filtered here, so are doubles)

  find-most-specific-signature(|t_target):
    a@[x|xs] -> result //t_arg*
    where arity := <length> t_target
        ; distances := <filter(where(length;?arity));make-set;map(find-most-specific-signature-helper(|t_target))> a
        //remove impossible matches (indicated by -1), then find most specific
        ; {| MostSpecificFunction : 
             <filter(not(fetch(?-1)));map(compare-distances-for-overloading)> distances
           ; ([y{result}] := <bagof-MostSpecificFunction>) 
              <+ <debug;!1;exit> ["multiple possible overloaded functions variants, this should be catched by typechecker",<bagof-MostSpecificFunction>] //fails if not one element, should report error in the typechecking phase, now error here
          |}
       
  find-most-specific-signature-helper(|t_target):    
    t_check -> result{t_check}
    where newlist := <zip( {|NumberOfExtends: count-number-of-extends-traversals|} )> (<map(remove-sort-constructor-warn)>t_target, <map(remove-sort-constructor-warn)>t_check)
        ; result := newlist

  remove-sort-constructor-warn= remove-sort-constructor <+ debug(!"warning: cannot extract sort for this type, reverting to basic overloaded function lookup, ie exact match of argument types") 
  remove-sort-constructor : SimpleSort(s) -> s
  remove-sort-constructor : GenericSort(_,[SimpleSort(s)]) -> s

  count-number-of-extends-traversals:
    ("Object",t) -> -1  //not matching at all
    where not(t := "Object")

  count-number-of-extends-traversals:
    (t,t) -> <NumberOfExtends <+ !0>
    
  count-number-of-extends-traversals:
    (t_target,t_check) -> <count-number-of-extends-traversals> newtuple
    where not(t_target := t_check)
    with  newnumber := <add> (<NumberOfExtends <+ !0>,1)
        ; rules( NumberOfExtends := newnumber)
        ; newtuple := (<extends-check> t_target,t_check)
        
  compare-distances-for-overloading:
    x -> x
    where if not(MostSpecificFunction)
          then rules (MostSpecificFunction :+= x)
          else 
            if <map(is-more-specific-function(|x))> <bagof-MostSpecificFunction>
            then repeat(once-MostSpecificFunction);rules (MostSpecificFunction :+= x)
            else 
              if not(<map(is-less-specific-function(|x))> <bagof-MostSpecificFunction>)
              then rules (MostSpecificFunction :+= x)
              end
            end
          end
          
  is-more-specific-function(|new)=
    ?current
  ; !(new,current)
  ; zip(leq)
  
  is-less-specific-function(|new)=
    ?current
  ; !(new,current)
  ; zip(geq)
