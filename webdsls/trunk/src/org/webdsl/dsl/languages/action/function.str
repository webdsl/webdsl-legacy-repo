module org/webdsl/dsl/languages/action/function

imports
  libstrategolib
  libjava-front

imports
  libwebdsl-front
  org/webdsl/dsl/generation/webdsl-generator

strategies

  // @TODO: Rename this strategy
  aggregate-and-combine-functions =
    ?app@Application(qid, sections)
    ; globalfuncs := <filter(\ Section(_,defs) -> <filter(?Function(_, _, _, _))> defs \) ;concat> sections
    ; overloadedentityfuncs := <collect(find-entity-functions);concat> sections
    ; rules ( RenamedEntityFunctions := overloadedentityfuncs )
    ; overloadedglobalfuncs := <map(\ Function(nm, _, _, _) -> nm \); find-doubles; make-set> globalfuncs
    ; sections2 := <alltd(rename-overloaded-global-function(|overloadedglobalfuncs) <+ rename-overloaded-entity-function(|overloadedentityfuncs))> sections
    ; !Application(qid, sections2)

  find-entity-root =
    ?srt
    ; Extends
    ; if ?"Entity" then
        !srt
      else
        find-entity-root
      end

  find-entity-root =
    ?srt
    ; not(Extends)

  find-entity-functions :
    Entity(ent, _, entbodydecs) -> result
    with result := <filter(\ Function(nm, _, _, _) -> (<find-entity-root> ent, nm) \); find-doubles> entbodydecs

  find-entity-functions :
    EntityNoSuper(ent, entbodydecs) -> result
    with result := <filter(\ Function(nm, _, _, _) -> (ent, nm) \); find-doubles> entbodydecs

  rename-overloaded-entity-function(|torename) :
    Entity(ent, s, entbodydecs) -> Entity(ent, s, [prop1*,fun2*])
    with  fun1*  := <filter(is-function-cons)> entbodydecs
        ; prop1* := <filter(is-property-cons)> entbodydecs
        ; {| ThisEntity
          : rules( ThisEntity := ent )
          ; fun2* := <with-toplevel-name(alltd(rename-overloaded-entity-function(|torename)))> fun1*
          |}

  rename-overloaded-entity-function(|torename) :
    EntityNoSuper(ent, entbodydecs) -> EntityNoSuper(ent, [prop1*,fun2*])
    with  fun1*  := <filter(is-function-cons)> entbodydecs
        ; prop1* := <filter(is-property-cons)> entbodydecs
        ; {| ThisEntity
          : rules( ThisEntity := ent )
          ; fun2* := <alltd(with-toplevel-name(rename-overloaded-entity-function(|torename)))> fun1*
          |}

  rename-overloaded-entity-function(|torename) :
    Function(nm, farg*, rt, b) -> fun
    where <elem> ((<ThisEntity; find-entity-root>, nm), torename)
    with nm2 := <new-function-name> (nm, <map(\ Arg(_, srt) -> srt \)> farg*)
       ; b2 := <alltd(rename-overloaded-entity-function(|torename))> b
       ; fun := Function(nm2, farg*, rt, b2)
       ; <declare-function(|<ThisEntity>)> fun

  rename-overloaded-entity-function(|torename) :
    Call(e, nm, arg*) -> Call(e, nm2, arg*)
    where SimpleSort(ent) := <type-of> e
        ; <elem> ((<find-entity-root> ent, nm), torename)
    with nm2 := <new-function-name> (nm, <map(type-of)> arg*)

  rename-overloaded-entity-function(|torename) :
    ThisCall(nm, arg*) -> result
    where ent := <ThisEntity>
        ; <CheckFunctionSignature> (SimpleSort(ent), nm, <map(type-of)> arg*) // is call to member function of this entity
        ; <elem> ((<find-entity-root> ent, nm), torename)
    with  nm2 := <new-function-name> (nm, <map(type-of)> arg*)
        ; {| Rename:
            <rename-bound(|SimpleSort(ent))> "this"
          ; result := Call(<rename-all> Var("this"),nm2,arg*)
          |}

  rename-overloaded-global-function(|torename) :
    Function(nm, farg*, rt, b) -> fun
    where <elem> (nm, torename)
    with nm2 := <new-function-name> (nm, <map(\ Arg(_, srt) -> srt \)> farg*)
       ; b2 := <alltd(rename-overloaded-global-function(|torename))> b
       ; fun := Function(nm2, farg*, rt, b2)
       ; <declare-global-func> fun

  rename-overloaded-global-function(|torename) :
    ThisCall(nm, arg*) -> ThisCall(nm2, arg*)
    where <elem> (nm, torename)
    with t_arg* := <map(type-of)> arg*  
        ; if listof-t_arg* := <bagof-CheckGlobalFunctionSignatureArgumentTypes> (None(), nm, t_arg*)
          then t_argnew* := <find-most-specific-signature(|t_arg*,nm)> listof-t_arg*
          else t_argnew* := t_arg* // fall back to basic lookup for now when specific search fails, need to have a clear definition of compatible types vs inheritance
          end
        ; nm2 := <new-function-name> (nm, t_argnew*)
       
  new-function-name :
    (nm, argtypes) -> nm2
    with extra := <map(sort-to-string)> argtypes
         ; nm2 := <concat-strings> [nm, "__", <separate-by(|"__"); concat-strings> extra]

	// also allow new-function-name on formal arguments
	sort-to-string :
		Arg(_, srt) -> <sort-to-string> srt

  sort-to-string :
    SimpleSort(x) -> x

  sort-to-string :
    GenericSort(t, [t2]) -> <concat-strings> [t, "_", <sort-to-string> t2]

rules

	get-toplevel-name = ?Function(<id>, _, _, _)
	get-toplevel-name = ?FunctionNoReturn(<id>, _, _)
