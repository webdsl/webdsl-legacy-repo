module org/webdsl/dsl/languages/ui/for-loop

rules

  normalize-ui :
    ForSepNoFilter(x, s, e, te1*, te2*) -> ForSep(x, s, e, Filter(True(), OrderAscending(Null()), Limit(Int("1000"), Int("0"))), te1*, te2*)

  normalize-ui :
    ForNoFilter(x, s, e, te*) -> For(x, s, e, Filter(True(), OrderAscending(Null()), Limit(Int("1000"), Int("0"))), te*)

  normalize-ui :
    ForAllNoFilter(x, s, te*) -> ForAll(x, s, Filter(True(), OrderAscending(Null()), Limit(Int("1000"), Int("0"))), te*)

rules

  rename-ui :
    For(x, srt, e1, f1, elems1) -> For(y, srt2, e2, f2, elems2)
    with e2 := <rename-all> e1
       ; {| Rename
          : srt2   := <rename-all> srt
          ; y      := <rename-bound(|srt2)> x
          ; f2     := <rename-all> f1
          ; elems2 := <rename-all> elems1
          |}

  rename-ui :
    ForNoFilter(x, srt, e1, elems1) -> ForNoFilter(y, srt2, e2, elems2)
    with e2 := <rename-all> e1
       ; {| Rename
          : srt2   := <rename-all> srt
          ; y      := <rename-bound(|srt2)> x
          ; elems2 := <rename-all> elems1
          |}

  rename-ui :
    ForSep(x, srt, e1, f1, elems1, elems2) -> ForSep(y, srt2, e2, f2, elems3, elems4)
    with e2 := <rename-all> e1
       ; {| Rename
          : srt2   := <rename-all> srt
          ; y      := <rename-bound(|srt2)> x
          ; f2     := <rename-all> f1
          ; elems3 := <rename-all> elems1
          |}
          ; elems4 := <rename-all> elems2 // separator cannot refer to loop index

  rename-ui :
    ForSepNoFilter(x, srt, e1, elems1, elems2) -> ForSepNoFilter(y, srt2, e2, elems3, elems4)
    with e2 := <rename-all> e1
       ; {| Rename
          : srt2   := <rename-all> srt
          ; y      := <rename-bound(|srt2)> x
          ; elems3 := <rename-all> elems1
          |}
          ; elems4 := <rename-all> elems2 // separator cannot refer to loop index

  rename-ui :
    ForAll(x, srt, f1, elems1) -> ForAll(y, srt2, f2, elems2)
    with {| Rename
          : srt2   := <rename-all> srt
          ; y      := <rename-bound(|srt2)> x
          ; f2     := <rename-all> f1
          ; elems2 := <rename-all> elems1
          |}

  rename-ui :
    ForAllNoFilter(x, srt, elems1) -> ForAllNoFilter(y, srt2, elems2)
    with {| Rename
          : srt2   := <rename-all> srt
          ; y      := <rename-bound(|srt2)> x
          ; elems2 := <rename-all> elems1
          |}

rules

  constraint-error-ui : For(_, srt, e, _, _)            -> <for-constraint-error(|srt, e)>
  constraint-error-ui : ForNoFilter(_, srt, e, _)       -> <for-constraint-error(|srt, e)>
  constraint-error-ui : ForSep(_, srt, e, _, _, _)      -> <for-constraint-error(|srt, e)>
  constraint-error-ui : ForSepNoFilter(_, srt, e, _, _) -> <for-constraint-error(|srt, e)>
     
  for-constraint-error(|srt, e) :
    x -> <add-error(|[<pp-webdsl> e, " should be a collection of type ", <pp-webdsl> srt])>
    where not(GenericSort(_, [srt]) := <type-of> e)  
    
rules    

  rename-ui :
    ForCount(x, e1, e2, elems1) -> ForCount(y, e3, e4, elems2)
    with  e3 := <rename-all> e1
        ; e4 := <rename-all> e2 
        ; {| Rename
          : y := <rename-bound(|SimpleSort("Int"))> x
          ; elems2 := <rename-all> elems1
          |}    
    
  constraint-error-ui : ForCount(x, e1, e2, elems1) -> <expression-type-constraint(|SimpleSort("Int"))> e1
  constraint-error-ui : ForCount(x, e1, e2, elems1) -> <expression-type-constraint(|SimpleSort("Int"))> e2
    