module org/webdsl/dsl/languages/ui/desugar

strategies

  desugar-ui = PreDeriveInput <+ DeriveInput
  desugar-ui = DeriveOutput
  
rules //Desugar group, groupitems become rows, group becomes table

  desugar-ui :
    TemplateCall("group", args, passign*, elems1) -> TemplateCall("group", args, passign*, [TemplateCall("table",[],[],elems2)])
    where not([TemplateCall("table",_,_,_)] := elems1) // this is needed to avoid non-termination
        ; elems2 := <try(auto-surround-with-template(|"groupitem")); map(desugar-groupitem)> elems1
          
  desugar-groupitem :
    TemplateCall("groupitem", args,passign*, elems) -> TemplateCall("row",args,passign*, elems)

  desugar-ui = desugar-groupitem

rules //Desugar rows and tables

  desugar-ui :
    TemplateCall("table", args, passign*, elems) -> TemplateCall("table", args, passign*, elems2)
    where elems2 := <auto-surround-with-template(|"row")> elems

  desugar-ui :
    TemplateCall("row", args, passign*, elems) -> TemplateCall("row", args, passign*, elems2)
    where elems2 := <auto-surround-with-template(|"column")> elems

  desugar-ui: 
    [TemplateCall("dummy",_,_,elems)| xs] -> <concat>[elems, xs]

rules //Desugar label, which is a bit trick because it results in multiple elements

  desugar-ui :
    elem |[ label(e*)[passign*]{ elem* } ]| -> elem |[ dummy{ label(e*)[passign2*]{} container {elem2*} } ]|
    where not([] := elem*)
        ; [TemplateCall(name, args, assigns, elems) | others] := elem*
    with  nid := <newname> "forid_"
        ; passign2* := <concat>[[PropertyAssignment("for", String(nid))], passign*]  //generate for assignment
        ; assigns2  := <concat>[[PropertyAssignment("id", nid)], assigns]           //generate id assignment
        ; elem2*    := <concat>[[TemplateCall(name, args, assigns2, elems)], others]

  desugar-ui :
    elem |[ label(e*)[passign*]{ elem* } ]| -> elem |[ dummy{ label(e*)[passign*]{} container {elem*} } ]|
    where not([] := elem*)
        ; not([TemplateCall(_, _, _, _) | others] := elem*) //elems not empty, be neither a template call to refer to at the begining


rules //Desugar helpers 

  auto-surround-with-template(|childname) : //ensures that all elements are a templatecall to 'childname', 
    elems -> elems2                       //fails if this was the case already (so disugar knows it can continue)
    where not(<all(?TemplateCall(childname,_,_,_) <+ ?TemplateCall("form",_,_,_) <+ not(?TemplateCall(_,_,_,_)))> elems)
    with  elems2:= <map(try(auto-surround-with-template-replace(|childname)))> elems

  /*
  auto-surround-with-template-replace(|childname) :
    t -> TemplateCall(childname, [],[],[t])
    where not(TemplateCall(_,_,_,_) := t); not(ForAll(_, _, _) := t); not(For(_, _, _, _) := t)
  */
  
  auto-surround-with-template-replace(|childname) :
    t@TemplateCall(x,_,_,_) -> TemplateCall(childname, [],[],[t])
    where not(childname := x); not("form" := x)

  /*
  auto-surround-with-template-replace(|childname) :
    t -> t
    where TemplateCall(childname,_,_,_) := t
  */

