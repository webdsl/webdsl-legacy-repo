module org/webdsl/dsl/languages/ui/declare

imports
  libwebdsl-front
  org/webdsl/dsl/languages/-

strategies

  declare-ui = initial-declare-template-definition 
  declare-ui = initial-declare-page-definition 

strategies // inital declare for globally visible pages/templates

  initial-declare-page-definition :
    def@Define(mod*, _, _, _, _) -> <with(<declare-page-definition> def)>
    where <fetch(?Page())> mod*

  initial-declare-template-definition :
    def@Define(mod*, _, _, _, _) -> <with(<declare-toplevel-template-definition> def )>
    where not(<fetch(?Page())> mod*)
        ; not(<fetch(?Email())> mod*)

   /* no local declares here
  declare-template-definition :
    def |[ define mod* x(farg1*) { elem1* } ]| -> <declare-local-template-definition> def |[ define mod* x(farg1*) { elem1* } ]| 
    where (InPage <+ InTemplate)
        ; not(<fetch(?Page())> mod*)
        ; not(<fetch(?Email())> mod*)
    with {| InTemplate
          : <debug(!"local")> x;rules ( InTemplate := x )
          ; <alltd(declare-template-definition)> elem1*
          |}*/
          
rules

  IsPage = where(PageDecl)
  PageNames = all-keys-PageDecl

  declare-page-definition =
    ?def@Define(mod*, name, fargs, targs, body)
    ; where(<fetch(?Page())> mod*)
    ; with(common-declare-template-rules)
    ; where(with (
      t1* := <template-formal-arguments-to-types> fargs
      ; rules (
          CheckPageSignature : (Page(), name, t1*) -> InternalSort("Page")
          PageDecl :+ name -> def
        )
    ))
    
  AllTopLevelTemplateNames =
      all-keys-TopLevelTemplateDefinitions
  AllTopLevelTemplateArguments =
      bagof-TopLevelTemplateDefinitions
    ; map(TopLevelTemplateDecl; ?Define(_,_,<template-formal-arguments-to-types>,_,_))
    
  declare-toplevel-template-definition =
    ?def@Define(mod*, name, fargs, targs, body)
    ; where(not(<fetch(?Page())> mod*))
    ; where(not(<fetch(?Email())> mod*))
    ; with(common-declare-template-rules)
    ; where(with(
        t* := <template-formal-arguments-to-types> fargs
      ; n := <strip-annos> name
      ; y := <newname> n
      ; rules (
        TopLevelTemplateDefinitions :+ n -> (n, t*)
        OverloadedTemplateSignature : (n, t*) -> y    // not used
        TopLevelTemplateDecl :+ (n, t*) -> def
        CheckPageSignature : (Page(), n, t*) -> InternalSort("Template") // for ajax
       )
    ))
    
  //only finds exact match for types, no polymorphism
  get-exact-definition-from-sig(|name,argtypes) : 
    _ -> def
    with  n := <strip-annos> name
    where def := <TemplateSignature> (n,argtypes)
  get-exact-definition-from-sig-farg(|name,fargs) :
    _ -> result
    with  t* := <template-formal-arguments-to-types> fargs
        ; result := <get-exact-definition-from-sig(|name,t*)>


  declare-local-template-definition =
    ?def@Define(mod*, name, fargs, targs, body)
    ; where(not(<fetch(?Page())> mod*))
    ; where(not(<fetch(?Email())> mod*))
    ; with(common-declare-template-rules)
    ; where(with( 
        page := <InPage <+ InTemplate>
        ; t1* := <template-formal-arguments-to-types> fargs
        ; n := <strip-annos> name
        ; rules (
            LocalTemplateNames :+ page -> name
            LocalTemplateSignature : (n, t1*) -> def
            EnclosingDefinition : name -> page
          )
      ))
   
  is-local-template-def = where(?def@Define(mod*, name, fargs, targs, body); <fetch(Local())> mod*)
  
  common-declare-template-rules :
    def@Define(mods, name, fargs, targs, body){anno*} -> def
    with  t* := <template-formal-arguments-to-types> fargs
        ; n := <strip-annos> name
        ; genname := <generate-template-name> (n,t*)
        ; rules( TemplateSignature  : (n, t*) -> def
                 TemplateNewName : (n, t*) -> genname //used in overload resolution
                 TemplateDefinition : n // mainly used to check whether generated templates are defined manually
                 TemplateArguments  : genname -> fargs //used for determining which args in call are ref args
                 TemplateRequires   : (n, t*) -> targs
               )
        // use only the first declaration of each template
        // there will be multiple definitions, and the last will no longer have origin info
        ; try(not(<TemplateDecl> genname); rules(TemplateDecl : genname -> def))
        ; if <oncetd( // check for each variant of elements for robustness
            ?TemplateCallNoBody("elements",_)
            <+?TemplateCallNoArgs("elements")            
            <+?TemplateCallNoAssigns("elements",_,_)  
            <+?TemplateCallPropsNoBody("elements",_,_)
            <+?TemplateCallProps("elements",_)        
            <+?TemplateCallPropsNoArgs("elements",_,_)
            <+?TemplateCallBody("elements",_)   
            <+?TemplateCall("elements",_,_,_) 
            )> body then rules( TemplateContainsElementsCall : genname ) end
        ; <try(alltd(declare-in-template))> body
        // generics    TODO: simplified lookup for generics
        ; if <oncetd(?SimpleSort("EntityType"))> fargs then rules (TemplateWithGenerics : name) end

  IsDefinedAsAjaxTemplate =
    where(TemplateDecl; ?Define(<id>, _, _, _, _); fetch(?AjaxTemplate()))

strategies

  declare-page-action(|direct-enclosing-define-name) =
    ?def@Action(name, fargs, body)
    ; with( 
        t1* := <map(?Arg(_,<strip-ref-sort>))> fargs //don't include ref sort when comparing types
      )
    ; with(
        rules(
          ActionDefinition  : name -> def
          
          CheckActionSignature :
            (direct-enclosing-define-name, name, t2*) -> fargs
            where <zip(type-compatible)> (t1*, t2*)
        )
      )

rules

signature constructors
  PageArgNumbersAdded : Term
  
rules
      
  add-backend-annotation :
    def@Define(mod*, name, fargs, targs, body){defanno*} -> Define(mod*, name, fargs1, targs, body){PageArgNumbersAdded(),defanno*}
    where <fetch(Page <+ AjaxTemplate)> mod*
        ; not(<fetch(PageArgNumbersAdded)> defanno*)
    with  fargs1 := <add-farg-numbers> fargs

rules

  get-toplevel-name = ?Define(_, <id>, _, _, _)
   