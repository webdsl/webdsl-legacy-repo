module org/webdsl/dsl/languages/ui/constraints

imports
  libstrategolib

imports
  libwebdsl-front

rules // constraints

  //duplicate page names
  constraint-error-ui :
    Application(nm, sections) -> <add-error(|["Pages ", <separate-by(|",")> page*, " are defined multiple times"])> 
    where pages := <collect(?Define([Page()], _, _, _)); map(\ Define([Page()], nm, _, _) -> nm \)> sections
        ; page* := <find-doubles> pages
        ; not([] := page*)

// @todo: check for multiple definitions of templates
/*  constraint-error-ui :
    Application(nm, sections) -> <add-error(|["Pages ", templates*, " are defined multiple times"])>
    where templates := <collect(?Define([Template()], _, _, _)); map(\ Define([Page()], nm, _, _) -> nm \)> sections
        ; templates* := <find-doubles> templates
        ; not([] := templates*)

  constraint-error-ui :
    Define([Template()], name, args, body) -> <add-error(|["Template ", name, " with arguments ", args, " is defined multiple times"])>
    where <TemplateSignature> (name, <map(?Arg(_,<id>))> args)
*/

  constraint-error-ui :
    IfTempl(e, _, _) -> <add-error(|["Expression ", <pp-webdsl> e, " should be of type Bool"])>
    where not(SimpleSort("Bool") := <type-of> e)

  constraint-error-ui :
    IfNoElseTempl(e, _) -> <add-error(|["Expression ", <pp-webdsl> e, " should be of type Bool"])>
    where not(SimpleSort("Bool") := <type-of> e)

  constraint-error-ui :
    For(_, srt, e, _) -> <add-error(|[<pp-webdsl> e, " should be of list type of ", <pp-webdsl> srt])>
    where not(GenericSort(_, srt) := <type-of> e)
    
/* Ruben: nog bezig; weet niet hoe ik kan checken of iets een entity of een andere srt is.
  constraint-error-ui :
    webdsl|[ 
      define page x_id(x_o : srt) {
        stat*
      }
    ]| -> <add-error(|["Entity", <pp-webdsl> srt, " does not exist "])>
    where not(<IsEntity> srt)*/

rules // typechecking template definitions


   /* @TODO: what to do with this?
   typecheck-variable =
     ?ExternalScopeVar(_) // is already checked at this point
   typecheck-page-variable :
     ExternalScopeVar(x) -> ExternalScopeVar(x){Type(t)}
     where if not(t := <TypeOf> x) then
             typecheck-error(|["variable ", x, " has no declared type",111111])
             ; t := "Error"
           end
           
      */
/*
rules // typechecking for inits

  constraint-error-ui : 
    InitAction(body) -> <add-error(|["An init block can not contain a return statement."])>
    where not([] := <collect(?Return(_))> body)
*/