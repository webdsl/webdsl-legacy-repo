module org/webdsl/dsl/languages/ui/constraints

imports
  libstrategolib

imports
  libwebdsl-front
  org/webdsl/dsl/generation/webdsl-generator

rules

  constraint-error-ui :
    IfTempl(e, _, _) -> <add-error(|["Expression ", <pp-webdsl> e, " should be of type Bool"])>
    where not(SimpleSort("Bool") := <type-of> e)
        ; <type-of> e // don't report cascaded error, e should have valid type

  constraint-error-ui :
    IfNoElseTempl(e, _) -> <add-error(|["Expression ", <pp-webdsl> e, " should be of type Bool"])>
    where not(SimpleSort("Bool") := <type-of> e)
        ; <type-of> e // don't report cascaded error, e should have valid type

  constraint-error-ui :
    IfElseIfTempl(e, _, _, _) -> <add-error(|["Expression ", <pp-webdsl> e, " should be of type Bool"])>
    where not(SimpleSort("Bool") := <type-of> e)
        ; <type-of> e // don't report cascaded error, e should have valid type

  constraint-error-ui :
    ElseIfTempl(e, _) -> <add-error(|["Expression ", <pp-webdsl> e, " should be of type Bool"])>
    where not(SimpleSort("Bool") := <type-of> e)
        ; <type-of> e // don't report cascaded error, e should have valid type

rules

  constraint-error-ui :
    TemplateCase(e*, talt*) -> <add-error(|["case expression should have value type instead of ", t*])>
    where t* := <map(type-of)> e*
        ; not([] := <filter(not(is-constant-type))> t*)

  constraint-error-ui :
    s@TemplateCase(e*, talt*) -> s
    where t* := <map(type-of)> e*
        ; not(<filter(constraint-error-case-alt(|t*))> talt* => [])

  constraint-error-ui(|t1*) :
    s@TemplateCaseAlt(e*, elem*) -> 
    <add-error(|["constant in case alternative ", e*, 
                 " should have same type as case expression ", t1*])>
    where t2* := <map(type-of)> e*
        ; not(<zip(type-compatible)>(t1*,t2*))

rules		// redefining action

	// slightly inefficient: traversing entire tree for each def
	constraint-error-ui : Define(_,_,_,_,body) -> <fail>
		where (?Define(mods, xname,_,_,_); !xname)
		where actions := <collect(?Action(_,_,_))> body
				; action-names := <map(?Action(<strip-annos>,_,_))> actions
  	    ; double-names := <find-doubles> action-names
  	    ; double-actions := <filter(where(?Action(<strip-annos>,_,_); <member> (<id>, double-names)))> actions
  	    ; <map(add-double-action-error)> double-actions
  	   
	add-double-action-error: Action(name,_,_) -> <id>
		where add-error(|["action with name '",name,"' defined multiple times"])
		
rules 		// redefining toplevel name
	
	constraint-error-ui :
    Application(nm, sections) -> <fail>
    where //get all top-level defines (local defines are meant to be duplicate)
          defines := <collect-om(?Define(_, _, _, _, _))> sections 
         	// filter out all template defines with parameters: they are renamed with their arguments
        ; filtereddefines := <remove-all(?Define(<not(fetch(?Page() <+ ?Email()))>, _, <not(?[])>, _, _))> defines
        ; doubledefinenames := <map(?Define(_, <strip-annos>, _, _, _));find-doubles> filtereddefines
        ; not([] := doubledefinenames)
    with <map(try(constraint-error-define-names(|doubledefinenames)))> filtereddefines
  
  constraint-error-define-names(|doublenames):
    Define(mods,name,_,_,_) -> <add-error(|["Multiple definitions with name '", namestripped, "'."])> 
    where namestripped := <strip-annos> name
       ; <fetch(?namestripped)> doublenames
  