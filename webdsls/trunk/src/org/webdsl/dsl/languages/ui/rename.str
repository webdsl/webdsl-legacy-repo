module org/webdsl/dsl/languages/ui/rename

imports
	libwebdsl-front
	org/webdsl/dsl/generation/webdsl-generator

rules

  rename-ui :
    Define(mod*, x,farg1*, req*, elem1*){anno*} -> <declare-page-definition> Define(mod*, x, farg2*, req*, elem2*){anno*}
    where   <fetch(?Page())> mod*
    with {| Rename, InDef, InPage, RenameActionCall, VarInTemplateContext, TemplateArg, ReqTemplateSig
          : rules ( InDef := True() )
          ; rules ( InPage := x )
          ; rules ( TemplateArg := farg1* ) //used in template-call.str
          ; farg2* := <map(rename-argument)/*;declare-generic-template-args(|x)*/> farg1*
          //; empty-args-in-context
          ; <declare-args-in-context> farg2*
          ; <declare-require-sig> req*
          ; elem2* := <alltd(rename-actions(|x)); rename-all> elem1*
          ; rules ( TypeOf : x -> "Component" )
          |}

  rename-ui :
    Define(mod*, x,farg1*, req*, elem1*){anno*} -> <declare-toplevel-template-definition> Define(mod*, y, farg2*, req*, elem2*){anno*}
    where not(InPage <+ InTemplate)
        ; not(<fetch(?Page())> mod*)
        //; not(<elem> (Email(), mod*))
        ; not(<fetch(?Email())> mod*)
    with {| Rename, InDef, InTemplate, RenameActionCall, VarInTemplateContext, TemplateArg, ReqTemplateSig
          : rules ( InDef := True() )
          ; y := x{<newname> x}
          ; rules ( InTemplate := y )
          ; rules ( TemplateArg := farg1* )
          ; genargs := <get-generictype-args> farg1*
          ; farg2* := <map(rename-argument)/*;declare-generic-template-args(|x)*/> farg1*
          //; empty-args-in-context
          ; <declare-args-in-context> farg2*
          ; <declare-require-sig> req*
          ; elem2* := <alltd(rename-actions(|y)); rename-all> elem1*
          |}
        
  rename-ui :
    Define(mod*, x,farg1*, req*, elem1*){anno*} -> <declare-local-template-definition> Define(mod*, y, farg2*, req*, elem2*){anno*}
    where (InPage <+ InTemplate)
        ; not(<fetch(?Page())> mod*)
        ; not(<fetch(?Email())> mod*)
    with {| Rename, InDef, InTemplate, RenameActionCall, VarInTemplateContext, TemplateArg, ReqTemplateSig
         : rules ( InDef := True() )
         ; y := x{<newname> x}
         ; rules ( InTemplate := y )
         ; rules ( TemplateArg := farg1* )
         ; farg2* := <map(rename-argument)/*;declare-generic-template-args(|x)*/> farg1*
         ; <declare-args-in-context> farg2*
         ; <declare-require-sig> req*
         ; elem2* := <alltd(rename-actions(|y)); rename-all> elem1*
         |}

  get-requires :
  [] -> []
  
  get-requires :
  None() -> []
  
  get-requires :
  TemplateArgs(args) -> args
  
  //get-requires :
  //[x | xs ] -> [x | xs]
  
  declare-require-sig =
    get-requires
  ; map(declare-require-sig-internal)
    
  declare-require-sig-internal =
    ?d@TemplateArg(name, _)
  ; xsa := <strip-annos> name
  ; rules (ReqTemplateSig : xsa )
    
  /**
   *  ThisCall constructor is overloaded for action calls, function calls, page calls (refactor to different constructors to simplify rules)
   */
  rename-ui :
    t@ThisCall(fname,e2*){origanno*} -> t3
    where not(fname := "email")
    with  if   t2@ThisCall(f, e1*){anno*} := <RenameActionCall> t //try to invoke renameActionCall first, this will be replaced by the more specific ActionCall soon
          then parent := <fetch-elem(?DirectEnclosingDefine(<id>))> anno*
             ; t3 := ThisCall(f, e1*){ThisCallParent(parent),anno*} // might add multiple annos, TODO check whether parent declared and/or changed.
          else //try to find a parent, and put it in the annotations. fails if already defined above
               if parent:= SimpleSort(<InEntity>)
               then newanno* := [ThisCallParent(parent)|origanno*]
               else newanno* := origanno*
               end          
             ; e3* := <rename-all> e2*       
             ; t3 := ThisCall(fname, e3*){newanno*}
          end

  rename-ui :  // don't go into actions without proper scopes; actions are sometimes renamed without going through the whole template rename rule, in that case the action rule below is not used
  Action(nm1, args1, b1) -> Action(nm1, args2, b2)
  with {| Rename, VarInTemplateContext
        : args2 := <map(rename-argument)> args1
        ; b2 := <rename-all> b1
       |}
          
signature
  constructors

    DirectEnclosingDefine : String -> Anno
 
rules

  rename-actions(|direct-enclosing-define-name) = ?Define(_, _, _, _, _) // End of scope

  rename-actions(|direct-enclosing-define-name) :
    Action(nm1, args1, b1) -> Action(nm2, args2, b2)
    with {| Rename, VarInTemplateContext
          : args2 := <map(rename-argument)> args1
          ; b2 := <rename-all> b1
          |}
       ; nm2 := nm1{<context-rename> nm1}
       ; rules ( RenameActionCall : //TODO remove this variant when all type of actions calls are converted
                  ThisCall(nm1, a1*){anno*} -> ThisCall(nm2, a2*){DirectEnclosingDefine(direct-enclosing-define-name),anno*}
                  with  a2* := <rename-all> a1* 
               )
       ; rules ( RenameActionCall :
                  ActionCall(nm1, a1*){anno*} -> ActionCall(nm2, a2*){DirectEnclosingDefine(direct-enclosing-define-name),anno*}
                  with  a2* := <rename-all> a1*
               )
       ; <declare-page-action(|direct-enclosing-define-name)> Action(nm2, args2, b1)

//  rename = RenameActionCall

  rename-ui :
    InitAction(bl) -> InitAction(bl2)
    where not(InDef) //global init
    with {| InDef, Rename, VarInTemplateContext
          : rules (InDef := True())
          ; bl2 := <rename-all> bl
          |}
          
  rename-ui :
    InitAction(bl) -> InitAction(bl2)
    where InDef //in template
    with {| Rename, VarInTemplateContext
          : bl2 := <rename-all> bl
          |}
          
rules // naming

	// return name prefixed with toplevel definition
	toplevel-rename: name -> newname
		with contextname := <generate-template-name> (<InTemplate <+ InPage>, <TemplateArg; map(?Arg(_,<id>))>)
			 ; newname := <separate-by(|"_"); concat-strings; newname> [contextname, "_", name]
	
	// return name prefixed with all surrounding definitions	
  context-rename: name -> newname
  	with arguments := <bigbagof-TemplateArg; map(map(?Arg(_,<id>)))>
  		 // if in page, the first definition of TemplateArg will be the page's arguments
  		 ; if InPage then
  		  	pagenames := [<InPage>]
			 ; (templateargs, pageargs) := <split-last> arguments
		   else
		   	  pagenames := []
		   	; templateargs := arguments
		   end
  		 ; templates := <zip> (<bigbagof-InTemplate>, templateargs)
  		 ; templatenames := <map(generate-template-name); reverse> templates
  		 ; newname := <concat; separate-by(|"_"); concat-strings> [pagenames, templatenames, [name]]
	
	rename-argument :
    Arg(x, srt) -> Arg(y, srt2)
    with srt2 := <rename-type> srt
       ; y := <rename-bound(toplevel-rename|srt2)> x
	