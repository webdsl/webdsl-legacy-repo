module org/webdsl/dsl/languages/ui/rename

imports
  libwebdsl-front
  libstratego-lib
  org/webdsl/dsl/typechecker/-
  org/webdsl/dsl/transformation/-
  org/webdsl/dsl/languages/ui/-
  org/webdsl/dsl/languages/generic/-
  org/webdsl/dsl/languages/action/-
  org/webdsl/dsl/languages/action/typechecker/-
  org/webdsl/dsl/languages/data-model/-

signature
  constructors
    IsTemplateArg : Term

rules
  
  add-is-template-arg-anno :
    a{anno*} -> a{IsTemplateArg(),anno*}
    
  //pass to rename-all so vardecl is handled first
  is-var-decl-cons = ?VarDecl(_,_) <+ ?VarDeclInit(_,_,_) <+ ?VarDeclInitInferred(_,_)
  //pass to rename-all so local defines are ignored
  is-define-cons = ?Define(_, _, _, _, _)
  
  rename-ui :
    Define(mod*, x,farg1*, req*, elem1*){anno*} -> <store-renamed-actions-reqs> Define(mod*, x, farg2*, req*, elem2*){anno*}
    where   <fetch(Page)> mod*
    with {| Rename, InDef, InPage, RenameActionCall, VarInTemplateContext, TemplateArg, ReqTemplateFargTypes
          : rules ( InDef := True() )
          ; rules ( InPage := x )
          ; farg2* := <map(rename; add-is-template-arg-anno)> farg1*
          ; rules ( TemplateArg := farg2* ) //used in template-call.str
          //; empty-args-in-context
          ; <declare-args-in-context> farg2*
          ; <declare-require-sig> req*
          ; elem2* := <alltd(rename-actions(|x)); rename-all(is-var-decl-cons)> elem1*
          ; rules ( TypeOf : x -> "Component" )
          |}

  rename-ui :
    Define(mod*, x,farg1*, req*, elem1*){anno*} -> <store-renamed-actions-reqs> Define(mod*, y, farg2*, req*, elem2*){anno*}
    where not(InPage <+ InTemplate)
        ; not(<fetch(Page)> mod*)
        ; not(<fetch(Email)> mod*)
    with {| Rename, InDef, InTemplate, RenameActionCall, VarInTemplateContext, TemplateArg, ReqTemplateFargTypes
          : rules ( InDef := True() )
          ; y := x{<newname> x}
          ; rules ( InTemplate := y )
          ; genargs := <get-generictype-args> farg1*
          ; farg2* := <map(rename; add-is-template-arg-anno)> farg1*
          ; rules ( TemplateArg := farg2* )
          //; empty-args-in-context
          ; <declare-args-in-context> farg2*
          ; <declare-require-sig> req*
          ; elem2* := <alltd(rename-actions(|y)); rename-all(is-var-decl-cons)> elem1*
          |}
       
  get-enclosing-define-from-context :     
    _ -> EnclosingDefine(templatekey, page-or-template-name, template-arg)
    where not(InsideArgDefine)
        ; page-or-template-name := <InTemplate <+ InPage <+ InEmail>
        ; template-arg := <TemplateArg>
      <+ (page-or-template-name,template-arg) := <InsideArgDefine>
    with templatekey := (page-or-template-name, <!template-arg;map(?Arg(_,<id>))>) //need name,type* tuple of enclosing template, to retrieve actions during desugar
        
  rename-ui :
    Define(mod*, x,farg1*, req*, elem1*){anno*} -> <declare-local-template-definition; store-renamed-actions-reqs> Define(mod2*, y, farg2*, req*, elem2*){newanno2*}
    where (InPage <+ InTemplate)
        ; not(<fetch(Page)> mod*)
        ; not(<fetch(Email)> mod*)
    with  newanno* := <put-closure-in-anno> anno* //need closure for lifting the definition to top-level
        ; mod2* := <fetch(Local()) <+ ![Local() | <id>]> mod* // add if not present
    with  newanno2* := [ <get-enclosing-define-from-context> | newanno*]   
    with {| Rename, InDef, InTemplate, RenameActionCall, VarInTemplateContext, TemplateArg, ReqTemplateFargTypes
         : rules ( InDef := True() )
         ; y := x{<toplevel-rename> x}
         ; rules ( InTemplate := y )
         ; farg2* := <map(rename; add-is-template-arg-anno)> farg1*
         ; rules ( TemplateArg := farg2* )
         ; <declare-args-in-context> farg2*
         ; <declare-require-sig> req*
         ; elem2* := <alltd(rename-actions(|y)); rename-all(is-var-decl-cons)> elem1*
         |}

  store-renamed-actions-reqs: def@Define(_, name, farg*, req*, elem*) -> def
    with  // do not collect inside nested templates or template calls
          // remove position annos for better cache hit ratio
          actions := <collect(?Action(_,_,_)<+?Define(_,_,_,_,_)<+get-tc-elements);remove-all(not(?Action(_,_,_))); remove-position-annos> elem*
          //store under name; unique because of annotations, even for local redefinitions which have the same signature as a top-level def
        ; rules( TemplateActions : name -> actions )
          //same for requires
        ; rules( TemplateRequiresList : name -> req* )

  get-requires :
  [] -> []
  
  get-requires :
  None() -> []
  
  get-requires :
  TemplateArgs(args) -> args
  
  //get-requires :
  //[x | xs ] -> [x | xs]
  
  declare-require-sig =
    get-requires
  ; map(declare-require-sig-internal)
    
  declare-require-sig-internal =
    ?d@TemplateArg(name, fargtypes)
  ; xsa := <strip-annos> name
  ; rules (ReqTemplateFargTypes : xsa -> fargtypes)
    
  /**
   *  ThisCall constructor is overloaded for function calls
   */
  rename-ui :
    t@ThisCall(fname,_) -> t3
    where not("email" := fname)
    with  // Replace ThisCall(pagename) arguments with PageCall for built-ins like navigatebutton
          ThisCall(fname, e*){origanno*} := <try(thiscall-replace-page-arguments)> t
          //try to find a parent, and put it in the annotations. fails if already defined above
        ; if parent:= SimpleSort(<InEntity>)
          then newanno* := [ThisCallParent(parent)|origanno*]
          else newanno* := origanno*
          end          
        ; e3* := <rename-all> e*
        ; t3 := ThisCall(fname, e3*){newanno*}

  rename-ui :  
  // don't go into actions without proper scopes; actions are sometimes renamed without going 
  // through the whole template rename rule, in that case this rule is used and the action itself is not renamed
  a@Action(nm1, args1, b1) -> Action(nm1, args2, b2)
  with {| Rename, VarInTemplateContext, InActionContext
        : rules( InActionContext := a)
        ; args2 := <map(rename)> args1
        ; <declare-args-in-context> args2
        ; b2 := <rename-all> b1
       |}
          
signature
  constructors

    DirectEnclosingDefine : String -> Anno
 
rules

  rename-actions(|direct-enclosing-define-name) = ?Define(_, _, _, _, _) // End of scope

  rename-actions(|direct-enclosing-define-name) :
    a@Action(nm1, args1, b1) -> Action(nm2, args2, b2)
    with {| Rename, VarInTemplateContext, InActionContext
          : rules( InActionContext := a)
          ; args2 := <map(rename)> args1
          ; <declare-args-in-context> args2
          ; b2 := <rename-all> b1
          |}
       ; nm2 := nm1{<toplevel-rename> nm1}
       ; rules ( RenameActionCall :
                  ActionCall(nm1, a1*){anno*} -> ActionCall(nm2, a2*){DirectEnclosingDefine(direct-enclosing-define-name),anno*}
                  with  a2* := <rename-all> a1*
               )
       ; <with-origin(declare-page-action(|direct-enclosing-define-name) | a)> Action(nm2, args2, b1)

//  rename = RenameActionCall

  rename-ui :
    a@InitAction(bl) -> InitAction(bl2)
    where not(InDef) //global init
    with {| InDef, Rename, VarInTemplateContext, InActionContext:
          rules (
              InDef := True()
              InActionContext := a
          )
          ; bl2 := <rename-all> bl
          |}
          
  rename-ui :
    a@InitAction(bl) -> InitAction(bl2)
    where InDef //in template
    with {| Rename, VarInTemplateContext, InActionContext:
          rules(InActionContext := a)
          ; bl2 := <rename-all> bl
          |}
          
  rename-ui :
    Return(tc){anno*} -> <rename-all> Return(<this-call-to-page-call> tc){anno*}
    where InActionContext
 