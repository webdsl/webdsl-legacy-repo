module org/webdsl/dsl/languages/ui/templatecall

/**
 *  Rename and constraints on template calls. All template call variants are covered here.
 *  A new name for defined templates is stored in a dynamic rule, to cope with overloading.
 *  When a tcall calls a defined template the new name is stored in a dynamic rule which can be accessed using the renamed tcall name.
 *  This new name is applied in the rename-identifiers phase.
 */

imports
  
  libwebdsl-front
  libstrategolib
  org/webdsl/dsl/typechecker/-
  org/webdsl/dsl/transformation/emit
  org/webdsl/dsl/languages/ui/declare
  org/webdsl/dsl/languages/ui/rename
  org/webdsl/dsl/languages/ui/navigate
  org/webdsl/dsl/languages/ui/built-in-template
  org/webdsl/dsl/languages/action/overloading
  org/webdsl/dsl/languages/action/function-utils
  org/webdsl/dsl/modules/email

rules // declare

  declare-in-template =
    (
        ?TemplateCallPropsNoBody(_,_,passign*)
      <+?TemplateCallProps(_,passign*)
      <+?TemplateCallPropsNoArgs(_,passign*,elem*)
      <+?TemplateCall(_,_,passign*,elem*)
    )
    ; ?tc
    ; <declare-template-html-id(|tc)> passign*
    ; try(<alltd(declare-in-template)> elem*)

rules //rename rule for each templatecall variant
   
  rename-ui :
    tc@TemplateCallPropsNoBody(x1, arg1*, passign1*){anno*}
    -> TemplateCallPropsNoBody(x2, arg2*, passign2*){anno*}
    with  arg2*     := <try(templatecall-replace-page-args(|x1)); rename-all> arg1*
        ; x2 := <resolve-template-call-name> (x1,arg2*)
        ; passign2* := <rename-all> passign1*
        
  rename-ui :
    tc@TemplateCallProps(x1, passign1*){anno*}
    -> TemplateCallProps(x2, passign2*){anno*}
    with  x2 := <resolve-template-call-name> (x1,[])
        ; passign2* := <rename-all> passign1*
        
  rename-ui :
    tc@TemplateCallPropsNoArgs(x1, passign1*, elem1*){anno*}
    -> TemplateCallPropsNoArgs(x2, passign2*, elem2*){anno*}
    with  x2 := <resolve-template-call-name> (x1,[])
        ; elem2*    := <rename-all> elem1*
        ; passign2* := <rename-all> passign1*
            
  rename-ui :
    tc@TemplateCall(x1, arg1*, passign1*, elem1*){anno*}
    -> TemplateCall(x2, arg2*, passign2*, elem2*){anno*}
    with  arg2*     := <try(templatecall-replace-page-args(|x1)); rename-all> arg1*
        ; x2 := <resolve-template-call-name> (x1,arg2*)
        ; elem2*    := <rename-all> elem1*
        ; passign2* := <rename-all> passign1*        
        
  rename-ui :
    tc@TemplateCallNoBody(x1, arg1*){anno*}
    -> TemplateCallNoBody(x2, arg2*){anno*}
    with  arg2* := <try(templatecall-replace-page-args(|x1)); rename-all> arg1*
        ; x2 := <resolve-template-call-name> (x1,arg2*)
        
  rename-ui : 
    tc@TemplateCallNoArgs(x1){anno*}
    -> TemplateCallNoArgs(x2){anno*}
    with  x2 := <resolve-template-call-name> (x1,[])
  
  rename-ui : 
    tc@TemplateCallNoAssigns(x1, arg1*, elem1*){anno*}
    -> TemplateCallNoAssigns(x2, arg2*, elem2*){anno*}
    with  arg2*  := <try(templatecall-replace-page-args(|x1)); rename-all> arg1*
        ; x2 := <resolve-template-call-name> (x1,arg2*)
        ; elem2* := <rename-all> elem1*
  
  rename-ui : 
    tc@TemplateCallBody(x1, elem1*){anno*}
    -> TemplateCallBody(x2, elem2*){anno*}
    with  x2 := <resolve-template-call-name> (x1,[])
        ; elem2* := <rename-all> elem1*

rules //template call either refers to a defined template, or to a built-in template, otherwise it is an error

  resolve-template-call-name :
    (x,arg*) -> x1
    with  x1 := x{<toplevel-rename> x}
        //; <debug> x; <debug> arg*; <debug> <InTemplate<+InPage<+InEmail<+!"unknown context">; <debug> x1; <debug> "\n"
        ; if not(InTypeCheckingPhase) 
          then with(<map(type-of <+ debug(!"cannot determine type of argument (type-of rule fails): ");fail) 
                     <+ <debug(!"error in templatecall found during model-to-model: ")> (x,arg*);fail> arg*) end //extra check in case model-to-model produces bad code
        ; !(x1,arg*)
        ; (  rename-template-call-name-required(|x)
           <+rename-template-call-name-defined-unique
           <+rename-template-call-name-defined
           <+rename-template-call-name-builtin
           <+rename-template-call-name-error
          )
        // collect variables for template closure
        ; oldvars := <CallContextVars <+ ![]> x
        ; if InTemplate <+ InPage <+ InEmail
          then vars := <bigbagof-VarInTemplateContext> //whole def renamed, collect environment
          else vars := <rename-all> oldvars //only this part renamed, only apply rename
          end
        ; rules ( CallContextVars : x1 -> vars )
        //collect actions for template closure
        ; ( //only for page and regular templates, not other template types like email
            //stores the key of the surrounding template
            //first check InTemplate, then InPage, because both InPage and InTemplate are defined when handling a local define inside a page
            templatekey := (<InTemplate <+ InPage;strip-annos>, <TemplateArg;map(?Arg(_,<id>))>)
          ; rules ( CallContextActionsKey : x1 -> templatekey )
          ; rules ( CallRequiresKey       : x1 -> templatekey )
          <+ 
            rules ( CallContextActionsKey : x1 -> None() )
          ; rules ( CallRequiresKey       : x1 -> None() )
            
          )
          
  rename-template-call-name-defined : 
    (x,arg*) -> x
    where xsa := <strip-annos> x
        ; name := <resolve-overloaded-template> (xsa,arg*,x) 
    with  rules ( CallToDefinedTemplate : x -> name )
        ; <store-enclosing-define-for-template-call> x 
          
  //used in translation of elements call to determine which ac rules to inherit 
  store-enclosing-define-for-template-call :  
    x -> x  
    with  if InTemplate <+ InPage
          then  enclosing-define := <get-enclosing-define-from-context> 
              ; rules ( DefinedTemplateGetEnclosingDefine : x -> enclosing-define )
          else if InEmail
               then rules ( DefinedTemplateGetEnclosingDefine : x -> Email() )
               end
          end
    
  /**
   *  Some template names are generated uniquely so no need for overloading, see desugar of ArgDef below
   */ 
  rename-template-call-name-defined-unique : 
    (x,arg*) -> x
    where xsa := <strip-annos> x
        ; name := <UniqueNameTemplateCall> xsa
    with  rules ( CallToDefinedTemplate : x -> name )
        ; <store-enclosing-define-for-template-call> x 

  rename-template-call-name-required(|x_old) : 
    (x,arg*) -> x
    where if (InTemplate <+ InPage) then
          xsa := <strip-annos> x
        ; <ReqTemplateSig> xsa
        else 
          <CallToRequiredTemplate> x_old //if not in rename, or only part of the page/template is renamed, the required calls cannot be resolved, this checks whether this call was already resolved in an earlier rename phase
        end        
    with  rules ( CallToRequiredTemplate : x )

  rename-template-call-name-builtin :
    (x,arg*) -> x
    where t* := <map(type-of)> arg*
        ; xsa := <strip-annos> x
        ; <CompatibleWithBuiltInTemplate> (xsa,t*)
    with  rules ( CallToBuiltInTemplate : x )
  
  rename-template-call-name-error : 
    (x,arg*) -> x
    with  rules ( IncorrectTemplateCall : x )
        ; if not(InTypeCheckingPhase) then //if no longer typechecking this is an error in the compiler
            <fatal-err(|"Error found during compilation: template call is not valid")> (x,arg*)
          end
     
  /**
   *  overloading resolution for template calls, resolved during rename
   *  template arguments needs explicit types no overloading resolution there
   *  x:strip-annos name
   *  arg* : farglist
   *  x1 : name with anno
   */
  resolve-overloaded-template :
  (x,arg*,x1) -> name
  where templates := <AllTopLevelTemplateArguments> x
      ; t_target := <map(type-of;strip-annos)> arg* 
      ; resolvedarg* := <find-most-specific-signature(|t_target,x1)> templates
      //each template is renamed for overloading, the arg types are appended to the name:
      ; name := <TemplateNewName>(x,resolvedarg*)     

strategies

  //given a list of property assignmenst and a corresponding templatecall, it declares HtmlEntityId if a "id" property exists
  declare-template-html-id(|tc) =
     all({x, y : 
         ?PropertyAssignment("id", x) ;rules( HtmlEntityId :+ x -> tc )
         <+ !"something" //build something
         })

rules // using page as template produces error; tested in fail/pageastemplate.app

  constraint-error-templatecall(|p,arg*) = constraint-error-page-as-template(|p)
   
  constraint-error-page-as-template(|p) :
    tc -> <add-error(|["Cannot use page as template: ",<pp-webdsl> p])>
    where <IncorrectTemplateCall> p //not a valid template call
    where <strip-annos;IsPage> p //but could be trying to invoke a page
 
rules //template not defined

  constraint-error-templatecall(|p,arg*) :
    x -> <add-error(|err*)>
    where <IncorrectTemplateCall> p
        ; if <ErrorDuringOverloadResolution> p
          then err* := <ErrorDuringOverloadResolution>
          else err* := ["Template with signature ",<pp-func-sig> (p,<map(type-of)>arg*)," not defined "] end
    
  constraint-error-ui = ?tc@TemplateCallNoBody(p,arg*)       ;where(<constraint-error-templatecall(|p,arg*)> tc)
  constraint-error-ui = ?tc@TemplateCallNoArgs(p)            ;where(<constraint-error-templatecall(|p,[]  )> tc)
  constraint-error-ui = ?tc@TemplateCallNoAssigns(p,arg*,_)  ;where(<constraint-error-templatecall(|p,arg*)> tc)
  constraint-error-ui = ?tc@TemplateCallPropsNoBody(p,arg*,_);where(<constraint-error-templatecall(|p,arg*)> tc)
  constraint-error-ui = ?tc@TemplateCallProps(p,_)           ;where(<constraint-error-templatecall(|p,[]  )> tc)
  constraint-error-ui = ?tc@TemplateCallPropsNoArgs(p,_,_)   ;where(<constraint-error-templatecall(|p,[]  )> tc)
  constraint-error-ui = ?tc@TemplateCallBody(p,_)            ;where(<constraint-error-templatecall(|p,[]  )> tc)
  constraint-error-ui = ?tc@TemplateCall(p,arg*,_,_)         ;where(<constraint-error-templatecall(|p,arg*)> tc)
 

rules // desugar 'elements' template argument for defined template calls

  desugar-ui :
    tc@TemplateCall(x,arg*,passign*,TemplateBody(elem*)){anno*} -> TemplateCall(x,arg*,[elementscall|passign*],TemplateBody([])){anno*} 
    where <CallToDefinedTemplate;TemplateContainsElementsCall> x
        ; not(<fetch(?TemplateCall(_,_,_,_))> passign*)
    with  x_newtempl := <toplevel-rename> "templateargument"
        ; vars := <CallContextVars> x
        ; farg* := <map(?Var(<!Arg(<id>, <type-of; if where({?_{anno_type*};<fetch(ImmutableReference)>anno_type*}) then strip-annos else strip-annos;!RefSort(<id>) end> Var(<id>))>))> vars //make all 'elements' arguments Ref args, unless the type has ImmutableReference annotation (e.g. because it belong to a for loop iterator)
        ; requires* := <CallRequiresKey;(TemplateRequires <+ ![])> x
        ; if EnclosingDefine(templatekey, encltemplatename, encltemplateargs) := <DefinedTemplateGetEnclosingDefine> x
          then
            action* := <TemplateActions <+ ![]> encltemplatename
          ; additionalaction* := <EnclosingDefinition; TemplateActions <+ ![]> encltemplatename //when the elements were lifted from a nested local redefinition, the enclosing actions need to be retrieved as well
          ; allaction* := [action*,additionalaction*]
          ; defelem* := [ AccessControlImportRules(encltemplatename,<map(get-varname-from-formarg)> encltemplateargs) | [elem*, allaction*] ]
          else
            Email() := <DefinedTemplateGetEnclosingDefine> x
          ; defelem* := elem*
          end
        ; <emit-webdsl-code> Define([NoSpan()], x_newtempl, farg*, requires*, defelem*)
        ; elementscall:=<rename-all> TemplateCall(x_newtempl,vars,[],TemplateBody([])) //encode as regular template call, so it gets renamed correctly in transformation/rename-identifiers.str

  desugar-ui :
    tc@TemplateCall(x,arg*,passign,TemplateWith(argdef*)) -> TemplateCall(x,arg*,passign2,TemplateBody([])) 
    with elementscall := <map(desugar-argdef(|x))> argdef*
       ; passign2 := <conc>(elementscall, passign)

rules        

// version without dynscope 
/*
  desugar-argdef(|templatename) :
    ArgDefine(x,origfarg,elem*) -> TemplateCall(x_newtempl, [],[ResolvedRequireKey(x)],TemplateBody([]))
    with x_newtempl := <conc-strings; newname> (x,"_argdef")
        ; action* := <CallContextActionsKey;(TemplateActions <+ ![])> templatename
        ; requires* := <CallRequiresKey;(TemplateRequires <+ ![])> templatename
        ; defelem* := [elem*, action*]
        ; <emit-webdsl-code> Define([NoSpan()], x_newtempl, origfarg, requires*, defelem*) 
         //  a special templatecall that only needs resolving by name, since the name is uniquely generated
         //  produces the name that should be used to look up the template in the hashmap
        ; t* := <map(?Arg(_,<id>))> origfarg
        ; rules (   
            UniqueNameTemplateCall : x_newtempl -> <generate-template-name> (x_newtempl,t*)
          )
*/

/* implementation which supports the usage of outlying variables in with definitions: e.g:
  template x() {
    var s: String := "abc"
    y() with {
      z() { output(s) }
    }
  }
*/            
  desugar-argdef(|templatename) :
    ArgDefine(x,origfarg*,elem*) -> TemplateCall(x_newtempl, var*,[ResolvedRequireKey(x)],TemplateBody([]))
    with x_newtempl := <conc-strings; toplevel-rename> (x,"_argdef")
        ; var* := <CallContextVars> templatename
        ; farg* := <map(?Var(<!Arg(<id>, <type-of> Var(<id>))>))> var*
        ; action* := <CallContextActionsKey;(TemplateActions <+ ![])> templatename
        ; requires* := <CallRequiresKey;(TemplateRequires <+ ![])> templatename
        ; defelem* := [elem*, action*]
        ; <emit-webdsl-code> Define([NoSpan()], x_newtempl, [origfarg*, farg*], requires*, defelem*) 
         // a special templatecall that only needs resolving by name, since the name is uniquely generated
         //  produces the name that should be used to look up the template in the hashmap
        ; t* := <map(?Arg(_,<id>))> [origfarg*, farg*]
        ; namewithargtypesappended :=  <generate-template-name> (x_newtempl,t*)
        ; rules (   
            UniqueNameTemplateCall : x_newtempl -> namewithargtypesappended
            IsArgDefineInWithTemplateCall : namewithargtypesappended 
          )
  
        /*; x_newtempldelegator := <conc-strings; newname> (x,"_argdef_delegate")
        ; origvar* := <map(?Arg(<!Var(<id>)>,_))> origfarg*
        ; <emit-webdsl-code> Define([NoSpan()], x_newtempldelegator, origfarg*, None(), TemplateBody([ TemplateCall(x_newtempl, [origvar*,var*],[],TemplateBody([])) ]) )
        */
/*  desugar-ui :
    tc@TemplateCall(x,arg*,passign*,Template(elem*)) -> TemplateCall(x,arg*,[elementscall|passign*],TemplateBody([])) 
    where <CallToRequiredTemplate> x
        ; not(<fetch(?TemplateCall(_,_,_,_))> passign*)
    with  x_newtempl := <newname> "templateargument"
        ; vars := <CallContextVars> x
        ; farg* := <map(?Var(<!Arg(<id>, <type-of> Var(<id>))>))> vars
        ; action* := <CallContextActionsKey;(TemplateActions <+ ![])> x
        ; defelem* := [elem*, action*]
        ; <emit-webdsl-code> Define([NoSpan()], x_newtempl, farg*, None(), defelem*)
        ; elementscall := TemplateCall(x_newtempl,vars,[],[]) //encode as regular template call, so it gets renamed correctly in transformation/rename-identifiers.str
*/

  built-in-template-rule-setup = <declare-built-in-template-rules> ("elements",[]);fail

rules

  add-backend-annotation =
      ?PageCall(p, args)
    ; not("url" := p)
    ; with(
        strippedpagename := <strip-annos> p
      ; def |[ define mod* x(farg*) req* { elem* } ]| := <TemplateSignature> (strippedpagename, <map(type-of);strip-annos> args)
     )
    ; add-new-anno(|PageArgsAnno(farg*))
    