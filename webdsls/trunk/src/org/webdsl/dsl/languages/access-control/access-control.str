/**

 Security rules for WebDSL

*/

module org/webdsl/dsl/languages/access-control/access-control

imports
  libstrategolib
  libjava-front

imports
  libwebdsl-front
  org/webdsl/dsl/typechecker/-
  org/webdsl/dsl/transformation/-
  org/webdsl/dsl/languages/access-control/-

rules

  is-toplevel-elem = ?AccessControlPrincipal(_,_)

rules
  
  AccessControlEnabled = where(PrincipalDecl)
  
  access-control-stage =
    {| ActionRulePageArgs:
        process-access-control
      ; if AccessControlEnabled then
          process-access-control-checks
          //add functions generated by ac rules
        ; desugar-top
        end
    |}
    
rules
  
  is-page-define :
    d@Define(mod*,_,_,_,_) -> d
    where <fetch(Page)> mod*
  
  process-access-control=
    if AccessControlEnabled then
        alltd(new-generate-access-control-rules-checks)

      //topdown that does all the global checks, nested checks are handled when normal checks are applied
      ; alltd( let f(s) = foldl(s <+ Snd) in fold-WeaveAccessControlPage(f) end) //doesn't apply to templates in page definitions
      ; alltd( is-page-define <+ let f(s) = foldl(s <+ Snd) in fold-WeaveAccessControlTemplate(f) end) //doesn't apply to templates in page definitions      
      ; alltd( let f(s) = foldl(s <+ Snd) in fold-WeaveAccessControlAction(f) end)
        //hack to cope with multiple function rules matching same functioncall, otherwise only first will be applied because of transformation
         /*;  alltd({| func-check-group, func-check-exp:
            let f(s) = foldl(s <+ Snd)
             in fold-WeaveAccessControlFunction(f) end
                  ; repeat({x:?x;!ACFunctionCheck(<once-func-check-group>,<once-func-check-exp>,x)}) 
                  |} )
           */
         
      //should be done at least before template expansion
      ; alltd(   is-page-define //ignore the defs inside pages
              <+ process-template-checks)  //TODO embed proces actions in order to get inference
              
      //problem: template actions are handled earlier and this removes the acactioncheck, after template expansion the page actions are handled (which the template action has become) and since there is no longer an acactioncheck it becomes a false check around the earlier added template check
      //solution: do the page actions before template expansion too
      ; alltd(process-page-actions<+process-template-actions)
    end
  ; alltd(remove-all( ?AccessControlDefinition(_,_) ))
    
  new-generate-access-control-rules-checks=
    ?webdsl|[ access control rules x_groupname acdef* ]|
  ; with ( <map(   create-page-rule(|x_groupname) 
                <+ create-template-rule(|x_groupname)
                <+ create-action-rule(|x_groupname,[],[])
              //  <+ create-function-rule(|x_groupname)
                <+ ?AccessControlPointcut(_,_,_)
                <+ {x:?x; !["error: access control definition unknown: ",x];debug}
                   )> acdef*
    )
                  
  get-formarg-from-matcharg:
    MatchArgs(formarg,wc)->formarg
  
  match-arguments=
    ?(fargrule,farg*)
    ; newfargs := <?MatchArgs(args,wc);!args> fargrule
    ; getWC := <?MatchArgs(args,wc);!wc> fargrule
    ; if <?None()> getWC 
      then newfarg* := farg*
      else newfarg* := <take(<length> newfargs)> farg* end
    ; <zip(extract-sorts;eq)> (newfargs,newfarg*)
  
  extract-sorts:
    (Arg(ident1,thesort1),Arg(ident2,thesort2)) -> (<strip-ref-sort> thesort1,<strip-ref-sort> thesort2)
    
  match-names:
    tup@(matchstring,name) -> tup
    where
    if not(matchstring := "*")
    then
        leftmatcher := <explode-string;reverse;drop-until(?'*');drop-while(?'*');reverse> matchstring
        ; if leftmatcher := [] 
          then // no * in the name, explicit match
               matchstring := name
          else //left-match: Succeeds if the first list of terms starts with the second list of terms.
               //            Returns the suffix of the first list that is not matched.
               <left-match> (<explode-string> name,leftmatcher)
          end
    end    
  
rules // create & emit predicate (optimization: return dummy predicate if condition is always true)
  
  create-pred-from-exp(|farg*, type, x_name):
    True() -> <dummy-pred-name>
  
  create-pred-from-exp(|farg*, type, x_name): e -> x_predname
    with	x_predname := <get-pred-id> (<concat-strings> ["gen",type,"predicate_"], x_name)
          //null checks are added to predicates automatically
        ; <emit-webdsl-code> def|[ predicate x_predname(farg*) { e } ]|
          
rules // pages 
  
  create-page-rule(|x_rulegroup):
    rule@acrule|[ rule page x_pagematchname(margs) { e acrule* } ]| -> rule
    with  rules(AccessControlRuleDeclared :+= rule)
        ; farg_match* := <get-formarg-from-matcharg> margs
        ; x_predname := <create-pred-from-exp(|farg_match*, "page", x_pagematchname)> e
        ; {| AccessControlWeavingName:
              rules(AccessControlWeavingName := x_pagematchname)
            ; actionpred_name* := <map(create-action-predicate(|x_rulegroup, farg_match*))> acrule*
          |}
        ; actionpred* := <zip> (acrule*, actionpred_name*)
        ; create-page-rule-helper(|rule, x_pagematchname, margs, <length> farg_match*, x_predname, x_rulegroup, actionpred*) 
        // a tempate can inherit the check from a page, necessary for lifting local defines
        ; create-template-rule-helper(|
            rule,  // actually a page rule in this case, but mainly used for warning about unused rules 
            "template", // only regular templates, not for ajax templates @TODO constraint
            x_pagematchname, // should not match directly, only through import of page ac rules
            margs, // also should not match directly
            <length> farg_match*, // number of args used in check
            x_predname, // name of generated ac check function
            x_rulegroup, //  group of ac function
            actionpred*, // nested rules (action)
            False() // no direct match allowed
            )
          
  create-page-rule-helper(|rule, x_pagematchname, margs, farg_length, x_predname, x_rulegroup, actionpred*) =
          rules( WeaveAccessControlPage :+
            def|[ define mod* x_pagename(farg*)  req* { elem* } ]| -> 
            def|[ define mod* x_pagename(farg*)  req* { elem_acpagecheck elem1* } ]|
              where <fetch(Page)> mod*
                  ; not(<fetch(IgnoreAccessControl)> mod*)
              where match-ac-rule-sig(|x_pagematchname, margs, x_pagename, farg*)
                  ; with(e* := <map(get-varname-from-formarg); take(|farg_length)> farg*) //no include of rules, add the page arguments
                 <+ extraruleargs := <matching-import-ac-rules-def(|x_pagematchname, margs, elem*)>
                  ; with(e* := <take(|farg_length)> extraruleargs) //other arguments have to be used when including rules
              with expr_check := ThisCall(x_predname, e*)
                  ; elem_acpagecheck := TemplateCall("acpagecheck",[Var(x_rulegroup),expr_check],[],TemplateBody([])){rule}
                    //nested actions
                  ; {| WeaveAccessControlAction:
                       extraargs := <map(try(\Var(nm)->ExternalScopeVar(nm)\))> e*
                    ; <map(\ (rule,actionpredname) -> <create-action-dr(|x_rulegroup,extraargs,actionpredname)> rule\)> actionpred*
                    // alltd is enough because global checks are handled already in
                    // the normal traversal, and deeper nested checks are handled in
                    // the parent checks again
                    ; elem1* := <alltd( let f(s) = foldl(s <+ Snd) in fold-WeaveAccessControlAction(f) end)> elem*
                  |}
            )
            
  matching-import-ac-rules-def(|matchname, margs, elem*) :
    x -> extraruleargs
    where ruleimports := <collect(?AccessControlImportRules(_,_))> elem*
        ; <not(?[])> ruleimports // if empty, fail
        ; AccessControlImportRules(_,extraruleargs) := <fetch-elem(match-ac-import-rule(|matchname, margs))> ruleimports
      
  match-ac-import-rule(|matchname, margs) :
    a@AccessControlImportRules(x_defname,arg*) -> a
    where farg* := <vars-to-fargs> arg*
        ; match-ac-rule-sig(|matchname, margs, x_defname, farg*)

  vars-to-fargs = map(var-to-farg)
  var-to-farg : 
    v@Var(x) -> Arg(x,type)
    with type := <type-of> v
      
  match-ac-rule-sig(|matchname, margs, x_defname, farg*) =
    where( <match-names> (matchname, <strip-annos> x_defname)
         ; <match-arguments> (margs, <strip-all-annos> farg*)
         )

rules // actions

  create-action-rule(|x_rulegroup,farg_page*,nestingvars) =
      where(x_predname := <create-action-predicate(|x_rulegroup,farg_page*)>)
    ; create-action-dr(|x_rulegroup,nestingvars,x_predname)
    
  create-action-predicate(|x_rulegroup,farg_page*):
    r@acrule|[ rule action x_actionmatchname(margs) { e acrule* } ]| -> x_predname
    with  rules(AccessControlRuleDeclared :+= r)
          // Use parent page/template name if available
        ; x_name := <concat-strings> [<AccessControlWeavingName; ![<id>,"_"]; concat-strings <+ !"">, x_actionmatchname]
        ; farg_actionrule* := <get-formarg-from-matcharg> margs
        ; (farg_page_subst*,e1) := <substitute-parent-vars-1> (farg_page*,e)
        ; farg_pred* := [farg_page_subst*,farg_actionrule*] //special: * at end of name inlines contents in list
        ; x_predname := <create-pred-from-exp(|farg_pred*, "action", x_name)> e1 
        // Remember number of page args for weaving the calls
        ; n_pageargs := <length> farg_page*
        ; rules(ActionRulePageArgs : x_predname -> n_pageargs)
        
  /**
   *  pass extraargs, since other template's arguments might to be passed to the check
   */
  create-action-dr(|x_rulegroup,extraargs,x_predname):
    r@acrule|[ rule action x_actionmatchname(margs) { e acrule* } ]| -> r
      with 
        specifiedargcount := <get-formarg-from-matcharg; length> margs
        ;	rules(   
            WeaveAccessControlAction :+
              elem|[ action x_actionname(farg*) { stat* } ]| -> 
              elem|[ action x_actionname(farg*) { e_acactioncheck;
                                                  stat* } ]|
              where <match-names> (x_actionmatchname,<strip-annos>x_actionname)
                  ; <match-arguments> (margs,<map(strip-annos)>farg*)
                  //take length of specified arguments, these became the predicates formal arguments
              with  e* := <concat> [extraargs,<map(get-varname-from-formarg);take(|specifiedargcount)> farg*]
                  ; e_check := ThisCall(x_predname,e*){ExtraArgsForImportAC(extraargs)}
                  ; e_acactioncheck := ThisCall("acactioncheck",[Var(x_rulegroup),e_check]){r}
          )
signature
  constructors
    ExtraArgsForImportAC : Term -> Term
rules // template

  create-template-rule(|x_rulegroup):
    rule@AccessControlRule(ruletype, x_templatematchname, margs, e, acrule*) -> rule
    where <?"template" <+ ?"ajaxtemplate";?isajaxtemplate> ruletype
    with  rules( AccessControlRuleDeclared :+= rule )
        ; farg_match* := <get-formarg-from-matcharg> margs
        ; x_predname := <create-pred-from-exp(|farg_match*, "template", x_templatematchname)> e
        ; {| AccessControlWeavingName:
              rules(AccessControlWeavingName := x_templatematchname)
            ; actionpred_name* := <map(create-action-predicate(|x_rulegroup, farg_match*))> acrule*
          |}
        ; actionpred* := <zip> (acrule*, actionpred_name*)
        //bind for more efficient dr retrieval, doesn't seem to work like this
        //; if <explode-string;not(elem('*'))> x_templatematchname then x_templatename:=x_templatematchname end
        ; create-template-rule-helper(|rule, ruletype, x_templatematchname, margs, <length> farg_match*, x_predname, x_rulegroup, actionpred*, True())
               
  /**
  create-template-rule-helper
    rule: the ac rule
    ruletype: template/ajaxtemplate
    x_templatematchname: name of template
    margs: arguments to match
    farg_length: length of arguments in check
    x_predname: name of generated ac check function
    x_rulegroup: group of ac function
    actionpred*: nested rules (action)
    direct_match_allowed: only allow direct match if True(), for template importing page check a direct match is not allowed
  */
  create-template-rule-helper(|rule, ruletype, x_templatematchname, margs, farg_length, x_predname, x_rulegroup, actionpred*, direct_match_allowed) =
        rules( WeaveAccessControlTemplate :+
                  def|[ define mod* x_templatename(farg*)  req*  { elem*  } ]| -> 
                  def|[ define mod* x_templatename(farg*)   req* { elem_actemplatecheck
                                                                   elem1* } ]|
                  where not(<fetch(?Page())> mod*)
                      ; not(<fetch(?Email())> mod*)
                      ; not(<fetch(?IgnoreAccessControl())> mod*)
                  where  if <?"ajaxtemplate">ruletype then <fetch(AjaxTemplate)> mod* else not(<fetch(AjaxTemplate)> mod*) end
                       ; match-ac-rule-sig(|x_templatematchname, margs, x_templatename, farg*)
                       ; e* := <map(get-varname-from-formarg); take(|farg_length)> farg* //no include of rules, add the page arguments
                       ; True() := direct_match_allowed
                    <+   extraruleargs := <matching-import-ac-rules-def(|x_templatematchname, margs, elem*)>
                       ; e* := <take(|farg_length)> extraruleargs //other arguments have to be used when including rules
                  with  expr_check := ThisCall(x_predname, e*)
                      ; elem_actemplatecheck := TemplateCall("actemplatecheck",[Var(x_rulegroup),expr_check],[],TemplateBody([])){rule}
                       //nested actions
                       ; {| WeaveAccessControlAction:
                               nestingvars := <map(try(\Var(nm)->ExternalScopeVar(nm)\))> e*
                             ; <map(\ (rule,actionpredname) -> <create-action-dr(|x_rulegroup,nestingvars,actionpredname)> rule\)> actionpred*
                            // alltd is enough because global checks are handled already in
                            // the normal traversal, and deeper nested checks are handled in
                            // the parent checks again
                             ; elem1* := <alltd( let f(s) = foldl(s <+ Snd) in fold-WeaveAccessControlAction(f) end)> elem*
                          |}
               )
    


 /*
  create-function-rule(|x_rulegroup):
    r@acrule|[ rule function x_functionmatchname(margs) { e acrule* } ]| -> r
    where x_predname := <newname> "genfunctionpredicate"
        ; farg2* := <get-formarg-from-matcharg> margs
        ; specifiedargcount := <length> farg2*
        //null checks are added to predicates automatically
        ; <Desugar;emit-webdsl-code> def|[ predicate x_predname(farg2*) { e } ]|
        //bind for more efficient dr retrieval, doesn't seem to work like this
        //; if <explode-string;not(elem('*'))> x_templatematchname then x_templatename:=x_templatematchname end
        ; rules( WeaveAccessControlFunction :+
                   |[  x_functionname( e1* )  ]| -> 
                   |[  x_functionname( e1* )  ]|
                   where <IsGlobalFunction;not(IsPredicate)> x_functionname//TODO fix overloading
                       ; <match-names> (x_functionmatchname,x_functionname)
                       ; farg* := <GlobalFunctionArgs> x_functionname
                       ; <match-arguments> (margs,farg*)
                       ; e2* := <map(get-varname-from-formarg);take(|specifiedargcount)> farg*
                       ; rules (func-check-group :+= x_rulegroup
                                func-check-exp   :+= |[x_predname(e2*)]| )
                       ; <debug> ["function rule applied",x_functionmatchname, x_functionname]
               )
        ; <debug> ["function rule created: ",x_functionmatchname," predicate: ",x_predname]    
  */

rules // rule name to identifier (replace non-letters with underscore)

  get-pred-id: (prefix, rulename) -> idname
    with rulestr := <match-name-to-id> rulename
       ; idname := <concat-strings; newname-i> [prefix, rulestr]

  // If not in [a-zA-Z0-9], replace with underscore
  replace-unsafe-char: x -> 95
    where(not(is-alphanum))
  
  match-name-to-id = string-as-chars(map(try(replace-unsafe-char)))
