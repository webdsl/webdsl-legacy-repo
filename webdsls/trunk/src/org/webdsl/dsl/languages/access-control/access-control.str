/**

 Security rules for WebDSL

*/

module org/webdsl/dsl/languages/access-control/access-control

imports
  libstrategolib
  libjava-front

imports
  libwebdsl-front
  org/webdsl/dsl/typechecker/-
  org/webdsl/dsl/transformation/-
  org/webdsl/dsl/languages/access-control/-

rules

  is-toplevel-elem = ?AccessControlPrincipal(_,_)

rules
  
  AccessControlEnabled = where(PrincipalDecl)
  
  access-control-stage =
    {| ActionRulePageArgs:
        process-access-control
      ; if AccessControlEnabled then
          process-access-control-checks
          //add functions generated by ac rules
        ; desugar-top
        end
    |}
    
rules
  
  is-page-define :
    d@Define(mod*,_,_,_,_) -> d
    where <fetch(Page)> mod*
  
  process-access-control=
    if AccessControlEnabled then
        alltd(new-generate-access-control-rules-checks)

      //topdown that does all the global checks, nested checks are handled when normal checks are applied
      ; alltd( let f(s) = foldl(s <+ Snd) in fold-WeaveAccessControlPage(f) end) //doesn't apply to templates in page definitions
      ; alltd( is-page-define <+ let f(s) = foldl(s <+ Snd) in fold-WeaveAccessControlTemplate(f) end) //doesn't apply to templates in page definitions      
      ; alltd( let f(s) = foldl(s <+ Snd) in fold-WeaveAccessControlAction(f) end)
        //hack to cope with multiple function rules matching same functioncall, otherwise only first will be applied because of transformation
         /*;  alltd({| func-check-group, func-check-exp:
            let f(s) = foldl(s <+ Snd)
             in fold-WeaveAccessControlFunction(f) end
                  ; repeat({x:?x;!ACFunctionCheck(<once-func-check-group>,<once-func-check-exp>,x)}) 
                  |} )
           */
         
      //should be done at least before template expansion
      ; alltd(   is-page-define //ignore the defs inside pages
              <+ process-template-checks)  //TODO embed proces actions in order to get inference
              
      //problem: template actions are handled earlier and this removes the acactioncheck, after template expansion the page actions are handled (which the template action has become) and since there is no longer an acactioncheck it becomes a false check around the earlier added template check
      //solution: do the page actions before template expansion too
      ; alltd(process-page-actions<+process-template-actions)
    end
  ; alltd(remove-all( ?AccessControlDefinition(_,_) ))
    
  new-generate-access-control-rules-checks=
    ?webdsl|[ access control rules x_groupname acdef* ]|
  ; with ( <map(   create-page-rule(|x_groupname) 
                <+ create-template-rule(|x_groupname)
                <+ create-action-rule(|x_groupname,[],[])
              //  <+ create-function-rule(|x_groupname)
                <+ ?AccessControlPointcut(_,_,_)
                <+ {x:?x; !["error: access control definition unknown: ",x];debug}
                   )> acdef*
    )
                  
  get-formarg-from-matcharg:
    MatchArgs(formarg,wc)->formarg
  
  get-varname-from-formarg:
    Arg(ident,srt) -> Var(ident)
  
  match-arguments=
    ?(fargrule,farg*)
    ; newfargs := <?MatchArgs(args,wc);!args> fargrule
    ; getWC := <?MatchArgs(args,wc);!wc> fargrule
    ; if getWC := None() 
      then newfarg* := farg*
      else newfarg* := <take(<length> newfargs)> farg* end
    ; <zip(extract-sorts;eq)> (newfargs,newfarg*)
  
  extract-sorts:
    (Arg(ident1,thesort1),Arg(ident2,thesort2)) -> (thesort1,thesort2)
    
  match-names:
    tup@(matchstring,name) -> tup
    where
    if not(matchstring := "*")
    then
        leftmatcher := <explode-string;reverse;drop-until(?'*');drop-while(?'*');reverse> matchstring
        ; if leftmatcher := [] 
          then // no * in the name, explicit match
               matchstring := name
          else //left-match: Succeeds if the first list of terms starts with the second list of terms.
               //            Returns the suffix of the first list that is not matched.
               <left-match> (<explode-string> name,leftmatcher)
          end
    end    
  
rules // create & emit predicate (optimization: return dummy predicate if condition is always true)
  
  create-pred-from-exp(|farg*, type, x_name):
    True() -> <dummy-pred-name>
  
  create-pred-from-exp(|farg*, type, x_name): e -> x_predname
    with	x_predname := <get-pred-id> (<concat-strings> ["gen",type,"predicate_"], x_name)
          //null checks are added to predicates automatically
        ; <emit-webdsl-code> def|[ predicate x_predname(farg*) { e } ]|
          
rules // pages 
  
  create-page-rule(|x_rulegroup):
    r@acrule|[ rule page x_pagematchname(margs) { e acrule* } ]| -> r
    with  rules(AccessControlRuleDeclared :+= r)
        ; farg_match* := <get-formarg-from-matcharg> margs
        ; x_predname := <create-pred-from-exp(|farg_match*, "page", x_pagematchname)> e
        ; {| AccessControlWeavingName:
              rules(AccessControlWeavingName := x_pagematchname)
            ; actionpred_name* := <map(create-action-predicate(|x_rulegroup, farg_match*))> acrule*
          |}
        ; actionpred* := <zip> (acrule*, actionpred_name*)
         ; rules( WeaveAccessControlPage :+
            def|[ define mod* x_pagename(farg*)  req* { elem* } ]| -> 
            def|[ define mod* x_pagename(farg*)  req* { elem_acpagecheck elem1* } ]|
              where <fetch(Page)> mod*
                  ; not(<fetch(IgnoreAccessControl)> mod*)
                  ; <match-names> (x_pagematchname,<strip-annos>x_pagename)
                  ; <match-arguments> (margs,<map(strip-annos)>farg*)
              with  e* := <map(get-varname-from-formarg);take(|<length> farg_match*)> farg*
                  ;	expr_check := ThisCall(x_predname, e*)
                  ; elem_acpagecheck := TemplateCall("acpagecheck",[Var(x_rulegroup),expr_check],[],TemplateBody([])){r}
                    //nested actions
                  ; {| WeaveAccessControlAction:
                       nestingvars := <map(try(\Var(nm)->ExternalScopeVar(nm)\))> e*
                    ; <map(\ (rule,actionpredname) -> <create-action-dr(|x_rulegroup,nestingvars,actionpredname)> rule\)> actionpred*
                    // alltd is enough because global checks are handled already in
                    // the normal traversal, and deeper nested checks are handled in
                    // the parent checks again
                    ; elem1* := <alltd( let f(s) = foldl(s <+ Snd) in fold-WeaveAccessControlAction(f) end)> elem*
                  |}
            )

rules // actions

  create-action-rule(|x_rulegroup,farg_page*,nestingvars) =
      where(x_predname := <create-action-predicate(|x_rulegroup,farg_page*)>)
    ; create-action-dr(|x_rulegroup,nestingvars,x_predname)
    
  create-action-predicate(|x_rulegroup,farg_page*):
    r@acrule|[ rule action x_actionmatchname(margs) { e acrule* } ]| -> x_predname
    with  rules(AccessControlRuleDeclared :+= r)
          // Use parent page/template name if available
        ; x_name := <concat-strings> [<AccessControlWeavingName; ![<id>,"_"]; concat-strings <+ !"">, x_actionmatchname]
        ; farg_actionrule* := <get-formarg-from-matcharg> margs
        ; (farg_page_subst*,e1) := <substitute-parent-vars-1> (farg_page*,e)
        ; farg_pred* := [farg_page_subst*,farg_actionrule*] //special: * at end of name inlines contents in list
        ; x_predname := <create-pred-from-exp(|farg_pred*, "action", x_name)> e1 
        // Remember number of page args for weaving the calls
        ; n_pageargs := <length> farg_page*
        ; rules(ActionRulePageArgs : x_predname -> n_pageargs)
        
  create-action-dr(|x_rulegroup,nestingvars,x_predname):
    r@acrule|[ rule action x_actionmatchname(margs) { e acrule* } ]| -> r
      with 
        specifiedargcount := <get-formarg-from-matcharg; length> margs
        ;	rules(   
            WeaveAccessControlAction :+
              elem|[ action x_actionname(farg*) { stat* } ]| -> 
              elem|[ action x_actionname(farg*) { e_acactioncheck;
                                                  stat* } ]|
              where <match-names> (x_actionmatchname,<strip-annos>x_actionname)
                  ; <match-arguments> (margs,<map(strip-annos)>farg*)
                  //take length of specified arguments, these became the predicates formal arguments
              with  e* := <concat> [nestingvars,<map(get-varname-from-formarg);take(|specifiedargcount)> farg*]
                  ; e_check := ThisCall(x_predname,e*)
                  ; e_acactioncheck := ThisCall("acactioncheck",[Var(x_rulegroup),e_check]){r}
          )

rules // template

  create-template-rule(|x_rulegroup):
    //r@acrule|[ rule template x_templatematchname(margs) { e acrule* } ]| -> r
    r@AccessControlRule(ruletype, x_templatematchname, margs, e, acrule*) -> r
    where <?"template" <+ ?"ajaxtemplate";?isajaxtemplate> ruletype
    with  rules(AccessControlRuleDeclared :+= r)
        ; farg_match* := <get-formarg-from-matcharg> margs
        ; x_predname := <create-pred-from-exp(|farg_match*, "template", x_templatematchname)> e
        ; {| AccessControlWeavingName:
              rules(AccessControlWeavingName := x_templatematchname)
            ; actionpred_name* := <map(create-action-predicate(|x_rulegroup, farg_match*))> acrule*
          |}
        ; actionpred* := <zip> (acrule*, actionpred_name*)
        //bind for more efficient dr retrieval, doesn't seem to work like this
        //; if <explode-string;not(elem('*'))> x_templatematchname then x_templatename:=x_templatematchname end
        ; rules( WeaveAccessControlTemplate :+
                  def|[ define mod* x_templatename(farg*)  req*  { elem*  } ]| -> 
                  def|[ define mod* x_templatename(farg*)   req* { elem_actemplatecheck
                                                             elem1* } ]|
                  where <match-names> (x_templatematchname,<strip-annos>x_templatename)
                      ; <match-arguments> (margs,<map(strip-annos)>farg*)
                      ; not(<fetch(?Page())> mod*)
                      ; not(<fetch(?Email())> mod*)
                      ; not(<fetch(?IgnoreAccessControl())> mod*)
                      ; if <?"ajaxtemplate">ruletype then <fetch(AjaxTemplate)> mod* else not(<fetch(AjaxTemplate)> mod*) end
                  with  e* := <map(get-varname-from-formarg);take(|<length> farg_match*)> farg*
                      ; expr_check := ThisCall(x_predname, e*)
                      ; elem_actemplatecheck := TemplateCall("actemplatecheck",[Var(x_rulegroup),expr_check],[],TemplateBody([])){r}
                       //nested actions
                       ; {| WeaveAccessControlAction:
                               nestingvars := <map(try(\Var(nm)->ExternalScopeVar(nm)\))> e*
                             ; <map(\ (rule,actionpredname) -> <create-action-dr(|x_rulegroup,nestingvars,actionpredname)> rule\)> actionpred*
                            // alltd is enough because global checks are handled already in
                            // the normal traversal, and deeper nested checks are handled in
                            // the parent checks again
                             ; elem1* := <alltd( let f(s) = foldl(s <+ Snd) in fold-WeaveAccessControlAction(f) end)> elem*
                          |}
               )

 /*
  create-function-rule(|x_rulegroup):
    r@acrule|[ rule function x_functionmatchname(margs) { e acrule* } ]| -> r
    where x_predname := <newname> "genfunctionpredicate"
        ; farg2* := <get-formarg-from-matcharg> margs
        ; specifiedargcount := <length> farg2*
        //null checks are added to predicates automatically
        ; <Desugar;emit-webdsl-code> def|[ predicate x_predname(farg2*) { e } ]|
        //bind for more efficient dr retrieval, doesn't seem to work like this
        //; if <explode-string;not(elem('*'))> x_templatematchname then x_templatename:=x_templatematchname end
        ; rules( WeaveAccessControlFunction :+
                   |[  x_functionname( e1* )  ]| -> 
                   |[  x_functionname( e1* )  ]|
                   where <IsGlobalFunction;not(IsPredicate)> x_functionname//TODO fix overloading
                       ; <match-names> (x_functionmatchname,x_functionname)
                       ; farg* := <GlobalFunctionArgs> x_functionname
                       ; <match-arguments> (margs,farg*)
                       ; e2* := <map(get-varname-from-formarg);take(|specifiedargcount)> farg*
                       ; rules (func-check-group :+= x_rulegroup
                                func-check-exp   :+= |[x_predname(e2*)]| )
                       ; <debug> ["function rule applied",x_functionmatchname, x_functionname]
               )
        ; <debug> ["function rule created: ",x_functionmatchname," predicate: ",x_predname]    
  */

rules // rule name to identifier (replace non-letters with underscore)

  get-pred-id: (prefix, rulename) -> idname
    with rulestr := <match-name-to-id> rulename
       ; idname := <concat-strings; newname-i> [prefix, rulestr]

  // If not in [a-zA-Z0-9], replace with underscore
  replace-unsafe-char: x -> 95
    where(not(is-alphanum))
  
  match-name-to-id = string-as-chars(map(try(replace-unsafe-char)))
