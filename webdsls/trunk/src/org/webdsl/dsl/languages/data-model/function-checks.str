module org/webdsl/dsl/languages/data-model/function-checks

imports
  libstrategolib

imports
  libwebdsl-front
  org/webdsl/dsl/languages/data-model/property-checks

rules //session entity
  
  constraint-error-data :
    Application(_, sections) -> 
    <constraint-error-data-duplication-in-session-entity(constraint-error-double-func-session)>
  
  get-functions-of-session-entities-by-name(|entities):
    x -> <collect(extract-session-entity-extend-functions-by-name(|x)); flatten-list> entities
    
  extract-session-entity-extend-functions-by-name(|x) =
    (  ?SessionEntity(x, <id>)
    <+ ?ExtendSessionEntity(x, <id>)
    )
  ; filter(is-function-cons)
  
  constraint-error-double-func-session(|entities) :
    x -> <id>
    with  functions := <get-functions-of-session-entities-by-name(|entities)> x
        ; <constraint-error-double-func-common(|functions, "Session Entity")> x

rules //entity

  constraint-error-data :
    Application(_, sections) -> 
    <constraint-error-data-duplication-in-entity(constraint-error-double-func-entity)>
        
  constraint-error-double-func-entity(|entities) :
    x -> <id>
    with  functions := <get-functions-of-entities-by-name(|entities)> x
        ; <constraint-error-double-func-common(|functions, "Entity")> x
  
  get-functions-of-entities-by-name(|entities):
    x -> <collect(extract-entity-extend-functions-by-name(|x)); flatten-list> entities
    
  extract-entity-extend-functions-by-name(|x) =
    (  ?Entity(x, _, <id>)
    <+ ?EntityNoSuper(x, <id>)
    <+ ?ExtendEntity(x, <id>)
    )
  ; filter(is-function-cons)

rules //common  
  
  constraint-error-double-func-common(|functions, entitytype) :
    x -> <id>
    with  functionsignatures := <remove-all(?ExtendFunction(_));map(extract-function-sig; sig-to-lower)> functions
        ; doublefuncsigs := <find-doubles> functionsignatures
        ; <map(try(constraint-error-double-func-helper(|doublefuncsigs, x, entitytype)))> functions
       
  extract-function-sig = 
     \Function(x,farg,_,_) -> (x, <map(farg-to-type)> farg)\
  <+ \FunctionNoReturn(x,farg,_) -> (x, <map(farg-to-type)> farg)\
  
  farg-to-type = ?Arg(_,<id>)

  sig-to-lower: (name,args) -> (<lower-case> name, args)
  
  constraint-error-double-func-helper(|doublefuncsigs, x, entitytype) :
    f -> <add-error(|["Function with signature ", prettysig," for ", entitytype," ", x, " is defined multiple times."])>
    where sig := <extract-function-sig; sig-to-lower> f
        ; <fetch(?sig)> doublefuncsigs  
        ; prettysig := <extract-function-sig; pp-func-sig> f
        
  pp-func-sig = ?(x,argtypes); <concat-strings> [x,"(",<map(pp-webdsl-to-string);separate-by(|", ");concat-strings> argtypes,")"]
  
rules // generic check entity function traversal

  constraint-error-data =
      where(get-entity-def)
    ; transform-entity-body(check-entity-functions)
  
rules // extend function
  
  check-entity-functions(|entityname):
    decls -> <fail>
    with <filter(check-entity-function(|entityname))> decls
       ; sigs := <filter(is-function-cons; extract-function-sig)> decls
       ; efuncs := <filter(?ExtendFunction(_))> decls
       ; <filter(match-extend-function-to-entity-function(|entityname))> efuncs 
         
  match-extend-function-to-entity-function(|entityname):
    ExtendFunction(f) -> <add-error(|["Extend function with signature ",prettysig," in ",entityname," extends a non-existing function."])>
    where sig@(name,argtypes) := <extract-function-sig> f
        ; <not(CheckFunctionSignature)> (SimpleSort(entityname),name,argtypes)
        ; prettysig := <pp-func-sig> sig 
     
rules // built-in function signature check
  
  check-entity-function(|entityname):
    decl -> <fail>
    where is-function-cons
      ; sig := <extract-function-sig> decl
	    ; msg := <is-builtin-ent-func-signature(|entityname)> sig
	    ; prettysig := <pp-func-sig> sig
	    ; <add-error(|
	            ["Function with signature ", prettysig, " for entity ", entityname,
	             " ", msg ] )> decl

rules
  
  is-builtin-ent-func-signature(|entname):
    (name, params) -> msg
    where fargs := <EntityFunctionNoOverloading> (entname, name)
        ; not(params := fargs)
        ; msg := <concat-strings> ["overloads a builtin function."]
  