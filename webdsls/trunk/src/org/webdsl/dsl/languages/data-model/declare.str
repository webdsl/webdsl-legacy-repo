module org/webdsl/dsl/languages/data-model/declare

signature constructors
  IsGeneratedProperty : Term

imports
	libwebdsl-front
	org/webdsl/dsl/generation/webdsl-generator

overlays

  NameProperty =
    Property("name", Simple(), SimpleSort("String"), []){IsGeneratedProperty()}

  IdProperty =
    Property("id", Simple(), SimpleSort("UUID"), []){IsGeneratedProperty()}

  VersionProperty =
    Property("version", Simple(), SimpleSort("Int"), []){IsGeneratedProperty()}

strategies

  declare-data = declare-entity  
  declare-data = declare-extend-entity

strategies

	// Prevent name clash of entity & functions for backend cache
	get-toplevel-name = get-entity-def; ?(<concat-strings> ["ent_",<id>],_)
	get-toplevel-name = get-extend-entity-def; ?(<concat-strings> ["ent_",<id>],_)

strategies // register all declared entities

  all-properties :
    x_class -> result
    with  props := <bagof-Properties; concat> x_class
        ; if not(<Extends> x_class)
          then result := []
          else
            if not("Entity" := <Extends> x_class) 
            then result := <concat> [props, <Extends; all-properties> x_class]
            else result := props end
          end

  /**
   *  gives all the properties of the entity and its supers, as a list of tuples of (entitywiththeproperty,property)
   *  includes built-in properties like id, version and name
   */
  all-entity-properties-tuples :
    x_class -> result
    with  props := <bagof-AllProperties; map(\x -> <PropertyDecl> (x_class, x)\)> x_class
        ; if not(<Extends> x_class)
          then result := []
          else
            props1 := <map(create-tuple-with-entity-prop(|x_class))> props
          ; if not("Entity" := <Extends> x_class) 
            then result := <concat> [props1, <Extends; all-entity-properties-tuples> x_class]
            else result := props1 end
          end
          
  create-tuple-with-entity-prop(|x_class) : prop -> (x_class,prop)
  
  all-functions :
    x_class -> result
    with  funcs := <bagof-Functions; concat> x_class
        ; if not(<Extends> x_class)
          then result := []
          else
            if not("Entity" := <Extends> x_class)
            then result := <concat> [funcs, <Extends; all-functions> x_class]
            else result := funcs end
          end

rules

	IsEntity = where(EntDecl)
  is-entity-type = where(?SimpleSort(<IsEntity>)) //without the where it would remove SimpleSort constructor due to term projection syntax

  Extends = EntDecl; ?Entity(_,<id>,_)

  declare-entity =
      ?ent@Entity(x_class, x_super, entbodydecs)
    ; with(
   	    props := <filter(is-property-cons)> entbodydecs
      ; funcs := <filter(is-function-cons)> entbodydecs
      ; rules(
        	EntDecl :+ x_class -> ent

          Properties :+
            x_class -> props

          Functions :+
            x_class -> funcs

/*
          SubClasses :+
            l -> [(x_super, x_class)|l] where not(<elem> ((x_super, x_class), l))

          SubClass :+
            x_super -> x_class
*/            
        )
      ; <map(declare-property(|x_class))> [VersionProperty(), IdProperty() | props]
      ; <map(declare-function(|x_class))> funcs
      ; <handle-entity-id(|x_class)> props   
      ; <declare-function(|x_class)> fun |[ function getName() : String { } ]|   
      ; not(<extend-entity-declare> Entity(x_class, x_super, entbodydecs)) //for example used in typechecker/entity-events, ends in fail for extensibility
      ; <filter(extend-entity-declare-body(|x_class))> entbodydecs
    )

  normalize-declare: EntityNoSuper(x_class, entbodydecs) -> Entity(x_class, "Entity", entbodydecs)

  declare-entity = ?EntityNoSuper(_, _); declare-normalized
  
	get-class-hierarchy:
		x -> [x | <defined-superclasses> x]

  defined-superclasses :
    x -> []
    where "Entity" := <Extends> x
       <+ not(<Extends> x) //e.g. x is not a valid entity, then the Extends rule is not declared
    
  defined-superclasses :
    x -> [super | <defined-superclasses> super]
    where super := <Extends> x
        ; not("Extends" := super)

  normalize-declare: SessionEntity(nm, entbodydecs) -> EntityNoSuper(<capitalize-string> nm, entbodydecs)

  declare-entity =
    ?sent@SessionEntity(nm, entbodydecs)
    ; with (id
      ; x_class := <capitalize-string> nm
      ; rules(
      		TypeOf : nm -> SimpleSort(x_class)
          IsSessionEntityType : SimpleSort(x_class) 
        )
      ; <declare-normalized> sent
    )
    
  declare-extend-entity :
    ExtendSessionEntity(x_class, entbodydecs) -> ExtendSessionEntity(x_class, entbodydecs)
    with <declare-extend-entity> ExtendEntity(<capitalize-string> x_class, entbodydecs)
    
  declare-extend-entity :
    ExtendEntity(x_class, entbodydecs) -> ExtendEntity(x_class, entbodydecs)
    with  props := <filter(is-property-cons)> entbodydecs
        ; funcs := <filter(is-function-cons)> entbodydecs
        ; rules( Properties :+
                  x_class -> props

                 Functions :+
                   x_class -> funcs
          )
        ; <map(declare-property(|x_class) <+ debug(!"declare extend entity property"))> props
        ; <map(declare-function(|x_class) <+ debug(!"declare extend entity function"))> funcs
        ; <filter(extend-entity-declare-body(|x_class))> entbodydecs
       
  IsProperty = where(PropertyDecl)
  TypeOfProperty = PropertyDecl; get-property-type
       
  declare-property(|x_class) =
    ?prop@Property(x, k, s, annos)
    ; rules( PropertyDecl   :+ (x_class, x) -> prop
             AllProperties  :+ x_class -> x             // used to get all properties, including built-ins
             //renaming to allow direct references to properties in entity functions/derived properties
             //RenameProperty : (x_class,x) -> y
           )
    ; with (
    		try(
   					<fetch(?SimpleAnno("searchable"))> annos
    			; rules( IndexedEntity : x_class )
    		)
    	)
    ; !prop
    ; try(declare-list-property(|x_class))
    ; try(<create-prop-required-rule(|x_class,x)> annos)
    ; not(<extend-property-declare(|x_class)> prop) //for example used in typechecker/property-events, ends in fail for extensibility
    ; !prop

  create-prop-required-rule(|class,propname) =
    ?annos
    ; not([] := <collect(?ValidationAnnoNotNull() + ?ValidationAnnoNotEmpty())> annos)
    ; rules(
        PropertyIsRequired : (class, propname) -> True()
      )
      
  normalize-declare: DerivedProperty(x, k, srt, annos, e) -> Property(x, k, srt, [])
  normalize-declare: DerivedPropertyNoAnno(x, k, srt, e) -> DerivedProperty(x, k, srt, [], e)
  normalize-declare: PropertyNoAnno(x, k, srt) -> Property(x, k, srt, [])
  
  declare-property(|x_class) =
    ?prop@DerivedProperty(x, k, srt, annos, e)
    ; where (
    		try(
   					<fetch(?SimpleAnno("searchable"))> annos
    			; rules( IndexedEntity : x_class )
    		)
    	)
    ; rules(
        IsDerivedProperty : (x_class, x) //use in constraint to prevent assignment to derived prop
      )
    ; with-origin(normalize-declare)
    ; declare-property(|x_class)

  declare-property(|x_class) =
      (?DerivedPropertyNoAnno(_,_,_,_) <+ ?PropertyNoAnno(_,_,_))
    ; with-origin(normalize-declare)
    ; declare-property(|x_class)
    
rules

declare-list-property(|x_class) =
    ?Property(x, k, GenericSort(coll, [s@SimpleSort(_)]), annos)
    ; where(
             y := <concat-strings>[x, "List"]
           ; t := GenericSort("List", [s])
           )
        ; rules(
            TypeOfProperty : (x_class, y) -> t
          )

rules

  is-derived-property =
    ?(x_class, x)
    ; (IsDerivedProperty <+ <is-derived-property> (<Extends> x_class, x))
    
  is-property =
    ?(x_class, x)
    ; (IsProperty <+ <is-property> (<Extends> x_class, x))

  type-of-property =
    ?(x_class, x)
    ; (TypeOfProperty <+ <type-of-property> (<Extends> x_class, x))
   
  property-annos =
    ?(x_class, x)
    ; (PropertyAnnos <+ <property-annos> (<Extends> x_class, x))

  built-in-template-rule-setup =
  		<map(declare-property(|"Entity"));fail> [VersionProperty(), IdProperty(), NameProperty()]
    
  is-indexed-entity =
      IndexedEntity
    <+ 
      Extends
      ; is-indexed-entity
      
rules // functions that cannot be overloaded

  declare-no-overloading(|x_class) =
         (name, params) := <extract-function-sig>
       ; match := (x_class, name)
       ; rules(EntityFunctionNoOverloading :+ match -> params )
       ; id

rules // backend annotations

  add-backend-annotation =
	  ?Entity(x_class,_,_)
  	; add-new-anno(|SuperClassesAnno(<defined-superclasses> x_class))
