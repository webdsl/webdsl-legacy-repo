module org/webdsl/dsl/languages/data-model/type-define
 
strategies

  rename :
    TypeDef(ident,elems1){anno*} -> TypeDef(ident,elems2){anno*}
    with {| Rename:    
            y := <rename-bound(|SimpleSort(ident))> "this"
          ; elems2 := <rename-all> elems1
          |}

rules
  
  declare = declare-type-def

  declare-type-def: td@TypeDef(ident,elems) -> td
   with	  anno* := <filter(?TypeDefAnno(<id>))> elems
        ; <map(declare-type-def-anno(|ident))> anno*
        ; nativefuncs := <filter(?NativeClassFunction(_,_,_,_) <+ ?NativeClassFunctionFromStatic(_,_))> elems
        ; <map(declare-type-def-native-class-func(|ident, None()))> nativefuncs
   
  declare-type-def-native-class-func(|ident, ignored):
    NativeClassFunctionFromStatic(staticfuncqid,ncf) -> <declare-type-def-native-class-func(|ident, staticfuncqid)> ncf
    
  declare-type-def-native-class-func(|ident, staticfuncname):
    ncf@NativeClassFunction(static,name,args,return) -> ncf
    with  if <?"String"> ident //String is a special case, string-compatible types are Java Strings at run-time as well, these also get the functions declared on String
          then <map({strident: ?strident; <declare-type-def-native-class-func-helper(|strident, staticfuncname)> ncf })> <bagof-StringCompatibleTypeNames>
          else if <?"DateTime"> ident //DateTime, Date, Time are all java.util.Date, use DateTime to declare for each at once
               then <map({strident: ?strident; <declare-type-def-native-class-func-helper(|strident, staticfuncname)> ncf })> ["DateTime","Date","Time"]
               else <declare-type-def-native-class-func-helper(|ident, staticfuncname)> ncf
               end
          end  

signature constructors StaticFunctionNameForNativeFunction : Term -> Term
rules 
  
  declare-type-def-native-class-func-helper(|ident, staticfuncname):
    ncf@NativeClassFunction(static,name,args,return) -> ncf1
    with  ncf1 := <add-anno(|StaticFunctionNameForNativeFunction(staticfuncname))> ncf
    with  <declare-native-class-func(|ident)> ncf1 //reuse declare of native function in native class import
      
  add-backend-annotation :
    c1@Call(e,x,args) -> c2
    where has-no-anno(?TypeNativeFunction(_))
    with  callee := <type-of> e
        ; t* := <map(type-of;strip-ref-sort)> args 
    where ncf := <resolve-function-call-to-decl> ( <type-of>e,x,<map(type-of;strip-ref-sort)> args)
    where <get-anno(?StaticFunctionNameForNativeFunction(staticfuncname))> ncf
    with  c2 := <add-anno(|TypeNativeFunction(staticfuncname))> c1

  /**
   *  Register type annotations declared in type x{} block
   */    
  declare-type-def-anno(|ident):
    anno -> anno
    with  annonumber := <toplevel-rename> "typeanno"
        ; rules( 
            TypeAnnotation :+ ident -> (annonumber,<remove-position-annos> anno)  
            TypeHasBeenExtended : ident
          )
  
/**
 *  Apply type annotations declared in type x{} block
 */   
rules

  desugar-ui :
    Entity(x_class,super, entbodydecs1) -> <rename> Entity(x_class,super, entbodydecs2) 
    where entbodydecs2 := <apply-type-def-annos> entbodydecs1
        ; not(entbodydecs1 := entbodydecs2)
    
  desugar-ui : 
    EntityNoSuper(x_class, entbodydecs1) -> <rename> EntityNoSuper(x_class, entbodydecs2) 
    where entbodydecs2 := <apply-type-def-annos> entbodydecs1
        ; not(entbodydecs1 := entbodydecs2)
    
  desugar-ui :
    SessionEntity(x_class, entbodydecs1) -> <rename> SessionEntity(x_class, entbodydecs2) 
    where entbodydecs2 := <apply-type-def-annos> entbodydecs1
        ; not(entbodydecs1 := entbodydecs2)
  
signature
  constructors 
    TypeAnnotationGenerated: Term -> Term
  
rules

  apply-type-def-annos:
    props -> props1
    with  props1 := <map(try(apply-type-def-annos-to-prop))> props

  apply-type-def-annos-to-prop :  
    prop@Property(x, k, ss@SimpleSort(s), anno*) -> 
    Property(x, k, ss, [anno*, newanno*])
    where <is-simple-sort> ss
        ; <TypeHasBeenExtended> s
    with  alltypeannos := <bagof-TypeAnnotation> s
        ; newtypeannos := <remove-all(is-already-applied-anno(|anno*))> alltypeannos
        ; newanno* := <alltd(\ Var("this") -> Var(<strip-annos> x) \)//FieldAccess(Var("this"),Var(<strip-annos> x)) \)
                             ; map(\(num,an)->[TypeAnnotationGenerated(num),an]  \)
                             ; try(concat)> newtypeannos
        
  is-already-applied-anno(|anno*):
    (annonumber,anno) -> anno
    where <fetch(?TypeAnnotationGenerated(annonumber))> anno*  
