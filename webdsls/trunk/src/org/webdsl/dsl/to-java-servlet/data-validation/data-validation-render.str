module org/webdsl/dsl/to-seam/data-validation-render

imports 
  libstrategolib  
  Java-15
  libjava-front 
  
imports 
  libwebdsl-front
  
rules

  elem-to-java-servlet :
    tc@elem|[ validatedInputWrapper()[passign*]{elem*} ]| -> result
    with  input_elements := <alltd(remove-all(validate-tempate-element))> elem*
        ; result := <render-error-messages-with-error-template> (elem*, input_elements)
       
  validate-tempate-element = ?elem|[ validate(e1,e2)[passign*]{} ]| 
  validate-tempate-element = ?elem|[ validationErrorsForInput(e1)[passign*]{} ]| 
  validate-tempate-element = ?elem|[ validationErrorsFor(e1)[passign*]{} ]| 
  validate-tempate-element = ?ValidationErrors(_)
  validate-tempate-element = ?ValidationErrors()
    
  render-error-messages-with-error-template :  
    (elem*,input_elements) -> 
    bstm* |[  
      java.util.List<String> x_list = new java.util.LinkedList<String>();
      bstm_messages*
      if(x_list.size() > 0){
        bstm_error*
      }
      else {
        bstm*
      }
    ]|
    with x_list := <newname> "messagesList"
       ; bstm_messages* := <collect(validation-message-production(|x_list));concat-with-sublists> elem*
       ; bstm_error* := <inline-error-template> (elem*,x_list,input_elements)
       ; bstm* := <elems-to-java-servlet> input_elements

  inline-error-template :
    (elem*,x_list,input_elements) -> bstm_error*
    with Define(mods, name,[Arg(nm,srt)], body) := <ErrorTemplateJavaServlet> //TemplateDefinition DR doesn't contain desugared template
       ; body3 := <alltd(insert-input-fields-in-error-template(|input_elements))> body
       ; bstm_error* := <elems-to-java-servlet;alltd(inline-error-template-helper(|x_list))> body3

  inline-error-template-helper(|x_list) :
    ExprName(Id(x)) -> ExprName(Id(x_list))
    where "errorMessages" := <OriginalNonUniqueName> x

  insert-input-fields-in-error-template(|input_elements) :
    TemplateCall("validatedInput",_,_,_) -> TemplateCall("dummy",[],[],input_elements)

rules
  
  elem-to-java-servlet :
    RemoveMe() -> []

rules //TODO these are relevant for error messages not connected to inputs
  elem-to-java-servlet :
    tc@elem|[ validate(e1,e2)[passign*]{} ]| -> []
  elem-to-java-servlet :
    tc@elem|[ validationErrorsForInput(e1)[passign*]{} ]| -> []
  elem-to-java-servlet :
    tc@elem|[ validationErrorsFor(e1)[passign*]{} ]| -> []
  elem-to-java-servlet :       
    ValidationErrors(x1) -> <render-error-messages-with-error-template> ([<id>], [RemoveMe()])

rules // add messages to list

  validation-message-production(|x_list) :
    tc@elem|[ validate(e1,e2)[passign*]{} ]| -> 
    bstm* |[
      if(inSubmittedForm && !e3){
        x_list.add(e4);
      }
    ]|
    with  e4 := <expression-to-java-servlet> e2
        ; e3 := <expression-to-java-servlet> e1
  
  validation-message-production(|x_list) :
    tc@elem|[ validationErrorsForInput(e)[passign*]{} ]| -> 
    <for-loop-counter-wrap-code> 
    bstm* |[
      if(inSubmittedForm){
        bstm*
      }
    ]|
    with  bstm* := <validation-message-production-helper(|x_list)> java:expr |[ ident + "~<pp-webdsl> e" ]|
        
  validation-message-production(|x_list) :
    tc@elem|[ validationErrorsFor(e1)[passign*]{} ]| -> 
    bstm* |[
      if(inSubmittedForm){
        java.util.List<utils.ValidationException> x = new java.util.LinkedList<utils.ValidationException>();
        for(utils.ValidationException ve : ps.getValidationExceptions()){
          Object x1 = ps.getOldValuesForInputs().get(e3);
          if(ve.getName() == null && x1==null?ve.isRelevantObject(e3):ve.isRelevantObject(x1)){
            x.add(ve);
          }
        }
        for(utils.ValidationException ve : x){
          x_list.add(ve.getErrorMessage());
          ps.getValidationExceptions().remove(ve);
        }
      }
    ]|
    with  e2 := <expression-to-java-servlet> e1
        ; if GenericSort(_,_) := <type-of> e1 
          then e3 := java:expr |[ e2.hashCode() ]|
          else e3 := e2
          end
        ; x := <newname> "ve"
        ; x1 := <newname> "object"
 
  validation-message-production(|x_list) : 
    ValidationErrors(x1) -> 
    <validation-message-production-helper(|x_list)> e
    with  e := java:expr |[ "~x1" ]|
    
  validation-message-production-helper(|x_list) : 
    e -> 
    bstm* |[
      java.util.List<utils.ValidationException> x = new java.util.LinkedList<utils.ValidationException>();
      for(utils.ValidationException ve : ps.getValidationExceptions()){
        if(ve.getName() != null && ve.getName().equals(e)){
          x.add(ve);
        }
      }
      for(utils.ValidationException ve : x){
        x_list.add(ve.getErrorMessage());
        ps.getValidationExceptions().remove(ve);
      }
    ]|
    with  x := <newname> "ve"  
      
  validation-message-production(|x_list) : 
    ValidationErrors() -> 
    bstm* |[
      for(utils.ValidationException ve : ps.getValidationExceptions()){
        x_list.add(ve.getErrorMessage());
      }
      ps.getValidationExceptions().clear();
    ]|

rules

  assignment-to-html-attr = ?PreDeriveInputDone()
  assignment-to-html-attr = ?InputErrorMessageBinding(_)

rules

  render-validation-exceptions = //catch all left-over validation messages, displayed at executed action
    !<render-error-messages-with-error-template> ([ValidationErrors()], [RemoveMe()])
    