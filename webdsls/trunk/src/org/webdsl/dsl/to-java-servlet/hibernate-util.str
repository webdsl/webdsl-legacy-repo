module org/webdsl/dsl/to-java-servlet/hibernate-util

imports
  libstratego-lib
  libjava-front

imports
  libwebdsl-front

overlays

  e_HibSession =
    java:expr |[ HibernateUtilConfigured.getSessionFactory().getCurrentSession() ]|

rules

  hibernate-forall-criteria :
    (term{anno*}, t, x, srt, fltr) -> e_criteria
    with <fetch-elem(?JoinProperties(joinproperties))> anno*
      ; e_criteria := <foldr(!<try(hibernate-add-cacheable(|anno*))>expr|[ e_HibSession.createCriteria(t.class) ]|,hibernate-forall-criteria-join)> joinproperties
        //try on next line since not all ordering can be translated to query
        /** ; e_criteria := <foldr(!e0,hibernate-forall-criteria-filter(|x,srt));where(rules(OrderAndLimitApplied:=True())) <+ !e0> [lim,ob]  */

  hibernate-add-cacheable(|anno*) :
    e -> expr |[ e.setCacheable(true) ]|
    where <fetch-elem(?CachedEntity())> anno*
    
  hibernate-forall-criteria-join:
    (str, e) -> expr|[ e.setFetchMode("~str", org.hibernate.FetchMode.JOIN) ]|

  /**
   * Hibernate optimization below on hold, Zef is working on a replacement ORM
   */
  /* 
  hibernate-forall-criteria-filter(|x,srt) = hibernate-forall-criteria-filter
  
  hibernate-forall-criteria-filter: 
    (Limit(limit,first), e) -> expr|[ e.setFirstResult(e_first).setMaxResults(e_limit) ]|
    with  e_limit := <expression-to-java-servlet> limit
        ; e_first := <expression-to-java-servlet> first

  hibernate-forall-criteria-filter(|x,srt) =
    // if the order clause is simply a property, then the query can do the ordering   
    hibernate-forall-criteria-order-is-prop(|x,srt)
  <+\(OrderDescending(Null()), e) -> e\
  <+\(OrderAscending(Null()), e) -> e\
  
  hibernate-forall-criteria-order-is-prop(|x,srt) :
    (OrderDescending(orderexp), e) -> <hibernate-forall-criteria-order-is-prop-helper(|x,srt,"desc")> (orderexp, e)
     
  hibernate-forall-criteria-order-is-prop(|x,srt) :
    (OrderAscending(orderexp), e) -> <hibernate-forall-criteria-order-is-prop-helper(|x,srt,"asc")> (orderexp, e)

  hibernate-forall-criteria-order-is-prop-helper(|x,srt,x_order) :
    (orderexp, e) -> expr|[ e.addOrder(org.hibernate.criterion.Order.x_order("~<concat-strings> ["_",prop]")) ]|
    with  SimpleSort(ent) := srt
    where FieldAccess(var,prop) := orderexp
        ; Var(x) := var
        ; <type-of-property> (ent,prop)
  */

rules

  generate-code-java-servlet-once = 
      bagof-AllEntityNames; string-sort-annos
    ; disable-code-generation-if-cache-exists 
    ; cached-generate(generate-java-servlet-hibernate-util | "internal_HibernateUtil")
    ; fail
    
  generate-java-servlet-hibernate-util :
    all-entity-names -> <emit-java-code-local> compilation-unit|[
    package utils;
    
    import java.util.Properties;
    
    import org.hibernate.*;
    import org.hibernate.type.*;
    import org.hibernate.cfg.*;
    import org.webdsl.*;
    import org.hibernate.event.*;
    import org.hibernate.event.def.*;
    import java.util.*;
    import java.io.*; 
    import org.hibernate.tool.hbm2ddl.DatabaseMetadata;
    import org.hibernate.tool.hbm2ddl.SchemaExport;
    import org.hibernate.tool.hbm2ddl.SchemaUpdate;
    import org.hibernate.dialect.Dialect;
    
    import pkgname.*;
    @SuppressWarnings("unused") 
    public class HibernateUtilConfigured {
        private static final SessionFactory sessionFactory;
        private static Configuration annotationConfiguration;
        static
        { 
          try
          { 
            annotationConfiguration = new Configuration();

            //Properties prop = HibernateUtil.getProperties();

            annotationConfiguration.addPackage("utils");
            annotationConfiguration.addAnnotatedClass(utils.ApplicationContextProperty.class);
            annotationConfiguration.addAnnotatedClass(utils.File.class);

            annotationConfiguration.addPackage("~domainpack");
            //annotationConfiguration.addAnnotatedClass(User.class);
            bstm*

            //annotationConfiguration.addProperties(prop);
            //bstm1*
            annotationConfiguration.setListener("save-update", new SetVersionSaveOrUpdateEventListener());    
            annotationConfiguration.setListener("flush-entity", new SetValidationEventListener());
      
            annotationConfiguration.setInterceptor( new TimestampInterceptor());
            sessionFactory = annotationConfiguration.buildSessionFactory();
            
            
            //database schema create/update
            String dbmode = utils.BuildProperties.getDbMode();
            if("update".equals(dbmode) || "create-drop".equals(dbmode)){
              Dialect dialect = Dialect.getDialect(annotationConfiguration.getProperties());
              Session session = sessionFactory.openSession();
              DatabaseMetadata meta = new DatabaseMetadata(session.connection(), dialect);
              if("create-drop".equals(dbmode)){
                String[] dropscript = annotationConfiguration.generateDropSchemaScript(dialect);
                if(dropscript.length>0){ System.out.println("\n=== dbmode=create-drop - Logging drop table SQL statements ===\n"); }
                else{ System.out.println("\n=== dbmode=create-drop - No drop table SQL statements were generated. ===\n"); }
                for(String s : Arrays.asList(dropscript)){
                    System.out.println(s);
                }
                System.out.println();
                String[] createscript = annotationConfiguration.generateSchemaCreationScript(dialect);
                if(createscript.length>0){ System.out.println("=== dbmode=create-drop - Logging create table SQL statements ===\n"); }
                else{ System.out.println("\n=== dbmode=create-drop - No create table SQL statements were generated. ===\n"); }
                for(String s : Arrays.asList(createscript)){
                    System.out.println(s);
                }
                System.out.println("\n=== dbmode=create-drop - Running database schema drop and create ===\n");
                boolean script = true;
                boolean doUpdate = true;
                new SchemaExport( annotationConfiguration ).create( script, doUpdate );
                System.out.println("\n=== dbmode=create-drop - Finished database schema drop and create  ===\n");
              }
              else if("update".equals(dbmode)){
                String[] updatescript = annotationConfiguration.generateSchemaUpdateScript(dialect, meta);
                if(updatescript.length>0){ 
                  System.out.println("\n=== dbmode=update - Logging update table SQL statements ===\n"); 
                  for(String s : Arrays.asList(updatescript)){
                    System.out.println(s);
                  }
                  System.out.println("\n=== dbmode=update - Running database schema update ===\n");
                  boolean script = true;
                  boolean doUpdate = true;
                  new SchemaUpdate( annotationConfiguration ).execute( script, doUpdate );
                  System.out.println("\n=== dbmode=update - Finished database schema update ===\n");
                }
                else{ System.out.println("\n=== dbmode=update - No update table SQL statements were generated. Schema update will be skipped. ===\n"); }
              }
              session.close();
            }
            else{
              System.out.println("\n=== application.ini contains setting 'dbmode="+dbmode+"', only 'update' or 'create-drop' will trigger database schema updates ===\n");
            }
          } 
          catch (Throwable ex) {
            throw new ExceptionInInitializerError(ex);
          }
        }
    
        public static SessionFactory getSessionFactory() {
            return sessionFactory;
        }
        
        public static Configuration getAnnotationConfiguration()
        { 
          return annotationConfiguration;
        }
        
        // references that will be implicitly stored in the db need version set to at least 1 as well to indicate a persisted entity     
        @SuppressWarnings("serial")
        private static class SetVersionSaveOrUpdateEventListener extends DefaultSaveOrUpdateEventListener 
        {
          public void onSaveOrUpdate(SaveOrUpdateEvent event)  throws HibernateException
          { 
            setVersion(event.getObject());
            super.onSaveOrUpdate(event);
          }
      
          public void setVersion(Object o)
          { 
            
            if(org.hibernate.Hibernate.isInitialized(o) && o instanceof WebDSLEntity)
            { 
              WebDSLEntity we = (WebDSLEntity)o;
              if(we.getVersion() <= 0)
              { 
                we.setVersion(1);
              }
            }
          }
          
        } 

        //register which objects need to be validated at the end of an action
        @SuppressWarnings("serial")
        private static class SetValidationEventListener extends DefaultFlushEntityEventListener
        { 
            public void onFlushEntity(FlushEntityEvent event) throws HibernateException
            { 
              validate(event.getEntity());
              super.onFlushEntity(event);
            }
            
            public void validate(Object o)
            { 
                if(o instanceof WebDSLEntity)
                { 
                    WebDSLEntity we = (WebDSLEntity)o;
                    AbstractPageServlet aps = ThreadLocalPage.get();
                    if(aps != null){
                      aps.addEntityToValidateAfterAction(we); 
                    }
                }
            }
        }
        
        private static class TimestampInterceptor extends EmptyInterceptor {
          public boolean onFlushDirty(Object entity, Serializable id, Object[] currentState, Object[] previousState, String[] propertyNames, Type[] types) 
          {
            if(org.hibernate.Hibernate.isInitialized(entity) && entity instanceof WebDSLEntity)
            {
              setValue(currentState, propertyNames, "_modified", new java.util.Date());
            } 
            return true;
          }

          public boolean onSave(Object entity, Serializable id, Object[] state, String[] propertyNames, Type[] types) 
          {
            if(org.hibernate.Hibernate.isInitialized(entity) && entity instanceof WebDSLEntity)
            {
              setValue(state, propertyNames, "_created", new java.util.Date());
              setValue(state, propertyNames, "_modified", new java.util.Date());
            }
            return true;
          }

          private void setValue(Object[] state, String[] propertyNames, String propertyToSet, Object value) 
          {
            int index = Arrays.asList(propertyNames).indexOf(propertyToSet);
            if (index >= 0) 
            {
              state[index] = value;
            }
          }
       }  
     }
    ]|
    with pkgname := <DomainPackage>
       ; domainpack := <pp-java5-to-string> <DomainPackage>
       ; bstm* := <map({\ 
                           x -> bstm |[ annotationConfiguration.addAnnotatedClass(x_class); ]| 
                           where x_class := <concat-strings> [<DomainPackage;pp-java5-to-string>,".",x,".class"]
                       \})> all-entity-names
      /* ; if not([] := <bagof-AllGlobalVars>) 
         then bstm1* := [ bstm |[ annotationConfiguration.addAnnotatedClass(ApplicationContextProperty.class); ]| ]
         else bstm1* := [] end
 */
