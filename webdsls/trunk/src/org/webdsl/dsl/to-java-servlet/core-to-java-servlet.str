module org/webdsl/dsl/to-java-servlet/core-to-java-servlet

imports
  libwebdsl-front
  
imports
  org/webdsl/dsl/to-java-servlet/-
  org/webdsl/dsl/to-java-servlet/types/-
  org/webdsl/dsl/to-java-servlet/uicomponents/-
  org/webdsl/dsl/to-java-servlet/ajax/- 
  org/webdsl/dsl/to-java-servlet/email/-
  org/webdsl/dsl/to-java-servlet/stratego-interface/-
  org/webdsl/dsl/to-java-servlet/data-validation/-
  org/webdsl/dsl/to-java-servlet/test/-
  org/webdsl/dsl/to-java-servlet/debug/-
  org/webdsl/dsl/to-java-servlet/native/-
  libback-end-transformations

imports		// local generation
  libjava-transformations
  libwrite-files

strategies

  set-DomainPackage(|pkg) = rules( DomainPackage := pkg )
  
  core-to-java-servlet =
      prepare-core-to-java-servlet
    ; log-time(generate-code-java-servlet      |"generate-code-java-servlet")
    ; transform-java-code
  
  transform-java-code =
    where(  pkgname1 := <BeanPackage>
          ; pkgname2 := <DomainPackage>
          ; pkgname3 := <ActionPackage>
          ; pkgname4 := <TestPackage>)
  ; <flatten-list>
      [  <log-time(bagof-JavaClassesToEmit; get-java-artifacts-java-servlet | "get-java-artifacts")>
       , <log-time(get-web-xml                    |"get-web-xml")>
       , JavaFile([<GeneratedOutputDir>], compilation-unit|[package pkgname2 ; public class Force_Domain_Package_Creation {} ]|) 
       , JavaFile([<GeneratedOutputDir>], compilation-unit|[package pkgname3 ; public class Force_Action_Package_Creation {} ]|)                   
       , JavaFile([<GeneratedOutputDir>], compilation-unit|[package pkgname4 ; public class Force_Test_Package_Creation {} ]|)                   
      ]
  
  get-web-xml =
    WebXMLToEmit
  
  prepare-core-to-java-servlet =
    ?Application(qid, sections)
    ; rules(
        Package       := <qid-to-package-name> qid        
        BeanPackage   := <qid-to-package-name> Qualified(qid, "beans")
        ActionPackage := <qid-to-package-name> Qualified(qid, "actions")
        TestPackage := <qid-to-package-name> Qualified(qid, "test")
        FunctionPackage := <qid-to-package-name> Qualified(qid, "functions")
      )
    ; set-DomainPackage(|<qid-to-package-name> Qualified(qid, "domain")) //strategy/rule shared with seam back-end
    ; !Application(qid, sections)
    ; annotate-pagecalls
    ; log-time(get-all-top-level-template-names|"get-all-top-level-template-names") //TODO should be available in a dynamic rule somewhere

  generate-code-java-servlet =
    ?def@Define(mods, name, args, targs, elems) ;
      {| ThisEmail, JavaThisPage, NestedTemplate, ThisTemplateName,ThisTemplateClassName, Variables, TemplateFormalArguments, ThisAjaxTemplateName: //Variables: to hold arguments/variables of parent templates/pages
          with (
              if ThisTemplateName   then rules ( NestedTemplate := name ) end
            ; if <fetch(Page)>  mods then rules ( JavaThisPage := name ) end
            ; if <fetch(Email)> mods then rules ( ThisEmail := name ) end
            ; if <fetch(AjaxTemplate)> mods then rules ( ThisAjaxTemplateName := name ) end
            ; rules ( 
              ThisTemplateName := name
              ThisTemplateClassName := <get-template-class-name> def
              //TemplateFormalArguments := args
            )
            // generate if: nested templates (no caching), or cache miss
            ; if not(CachingEnabled) <+ NestedTemplate <+ not(check-cache-equality(|<TopLevelTemplateClassName> name)) then
                scope-local-emit(
                  annotate-with-unique-element-ids
                ; log-time(not(GenerateCodeJavaServlet)|"generate code define")
                ; all(generate-code-java-servlet)
                | name
                )
              end
          )
       |}
   <+(?Action(_, _, _) <+ ?InitAction(_)) ;
         {| InAction, Variables:
           rules ( InAction := True() )
         ; log-time(not(GenerateCodeJavaServlet)|"generate code action")
         ; all(generate-code-java-servlet)
         |}
   <+?Function(_,_,_,_) /*;  handled with dynamic rule that holds all functions
         {| Variables://InFunction, Variables:
           //rules ( InFunction := <id> )
           not(GenerateCodeJavaServlet)
         ; all(generate-code-java-servlet)
         |}*/
   <+(?Entity(ent_name,_,_)<+?SessionEntity(ent_name,_)<+?EntityNoSuper(ent_name,_)) ;
         {| JavaInEntity:
           rules ( JavaInEntity := <id> )
         ; if not(CachingEnabled) <+ not(check-cache-equality(get-entity-def; ?(<id>,_))) then
             scope-local-emit(
               log-time(not(GenerateCodeJavaServlet)|"generate code entity")
               ; all(generate-code-java-servlet)
               | ent_name
             )
           end
         |}
   <+{?el@elem|[ var x : srt := e ]|
         ; where(<elem> (el,<bagof-AllGlobalVars>))}
   <+      log-time(not(GenerateCodeJavaServlet)|"generate code other")
         ; all(generate-code-java-servlet)

// some helping annotations to create uniqueness among the static elements

signature
  constructors
    TemplateCallNumber : String -> Annotation
    FormNumber : String -> Annotation
    InputNumber : String -> Annotation
    ActionNumber : String -> Annotation //action calls/actionLink
    TemplateClassName : String -> Annotation
    RefArgClassNameFirstPart : String -> Annotation
    RefArgClassNameSecondPart : String -> Annotation
   /* ActionClassName : String -> Annotation*/
        
rules

  get-templatecallnumber :
    _{anno*} -> compid
    where TemplateCallNumber(compid) := <collect(?TemplateCallNumber(_));Hd> anno*
 
  get-formnumber :
    _{anno*} -> compid
    where FormNumber(compid) := <collect(?FormNumber(_));Hd> anno* 
    
  get-inputnumber :
    _{anno*} -> compid
    where InputNumber(compid) := <collect(?InputNumber(_));Hd> anno* 
    
  get-actionnumber :
    _{anno*} -> compid
    where ActionNumber(compid) := <collect(?ActionNumber(_));Hd> anno* 
    
  get-refargclassname-first :
    _{anno*} -> compid
    where RefArgClassNameFirstPart(compid) := <collect(?RefArgClassNameFirstPart(_));Hd> anno* 
  get-refargclassname-second :
    _{anno*} -> compid
    where RefArgClassNameSecondPart(compid) := <collect(?RefArgClassNameSecondPart(_));Hd> anno* 
    
  get-template-class-name :
    _{anno*} -> compid
    where TemplateClassName(compid) := <collect(?TemplateClassName(_));Hd> anno* 
 /*
  get-action-class-name :
    _{anno*} -> compid
    where ActionClassName(compid) := <collect(?ActionClassName(_));Hd> anno* 
   */        

strategies

  annotate-pagecalls = 
    alltd(annotate-pagecall)

rules

  annotate-pagecall:
    Define(a,name,b,c,elems) -> Define(a,name,b,c,elems1)
    with {| ThisTemplateName: 
           rules(ThisTemplateName := name)
         ; elems1 := <alltd(annotate-pagecall)> elems
         |}

  annotate-pagecall :
    PageCall(pagename,arg*){anno*} -> PageCall(pagename,arg1*){anno*} 
    where not("url" := pagename) //TODO url variant of navigate should have different cons
    with  get-anno(?PageArgsAnno(farg*))
        ; farg1* := <add-farg-numbers> farg*
        ; arg1* := <zip(add-ref-arg-class-names(|pagename)<+?(_,<id>))> (farg1*,arg*)
          
  add-ref-arg-class-names(|pagename) :
    (farg{anno*},arg{anno1*}) -> result
    where <?Arg(_,RefSort(_))> farg
    with  <fetch(?ArgNumber(argnum))> anno*
        ; first := <gen-page-ref-arg-class-name-first-part> (pagename,argnum)
        ; second := <gen-page-ref-arg-class-name-second-part>
        ; newid := <concat-strings> [first,second]
        ; rules( RefArgClassName :+= newid)
        ; result := arg{RefArgClassNameFirstPart(first),RefArgClassNameSecondPart(second),anno1*}

  /**
   *  first part, used for all calls to this particular argument of the page
   */ 
  gen-page-ref-arg-class-name-first-part : (pagename,argnum) -> <concat-strings> ["RefArg_",pagename,"_",<int-to-string> argnum,"_"]
          
  /**
   *  second part, added in URL, which selects a particular call site (templatename + (pagecall) number in template) to determine the RefArg class to use
   *  ThisTemplateName is unique, so there is no newname overlap with other templates
   *  since these names are used in a global lookup hashmap, otherwise caches can become invalid
   */
  gen-page-ref-arg-class-name-second-part  = <concat-strings;newname> [<ThisTemplateName>,"pc"]
  
strategies

  annotate-with-unique-element-ids = 
    topdown(try(java-servlet-element-id))
    
rules

  java-servlet-element-id :
    tc@TemplateCall(name, args,passign*, _){anno*} -> tc{TemplateCallNumber(newid),anno*} 
    where <not(is-input-template)> tc 
        ; <get-anno(?CallToDefinedAnno() <+ ?CallToRequiredAnno())> tc
        //; <TemplateSignature <+ LocalTemplateSignature <+ !<strip-annos> name;TemplateWithGenerics> (name,t*)
        ; newid := <newname> "tcall"
    
  java-servlet-element-id :
    tc@TemplateCall("form", attrs,passign*, elems){anno*} -> tc{FormNumber(newid),anno*} 
    where  newid := <newname> "form"
  
  java-servlet-element-id :
    tc@PropertySubmit(_,_){anno*} -> tc{ActionNumber(newid),anno*} 
    where  newid := <newname> "action"
  java-servlet-element-id-template-call : 
    tc -> tc{InputNumber(newid),anno*} 
    with  _{anno*} := tc
        ; newid := <newname> "input" 
    
  get-all-top-level-template-names =
    alltd(register-top-level-template-name)
  register-top-level-template-name = 
    ?tmplt@webdsl|[ define mod* x(farg*)  req*  { elem* } ]|
    ; with(
        // TemplateFormalArguments used in dispatch-servlet.str
        rules( TemplateFormalArguments : x -> farg* )
      ; if <not(fetch(Page <+ Email))> mod*
        then rules(AllTopLevelTemplateNamesJavaServlet :+= x  // used to create lookup hashmap in java-base-page.str
                   IsTopLevelTemplateNameJavaServlet : x
                   TopLevelTemplateArgumentsJavaServlet : x -> farg* 
                   GetTopLevelTemplateJavaServlet : x -> tmplt
                   )
           ; if <fetch(AjaxTemplate)> mod* then rules ( AllTopLevelTemplateNamesWithAjax :+= x ) end
        end
        ; if <fetch(Email)> mod* then rules ( AllEmailNames :+= x ) end
        ; if "errorTemplateInputListString"  := x then rules ( ErrorTemplateInput := tmplt ) end
        ; if "errorTemplateFormListString"   := x then rules ( ErrorTemplateForm := tmplt ) end
        ; if "errorTemplateActionListString" := x then rules ( ErrorTemplateAction := tmplt ) end
        ; if "templateSuccessListString"     := x then rules ( TemplateSuccess := tmplt ) end
      )
    ; !<register-template-name(|True())> tmplt
    
  register-template-name(|toplevel)  :
    tc@Define(mod*,x,farg*, targs, elem*) -> Define(mod*,x,farg*, targs, elem1*){TemplateClassName(newid),anno*} 
    with  _{anno*} := tc
        ; parentNames := <bigbagof-CurrentHierarchicalName>
        ; name-parts := <concat; separate-by(|"_")> [<reverse> parentNames, [x,"Template"]]
        ; all-parts := <concat-strings> (name-parts)
        ; if <oncetd(?Email())> mod* then
              newid := <concat-strings> [all-parts, "_Email"]
            ; rules ( EmailClassName : x -> newid)
          else
              newid := all-parts
          end
        ; if True() := toplevel then rules( TopLevelTemplateClassName : x -> newid ) end
        ; if <fetch(Page)> mod*
          then rules( AllPageNames  :+= x 
                      PageClassName : x -> newid) // used to create lookup hashmap in java-base-page.str 
                    //  PageFargs : x -> farg*)  
                                                  // TODO needs renaming, used for any type of template now
          end
        ; {| CurrentHierarchicalName :
          rules(
            CurrentHierarchicalName :+= x
          )
          ; elem1* := <alltd(register-template-name(|False()))> elem*
          |}
          