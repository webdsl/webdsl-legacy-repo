module org/webdsl/dsl/typechecker/declare

imports
  libstrategolib

imports
  libwebdsl-front

strategies // register all declared entities

  inherit-object :
    EntityNoSuper(x_class, props, functions) -> Entity(x_class, "Object", props, functions)

  declare-entity = where(
    try(inherit-object)
    ; ?Entity(x_class, x_super, props, funcs)
    ; newprops := <concat> [<Properties<+![]> x_class, props] // @TODO This should be determined on the fly, not like this
    ; newfuncs := <concat> [<Functions <+![]> x_class, funcs]
    ; rules(
        Entities :+= x_class

        IsEntity :+
          x_class -> x_class

        Properties :
          x_class -> newprops

        Functions :
          x_class -> newfuncs

        Extends :
          x_class -> x_super

        SubClasses :+
          l -> [(x_super, x_class)|l] where not(<elem> ((x_super, x_class), l))

        SubClass :+
          x_super -> x_class

        DefinedJavaType :
          SimpleSort(x_class) -> type|[ x_class ]|

        DefinedJavaTypeString :
          SimpleSort(x_class) -> <concat-strings> [<packagename-to-string> <DomainPackage>, ".", x_class]
      )
    ; where(
        <map(declare-property(|x_class) <+ debug)> [NameProperty() | <inherited-properties> x_class]
        ; <map(declare-function(|x_class) <+ debug)> <inherited-functions> x_class
        ; <filter(extract-entity-id(|x_class))> props
      )
  )

  declare-entity = where(
    ?SessionEntity(nm, props, functions)
    ; x_class := <capitalize-string> nm
    ; rules(
        TypeOf : nm -> SimpleSort(x_class)
        IsSessionVariable : nm )
    ; <declare-entity> Entity(x_class, "Object", props, functions))
    
  declare-extend-entity :
    ExtendSessionEntity(x_class, props, funcs) -> ExtendSessionEntity(x_class, props, funcs)
    with <declare-extend-entity> ExtendEntity(<capitalize-string> x_class, props, funcs)
    
  declare-extend-entity :
    ExtendEntity(x_class, props, funcs) -> ExtendEntity(x_class, props, funcs)
    with newprops := <concat> [<Properties<+![]> x_class, props]
       ; newfuncs := <concat> [<Functions <+![]> x_class, funcs]
       ; rules( Properties :
                  x_class -> newprops

                Functions : 
                  x_class -> newfuncs
         )
       ; <map(declare-property(|x_class) <+ debug(!"declare extend entity property"))> props
       ; <map(declare-function(|x_class) <+ debug(!"declare extend entity function"))> funcs

  extract-entity-id(|x_Class) =
    ?Property(x, k, s, annos)
    ; where(
        if <elem> (SimpleAnno("id"), annos) then
          rules (
            EntityIdType : x_Class -> s
            EntityIdName : x_Class -> x
            )
        end
      )

  extract-entity-id(|x_Class) =
    ?DerivedProperty(_, _, _, _, _)

  inherited-properties =
    <conc>(<Properties>, <Extends; inherited-properties>)

  inherited-functions =
    <conc>(<Functions>, <Extends; inherited-functions>)

  inherited-properties :
    "Object" -> []

  inherited-functions :
    "Object" -> []

  declare-property(|x_class) =
    ?Property(x, k, s, annos)
    ; rules( TypeOfProperty : (x_class, x) -> s 
             IsProperty : (x_class, x) )
    ; try(declare-list-property(|x_class))
    ; try(<create-prop-required-rule(|x_class,x)> annos)
    
  declare-property(|x_class) =
    ?PropertyNoAnno(x, k, s)
    ; <declare-property(|x_class)> Property(x, k, s, [])

  create-prop-required-rule(|class,propname) =
    ?annos
    ; not([] := <collect(?ValidationAnnoNotNull() + ?ValidationAnnoNotEmpty())> annos)
    ; rules(
        PropertyIsRequired : (class, propname) -> True()
      )

  declare-list-property(|x_class) =
    ?Property(x, k, GenericSort(coll, [s@SimpleSort(_)]), annos)
    ; where(
             y := <concat-strings>[x, "List"]
           ; t := GenericSort("List", [s])
           )
        ; rules(
            TypeOfProperty : (x_class, y) -> t
          )
    
  declare-property(|x_class) =
    ?DerivedProperty(x, k, s, annos, e)
    ; rules(
        TypeOfProperty : (x_class, x) -> s
        IsProperty : (x_class, x)
        IsDerivedProperty : (x_class, x)
      )
    ; where(try(declare-list-property(|x_class)))

  declare-property(|x_class) =
    ?DerivedPropertyNoAnno(x, k, s, e)
    ; <declare-property(|x_class)> DerivedProperty(x, k, s, [], e)


  declare-property(|x_class) =
    ?DerivedPropertyNoAnno(x, k, srt, e)
    ; <declare-property(|x_class)> DerivedProperty(x, k, srt, [], e)

  declare-property(|x_class) =
    ?PropertyNoAnno(x, k, srt)
    ; <declare-property(|x_class)> Property(x, k, srt, [])

  declare-list-property(|x_class) =
    ?DerivedProperty(x, k, GenericSort(coll, [s@SimpleSort(_)]), annos, e)
    ; where(
        y := <concat-strings>[x, "List"]
      ; t := GenericSort("List", [s])
      )
    ; rules(
        TypeOfProperty : (x_class, y) -> t
      )

  declare-function(|x_class) =
     ?Function(f, args, sort, body1)
     ; t1* := <map(?Arg(_,<id>))> args
     ; rules( CheckFunctionSignature :
                   (SimpleSort(x_class), f, t2*) -> sort
                       where <zip(type-compatible)> (t1*, t2*)
            )
     ; rules( CheckFunctionSignature :+ // For after desugar
                   (None(), f, t3*) -> sort
                       where [SimpleSort(x_class)|t2*] := t3*
                           ; <zip(type-compatible)> (t1*, t2*)
            )
     ; rules( CheckFunctionSignature :+
                   (None(), f, t2*) -> sort
                       where <zip(type-compatible)> (t1*, t2*)
              IsFunction : (x_class, f)
            )

overlays

  NameProperty =
    Property("name", Simple(), SimpleSort("String"), [])

strategies // register top-level template definitions

//  declare-template-definitions =
//    alltd(declare-template-definition)


  declare-page-definition =
    ?def@Define([Page()], name, args, body)
    ; {| ThisPage
    : rules ( ThisPage := name )
    ; rules (
        TemplateDefinition : name -> def
        TemplateArguments  : name -> args
      )
     ; t1* := <map(?Arg(_,<id>))> args
     ; rules (
        IsPage :+ name -> name
        CheckPageSignature : (None(), name, t1*) -> SimpleSort("Page")
        TemplateSignature : (name, t1*) -> def
       )
//    ; try(declare-page-definition)
//    ; try(declare-email-definition) // @TODO make generic
//    ; <alltd(declare-email-action)> body // @TODO make generic
//    ; <debug> ["________declare_page", def]
//    ; <debug> ""
    ; !def
    |}

  declare-template-definition =
    ?def@Define(mods, name, fargs, body)
    ; t1* := <map(?Arg(_,<id>))> fargs
    ; rules (
        TemplateSignature : (name, t1*) -> def
        TemplateDefinition: (name, fargs) -> def
      )
//    ; <debug> ["________declare_template", name, fargs]
//    ; <debug> ""
    ; !def

  declare-toplevel-template-definition =
    ?Define(mods, name, fargs, body)
    ; if not(<elem> ((name, fargs), <bagof-TopLevelTemplateDefinitions> name)) then
        rules ( TopLevelTemplateDefinitions :+ name -> (name, fargs) )
      end
    ; declare-template-definition

  declare-local-template-definition =
    with (
      ?def@Define(mods, name, fargs, body)
      ; t1* := <map(?Arg(_,<id>))> fargs
      ; rules ( LocalTemplateSignature : (name, t1*) -> def )
      )
      ; !def

  declare-template-arg :
    Arg(x, s) -> Arg(x, s)
    where template := <InTemplate>
//        ; <debug> [".........", Arg(x,s), template]
        ; rules ( TemplateArguments :+ template -> Arg(x, s) )

  declare-template-args-old =
    <newname> "param"

  declare-template-arg-old(|template) =
    ?(Arg(x, SimpleSort(s)), y)
    ; rules ( TemplateArgument : (template, x) -> y
              IsTemplateArgument : y -> x )
//              TypeOf : y -> t' where t' := SimpleSort(<get-superclass> s) )

/*  declare-page-template-calls =
    ?def@Define([Page()], name, args, body)
    ; <all(declare-page-template-call)> body
    
  declare-page-template-call =
    ?t@TemplateCall(name, args, elems)
    ; page := <InPage>
    ; rules ( PageTemplateCalls :+ page -> t )*/

strategies

  declare-action =
    ?def@Action(name, fargs, body)
    ; where( t1* := <map(?Arg(_,<id>))> fargs )
    ; rules(
        ActionDefinition  : name -> def
        ActionArguments  : name -> fargs

        CheckActionSignature :
          (None(), name, t2*) -> SimpleSort("void")
          where <zip(type-compatible)> (t1*, t2*)
      )

strategies

  /*
  declare-globals =
    ?gd@GlobalsDefinition(decls)
    ; <map(declare-global-vars <+ declare-global-funcs)> decls
    ; !gd

  declare-global-vars =
    ?VarDeclInit(ident,sort,_)
    ; rules (
        TypeOf : ident -> sort
        IsGlobal : ident )

*/
  declare-global-func = where (
    ?fu@Function(f, args, s, b)
    ; t1* := <map(?Arg(_,<id>))> args
    ; f2 := f
    ; rules ( CheckGlobalFunctionSignature :+ (None(), f2, t2*) -> s
                       where <zip(type-compatible)> (t1*, t2*)
              IsGlobalFunction : (f, args, s)
              IsGlobalFunction : f
              GlobalFunctionArgs : f -> args
              GlobalFunctionBlock : f -> b
            )
    )

  declare-global-func =
    ?FunctionNoReturn(f, args, b)
    ; where(<declare-global-func> Function(f, args, SimpleSort("Void"), b))

rules // typechecking

  constraint-error : 
    GoTo(ThisCall(p, args)) -> <add-error(|["page ", <pp-webdsl> p, " does not exist."])>
    where not(<IsPage> p)
