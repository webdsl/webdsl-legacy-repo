module org/webdsl/dsl/typechecker/page

imports
  libstrategolib

imports
  libwebdsl-front

rules // constraints

  //duplicate page names
  constraint-error-ui :
    Application(nm, sections) -> <add-error(|["Pages ", <separate-by(|",")> page*, " are defined multiple times"])> 
    where pages := <collect(?Define([Page()], _, _, _)); map(\ Define([Page()], nm, _, _) -> nm \)> sections
        ; page* := <find-doubles> pages
        ; not([] := page*)

// @todo: check for multiple definitions of templates
/*  constraint-error-ui :
    Application(nm, sections) -> <add-error(|["Pages ", templates*, " are defined multiple times"])>
    where templates := <collect(?Define([Template()], _, _, _)); map(\ Define([Page()], nm, _, _) -> nm \)> sections
        ; templates* := <find-doubles> templates
        ; not([] := templates*)

  constraint-error-ui :
    Define([Template()], name, args, body) -> <add-error(|["Template ", name, " with arguments ", args, " is defined multiple times"])>
    where <TemplateSignature> (name, <map(?Arg(_,<id>))> args)
*/

  constraint-error-ui :
    IfTempl(e, _, _) -> <add-error(|["Expression ", <pp-webdsl> e, " should be of type Bool"])>
    where not(SimpleSort("Bool") := <type-of> e)

  constraint-error-ui :
    IfNoElseTempl(e, _) -> <add-error(|["Expression ", <pp-webdsl> e, " should be of type Bool"])>
    where not(SimpleSort("Bool") := <type-of> e)

  constraint-error-ui :
    For(_, srt, e, _) -> <add-error(|[<pp-webdsl> e, " should be of list type of ", <pp-webdsl> srt])>
    where not(GenericSort(_, srt) := <type-of> e)
    
/* Ruben: nog bezig; weet niet hoe ik kan checken of iets een entity of een andere srt is.
  constraint-error-ui :
    webdsl|[ 
      define page x_id(x_o : srt) {
        stat*
      }
    ]| -> <add-error(|["Entity", <pp-webdsl> srt, " does not exist "])>
    where not(<IsEntity> srt)*/

rules // typechecking template definitions


   /* @TODO: what to do with this?
   typecheck-variable =
     ?ExternalScopeVar(_) // is already checked at this point
   typecheck-page-variable :
     ExternalScopeVar(x) -> ExternalScopeVar(x){Type(t)}
     where if not(t := <TypeOf> x) then
             typecheck-error(|["variable ", x, " has no declared type",111111])
             ; t := "Error"
           end
           
      */

rules // typechecking page elements

  constraint-error-ui :
    TemplateCall("navigate", [e | _],passign*, []) -> <add-error(|["Not a valid link: ", <pp-webdsl> e])>
    where not(<check-link> e)


  constraint-error-ui :
    TemplateCall("navigate", [e | _],passign*, elems) -> <add-error(|["Not a valid link: ", <pp-webdsl> e])>
    where not(<check-link> e)


  constraint-error-ui :
    TemplateCall("navigatebutton", [e | _],passign*, elems) -> <add-error(|["Not a valid link: ", <pp-webdsl> e])>
    where not(<check-link> e)

  check-link :
    ThisCall("url", [e]) -> ThisCall("url", [e])
    where <type-of> e

  check-link :
    ThisCall(p, args) -> ThisCall(p, args)
    where not("url" := p)
        ; if not(<IsPage> p) then
            add-error(|["link to undefined page ", p])
          end

rules // typechecking for inits

  constraint-error-ui : 
    InitAction(body) -> <add-error(|["An init block can not contain a return statement."])>
    where not([] := <collect(?Return(_))> body)

rules // using page as template produces warning; tested in fail/pageastemplate.app

  constraint-error-page-as-template(|p) :
    x -> <add-warning(|["Shouldn't use page as template: ",<pp-webdsl> p])>
    where <IsPage> p
  
  //not all templatecall variants can be calls to defined templates    
  constraint-error-ui = ?tc@TemplateCallNoBody(p,_)       ;where(<constraint-error-page-as-template(|p)> tc)
  //constraint-error-ui = ?tc@TemplateCallNoArgs(p)         ;where(<constraint-error-page-as-template(|p)> tc) //has no args
  //constraint-error-ui = ?tc@TemplateCallNoAssigns(p,_,_)  ;where(<constraint-error-page-as-template(|p)> tc) //has a body
  constraint-error-ui = ?tc@TemplateCallPropsNoBody(p,_,_);where(<constraint-error-page-as-template(|p)> tc)
  //constraint-error-ui = ?tc@TemplateCallProps(p,_)        ;where(<constraint-error-page-as-template(|p)> tc) //has no args
  //constraint-error-ui = ?tc@TemplateCallPropsNoArgs(p,_,_);where(<constraint-error-page-as-template(|p)> tc) //has a body
  //constraint-error-ui = ?tc@TemplateCallBody(p,_)         ;where(<constraint-error-page-as-template(|p)> tc) //has a body
  //constraint-error-ui = ?tc@TemplateCall(p,_,_,_)         ;where(<constraint-error-page-as-template(|p)> tc) //has a body
 
rules //template not defined

  constraint-error-template-not-defined(|p,arg*) :
    x -> <add-error(|["Template with this signature not defined "])>
    where t* := <map(type-of)> arg* 
        ; not(<TemplateSignature> (p,t*))//TODO use lookup   // any local define is also correct here
        ; not(<CompatibleWithBuiltInTemplate> (p,t*))
        ; not(<TemplateWithGenerics> p)//TODO simplified lookup for generics for now
        ;<debug(!"check")> (p,t*)
    
  constraint-error-ui = ?tc@TemplateCallNoBody(p,arg*)       ;where(<constraint-error-template-not-defined(|p,arg*)> tc)
  constraint-error-ui = ?tc@TemplateCallNoArgs(p)            ;where(<constraint-error-template-not-defined(|p,[])> tc)
  constraint-error-ui = ?tc@TemplateCallNoAssigns(p,arg*,_)  ;where(<constraint-error-template-not-defined(|p,arg*)> tc)
  constraint-error-ui = ?tc@TemplateCallPropsNoBody(p,arg*,_);where(<constraint-error-template-not-defined(|p,arg*)> tc)
  constraint-error-ui = ?tc@TemplateCallProps(p,_)           ;where(<constraint-error-template-not-defined(|p,[])> tc)
  constraint-error-ui = ?tc@TemplateCallPropsNoArgs(p,_,_)   ;where(<constraint-error-template-not-defined(|p,[])> tc)
  constraint-error-ui = ?tc@TemplateCallBody(p,_)            ;where(<constraint-error-template-not-defined(|p,[])> tc)
  constraint-error-ui = ?tc@TemplateCall(p,arg*,_,_)         ;where(<constraint-error-template-not-defined(|p,arg*)> tc)
  
  
/* local redefine static checks
rules //check local defines
  constraint-error-ui : 
    def@Define(mods, name, fargs, body) -> def
    with <alltd(c-e-necessary-template-override-not-defined-1(|def))> body
    
  c-e-necessary-template-override-not-defined-1(|def) = ?tc@TemplateCallNoBody(p,arg*)       ;where(<c-e-necessary-template-override-not-defined-2(|<strip-annos> p,arg*)> def)
  c-e-necessary-template-override-not-defined-1(|def) = ?tc@TemplateCallPropsNoBody(p,arg*,_);where(<c-e-necessary-template-override-not-defined-2(|<strip-annos> p,arg*)> def)

  c-e-necessary-template-override-not-defined-2(|p,arg*) :
    def@Define(_, _, _, body) -> <add-error(|["Template override not defined: ",<pp-webdsl> p])>
    where t* := <map(type-of)> arg*
        ; not(<CompatibleWithBuiltInTemplate> (p,t*))
        ; reqs := <remove-all(CompatibleWithBuiltInTemplate);debug(!"filtered")> <bagof-TemplateRequires> (p,t*)
        ; not([] := reqs)
        ; <debug(!"local template check")> [p,arg*,<map(type-of <+ !"failed type-of")>arg*, (p,t*)]
        ; <map(\(p,t*) -> (p,t*) where [] := <collect(c-e-necessary-template-override-not-defined-3(|p,t*))> body \)> reqs

  c-e-necessary-template-override-not-defined-3(|p,t*) :
    def@Define(_,p,fargs,_) -> (p,t*)
    where not(<OverloadedTemplateSignature> (p,t*)) //there is no toplevel template for this call
        ; argtype* := <map(\Arg(_,srt) -> srt\)> fargs
        ; <zip(type-compatible)> (argtype*,t*)// generic,specific
*/
    
