module org/webdsl/dsl/typechecker/utils

imports
  libstrategolib

imports
  libwebdsl-front

strategies

  type-of = eq-type-of

rules

  is-webdsl-type = is-entity-type <+ is-simple-sort <+ is-generic-sort
  is-builtin-type = is-simple-sort <+ is-generic-sort

/* ANCIENT
rules

  type-of :
    e{t*} -> t
    where t := <fetch-elem(?Type(<id>))> t*

*/

rules // type compatibility

  /**
   *  understandable alias of type-compatible
   */
  first-is-super-or-same-type = type-compatible

  /**
   * <type-compatible> (t1, t2) if a value of type t2 can be assigned
   * to a variable of type t1
   */

  type-compatible =
    ?(t, t)

  type-compatible =
    ?(supertype, subtypetobechecked) //(supertype,subtype to be checked)
    ; where(<subtype-of> (subtypetobechecked, supertype))
    
  subtype-of =
    eq

  subtype-of =
    ?(SimpleSort(subtypetobechecked), SimpleSort(supertype))
    ; where( <extends>(subtypetobechecked, supertype) )

  extends-check = Extends
  extends-check = extends-builtin
  extends-check = extends-genericsorts
  
rules // (front-end) types to (back-end) annotations

  extends =
    while-not(eq, (extends-check, id))

  types-to-annotations =
    bottomup(try(type-to-annotation))
  
  type-to-annotation =
      where(sort := <type-of; try(add-extra-annotations)>)
    ; add-anno(|TypeAnno(sort))
      
  /* For SimpleSort(name) remember whether name represents a native class */
  add-extra-annotations =
      ?type@SimpleSort(name)
    ; class := <NativeClassQualifiedName> name         // fails if name is not a native class
    ; <add-anno(|NativeClassAnno(name, class))> type
