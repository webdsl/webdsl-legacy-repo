module org/webdsl/dsl/typechecker/entity

imports
  libstrategolib

imports
  libwebdsl-front

rules // typechecking entity declarations

  //duplicate entity names
  constraint-error :
    Entity(x_class, _, _, _) -> <add-error(|["Entity ", x_class, " is defined multiple times."])>
    where <bagof-IsEntity;length;not(?1)> x_class
  constraint-error :
    EntityNoSuper(x_class, _, _) -> <add-error(|["Entity ", x_class, " is defined multiple times."])>
    where <bagof-IsEntity;length;not(?1)> x_class
  constraint-error :
    SessionEntity(x_class, _, _) -> <add-error(|["Session Entity ", x_class, " of type ",<capitalize-string> x_class," is defined multiple times."])>
    where <bagof-IsEntity;length;not(?1)> <capitalize-string> x_class

  /*
  type-annotate-local(s) :
    def@def|[ entity x_class{ prop* fun* } ]| -> def'
    where {| TypeOf
           : rules( TypeOf : "this" -> SimpleSort(x_class) )
           ; def' := <s> def
           |}

  typecheck-entity :
    EntityNoSuper(x_class, props, function*) -> EntityNoSuper(x_class, props, function2*)
    where {| TypeOf
          : in-tc-context(
              rules( TypeOf : "this" -> SimpleSort(x_class) )
              ; where( <map(typecheck-property(|x_class))> props)
              ; function2* := <map(typecheck-function)> function*
              ; <map(extract-entity-id(|x_class))> props
              | ["entity declaration ", x_class]) |}
              */


/*
  typecheck-entity :
    Entity(x_class, s, props, functions) -> Entity(x_class, s, props, functions2)
    where {| TypeOf
           : in-tc-context(
                rules( TypeOf : "this" -> SimpleSort(x_class) )
              ; where( <typecheck-supertype> s )
              ; where( <map(typecheck-property(|x_class))> props )
              ; functions2 := <map(typecheck-function)> functions
              ; <map(extract-entity-id(|x_class))> props
              | ["entity declaration ", x_class]) |}

*/
  constraint-error :
    Entity(x_class, s, props, functions) -> <add-error(|["Super entity ", <pp-webdsl> s, " for ", x_class, " does not exist."])>
    where not(<typecheck-supertype> s)

/*
  typecheck-entity :
    SessionEntity(nm, props, function*) -> SessionEntity(nm, props, function2*)
    where {| TypeOf
          :   x_class := <capitalize-string> nm
              ; in-tc-context(
                rules( TypeOf : "this" -> SimpleSort(x_class) )
              ; where( <map(typecheck-property(|x_class))> props)
              ; function2* := <map(typecheck-function)> function*
              ; <map(extract-entity-id(|x_class))> props
              | ["session declaration ", nm]) |}

*/
  typecheck-supertype =
    ?s
    ; if not(<IsEntity> s) then
        add-error(|["supertype ", <pp-webdsl> s, " is not a defined entity"])
      end
    ; <map(declare-super-property(|s))> <Properties> s

  declare-super-property(|x_class) =
    ?Property(x, k, s, annos)
    ; rules( TypeOf : x -> s )
    ; rules( IsProperty : (x_class, x) )

  declare-super-property(|x_class) =
    ?DerivedProperty(x, k, s, annos, e)
    ; rules( TypeOf : x -> s )
    ; rules( IsProperty : (x_class, x) )

/*
  typecheck-property(|x_class) =
    ?prop@Property(x, k, s, annos)
    ; if not(<java-type> s) then
        typecheck-error(|["property ", x, " has invalid type"])
      end
    ; rules( TypeOf : x -> s )
    ; rules( IsProperty : (x_class, x) )
    ; <map(try(typecheck-annos(|prop)))> annos
*/

  constraint-error =
    (  ?DerivedProperty(x, _, s, _, e)
    <+ ?DerivedPropertyNoAnno(x, _, s, e) )
    ; where (
        te := <type-of> e
        ; <debug> te
        ; not(<type-compatible> (te, s))
        ; add-error(|["The expression of the derived property ", x, " should have type ", <pp-webdsl> s])
      )

  /*
  typecheck-property(|x_class) :
    DerivedProperty(x, k, s, annos, e) -> DerivedProperty(x, k, s, annos, e2)
    where e2 := <typecheck-expression> e
        ; <?_{Type(e2t)}> e2
        ; if not(<type-compatible>(e2t, s)) then
             typecheck-error(|["The expression of the derived type ", x, " should have type ", s, " but instead has type ", e2t])
          end
        ; rules( TypeOf : x -> s )
        ; rules( IsProperty : (x_class, x) )
        */

  constraint-error :
    InverseAnno(ent, fld) -> <add-error(|["The entity ", ent, " does not exist."])>
    where not(<IsEntity> ent)

  constraint-error :
    InverseAnno(ent, fld) -> <add-error(|["The field ", ent, ".", fld, " is not of the right type."])>
    where not(<TypeOfProperty> (ent, fld))

  constraint-error :
    InverseAnno(ent, fld) -> <add-error(|["Inverse annotations cannot be declared on both sides. Remove either the (inverse=", ent, ".", fld, ") or the (inverse=", i_ent, ".", i_fld, ") annotation."])>
    where [inverse_prop] := <filter(?Property(fld, _, _, annos))> <Properties> ent
        ; not([] := <filter(?InverseAnno(i_ent, i_fld))> annos)

  constraint-error :
    InverseAnno(ent, fld) -> <add-error(|["In a many-to-one bidirectional association the inverse annotation should be declared on the many side. (inverse=", i_ent, ".", i_fld, ")"])>
    where <filter(?Property(fld, _, _, annos))> <Properties> ent
        ; [InverseSlaveAnno(i_ent, i_fld)] := <filter(?InverseSlaveAnno(_, _))> annos
        ; SimpleSort(_) := <TypeOfProperty> (ent, fld)
        ; GenericSort(_, _) := <TypeOfProperty> (i_ent, i_fld)
  
/**
 * Check inverse annotations for
 * - type-compatibility between srt2 and e2
 * - type-compatibility between srt1 and e1
 *
 * Code example
 *   entity e1 {
 *     instance2 -> srt2 (inverse=e2.instance1)
 *   }
 *   entity e2 {
 *     instance1 -> srt1
 *   }
 */
  
  // check all properties in the context of an entity. This is necessary for the inverse check on attribute type
  constraint-error =
    (  ?Entity(ent1, _, props, _) 
    <+ ?EntityNoSuper(ent1, props, _) 
    <+ ?ExtendEntity(ent1, props, _)  )
    ; where (
        <map(check-property-inverse-annos(|ent1))> props
      )
  
  // takes care of different constructor types of properties
  check-property-inverse-annos(|ent1) =
    (?Property(_, _, srt2, annos) <+ ?DerivedProperty(_, _, srt2, annos, _))
    ; <check-property-inverse-annos> (ent1, srt2, annos)

  // check type-compatibility between srt2 and e2
  check-property-inverse-annos :
    (ent1, srt2, annos) -> <add-error(|["Type mismatch between attribute type ", <pp-webdsl> srt2, " and inverse entity type ", <pp-webdsl> ent2])>
    where <filter(?InverseAnno(ent2, fld))> annos
        ; <debug> (srt2, SimpleSort(ent2))
        ; not( <inverse-compatible> (srt2, SimpleSort(ent2)) )
        
  // check type-compatibility between srt1 and e1
  check-property-inverse-annos :
    (ent1, srt2, annos) -> <add-error(|["Type mismatch between inverse attribute type ", <pp-webdsl> srt1, " and entity type ", <pp-webdsl> ent1])>
    where <filter(?InverseAnno(ent2, fld))> annos
        ; properties := <Properties> ent2
        ; <fetch(
               ?Property(fld, _, srt1, _) 
            <+ ?PropertyNoAnno(fld, _, srt1)
            <+ ?DerivedProperty(fld, _, srt1, _, _)
            <+ ?DerivedPropertyNoAnno(fld, _, srt1, _))
          > properties
        ; <debug> (SimpleSort(ent1), srt1)
        ; not( <inverse-compatible> (SimpleSort(ent1), srt1) )
      
  inverse-compatible = ?(srt, srt)
  inverse-compatible = ?(GenericSort(_, [srt]), srt)
  inverse-compatible = ?(srt, GenericSort(_, [srt]))
  
  constraint-error =
    (  ?Property(x, propkind, srt, _)
    <+ ?PropertyNoAnno(x, propkind, srt)
    <+ ?DerivedProperty(x, propkind, srt, _, _)
    <+ ?DerivedPropertyNoAnno(x, propkind, srt, _) )
    ; where(
           <check-no-null-attribute> (x, srt)         // check for wrong attribute types
        <+ <check-no-void-attribute> (x, srt)
        <+ <check-simple-propkind> (propkind, srt)    // check for incompatible propkinds, such as :: Set<User> (which should be -> Set<User>)
        <+ <check-complex-propkind> (propkind, srt) 
      )
  
  check-no-null-attribute :
    (x, SimpleSort("Null")) -> <add-error(|["Attribute type Null is not allowed in attribute ", <pp-webdsl> x])>

  check-no-void-attribute :
    (x, SimpleSort("Void")) -> <add-error(|["Attribute type Void is not allowed in attribute ", <pp-webdsl> x])>

  check-simple-propkind :
    (Simple, srt) -> <add-error(|["Expected: Simple type. Encountered: ", <pp-webdsl> srt])>
    where not(<is-simple-sort> srt)

  check-complex-propkind =
    (?(Ref, srt) <+ ?(Comp, srt))
    ; where (
        <is-simple-sort> srt
        ; add-error(|["Expected: Reference type or Composite type. Encountered: ", <pp-webdsl> srt])
      )
    

  is-simple-sort = ?SimpleSort("Bool")
  is-simple-sort = ?SimpleSort("Date")
  is-simple-sort = ?SimpleSort("Email")
  is-simple-sort = ?SimpleSort("File")
  is-simple-sort = ?SimpleSort("Image")
  is-simple-sort = ?SimpleSort("Int")
  is-simple-sort = ?SimpleSort("Patch")
  is-simple-sort = ?SimpleSort("Secret")
  is-simple-sort = ?SimpleSort("String")
  is-simple-sort = ?SimpleSort("Text")
  is-simple-sort = ?SimpleSort("Url")
  is-simple-sort = ?SimpleSort("WikiText")

/*  constraint-error =
    (?Property(_, Simple, srt, _) <+ ?DerivedProperty(_, Simple, srt, _, _)); <check-propkind> srt

  check-propkind-simple :
    srt -> <add-error(|["Expecting simple type, encountered ", <pp-webdsl> srt])>
    where not(<is-simple-type> srt)
*/    
  /*
  typecheck-annos(|prop) =
    ?InverseAnno(ent, fld)
    ; where (
        if not(<IsEntity> ent) then
          typecheck-error(|["The entity ", ent, " does not exist."])
        end
      ; if not(t := <TypeOfProperty> (ent, fld)) then
          typecheck-error(|["The field ", ent, ".", fld, " is not of the right type."])
        end
      ; [inverse_prop] := <filter(?Property(fld, _, _, annos))> <Properties> ent
      ; if (not([] := <filter(?InverseAnno(i_ent, i_fld))> annos)) then
          typecheck-error(|["Inverse annotations cannot be declared on both sides. Remove either the (inverse=", ent, ".", fld, ") or the (inverse=", i_ent, ".", i_fld, ") annotation."])
        end
      ; if ([InverseSlaveAnno(i_ent, i_fld)] := <filter(?InverseSlaveAnno(_, _))> annos) then
          if ( SimpleSort(_) := t ; GenericSort(_, _) := <TypeOfProperty> (i_ent, i_fld) ) then
            typecheck-error(|["In a many-to-one bidirectional association the inverse annotation should be declared on the many side. (inverse=", i_ent, ".", i_fld, ")"])
          end
        end
    )
    */
//    ; GenericSort(coll, [SimpleSort(x_Class)]) := <TypeOfProperty> (ent, fld)


 /*   ; if not(<?GenericSort(_, _)> t) then
        typecheck-error(|["The property refered to is not a collection: ", ent, ".", fld])
      end */

rules // typechecking entity functions
  /*
  typecheck-function :
    Function(f, args, sort, body1) -> Function(f, args, sort, body2)
    where( {| TypeOf, ReturnType
            : in-tc-context(
               rules( ReturnType := sort )
               ; <map(declare-typeof-arg)> args
               ; body2 := <typecheck-function-block> body1
             |["function ", f, "/"])
           |} )
        */

  /*
  typecheck-function-stat =
    typecheck-function-block
    <+ typecheck-assignment-stat
    <+ typecheck-vardecl
    <+ typecheck-if
    <+ typecheck-for
    <+ typecheck-function-return
    <+ Stat(typecheck-expression)
    <+ warn(|"warning: not typechecking statement: ")

  typecheck-function-block =
    Block({| TypeOf : in-tc-context(map(typecheck-function-stat)|["block/"]) |})

  typecheck-function-return :
    Return(e1) -> Return(e2)
    where e2 := <typecheck-expression> e1
        ; <?_{Type(e2t)}> e2
        ; rt := <ReturnType>
        ; if not(<type-compatible>(e2t, rt)) then
             typecheck-error(|["The return statement expression of the derived type ", e2t, " should have type ", rt])
           end
           */
