 /**

   Generate a JPA/Hibernate entity class from an entity declaration

 */

 module org/webdsl/dsl/to-seam/java-entity

 imports
   libstrategolib
   libjava-front

 imports
   libwebdsl-syntax
   libwebdsl-utils
   org/webdsl/dsl/transformation/types

overlays

  e_UTILS = expr|[ org.webdsl.tools.Utils ]|

strategies

   GenerateCode = entity-to-java-entity; fail

   // @todo factor out code generation for properties to generate @Partial classes

   entity-to-java-entity :
     EntityNoSuper(x_Class, props, functions) ->
     <emit-java-code> compilation-unit|[
       package pkgname;

       import java.util.*;
       import org.jboss.seam.persistence.*;
       import javax.persistence.*;
       import pkgname.*;
       import java.io.Serializable;

       @Entity
       //@javax.persistence.Inheritance(strategy = javax.persistence.InheritanceType.JOINED)
       @javax.persistence.Inheritance(strategy = javax.persistence.InheritanceType.SINGLE_TABLE)
       @javax.persistence.DiscriminatorColumn(name = "DISCRIMINATOR", discriminatorType = javax.persistence.DiscriminatorType.STRING, length = 255)
       public class x_Class implements org.webdsl.WebDSLEntity
       {
          public x_Class () {}

          ~*idcodes

        public boolean equals(Object o) {
          return o != null && e_UTILS.isInstance(o, x_Class.class) && e_UTILS.equal(((x_Class)o).getId(), getId());
        }

          public int hashCode() {
            if (getId() == null)
              return super.hashCode();
            else
              return getId().hashCode();
          }

          public int compareTo(org.webdsl.WebDSLEntity o) {
            return getId().compareTo(((x_Class)o).getId());
          }

          public boolean isInstance(Class<?> c) {
            return c.isInstance(this);
          }

          ~*cbds
          ~*fcbs
       }
     ]|
     where {| ClassName
      : rules( ClassName := x_Class )
      ; idcodes := <generate-id-code> x_Class
      ; cbds := <properties-to-code(|x_Class)> props
      ; fcbs := <functions-to-code(|x_Class)> functions
      ; pkgname := <DomainPackage>
      |}

   entity-to-java-entity :
     SessionEntity(x_ident, props, functions) ->
     <emit-java-code> compilation-unit|[
       package pkgname;

       import java.util.*;
       import org.jboss.seam.persistence.*;
       import javax.persistence.*;
       import pkgname.*;
       import java.io.Serializable;

       @Entity
       @org.jboss.seam.annotations.Scope(org.jboss.seam.ScopeType.SESSION)
       @org.jboss.seam.annotations.Name("~x_ident")
       public class x_Class implements org.webdsl.WebDSLEntity
       {
        public x_Class () {}

        @Id @GeneratedValue
        private Long id;

        public Long getId() { return id; }

        public void setId(Long id) { this.id = id; }

        public boolean equals(Object o) {
          return o != null && e_UTILS.isInstance(o, x_Class.class) && e_UTILS.equal(((x_Class)o).getId(), getId());
        }

        public int hashCode() {
          if (getId() == null)
            return super.hashCode();
          else
            return getId().hashCode();
        }

        public int compareTo(org.webdsl.WebDSLEntity o) {
          return getId().compareTo(((x_Class)o).getId());
        }

        public boolean isInstance(Class<?> c) {
          return c.isInstance(this);
        }

        ~*cbds
        ~*fcbs
       }
     ]|
     where x_Class := <capitalize-string> x_ident
    ; {| ClassName
        : rules( ClassName := x_Class )
        ; cbds := <properties-to-code(|x_Class)> props
        ; fcbs := <functions-to-code(|x_Class)> functions
        ; pkgname := <DomainPackage>
        |}

   entity-to-java-entity :
     Entity(x_Class, x_super, props, functions) ->
     <emit-java-code> compilation-unit|[
       package pkgname;

       import java.util.*;
       import org.jboss.seam.persistence.*;
       import javax.persistence.*;
       import pkgname.*;
       import java.io.Serializable;

       @Entity
       public class x_Class extends x_super implements org.webdsl.WebDSLEntity
       {
      public x_Class () {}

        public boolean equals(Object o) {
          return o != null && e_UTILS.isInstance(o, x_Class.class) && e_UTILS.equal(((x_Class)o).getId(), getId());
        }

      public int hashCode() {
        if (getId() == null)
          return super.hashCode();
        else
          return getId().hashCode();
      }

        public int compareTo(org.webdsl.WebDSLEntity o) {
          return getId().compareTo(((x_Class)o).getId());
        }

        public boolean isInstance(Class<?> c) {
          return c.isInstance(this);
        }

        ~*cbds
        ~*fcbs
       }
     ]|
     where {| ClassName
      : rules( ClassName := x_Class )
      ; cbds := <properties-to-code(|x_Class)> props
      ; fcbs := <functions-to-code(|x_Class)> functions
      ; pkgname := <DomainPackage>
      |}
      // @note: don't define id on an entity with a super class; it
      // is inherited from the super class

   entity-to-class-fails =
     (?EntityNoSuper(_, _, _) <+ ?Entity(_,_,_,_))
     ; err(|"cannot generate code for entity")

 strategies
   generate-id-code =
     ?x_Class
     ; if <EntityIdName> x_Class then
         x_idget := <concat-strings> ["get", <capitalize-string> <EntityIdName> x_Class]
         ; x_idset := <concat-strings> ["set", <capitalize-string> <EntityIdName> x_Class]
         ; t := <java-type> <EntityIdType> x_Class
         ; !class-body-dec* |[
            public t getId() { return x_idget(); }
            public void setId(t val) { x_idset(val); }
          ]|
       else
         !class-body-dec* |[
           @Id @GeneratedValue
           private Long id;

           public Long getId() { return id; }

           public void setId(Long id) { this.id = id; }
         ]|
       end

   properties-to-code(|x_Class) :
     props -> cbds
     where cbds1 := <filter-concat-warn(property-to-property-code(|x_Class)
          | "cannot generate code for property: ")> props
  ; cbds2 := <inherited-properties; name-property(|x_Class) <+ ![]> x_Class
  ; cbds  := <concat>[cbds1, cbds2]


   functions-to-code(|x_Class) :
     functions -> fcbs1
     where fcbs1 := <filter-concat-warn(function-to-function-code(|x_Class)
          | "cannot generate code for function: ")> functions
  //; fcbs2 := <inherited-functions <+ ![]> x_Class
  //; fcbs  := <concat>[fcbs1, fcbs2]


 strategies

   name-property(|x_Class) :
     props -> class-body-dec* |[
       public String getName() {
  return x_get().toString();
       }
     ]|
     where <not(fetch(?Property("name", _, _, _)))> props
  ; x_prop := <get-namefield> props
  ; x_get := <concat-strings>["get", <capitalize-string> x_prop]

 rules

   /**
    * Property is a private field with a getter and a setter.
    */

   property-to-property-code(|x_Class) :
     prop@Property(x, k, s, annos) -> class-body-dec* |[

       mod0* mod1* mod2* private t _#x = e;

        mod3*
       public t get#x() {
      return _#x;
       }

       public void set#x(t value) {
          _#x = value;
         ~*bas*
       }

       ~*cbd*

     ]|
     where t      := <java-type> s
        ; e      := <initialization-expression> (k, s)
        ; if x := <EntityIdName> x_Class then
            mod0* := [anno|[ @Id ]|]
          else
            mod0* := []
          end
        ; mod1*  := <persistence-annotations> s
        ; mod2*  := <property-to-persistence-annotations(|x_Class)> prop
        ; mod3*  := <validation-annotations-to-property-code> annos
        ; cbd*   := <property-to-special-getters(|x_Class) <+ ![]> prop
        ; bas*	  := <bidirectional-association-setter <+ ![]> prop

   property-to-property-code(|x_Class) :
     prop@DerivedProperty(x, k, s, annos, e) -> class-body-dec* |[

       public t get#x() {
    return ~e:gettercode;
       }

       ~*cbd*
     ]|
     where t      := <java-type> s
  ; gettercode := <expression-to-java> e
  ; cbd*   := <property-to-special-getters(|x_Class) <+ ![]> prop

 rules // property initialization

   initialization-expression =
     builtins-initialization-expression
     <+ default-initialization-expression

   default-initialization-expression :
     (Ref(), SimpleSort(y)) -> java |[ null ]|

   default-initialization-expression :
     (Comp(), SimpleSort(y)) -> |[ new y() ]|

   default-initialization-expression :
     (k, s) -> <java-type-default-value> s
     where not(?(Ref(),SimpleSort(_)) <+ ?(Comp(),SimpleSort(_)))

 rules // annotations for properties

   property-to-persistence-annotations(|x_Class) :
     Property(x_prop, k, s, annos) ->
     <concat>[
       <association-annotations(|x_Class, x_prop, annos)> s,
       <cascade-annotations> k
     ]

 rules // function generation

   function-to-function-code(|x_Class) :
     function@Function(x, args, s, Block(stm*)) -> class-body-dec* |[

       public t x(param*) {
         bstm*
       }

     ]|
     where {| InFunction
            : rules( InFunction := <id> )
            ; t      := <java-type> s
      ; param* := <map(action-arg-to-method-arg)> args
      ; bstm* := <statements-to-java> stm*
      |}


 rules // association annotations

   // Property with a value type

   association-annotations(|x_Class, x_prop, annos) :
     s@SimpleSort(y) -> []
     where <builtin-java-type> s

   // Property with a reference association type

   // Many-to-One associations

   association-annotations(|x_Class, x_prop, annos) :
     s@SimpleSort(y) -> [anno]
     where t := <defined-java-type> s
         ; [] := <filter(?SimpleAnno(_))> annos
         ; [] := <collect(?InverseAnno(_, _))> annos
         ; [] := <collect(?InverseSlaveAnno(_, _))> annos
         ; if <SubClass> y then
             anno := anno|[ @ManyToOne(fetch=javax.persistence.FetchType.EAGER) ]|
           else
             anno := anno|[ @ManyToOne(fetch=javax.persistence.FetchType.LAZY) ]|
           end

   // bidirectional many-to-one controlling side
   association-annotations(|x_Class, x_prop, annos) :
     s@SimpleSort(y) ->
     [
       anno|[ @ManyToOne(fetch=javax.persistence.FetchType.LAZY) ]|,
       anno|[ @JoinColumn(name="~columnname") ]|
     ]
     where t := <defined-java-type> s
         ; [InverseAnno(ent, fld) | xs ]       := <collect(?InverseAnno(_, _))> annos
         ; GenericSort(coll, [SimpleSort(yy)]) := <TypeOfProperty> (ent, fld)
         ; columnname := <concat-strings>[x_Class, x_prop]


   // Property with a reference one-to-one association type

   // bidirectional one-to-one controlling side
   association-annotations(|x_Class, x_prop, annos) :
     s@SimpleSort(y) ->
     [
       anno|[ @OneToOne(fetch=javax.persistence.FetchType.LAZY) ]|,
       anno|[ @JoinColumn(name="~x_fk") ]|
     ]
     where t := <defined-java-type> s
         ; [InverseAnno(ent, fld) | xs ] := <collect(?InverseAnno(_, _))> annos
         ; SimpleSort(yy)                := <TypeOfProperty> (ent, fld)
         ; x_fk                          := <concat-strings> [x_Class, x_prop, "_fk"]

   // bidirectional one-to-one inverse side
   association-annotations(|x_Class, x_prop, annos) :
     s@SimpleSort(y) ->
     [
       anno|[ @OneToOne(mappedBy="~mappedby",fetch=javax.persistence.FetchType.LAZY) ]|
     ]
     where t := <defined-java-type> s
         ; [InverseSlaveAnno(ent, fld)|xs] := <collect(?InverseSlaveAnno(_, _))> annos
         ; SimpleSort(yy) := <TypeOfProperty> (ent, fld)
         ; mappedby       := <concat-strings> ["_", fld]


   // Collection types

   // One-to-Many association

   // bidirectional one-to-many inverse side
   association-annotations(|x_Class, x_prop, annos) :
     GenericSort(coll, [s]) -> [ 
       anno|[ @OneToMany( mappedBy="~mappedby", targetEntity=x_ent ,fetch=javax.persistence.FetchType.LAZY) ]| 
     ]
     where <?"Set" <+ ?"List"> coll
     ; t := <defined-java-type> s
     ; [InverseSlaveAnno(ent, fld)|xs] := <collect(?InverseSlaveAnno(_, _))> annos
     ; SimpleSort(ident) := <TypeOfProperty> (ent, fld)
     ; x_ent             := <concat-strings> [ent, ".class"]
     ; mappedby          := <concat-strings> ["_", fld]

   // Many-to-Many associations

   // unidirectional many-to-many
   association-annotations(|x_Class, x_prop, annos) :
     GenericSort("List", [s]) -> [
       anno|[ @ManyToMany(fetch=javax.persistence.FetchType.LAZY) ]|
     ]
     where t := <defined-java-type> s

   // unidirectional many-to-many
   association-annotations(|x_Class, x_prop, annos) :
     GenericSort("Set", [s@SimpleSort(ss)]) -> [
       anno|[ @ManyToMany(fetch=javax.persistence.FetchType.LAZY) ]|,
       anno|[ @JoinTable(name = "~tableName") ]|
       ]
    where t := <defined-java-type> s
        ; [] := <collect(?InverseSlaveAnno(_, _))> annos
        ; [] := <collect(?InverseAnno(_, _))> annos
        ; tableName := <concat-strings> [x_Class, "_", x_prop]

   // bidirectional many-to-many controlling side
   association-annotations(|x_Class, x_prop, annos) :
      GenericSort(coll, [s@SimpleSort(ss)]) ->
      [
        anno|[ @ManyToMany(fetch=javax.persistence.FetchType.LAZY) ]|,
        anno|[ @JoinTable( name="~colname",
                           joinColumns={@JoinColumn(name="~thisid")},
                           inverseJoinColumns={@JoinColumn(name="~otherid")} )
        ]|
      ]
    where <?"Set" <+ ?"List"> coll
        ; t := <defined-java-type> s
        ; [InverseAnno(ent, fld) | xs ] := <collect(?InverseAnno(_, _))> annos
        ; colname   := <concat-strings> [x_Class, "_", x_prop, "_", ss]
        ; thisid    := <concat-strings> [x_Class, "_id_this"]
        ; otherid   := <concat-strings> [ent, "_id_other"]

   // bidirectional many-to-many inverse side
   association-annotations(|x_Class, x_prop, annos) :
     GenericSort(coll, [s@SimpleSort(ss)]) ->
       [
         anno|[ @ManyToMany( mappedBy="~mappedby", targetEntity=x_ent ,fetch=javax.persistence.FetchType.LAZY) ]|
       ]
     where <?"Set" <+ ?"List"> coll
     ; t := <defined-java-type> s
  ; [InverseSlaveAnno(ent, fld)|xs]  := <collect(?InverseSlaveAnno(_, _))> annos
  ; x_ent                            := <concat-strings> [ent, ".class"]
  ; mappedby                         := <concat-strings> ["_", fld]

   association-annotations(|x_Class, x_prop, annos) :
     GenericSort("Map", [s1, s2]) -> [anno|[ @ManyToMany(fetch=javax.persistence.FetchType.LAZY) ]|]
     where t1 := <builtin-java-type> s1
  ; t2 := <defined-java-type> s2

   // Set of values.

   association-annotations(|x_Class, x_prop, annos) :
     GenericSort("Set", [s@SimpleSort(_)])->
     [
       anno|[
         @org.hibernate.annotations.CollectionOfElements(targetElement = t.class)
       ]|,

       anno|[ @JoinTable(name = "~tableName") ]|, //, joinColumns = @JoinColumn(name = "~joincolumn")

       anno|[ @Column(name = "~x_prop", nullable = false) ]|
     ]
     where t         := <builtin-java-type> s
  ; x_Prop    := <capitalize-string> x_prop
  ; tableName := <concat-strings>[x_Class, "_", x_Prop]

  // Property with a composite association type,
  // i.e., to a defined entity that is owned by x_Class.
  // @note might be translated as @Embeddable

  association-annotations(|x_Class, x_prop, annos) :
    s@SimpleSort(y) ->
    [
      anno|[ @ManyToOne(fetch=javax.persistence.FetchType.LAZY) ]|,
      anno|[ @JoinColumn(name = "~columnname") ]|
    ]
    where t          := <defined-java-type> s
        ; x_Prop     := <capitalize-string> x_prop
        ; columnname := <concat-strings>[x_Class, x_Prop]

rules // cascading annotations

  cascade-annotations :
    Ref() -> [anno|[
      @org.hibernate.annotations.Cascade({
      org.hibernate.annotations.CascadeType.PERSIST,
        org.hibernate.annotations.CascadeType.SAVE_UPDATE,
        org.hibernate.annotations.CascadeType.MERGE
      })
    ]|]

  cascade-annotations :
    Comp() -> [anno|[
      @org.hibernate.annotations.Cascade({
      org.hibernate.annotations.CascadeType.ALL
      })
    ]|]

  cascade-annotations :
    Simple() -> []

rules // special methods

   property-to-special-getters(|x_Class) :
    prop@Property(x, k, s@GenericSort(coll, [SimpleSort(y)]), annos) ->
    class-body-dec* |[
      public t get#x#List() {
        return new ArrayList(get#x());
      }

      public void set#x#List(t x_listvar) {
        ~*bas*
        set#x(e_newgen);
      }

      public int get#x#Length() {
        return get#x().size();
      }

      ~*cbds
    ]|
    where <?"Set" <+ ?"List"> coll
        ; t         := <java-type> GenericSort("List", [SimpleSort(y)])
        ; x_listvar := <newname> "list"
        ; e_newgen  := <transform-list-to-genericset(|x_listvar)> s
        ; bas*	    := <bidirectional-manytomany-setter(|x_listvar) <+ ![]> prop
        ; cbds      := <collection-mutation-methods <+ ![]> prop

  property-to-special-getters(|x_Class) :
    DerivedProperty(x_prop, k, s@GenericSort(coll, [SimpleSort(y)]), annos, expr) ->
    class-body-dec* |[
      public t x_getList() {
        return new ArrayList(x_get());
      }

      public int x_getLength() {
        return x_get().size();
      }
    ]|
    where <?"Set" <+ ?"List"> coll
        ; t         := <java-type> GenericSort("List", [SimpleSort(y)])
        ; x_Prop    := <capitalize-string> x_prop
        ; x_getList := <concat-strings>["get", x_Prop, "List"]
        ; x_getLength := <concat-strings>["get", x_Prop, "Length"]
        ; x_get     := <concat-strings>["get", x_Prop]

  collection-mutation-methods :
    prop@Property(x_prop, k, s@GenericSort(coll, [SimpleSort(y)]), annos) ->
    class-body-dec* |[
      public void x_removeFrom(t_y item) {
        x_get().remove(item);
        bstm0*
      }

      public void x_addTo(t_y item) {
        x_get().add(item);
        bstm1*
      }
    ]|
    where t_y       := <java-type> SimpleSort(y)
        ; x_get     := <property-getter> x_prop
        ; x_addTo   := <concat-strings>["addTo", <capitalize-string> x_prop]
        ; x_removeFrom := <concat-strings>["removeFrom", <capitalize-string> x_prop]
        ; inverse := <filter(?InverseSlaveAnno(_, _) + ?InverseAnno(_, _))> annos
        ; if [] := inverse then
              bstm0* := []
            ; bstm1* := []
          else
            bstm0* := <remove-bidirectional-reference <+ ![]> inverse
          ; bstm1* := <add-bidirectional-reference <+ ![]> inverse
          end

  transform-list-to-genericset(|x_listvar) :
    GenericSort("List", [s]) -> |[ new java.util.ArrayList<t>(x_listvar) ]|
    where t := <java-wrapper-type> s

  transform-list-to-genericset(|x_listvar) :
    GenericSort("Set", [s]) -> |[ new java.util.LinkedHashSet<t>(x_listvar) ]|
    where t := <java-wrapper-type> s

  transform-list-to-genericset(|x_listvar) :
    GenericSort("Map", [s1,s2]) -> |[ new java.util.HashMap<t1,t2>(x_listvar) ]|
    where t1 := <java-wrapper-type> s1
        ; t2 := <java-wrapper-type> s2

  remove-bidirectional-reference :
    name#([x_c, x_p]) ->
      bstm* |[
        if ( item.x_getInverse().contains(this) ) {
          item.x_getInverse().remove(this);
        }
      ]|
    where <?"InverseAnno" <+ ?"InverseSlaveAnno"> name
        ; GenericSort(coll,[_]) := <TypeOfProperty> (x_c, x_p)
        ; <?"Set" <+ ?"List"> coll
        ; x_P := <capitalize-string> x_p
        ; x_getInverse := <concat-strings>["get", x_P]

  remove-bidirectional-reference :
    InverseSlaveAnno(x_c, x_p) -> bstm* |[ item.x_setInverse(null); ]|
    where SimpleSort(_) := <TypeOfProperty> (x_c, x_p)
        ; x_P := <capitalize-string> x_p
        ; x_setInverse := <concat-strings>["set", x_P]

  add-bidirectional-reference :
    name#([x_c, x_p]) ->
      bstm* |[
        if ( !item.x_getInverse().contains(this) ) {
          item.x_getInverse().add(this);
        }
      ]|
    where <?"InverseAnno" <+ ?"InverseSlaveAnno"> name
        ; GenericSort(coll,[_]) := <TypeOfProperty> (x_c, x_p)
        ; <?"Set" <+ ?"List"> coll
        ; x_P := <capitalize-string> x_p
        ; x_getInverse := <concat-strings>["get", x_P]

  add-bidirectional-reference :
    InverseSlaveAnno(x_c, x_p) ->
      bstm* |[
        if (item.x_getInverse() != this) {
          item.x_setInverse(this);
        }
      ]|
    where SimpleSort(_) := <TypeOfProperty> (x_c, x_p)
        ; x_P := <capitalize-string> x_p
        ; x_setInverse := <concat-strings>["set", x_P]
        ; x_getInverse := <concat-strings>["get", x_P]

  // one-to-many
  bidirectional-association-setter :
    Property(prop, k, s@GenericSort(coll, [SimpleSort(y)]), annos) ->
      bstm* |[
        for (t1 var1 : this.x_items()) {
            var1.x_set(null);
      }
        for (t1 var1 : x_prop) {
            if (var1.x_get() != this) {
            var1.x_set(this);
          }
      }
      ]|
    where [InverseSlaveAnno(ent, fld) | xs] := <collect(?InverseSlaveAnno(_, _))> annos
        ; <?"Set" <+ ?"List"> coll
        ; SimpleSort(x_Class) := <TypeOfProperty> (ent, fld)
        ; t1					:= <java-type> SimpleSort(y)
        ; x_set  				:= <property-setter> fld
        ; x_get  				:= <property-getter> fld
        ; x_prop 				:= <concat-strings>["_", prop]
        ; x_items               := <property-getter> prop

   // many-to-many
   bidirectional-manytomany-setter(|x_listvar) :
    Property(prop, k, s@GenericSort(coll1, [SimpleSort(y)]), annos) ->
      bstm* |[
          for (t1 var1 : this.x_prop()) {
            if (!x_listvar.contains(var1)) {
              var1.x_removeFrom(this);
            }
        }
        for (t1 var1 : x_listvar) {
          if (!this.x_prop().contains(var1)) {
              var1.x_addTo(this);
            }
        }
      ]|
    where [name#([ent, fld])] := <filter(?InverseSlaveAnno(_, _))> annos
        ; GenericSort(coll2, [SimpleSort(x_Class)]) := <TypeOfProperty> (ent, fld)
        ; <?"Set" <+ ?"List"> coll1
        ; <equal> (coll1, coll2)
        ; t1				  := <java-type> SimpleSort(y)
        ; x_addTo             := <concat-strings> ["addTo", <capitalize-string> fld]
        ; x_removeFrom        := <concat-strings> ["removeFrom", <capitalize-string> fld]
        ; x_var 			  := <concat-strings>["_", prop]
        ; x_prop 			  := <property-getter> prop

   // many-to-one
   bidirectional-association-setter :
    Property(prop, k, SimpleSort(y), annos) ->
      bstm* |[
        if (x_prop != null && !x_prop.x_get().contains(this)) {
          x_prop.x_addTo(this);
        }
      ]|
    where [InverseAnno(ent, fld)] := <filter(?InverseAnno(_, _))> annos
        ; GenericSort(coll, [SimpleSort(x_Class)]) := <TypeOfProperty> (ent, fld)
        ; <?"Set" <+ ?"List"> coll
        ; x_addTo               := <concat-strings> ["addTo", <capitalize-string> fld]
        ; x_prop 				:= <concat-strings>["_", prop]
        ; x_get                 := <property-getter> fld

   // one-to-one
   bidirectional-association-setter :
    Property(prop, k, SimpleSort(y), annos) ->
      bstm* |[
        if (x_prop != null && x_prop.x_get() != this) {
          x_prop.x_set(this);
        }
      ]|
    where [name#([ent, fld])] := <filter(?InverseAnno(_, _) + ?InverseSlaveAnno(_, _))> annos
        ; SimpleSort(x_Class) := <TypeOfProperty> (ent, fld)
        ; x_prop 		      := <concat-strings>["_", prop]
        ; x_get               := <property-getter> fld
        ; x_set               := <property-setter> fld
