/**
 * Generate a Seam EntityHome class for a declared entity
 */

module org/webdsl/dsl/generation/java-EntityHome

imports 
  libstrategolib  
  Java-15 
  libjava-front 
  
imports 
  org/webdsl/dsl/syntax/WebDSL
  org/webdsl/dsl/utils/utils

rules // session bean from page definition

  page-to-java : 
    def@Define([Page()], x_page, args, elems1) -> 
    <create-local-interface(|pkgname, pkgname2, x_PageBeanInterface)> JavaFile(["src"], 
    compilation-unit|[
      package pkgname;
      import java.util.*;
      import java.io.Serializable;

      import static javax.persistence.PersistenceContextType.EXTENDED;
      
      import javax.persistence.PersistenceContext;
      import javax.persistence.EntityManager;
      
      import javax.ejb.Stateless;
      import javax.ejb.Stateful;
      import javax.ejb.Remove;

      import org.jboss.seam.ScopeType;
      import org.jboss.seam.annotations.Begin;
      import org.jboss.seam.annotations.End;
      import org.jboss.seam.annotations.Destroy;
      import org.jboss.seam.annotations.Name;
      import org.jboss.seam.annotations.Scope;
      import org.jboss.seam.annotations.Create;
      import org.jboss.seam.annotations.Logger;
      import org.jboss.seam.annotations.RequestParameter;
      import org.jboss.seam.annotations.datamodel.DataModel;
      import org.jboss.seam.annotations.datamodel.DataModelSelection;
      import org.jboss.seam.core.FacesMessages;
      import org.jboss.seam.log.Log;

      import org.jboss.seam.annotations.In;
      import org.jboss.seam.annotations.Out;

      import org.jboss.seam.annotations.Factory;
      
      import pkgname2.*;
  
      @Stateful
      @Name(~string:String([Chars(x_page)]))
      public class x_PageBean implements x_PageBeanInterface {
      
        @Logger 
        private Log log;
      
        @PersistenceContext(type = EXTENDED)
        private EntityManager em;

        @In 
        private FacesMessages facesMessages;

        @Create @Begin 
	    public void initialize() {
		  bstm*
	    }
	    
	    @Destroy @Remove
	    public void destroy() {}
	    
	    ~*cbds
	    
	    ~*cbds2
      }
    ]|)
    where pkgname    := <BeanPackage>
        ; pkgname2   := <DomainPackage>
        ; x_Page     := <capitalize-string> x_page
	    ; x_PageBean := <concat-strings> [x_Page, "Bean"]
	    ; x_PageBeanInterface := <concat-strings> [x_Page, "BeanInterface"]
	    ; cbds := <filter-concat-warn(argument-to-bean-property | "cannot generate bean property for argument: ")> args
	    ; bstm* := <filter-concat-warn(argument-to-initialization | "cannot generate initialization code for argument: ")> args
	    ; cbds2 := <collect(action-to-bean-method)> elems1
	    
	// @todo not all beans need to declare initialize to @Begin a conversation
	   
rules // bean parameters
	   
  argument-to-bean-property :
    Arg(x, SimpleSort(x_Class)) -> 
    |[
       @RequestParameter("~x")
       private Long x_Id;
      
       private x_Class x;
      
       public void x_set(x_Class x) {
         this.x = x;
       }
      
       public x_Class x_get() {
         return x;
       }
    ]|
    where x_Id := <concat-strings>[x, "Id"]
        ; x_get := <property-getter> x
        ; x_set := <property-setter> x
        
  argument-to-initialization :
    Arg(x, SimpleSort(x_Class)) -> 
    bstm*|[
	  if (x_Id == null)
	    {
		  log.debug("No " + "~x_Id" + " defined, couldn't start conversation");
        } 
      else 
        {
		  x = em.find(x_Class.class, x_Id);
	    }
    ]|
    where x_Id := <concat-strings>[x, "Id"] 

rules // action methods

  action-to-bean-method :
    TemplateCall("action", [e1, Call(Var(component), "save", []), e2], []) ->
    |[
 	  @End
	  public String save() {
	    log.info("save");
		em.flush();
		return e4 ;
	  }
	]|
	where e4 := <call-to-view-string> e2

  action-to-bean-method :
    TemplateCall("action", [e1, Call(Var(component), "cancel", []), e2], []) ->
    |[
 	  @End
	  public String cancel() {
	    log.info("cancel");
		return e4 ;
	  }
	]|
	where e4 := <call-to-view-string> e2
	
  action-to-bean-method :
    TemplateCall("action", [e1, Call(FieldAccess(Var(component), Var(x)), "delete", []), e2], []) ->
    |[
 	  @End
	  public String () {
	    log.info("delete (nothing deleted)");
	    em.remove(x);
	    em.flush();
		return e4 ;
	  }
	]|
	where e4 := <call-to-view-string> e2
	
	// @todo what does it mean to delete an object?
	
rules // view transition

  call-to-view-string :
    ThisCall(p,args) -> |[ "/" + "~p" + ".seam?" + e ]|
    where <IsPage> p
        ; fargs := <TemplateArguments> p
        ; params := <zip(view-string-bind-param)> (fargs, args)
        ; e := <foldr(!|[ "" ]|, add-string-expressions)> params
        
  add-string-expressions :
    (e1, e2) -> |[ e1 + e2 ]|
   
  view-string-bind-param :
    (Arg(x, s@SimpleSort(x_Class)), e1) -> |[ "~x" + "=" + e2.getId() ]|
    where <defined-java-type> s
        ; e2 := <arg-to-java-exp> e1
        
  arg-to-java-exp :
    Var(x){Type(t)} -> |[ x ]|
    where not(<eq>(t, "Component"))
    
  arg-to-java-exp :
    FieldAccess(Var(x){Type("Component")}, y) -> |[ y ]|
    
  arg-to-java-exp :
    FieldAccess(e1, y) -> |[ e2.y ]|
    where e2 := <arg-to-java-exp> e1
    
    
    
    
         	