module org/webdsl/dsl/modules/email

imports 
  libstrategolib 
  Java-15 
  libjava-front 
  libwebdsl-front
  
rules
  declare-email-definition =
    ?Define([Email()], name, args, body)
    ; rules(
        IsEmail : name
        CheckEmailDefinitionSignature : (None(), name, _) -> SimpleSort("void")
      )

  declare-email-action =
    ?TemplateCall("email", [ThisCall(name, args)], []) // -> TemplateCall("email", bla, bla1)
    ; rules ( CheckEmailActionSignature : (None(), name, _) -> SimpleSort("void") )

  typecheck-specific-definition =
    typecheck-email-template-definition

rules // typechecking email templates

  typecheck-email-template-definition :
    Define(mods, f, args, elems1) -> Define(mods, f, args, elems2)
    where <elem> (Email(), mods)
        ; {| TypeOf, TemplateDefinition, TemplateArguments, IsEmail
           : in-tc-context(id
               ; <map(declare-typeof-arg)> args
//               ; <check-to-arg> args
               ; <alltd(declare-action <+ declare-template-definition <+ typecheck-vardecl)> elems1
               ; elems2 := <typecheck-email-elements> elems1
             |["email-definition ", f, "/"])
           |}

  check-to-arg =
    ?[arg|tail]
    ; if <not(?Arg(_, SimpleSort("Email")))> := arg then
        typecheck-error(|["First argument of email template should be of type Email"])
      end

  typecheck-email-elements =
    check-email-element-presence(|"to")
    ; check-email-element-presence(|"from")
    ; check-email-element-presence(|"subject")
    ; map(typecheck-email-element)
    <+ ?elems; typecheck-error(|["not a list of elements: ", elems])

  typecheck-email-element =
    typecheck-email-to
    <+ typecheck-email-from
    <+ typecheck-email-subject
    <+ typecheck-email-body

  check-email-element-presence(|tempcall) = where (
    ?elems
    ; t_list := <collect(?TemplateCall(tempcall, _, _))> elems
    ; if <?[]> := t_list then
        typecheck-error(|["Missing templatecall in email definition: ", tempcall])
      end )

  typecheck-email-to :
    TemplateCall("to", [elem1], []) -> TemplateCall("to", [elem2], [])
    where elem2 := <typecheck-expression> elem1
    ; if <not(?_{Type(SimpleSort("Email"))})> := elem2 then
        typecheck-error(|["Argument of templatecall 'to' should be of type Email"])
      end

  typecheck-email-from :
    TemplateCall("from", [exp1, exp2], []) ->
      TemplateCall("from", [exp3, exp4], [])
    where exp3 := <typecheck-expression> exp1
        ; exp4 := <typecheck-expression> exp2
        ; xt := <?_{Type(<id>)}> exp3
        ; yt := <?_{Type(<id>)}> exp4
        ; if (not(<type-compatible>(xt, SimpleSort("String"))) ; not(<type-compatible>(yt, SimpleSort("String")))) then
            typecheck-error(|["Templatecall 'from' takes two arguments of a type compatable to String"])
          end

  typecheck-email-subject :
    TemplateCall("subject", [exp1], []) -> TemplateCall("subject", [exp2], [])
    where exp2 := <typecheck-expression> exp1
    ; xt := <?_{Type(<id>)}> exp2
    ; if not(<type-compatible>(xt, SimpleSort("String"))) then
        typecheck-error(|["Argument of templatecall 'subject' should be of a type compatable to String"])
      end

  typecheck-email-body :
    TemplateCall("body", [], elems1) -> TemplateCall("body", [], elems2)
    where elems2 := <typecheck-page-elements> elems1

rules

  typecheck-template-call :
    ThisCall(p, [e1@ThisCall(name, args)]) -> ThisCall(p, [ThisCall(name, args2)])
    where in-tc-context(id
            ; "email" := p
            ; if not(<IsEmail> name) then
                typecheck-error(|["email to undefined emailtemplate ", name])
              else
//                info(|<typecheck-expression> e1)
                args2 := <map(typecheck-expression)> args
                ; <match-arguments> (<TemplateArguments> name, args2)
 /*               ; <typecheck-variable <+ typecheck-fieldaccess> email
                ; ?_{Type(t@SimpleSort(tt))}
                ; if not(SimpleSort("Email") := t) then
                    typecheck-error(|["email to property of type ", tt, " should be of type Email"])
                  end*/
              end
          | ["email/"])

  typecheck-other-statement :
    Stat(e1@ThisCall("email", elems1)) -> Stat(e2)
    where e2 := <typecheck-call-email> e1
//        ; info(|"hier komt ie")

