/**
 * Derive
 * 
 * Derive a page from an entity and a list of properties - only for the given properties, form fields are generated
 *
 * derive editPage for p (name, comment)
 *   => Derive(EditPage(), p, [name, comment])
 * derive editPage for p
 *   => Derive(EditRows(), p, [])
 */


// @todo : enable customization of header, title, description of derived pages
//
// e.g. derive editPage from foo for (bar, baz) with { header{"Provide Bar/Baz Info"} }

module org/webdsl/dsl/modules/derive

imports
  libstrategolib
  libwebdsl-front

rules // typechecking derive statements

  /**
   * checks whether the given entity e has a property with name prop
   */
/*  constraint-error =
    ?elem|[ derive x_deriveType from e for (dprop*) ]|
    ; info(|"checking constraint 1")
    ; <map(check-derive-property-exists(|e))> dprop*

  check-derive-property-exists(|e) :
    DeriveDefault(prop) -> <add-error(|["entity '", e, "' has no property '", prop, "'"])>
    where info(|"start gemapte 1")
        ; try(info(|"debugging typeofproperty: "); <debug> <TypeOfProperty> (e, prop))
        ; not(<TypeOfProperty> (e, prop))
*/
  /**
   * checks whether the given property is not a derived property
   */
/*  constraint-error =
    ?elem|[ derive x_deriveType from e for (dprop*) ]|
    ; info(|"checking constraint 2")
    ; where(
        info(|"voor is-derive-edit-type")
        ; <is-derive-edit-type> x_deriveType
        ; info(|"na is-derive-edit-type")
        ; <debug> dprop*
        ; <map(check-derive-derivedproperty(|e))> dprop*
        ; info(|"einde constraint 2")
      )

  check-derive-derivedproperty(|e) :
    DeriveDefault(prop) -> <add-error(|["property ", prop, " is a derived property and hence cannot be edited"])>
    where <IsDerivedProperty> (e, prop)
*/

rules // desugaring

  desugar = derive-page 
  desugar = derive-edit-rows 
  desugar = derive-view-rows
  desugar = desugar-derive
  
  /**
   * If no properties given, add all properties
   *
   * The difference between viewPage and other pages is that for viewPage, derived properties
   *   are included.
   */
  desugar-derive : // gather properties for derive editPage and createPage
    elem|[ derive x_deriveType from e ]| -> 
    elem|[ derive x_deriveType from e for (dprop*) ]|
    where <is-derive-edit-type> x_deriveType
        ; SimpleSort(t) := <type-of> e
        ; dprop* := <Properties; filter(
               \Property(name,_,_,_) -> DeriveDefault(name) \ 
            <+ \PropertyNoAnno(name,_,_) -> DeriveDefault(name)\ 
          )> t
  
  desugar-derive : // gather properties for derive viewPage
    elem|[ derive x_deriveType from e ]| -> 
    elem|[ derive x_deriveType from e for (dprop*) ]|
    where <is-derive-view-type> x_deriveType
        ; SimpleSort(t) := <type-of> e
        ; dprop* := <Properties; filter( 
               \Property(name,_,_,_) -> DeriveDefault(name) \
            <+ \PropertyNoAnno(name,_,_) -> DeriveDefault(name) \
            <+ \DerivedProperty(name,_,_,_,_) -> DeriveDefault(name) \
            <+ \DerivedPropertyNoAnno(name,_,_,_) -> DeriveDefault(name) \
          )> t

  is-derive-edit-type =
    ?"editPage" <+ ?"createPage"

  is-derive-view-type =
    ?"viewPage"


rules // deriving pages

  // derive editPage from e for (property1, property2)
  derive-page : 
    elem|[ derive editPage from e for (dprop*) ]| -> 
    <rename-all> elem|[ 
      dummy() {
        main()
        define body() {
          header{"Edit " text(e.name) } 
          form { 
            table { 
              derive editRows from e for (dprop*)
            } 
            action("Save", save()) 
          }
          action save() { 
            //return x_view (e ); @todo: what pages do exist at this time?
            return home();
          }
        }
      } 
    ]| 
    where info(|"derive editPage start")
        ; <debug> dprop*
        ; SimpleSort(srt) := <type-of> e
        ; <debug> srt
        ; x_view := <decapitalize-string> srt 
        ; info(|"derive editPage end")

  // derive createPage from e for (property1, property2)
  derive-page : 
    elem|[ derive createPage from e for (dprop*) ]| ->
    <rename-all> elem|[ 
      dummy() {
        main()
        define body() {
          header{"Create " text(e.name) } 
          form { 
            table { 
              derive editRows from e for (dprop*)
            } 
            action("Save", save()) 
          }
          action save() { 
            e.save(); 
            //return x_view (e ); @todo: what pages do exist at this time?
            return home();
          }
        }
      } 
    ]| 
    where info(|"derive createPage") 
        ; SimpleSort(srt) := <type-of> e
        ; <debug> srt
        ; x_view := <decapitalize-string> srt 
        ; info(|"derive createPage end")

  // derive viewPage from e for (property1, property2)
  derive-page : 
    elem|[ derive viewPage from e for (dprop*) ]| ->
    <rename-all> elem|[ 
      dummy() {
        main()
        define body() {
          header{text(e.name) } 
          table { 
            derive viewRows from e for (dprop*)
          }
        } 
      }
    ]| 
    where info(|"derive viewPage start")
        ; SimpleSort(srt) := <type-of> e
        ; <debug> srt
        ; x_view := <decapitalize-string> srt 
        ; info(|"derive viewPage end")

rules // derives edit rows for specified properties

  derive-edit-rows :
    elem|[ derive editRows from e for (dprop*) ]| -> elem|[dummy(){elem*}]| 
    where info(|"derive editRows start")
        ; elem* := <filter-warn(derive-edit-row(|e )|"not a valid mode for edit row")> dprop*
        ; info(|"derive editRows end")

  derive-edit-row(|e) : 
    DeriveDefault(y) -> <derive-edit-row(|e)> DeriveMode("edit", y)
    
  derive-edit-row(|e ) : 
    DeriveMode("edit", y) -> elem|[row{str input(e.y )}]| 
    where info(|"Derive editRow")
        ; debug
        ; str := <concat-strings> [<make-human-readable> y , ": "]
    
  derive-edit-row(|e ) : 
    DeriveMode("view", y) -> elem|[row{str output(e.y )}]| 
    where str := <concat-strings> [<make-human-readable> y , ": "]

rules // derives view rows for specified properties

  derive-view-rows :
    elem|[ derive viewRows from e for (dprop*) ]| -> elem|[ dummy(){elem*} ]| 
    where info(|"derive viewRows start")
        ; elem* := <filter-warn(derive-view-row(|e )|"not a valid mode for view row")> dprop*
        ; info(|"derive viewRows end")

  derive-view-row(|e) : 
    DeriveDefault(y) -> <derive-view-row(|e)> DeriveMode("view", y)
    
  derive-view-row(|e ) : 
    DeriveMode("view", y) -> elem|[ row{ str output(e.y) } ]| 
    where str := <concat-strings> [<make-human-readable> y , ": "]
    
    
    
  
