/**
 * Derive procedureViewPage
 * 
 * Addition for deriving procedureViewPages which have a sidebar containing a tasklist
 */

module org/webdsl/dsl/modules/procedures/derive

imports
  libstrategolib
  libwebdsl-front

rules // typechecking derive statements

/*nog niet verzonnen  constraint-error =
    ?elem|[ derive x_deriveType from e for (dprop*) ]|
    ; SimpleSort(srt) := <type-of> e
    ; <map(try(check-derive-property-exists(|srt)))> dprop*
    ; fail*/

rules // actual derive

  // derive procedurePage from e for (property1, property2)
  derive-page : 
    elem|[ derive procedureViewPage from e for (dprop*) ]| ->
    <rename-all> elem|[ 
      dummy() {
        main()
        define local body() {
          header{text(e.name) } 
          table { 
            derive viewRows from e for (dprop*)
          }
        } 
        define local contextSidebar() {
          x1(e)
        }
      }
    ]| 
    where SimpleSort(srt) := <type-of> e
        ; x_view := <decapitalize-string> srt
        ; x1 := <concat-strings>[x_view, "Procedures"]

  is-derive-view-type =
    ?"procedureViewPage"

rules // Derive procedurePage

  derive-procedure-page :
    //Derive("procedurePage", e, dprop*) 
    elem|[ derive procedurePage from e for (dprop*) ]| -> 
    elem|[ 
      dummy() {
        main()
        define local contextSidebar() {
          x(e)
        }
        define local body() {
          header{ text(e3) " " output(e) } 
          form { 
            //table { elem }
            table { 
              derive editRows from e for (dprop*)
            }
            action("Submit", do()) 
          }
        } 
      }
    ]| 
    where 
        t := <type-of> e
      ; SimpleSort(srt) := t
      ; x := <concat-strings> [<decapitalize-string> srt, "Procedures"]
      //; elem := <derive-edit-rows> Derive("editRows", e, dprop*)  // should use recursive application of derive
      ; e3 := String(<make-human-readable> "CurrentPage") // @REFACTOR <CurrentPage>

