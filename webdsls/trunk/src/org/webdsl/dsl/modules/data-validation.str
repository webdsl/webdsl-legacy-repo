module org/webdsl/dsl/modules/types/data-validation

imports 
  libstrategolib 
  Java-15 
  libjava-front 
  libwebdsl-front
signature
  constructors

    PreDeriveInputDone : Annotation

rules //should be done only once, uses above constructor in passign* to flag

  PreDeriveInput :
    tc@TemplateCall(x,e*,passign*,elem*) -> TemplateCall("validatedInputWrapper",[],[],newelem*)
    where newelem* := <PreDeriveInput-helper> tc
  
  // desugaring rule which assumes innermost normalization
  wrap-label-with-data-validation :
    [tc@TemplateCall("label",e*,passign*,[]),elem*] -> 
    TemplateCall("validatedInputWrapper",[],[],
      [TemplateCall("column",[],[],
        [TemplateCall("label",e*,[PreDeriveInputDone()|passign*],[])])
     , TemplateCall("column",[],[],newelem*)])
    where not(<fetch(?PreDeriveInputDone())> passign*)
    with  newelem* := <alltd(PreDeriveInput-label-helper)> elem*  
  
  //helper rule to extract inputs from desugared inputs (remove the validatedInputWrapper template calls)
  PreDeriveInput-label-helper :
    TemplateCall("validatedInputWrapper",[],passign*,[TemplateCall(a,b,c*,d) | elem* ]) -> TemplateCall("dummy",[],[],[TemplateCall(a,b,[passign*,c*],d) | elem* ])
  
rules

  PreDeriveInput-helper :
    tc@TemplateCall(x,e*,passign*,elem*) -> [TemplateCall(x,e*,passignnew*,[])|rest]
    where not(<fetch(?PreDeriveInputDone())> passign*)//template calls get rewritten too often without handling annotations, passign* however, is passed everywhere
        ; <is-input-template-call> x
        ; if <oncetd(?webdsl:e|[conversionError(e*)]|)> tc // check that there wasn't an explicit mention of the conversionError, no need to add default in that case
          then rest := elem*
         // else rest := [elem|[ validate(conversionSucceeded(e*),conversionError(e*)) ]| | [elem|[ validationErrorsFor(e*)]| | elem*]] end
          else rest := [elem|[ validate(conversionSucceeded(e*),conversionError(e*)) ]| | [elem|[ validationErrorsFor(e*)]| | elem*]] end
        ; passignnew* := [PreDeriveInputDone()|passign*]

  is-input-template-call :
    x -> x
    where <  ?"input"  //TODO refactor into small declarations for input template calls in each type file
          <+ ?"inputBool"
          <+ ?"inputDate"
          <+ ?"inputDateTime"
          <+ ?"inputTime"
          <+ ?"inputEmail"
          <+ ?"inputFile"
          <+ ?"inputFloat"
          <+ ?"inputImage"
          <+ ?"inputInt"
          <+ ?"inputPatch"
          <+ ?"inputSecret"
          <+ ?"inputString"
          <+ ?"inputText"
          <+ ?"inputURL"
          <+ ?"inputWikiText"
          <+ ?"inputSDF"
            > x

rules //validate template call

  built-in-template-rule-setup = <declare-built-in-template-rules> ("validate",[SimpleSort("Bool"),SimpleSort("String")]);fail
  
/*rules //validate function

  check-builtin-signature :
    (None(), "validate", [s1,s2]) -> None()
    where <type-compatible> (SimpleSort("Bool"),s1)
        ; <type-compatible> (SimpleSort("String"),s2)*/
        
rules //error template

  
  //()
  
  built-in-template-rule-setup = <declare-built-in-template-rules> ("validatedInput",[]);<emit-webdsl-code> Define([],"validatedInput",[],[]);fail
  built-in-template-rule-setup = <declare-built-in-template-rules> ("validatedInputWrapper",[]);setup-error-template;fail //used internally to represent input with validations, declared as wrapper to reuse back-end code for each different input type

  setup-error-template = get-error-template <+ default-error-template
  
  get-error-template = !<TemplateDefinition> "errorTemplate"

  default-error-template =
    <emit-webdsl-code> def|[
      define ignore-access-control errorTemplate(errorMessages : List<String>){
        block()[class := error]{
          validatedInput()
          for(ve: String in errorMessages){
            output(ve)
          } separated-by{", "}
        }
      }
    ]|
  