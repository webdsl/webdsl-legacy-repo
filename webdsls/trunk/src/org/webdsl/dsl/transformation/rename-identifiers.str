module org/webdsl/dsl/transformation/rename-identifiers

imports 
  libstrategolib
  
imports 
  libwebdsl-front

rules

  rename-identifiers-top =
    map-toplevel(
      fail,
      with-toplevel-name(
        rename-identifiers
      )
    )
    
  rename-identifiers = alltd(rename-bound-variables)

  rename-bound-variables =
       exclude-from-var-renaming
    <+ ExcludeFromVarRenaming  
    //<+ Define(id,id,rename-identifiers,rename-identifiers) // otherwise local template definitions get renamed and dynamic scoping breaks (eg the local body will be inserted as body12 in the lookup hashmap)
    <+ rename-template-def-id
    <+ rename-template-call-id
    <+ use-existing-renaming
  
  exclude-from-var-renaming = ?"this"
  
  use-existing-renaming :
    x{anno*} -> y{new-anno*}
    where <is-string> x
        ; y := <fetch-elem(is-string)> anno*
        ; <remove-all(?y)> anno*
        ; ![OriginalNameAnno(x{}) | <id>]
        ; ?new-anno*

  rename-template-def-id :
    Define(mod*, x, farg*, targs, elem*){anno*} ->
    Define(mod*, x{orig}, <rename-identifiers> farg*, targs, <rename-identifiers> elem*){anno*}
    where <fetch(?Page())> mod*
       <+ <fetch(?Email())> mod* //no overloading for emails yet
    with  orig := OriginalNameAnno(x{})
                 
  rename-template-def-id :
    Define(mod*, x, farg*, targs, elem*){anno*} ->
    Define(mod*, y{orig}, <rename-identifiers> farg*, targs, <rename-identifiers> elem*){new-anno*}
    where not(<fetch(?Page())> mod*)
        ; not(<fetch(?Email())> mod*)
    with  xsa := <strip-annos> x
        ; y := <TemplateNewName> (xsa,<template-formal-arguments-to-types;strip-annos> farg*)
        ; orig := OriginalNameAnno(x{})
        ; !anno*
        ; if <fetch(?InputTemplate())> mod* then
            ![InputTemplateAnno() | anno*]
          end
        ; ?new-anno*
    
  rename-template-call-id :
    tc@TemplateCall(x, arg*, passign*, TemplateBody(elem*)){anno*}
    -> TemplateCall(y{orig}, <rename-identifiers> arg*, <rename-identifiers> passign*, TemplateBody(<rename-identifiers> elem*)){new-anno*}
    where y := <CallToDefinedTemplate> x
        ; orig := OriginalNameAnno(x{})
        ; <rename-identifiers> anno*
        ; ![CallToDefinedAnno() | <id>]
        ; ![CalledTemplateArgs(<TemplateArguments> y) | <id>]
        ; ?new-anno*

  rename-template-call-id :
    tc@TemplateCall(x, arg*, passign*, TemplateBody(elem*)){anno*} 
    -> TemplateCall(x{orig}, <rename-identifiers> arg*, <rename-identifiers> passign*, TemplateBody(<rename-identifiers> elem*)){new-anno*} 
    where <CallToRequiredTemplate> x
        ; orig := OriginalNameAnno(x{})
        ; <rename-identifiers> anno*
        ; ![CallToRequiredAnno() | <id>]
        ; ?new-anno*

  rename-template-call-id :
    tc@TemplateCall(x, arg*, passign*, TemplateBody(elem*)){anno*}
    -> TemplateCall(y, <rename-identifiers> arg*, <rename-identifiers> passign*, TemplateBody(<rename-identifiers> elem*)){<rename-identifiers> anno*}
    where <CallToBuiltInTemplate> x
        ; y := <strip-annos> x //code generator assumes that built-in templates don't have annotations on the name
    