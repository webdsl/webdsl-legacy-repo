/**

  Type rules for WebDSL
  
*/

module org/webdsl/dsl/transformation/types

imports 
  libstrategolib 
  Java-15 
  libjava-front 
  
imports 
  org/webdsl/dsl/syntax/WebDSL

signature
  constructors
    Type : Sort -> Annotation
    
strategies // register all declared entities

  inherit-object :
    EntityNoSuper(x_class, props, functions) -> Entity(x_class, "Object", props, functions)
        
  declare-entity = where(
    try(inherit-object)
    ; ?Entity(x_class, x_super, props, functions)
    ; rules(
        IsEntity : 
          x_class
          
        Properties :
          x_class -> props
               
        Functions :
          x_class -> functions

        Extends :
          x_class -> x_super
        
        SubClasses :+
          l -> [(x_super, x_class)|l] where not(<elem> ((x_super, x_class), l))
        
        DefinedJavaType : 
          SimpleSort(x_class) -> type|[ x_class ]|
        
        DefinedJavaTypeString :
          SimpleSort(x_class) -> <concat-strings> [<packagename-to-string> <DomainPackage>, ".", x_class]
      )
    ; where( 
        <map(declare-property(|x_class))> [NameProperty() | <inherited-properties> x_class]
        ; <map(declare-function(|x_class))> <inherited-functions> x_class
      )
  )
  
  declare-entity = where(
    ?SessionEntity(nm, props, functions)
    ; x_class := <capitalize-string> nm
    ; rules(
        TypeOf : nm -> SimpleSort(x_class)
        IsSessionVariable : nm )
    ; <declare-entity> Entity(x_class, "Object", props, functions))
  
  inherited-properties =
    <conc>(<Properties>, <Extends; inherited-properties>)
    
  inherited-functions =
    <conc>(<Functions>, <Extends; inherited-functions>)

  inherited-properties :
    "Object" -> []

  inherited-functions :
    "Object" -> []
   
  /**
   * @obsolete
   */
   
  properties = Properties 
  
  declare-property(|x_class) =
    ?prop@Property(x, k, s, annos)
    ; rules(
        TypeOfProperty : (x_class, x) -> s
      )
    ; where(try(declare-list-property(|x_class)))
    ; <try(create-file-property-rule(|x_class))> prop
    ; <try(create-prop-required-rule(|x_class,x))> annos
  
  create-prop-required-rule(|class,propname) =
    ?annos
    ; not([] := <collect(?ValidationAnnoNotNull() + ?ValidationAnnoNotEmpty())> annos)
    ; rules(
        PropertyIsRequired : (class, propname) -> True()
      )
            
  create-file-property-rule(|x_Class) =
    ?prop@Property(x, k, SimpleSort("File"), annos)
    ; rules (
        HasFileProperty :
          x_Class -> prop
      )            
    
  declare-list-property(|x_class) =
    ?Property(x, k, GenericSort(coll, [s@SimpleSort(_)]), annos)
    ; where(
             y := <concat-strings>[x, "List"] 
           ; t := GenericSort("List", [s])
           )
        ; rules(
            TypeOfProperty : (x_class, y) -> t
          )
  
  declare-property(|x_class) =
    ?DerivedProperty(x, k, s, annos, e)
    ; rules(
        TypeOfProperty : (x_class, x) -> s
      )
    ; where(try(declare-list-property(|x_class)))

  declare-list-property(|x_class) =
    ?DerivedProperty(x, k, GenericSort(coll, [s@SimpleSort(_)]), annos, e)
    ; where( 
        y := <concat-strings>[x, "List"] 
      ; t := GenericSort("List", [s])
      )
    ; rules(
        TypeOfProperty : (x_class, y) -> t
      )
      
  declare-function(|x_class) =
     ?Function(f, args, sort, body1)
     ; t1* := <map(?Arg(_,<id>))> args
     ; rules( CheckFunctionSignature :
                   (SimpleSort(x_class), f, t2*) -> sort
                       where <zip(type-compatible)> (t1*, t2*)
                   )
     ; rules( CheckFunctionSignature : // TODO: Make context-dependent
                   (None(), f, t2*) -> sort
                       where <zip(type-compatible)> (t1*, t2*)
                   )                   

overlays 

  NameProperty =
    Property("name", Simple(), SimpleSort("String"), [])
      
strategies // register top-level template definitions

  declare-template-definitions =
    alltd(declare-template-definition)
  
  declare-template-definition =
    ?def@Define(mods, name, fargs, body)
    ; rules(
        TemplateDefinition : name -> def
        TemplateArguments  : name -> fargs
      )
    ; try(declare-page-definition)
    ; try(declare-email-definition)

  declare-page-definition =
    ?Define([Page()], name, args, body)
    ; rules(
        IsPage : name
      )
  
  declare-email-definition =
    ?Define([Email()], name, args, body)
    ; rules(
        IsEmail : name
      )
      
strategies

  declare-action =
    ?def@Action(name, fargs, body)
    ; where( t1* := <map(?Arg(_,<id>))> fargs )
    ; rules(
        ActionDefinition  : name -> def
        ActionArguments  : name -> fargs
        
        CheckActionSignature : 
          (None(), name, t2*) -> SimpleSort("void")
          where <zip(type-compatible)> (t1*, t2*)
      )

strategies
  
  declare-globals =
    ?gd@GlobalsDefinition(decls)
    ; <map(declare-global-vars <+ declare-global-funcs)> decls
    ; !gd
     
  declare-global-vars =
    ?VarDeclInit(ident,sort,_)	
    ; rules (
        TypeOf : ident -> sort
        IsGlobal : ident )

  declare-global-funcs =
    ?fu@Function(f, args, s, b)
    ; t1* := <map(?Arg(_,<id>))> args
    ; rules ( CheckGlobalFunctionSignature : (None(), f, t2*) -> s 
                       where <zip(type-compatible)> (t1*, t2*))
    ; rules ( IsGlobalFunction : (f, args, s) )

strategies

  java-type =
    defined-java-type <+ builtin-java-type <+ object-type

  java-wrapper-type =
    defined-java-type <+ builtin-wrapper-java-type <+ builtin-java-type <+ object-type
    
  defined-java-type =
    DefinedJavaType
  
  defined-java-type :
    SimpleSort(x) -> <DefinedJavaType> x

  persistence-annotations =
    builtin-persistence-annotations <+ ![]
    
  java-type-default-value =
    defined-java-type-default-value 
    <+ builtin-java-type-default-value
    
  defined-java-type-default-value :
    s@SimpleSort(y) -> |[ null ]| //|[ new y() ]|
    where <defined-java-type> s

rules

  sort-to-java-type-string : SimpleSort("Object") -> "java.lang.Object"
  sort-to-java-type-string : SimpleSort("String") -> "java.lang.String"
  sort-to-java-type-string : SimpleSort("Int") -> "java.lang.Integer"
  sort-to-java-type-string : SimpleSort("Bool") -> "java.lang.Boolean"
  sort-to-java-type-string : SimpleSort("Float") -> "java.lang.Double"
  sort-to-java-type-string : SimpleSort("Text") -> "java.lang.String"
  sort-to-java-type-string : SimpleSort("Secret") -> "java.lang.String"
  sort-to-java-type-string : SimpleSort("Patch") -> "java.lang.String"
  sort-to-java-type-string : SimpleSort("Email") -> "java.lang.String"
  sort-to-java-type-string : SimpleSort("Image") -> "java.lang.String"
  sort-to-java-type-string : SimpleSort("Binary") -> "java.lang.Byte[]"
  sort-to-java-type-string : GenericSort("List", [x]) -> <concat-strings> ["java.util.List<", <sort-to-java-type-string> x, ">"]
  sort-to-java-type-string : GenericSort("Set", [x]) -> <concat-strings> ["java.util.Set<", <sort-to-java-type-string> x, ">"]
  sort-to-java-type-string : GenericSort("Map", [x, y]) -> <concat-strings> ["java.util.Map<", <sort-to-java-type-string> x, ",", <sort-to-java-type-string> y, ">"]
  sort-to-java-type-string : x -> <DefinedJavaTypeString> x

  object-type :
    SimpleSort("Object") -> type|[ Object ]|

  builtin-java-type : 
    SimpleSort("Int") -> type|[ Integer ]|

  builtin-wrapper-java-type :
    SimpleSort("Int") -> type|[ Integer ]|

  builtin-java-type : 
    SimpleSort("Float") -> type|[ double ]| // Not sure, maybe float?

  builtin-wrapper-java-type :
    SimpleSort("Float") -> type|[ Double ]|
   
  builtin-java-type-default-value :
    SimpleSort("Int") -> |[ 0 ]|

  builtin-java-type-default-value :
    SimpleSort("Float") -> |[ 0.0 ]|

  builtin-java-type : 
    SimpleSort("Bool") -> type|[ Boolean ]|

  builtin-wrapper-java-type : 
    SimpleSort("Bool") -> type|[ Boolean ]|
    
  builtin-java-type-default-value :
    SimpleSort("Bool") -> |[ false ]|
    
  builtin-java-type : 
    SimpleSort("String") -> type|[ String ]|

  builtin-java-type-default-value :
    SimpleSort("String") -> |[ "" ]|

  builtin-java-type : 
    SimpleSort("Secret") -> type|[ String ]|

  builtin-java-type-default-value :
    SimpleSort("Secret") -> |[ "" ]|

  builtin-java-type : 
    SimpleSort("Text") -> type|[ String ]|
    
  builtin-java-type-default-value :
    SimpleSort("Text") -> |[ ""  ]|

  builtin-persistence-annotations :
    SimpleSort("Text") -> [anno|[ @Column(length = 1000000) ]|]

  builtin-java-type : 
    SimpleSort("Date") -> type|[ java.util.Date ]|
    
  builtin-java-type-default-value :
    SimpleSort("Date") -> |[ new java.util.Date() ]|

  builtin-java-type : 
    SimpleSort("URL") -> type|[ String  ]|
    
  builtin-java-type-default-value :
    SimpleSort("URL") -> |[ "" ]|

  builtin-java-type : 
    SimpleSort("Image") -> type|[ String ]|
    
  builtin-java-type-default-value :
    SimpleSort("Image") -> |[ "" ]|

  builtin-java-type : 
    SimpleSort("Email") -> type|[ String ]|
            
  builtin-java-type-default-value :
    SimpleSort("Email") -> |[ "" ]|
    
  builtin-java-type : 
     SimpleSort("Patch") -> type|[ String ]|
     
  builtin-java-type-default-value :
    SimpleSort("Patch") -> |[ "" ]|
             
  builtin-java-type : 
    SimpleSort("WikiText") -> type|[ String ]|

  builtin-java-type-default-value :
    SimpleSort("WikiText") -> |[ "" ]|
    
  builtin-persistence-annotations :
    SimpleSort("WikiText") -> [anno|[ @Column(length = 1000000) ]|]
    
  builtin-java-type : 
    SimpleSort("Binary") -> type|[ byte[] ]|

  builtin-java-type-default-value :
    SimpleSort("Binary") -> |[ null ]|
    
/*
  builtin-java-type : 
    SimpleSort("Upload") -> |[ new Upload() ]|
    
  builtin-java-type-default-value :
    SimpleSort("Upload") -> |[ null ]|
*/    
  builtin-java-type :
    GenericSort("List", [s]) -> type|[ java.util.List<t> ]|
    where t := <java-wrapper-type> s

  builtin-java-type-default-value :
    GenericSort("List", [s]) -> |[ new java.util.ArrayList<t>() ]|
    where t := <java-wrapper-type> s

  builtin-java-type :
    GenericSort("Set", [s]) -> type|[ java.util.Set<t> ]|
    where t := <java-wrapper-type> s

  builtin-java-type-default-value :
    GenericSort("Set", [s]) -> |[ new java.util.HashSet<t>() ]|
    where t := <java-wrapper-type> s

  builtin-java-type :
    GenericSort("Map", [s1, s2]) -> type|[ java.util.Map<t1, t2> ]|
    where t1 := <java-wrapper-type> s1
        ; t2 := <java-wrapper-type> s2
        
  builtin-java-type-default-value :
    GenericSort("Map", [s1,s2]) -> |[ new java.util.HashMap<t1,t2>() ]|
    where t1 := <java-wrapper-type> s1
        ; t2 := <java-wrapper-type> s2
        
rules // typechecking context

  tc-context =
    TcContext <+ !"" 
    
  add-tc-context = ?msg; 
    if x := <TcContext> then
      <concat-strings>[x | msg]
    else 
      <concat-strings>msg
    end
    
  in-tc-context(s|msg) =
    {| TcContext
     : rules( TcContext := <add-tc-context> msg )
     ; s
     |}
    
  typecheck-error(|msg) =
    err-msg(|["module ", <Module>, "/", <tc-context>, ": " | msg])
    ; rules( TypecheckError := True() )
    
rules 

  type-of :
    e{t*} -> t
    where t := <fetch-elem(?Type(<id>))> t*
  
rules

  typecheck =
    typecheck-application
    ; if TypecheckError then
        typecheck-error(|["typechecking failed; repair errors above"])
        ; fail
      end
  
  typecheck-application =
    Application(?qid, {| Module : rules( Module := qid ); map(typecheck-section) |})
    <+ ?x; typecheck-error(|["application expected: ", x])
    
  typecheck-section =
    Section(id, map(typecheck-definition))
    <+ typecheck-module
    <+ Description(id)
    <+ Note(id)
    <+ ?x; typecheck-error(|["section expected: ", x])
    
  typecheck-module :
    Module(mod, section1*) -> Module(mod, section2*)
    where {| Module
           : rules( Module := mod )
           ; section2* := <map(typecheck-section)> section1*
           |}
    
  typecheck-definition =
    typecheck-template-definition
    <+ typecheck-email-template-definition
    <+ typecheck-entity
    <+ typecheck-globals
    <+ ?def; typecheck-error(|["definition not typechecked: ", def])
      
rules // typechecking entity declarations

  typecheck-entity :
    EntityNoSuper(x_class, props, function*) -> EntityNoSuper(x_class, props, function2*)
    where {| TypeOf
          : in-tc-context(
              rules( TypeOf : "this" -> SimpleSort(x_class) )
              ; where( <map(typecheck-property(|x_class))> props)
              ; function2* := <map(typecheck-function)> function*
              ; <map(extract-entity-id(|x_class))> props
              | ["entity declaration ", x_class]) |}
    
    
  typecheck-entity :
    Entity(x_class, s, props, functions) -> Entity(x_class, s, props, functions2)
    where {| TypeOf
           : in-tc-context(
                rules( TypeOf : "this" -> SimpleSort(x_class) )
              ; where( <typecheck-supertype> s )
              ; where( <map(typecheck-property(|x_class))> props )
              ; functions2 := <map(typecheck-function)> functions
              ; <map(extract-entity-id(|x_class))> props
              | ["entity declaration ", x_class]) |}
      
  typecheck-entity :
    SessionEntity(nm, props, function*) -> SessionEntity(nm, props, function2*)
    where {| TypeOf
          :   x_class := <capitalize-string> nm
              ; in-tc-context(
                rules( TypeOf : "this" -> SimpleSort(x_class) )
              ; where( <map(typecheck-property(|x_class))> props)
              ; function2* := <map(typecheck-function)> function*
              ; <map(extract-entity-id(|x_class))> props
              | ["session declaration ", nm]) |}

  extract-entity-id(|x_Class) =
   ?Property(x, k, s, annos)
   ; where(
       if <elem> (SimpleAnno("id"), annos) then
         rules (
           EntityIdType : x_Class -> s
           EntityIdName : x_Class -> x
           )
       end
     )

  extract-entity-id(|x_Class) =
   ?DerivedProperty(_, _, _, _, _)
  
  typecheck-supertype = 
    ?s
    ; if not(<IsEntity> s) then
        typecheck-error(|["supertype ", s, " is not a defined entity"])
      end
    ; <map(declare-super-property(|s))> <Properties> s

  declare-super-property(|x_class) =
    ?Property(x, k, s, annos)
    ; rules( TypeOf : x -> s )
    ; rules( IsProperty : (x_class, x) )

  declare-super-property(|x_class) =
    ?DerivedProperty(x, k, s, annos, e)
    ; rules( TypeOf : x -> s )
    ; rules( IsProperty : (x_class, x) )
    
  typecheck-property(|x_class) =
    ?Property(x, k, s, annos)
    ; if not(<java-type> s) then
        typecheck-error(|["property ", x, " has invalid type"])
      end
    ; rules( TypeOf : x -> s )
    ; rules( IsProperty : (x_class, x) )
    ; <map(try(typecheck-annos))> annos
  
  typecheck-property(|x_class) :
    DerivedProperty(x, k, s, annos, e) -> DerivedProperty(x, k, s, annos, e2)
    where e2 := <typecheck-expression> e
        ; <?_{Type(e2t)}> e2
        ; if not(<type-compatible>(e2t, s)) then
             typecheck-error(|["The expression of the derived type ", x, " should have type ", s, " but instead has type ", e2t])
          end
        ; rules( TypeOf : x -> s )
        ; rules( IsProperty : (x_class, x) )

  typecheck-annos =
    ?InverseAnno(ent, fld)
    ; if not(<IsEntity> ent) then
        typecheck-error(|["The entity ", ent, " does not exist."])
      end
    ; if not(t := <TypeOfProperty> (ent, fld)) then
        typecheck-error(|["The field ", ent, ".", fld, " is not of the right type."])
      end
 /*   ; if not(<?GenericSort(_, _)> t) then
        typecheck-error(|["The property refered to is not a collection: ", ent, ".", fld])
      end */
  
rules // typechecking entity functions
  typecheck-function :
    Function(f, args, sort, body1) -> Function(f, args, sort, body2)
    where( {| TypeOf, ReturnType
            : in-tc-context(
               rules( ReturnType := sort )
               ; <map(declare-typeof-arg)> args
               ; body2 := <typecheck-function-block> body1
             |["function ", f, "/"])
           |} )
         ; if <IsGlobalFunction> (f, args, sort) then
             body3 := <try(repeat(sometd(DesugarLiftExp)))> body2
             ; if [] := <collect(?Function(f, args, sort, _))> <global-functions>
             then
               new-global-functions := [Function(f, args, sort, body3)|<global-functions <+ ![]>]
             else
               new-global-functions := <global-functions <+ ![]>
             end
             ; rules ( global-functions :=  new-global-functions )
          end
           
  typecheck-function-stat =
    typecheck-function-block
    <+ typecheck-assignment-stat
    <+ typecheck-vardecl
    <+ typecheck-if
    <+ typecheck-for
    <+ typecheck-function-return
    <+ Stat(typecheck-expression)
    <+ warn(|"warning: not typechecking statement: ")
  
  typecheck-function-block =
    Block({| TypeOf : in-tc-context(map(typecheck-function-stat)|["block/"]) |})
  
  typecheck-function-return :
    Return(e1) -> Return(e2)
    where e2 := <typecheck-expression> e1
        ; <?_{Type(e2t)}> e2
        ; rt := <ReturnType>
        ; if not(<type-compatible>(e2t, rt)) then
             typecheck-error(|["The return statement expression of the derived type ", e2t, " should have type ", rt])
           end

rules //typechecking globals

  typecheck-globals :
    GlobalsDefinition(body1) -> GlobalsDefinition(body2)
    where {| TypeOf
           : in-tc-context(
               body2 := 
               <map(typecheck-vardecl-extra-global ; typecheck-vardecl <+ typecheck-function)> body1
             |["globals /"])
           |}

  typecheck-vardecl-extra-global :
    VarDeclInit(x, s, e1) -> VarDeclInit(x, s, e1)
    where if not( <defined-java-type> s ) then
            typecheck-error(|["type not allowed or unknown in global declaration ", s])
          end
        ; if [] := <collect(?VarDeclInit(x,s,_))> <global-variables> // _ for the expression because it could contain typecheck info
          then
            new-global-vars := [VarDeclInit(x, s, e1)|<global-variables <+ ![]>]
          else
            new-global-vars := <global-variables <+ ![]>
          end
        ; rules ( global-variables :=  new-global-vars )

  typecheck-vardecl-extra-global :
    VarDecl(x, s) -> VarDecl(x, s)
    where typecheck-error(|["var needs to be initialized in global declaration ", x])

rules // typechecking template definitions

  typecheck-template-definition :
    Define(mods, f, args, elems1) -> Define(mods, f, args, elems2)
    where <not(elem)> (Email(), mods)
        ; dbg(|"typecheck-definition in: ")
        ; {| TypeOf, TemplateDefinition, TemplateArguments, IsPage
           : in-tc-context(id
               ; dbg(|"typecheck-definition a: ")
               ; <map(declare-typeof-arg)> args
               ; dbg(|"typecheck-definition b: ")
               ; <alltd(declare-action <+ declare-template-definition <+ typecheck-vardecl)> elems1
               ; dbg(|"typecheck-definition c: ")
               ; elems2 := <typecheck-page-elements> elems1
               ; dbg(|"typecheck-definition d: ")
             |["definition ", f, "/"])
           |}
         ; dbg(|"typecheck-definition out: ")
  
  declare-typeof-arg = 
    ?Arg(x, s)
    ; if not(<java-type> s) then 
        typecheck-error(|["parameter ", x, " has invalid type"])
      else 
        rules( TypeOf : x -> s )
      end

rules // typechecking email templates

  typecheck-email-template-definition :
    Define(mods, f, args, elems1) -> Define(mods, f, args, elems2)
    where <elem> (Email(), mods)
        ; {| TypeOf, TemplateDefinition, TemplateArguments, IsEmail
           : in-tc-context(id
               ; <map(declare-typeof-arg)> args
//               ; <check-to-arg> args
               ; <alltd(declare-action <+ declare-template-definition <+ typecheck-vardecl)> elems1
               ; elems2 := <typecheck-email-elements> elems1
             |["email-definition ", f, "/"])
           |}

  check-to-arg =
    ?[arg|tail]
    ; if <not(?Arg(_, SimpleSort("Email")))> := arg then
        typecheck-error(|["First argument of email template should be of type Email"])
      end

  typecheck-email-elements =
    check-email-element-presence(|"to")
    ; check-email-element-presence(|"from")
    ; check-email-element-presence(|"subject")
    ; map(typecheck-email-element)
    <+ ?elems; typecheck-error(|["not a list of elements: ", elems])
  
  typecheck-email-element = 
    typecheck-email-to
    <+ typecheck-email-from
    <+ typecheck-email-subject
    <+ typecheck-email-body
  
  check-email-element-presence(|tempcall) = where (
    ?elems
    ; t_list := <collect(?TemplateCall(tempcall, _, _))> elems
    ; if <?[]> := t_list then
        typecheck-error(|["Missing templatecall in email definition: ", tempcall])
      end )
  
  typecheck-email-to :
    TemplateCall("to", [elem1], []) -> TemplateCall("to", [elem2], [])
    where elem2 := <typecheck-expression> elem1
    ; if <not(?_{Type(SimpleSort("Email"))})> := elem2 then
        typecheck-error(|["Argument of templatecall 'to' should be of type Email"])
      end
  
  typecheck-email-from :
    TemplateCall("from", [exp1, exp2], []) ->
      TemplateCall("from", [exp3, exp4], [])
    where exp3 := <typecheck-expression> exp1
        ; exp4 := <typecheck-expression> exp2
        ; xt := <?_{Type(<id>)}> exp3
        ; yt := <?_{Type(<id>)}> exp4
        ; if (not(<type-compatible>(xt, SimpleSort("String"))) ; not(<type-compatible>(yt, SimpleSort("String")))) then
            typecheck-error(|["Templatecall 'from' takes two arguments of a type compatable to String"])
          end
  
  typecheck-email-subject :
    TemplateCall("subject", [exp1], []) -> TemplateCall("subject", [exp2], [])
    where exp2 := <typecheck-expression> exp1
    ; xt := <?_{Type(<id>)}> exp2
    ; if not(<type-compatible>(xt, SimpleSort("String"))) then
        typecheck-error(|["Argument of templatecall 'subject' should be of a type compatable to String"])
      end

  typecheck-email-body :
    TemplateCall("body", [], elems1) -> TemplateCall("body", [], elems2)
    where elems2 := <typecheck-page-elements> elems1
  
rules // typechecking page elements 
      
  typecheck-page-elements =
    map(typecheck-page-element)
    <+ ?elems; typecheck-error(|["not a list of elements: ", elems])
    
  typecheck-page-element = dbg(|"typecheck-page-element in: "); (
    typecheck-template-definition
    <+ typecheck-text  
    <+ typecheck-select
    <+ typecheck-action 
    <+ typecheck-init
    <+ typecheck-if-templ
    <+ typecheck-call-action 
    <+ typecheck-call-navigate
    <+ typecheck-call-subtable
    <+ typecheck-call-email
    <+ typecheck-template-call
    <+ typecheck-iterator
    <+ typecheck-vardecl
    <+ dbg(|"unknown page element? ")
       ; all(typecheck-page-element)
  ); dbg(|"typecheck-page-element out: ")
    
  typecheck-text =
    Text(is-string)
  
  typecheck-call-action :
    TemplateCall(f, [e1,e2], []) -> TemplateCall(f, [e1',e2'], [])
    where !f; (?"action" + ?"actionLink")
        ; in-tc-context(id
            ; e1' := <typecheck-expression> e1
            ; e2' := <typecheck-expression> e2
          | [f, "/"])

                
  typecheck-call-subtable :
    TemplateCall("subtable", [f], columns1) -> TemplateCall("subtable", [f], columns1)
    where FieldAccess(Var(exp), ident) := f
        ; <should-have-list-type> ident
        ; GenericSort(v,[SimpleSort(s)]) := <TypeOf> ident
        ; <map(typecheck-template-call-in-subtable(|s))> columns1
        
  typecheck-template-call-in-subtable(|s) :
    TemplateCall("text", e@[Var(x)], []) -> TemplateCall("text", e, [])
    where <TypeOfProperty> (s, x)
        
  typecheck-template-call-in-subtable(|s) :
    TemplateCall("text", e@[FieldAccess(Var(x), i)], []) -> TemplateCall("text", e, [])
    where SimpleSort(ss) := <TypeOfProperty> (s, x)
        ; <TypeOfProperty> (ss, i)
  
  typecheck-call-navigate :
    TemplateCall("navigate", [e], elems1) -> TemplateCall("navigate", [e'], elems2)
    where in-tc-context(id
            ; e' := <typecheck-link> e
            ; elems2 := <typecheck-page-elements> elems1
          | ["navigate/"])

  typecheck-call-navigate :
    TemplateCall("navigate", [e1,e2], []) -> TemplateCall("navigate", [e1', e2'], [])
    where in-tc-context(id
            ; e1' := <typecheck-expression> e1
            ; e2' := <typecheck-link> e2
          | ["navigate/"])
             
  typecheck-call-email :
    ThisCall(p, [e1@ThisCall(name, args)]) -> ThisCall(p, [ThisCall(name, args2)])
    where in-tc-context(id
            ; "email" := p
            ; if not(<IsEmail> name) then
                typecheck-error(|["email to undefined emailtemplate ", name])
              else
                args2 := <map(typecheck-expression)> args
                ; <match-arguments> (<TemplateArguments> name, args2)
 /*               ; <typecheck-variable <+ typecheck-fieldaccess> email
                ; ?_{Type(t@SimpleSort(tt))}
                ; if not(SimpleSort("Email") := t) then
                    typecheck-error(|["email to property of type ", tt, " should be of type Email"])
                  end*/
              end
          | ["email/"])
  
  typecheck-link :
    ThisCall("url", [e1]) -> ThisCall("url", [e2])
    where e2 := <typecheck-expression> e1

  typecheck-link :
    ThisCall(p, args1) -> ThisCall(p, args2)
    where not("url" := p)
        ; if not(<IsPage> p) then
            typecheck-error(|["link to undefined page ", p])
          else
            TemplateCall(p, args2, []) := <typecheck-template-call> TemplateCall(p, args1, [])
          end

  typecheck-template-call :
    TemplateCall(f, args1, elems1) -> TemplateCall(f, args2, elems2)
    where in-tc-context(id
            ; args2 := <map(typecheck-expression)> args1
            ; try(<match-arguments> (<TemplateArguments> f, args2))
            ; elems2 := <typecheck-page-elements> elems1
            | [f, "/"])
        
        // @todo account for arguments of built-in templates (for which TemplateArguments fails)
   
  typecheck-template-call :
    TemplateCallDeclaredType(f, x, s, elems1) -> TemplateCallDeclaredType(f, x, s, elems2)
    where in-tc-context(
               {| TypeOf
                : if not(<defined-java-type> s) then
                    typecheck-error(|["index ", x, " has invalid type ", s])
                    // @todo check that type of x corresponds to element type of collection s
                  else
                    rules( TypeOf : x -> s )
                  end
                ; elems2 := <typecheck-page-elements> elems1
                |}
             | [f, "/"] ) 
   
   match-arguments = 
     ?(formal_args, actual_args)
     ; if not(equal(|<length> formal_args, <length> actual_args)) then
         typecheck-error(|["number of formal arguments and actual arguments do not match"])
       else
         <zip(try(match-argument))> (formal_args, actual_args)
       end
                      
   match-argument =
    ?(Arg(x, t1), e{Type(t2)})
    ; if not(<subtype-of>(t2, t1)) then
        typecheck-error(|["type ", t2, " of argument ", e{}, " does not match formal parameter '", x, "' (", t1, ")"])
      end
   
   subtype-of =
     eq
     
   subtype-of = 
     ?(SimpleSort(t1), SimpleSort(t2))
     ; where( <extends>(t1, t2) )
   
   extends = 
     while-not(eq, (Extends, id))
  
   typecheck-iterator :
     For(x, s, e1, elems1) -> For(x, s, e2, elems2)
     where in-tc-context(
             e2 := <typecheck-expression> e1
             ; <should-have-list-type> e2
             ; {| TypeOf
                : if not(<java-type> s) then
                    typecheck-error(|["index ", x, " has invalid type ", s])
                    // @todo check that type of x corresponds to element type of collection s
                  else
                    rules( TypeOf : x -> s )
                  end
                ; elems2 := <typecheck-page-elements> elems1
                |}
             | ["iterator ", x, "/"] )
             
   typecheck-iterator :
     ForAll(x, s, elems1) -> ForAll(x, s, elems2)
     where in-tc-context(
               {| TypeOf
                : if not(<defined-java-type> s) then
                    typecheck-error(|["index ", x, " has invalid type ", s])
                    // @todo check that type of x corresponds to element type of collection s
                  else
                    rules( TypeOf : x -> s )
                  end
                ; elems2 := <typecheck-page-elements> elems1
                |}
             | ["for all iterator ", x, "/"] ) 
                         
  typecheck-select :
    Select(x,s@SimpleSort(_),label,e1) -> Select(x,s,label,e2)
    where in-tc-context(id
            ; if not(<defined-java-type> s) then
                typecheck-error(|["index ", x, " should have a defined entity type, is ", s])
              else
                rules( TypeOf : x -> s )
              end
            ; e2 := <typecheck-expression> e1
          | ["select/"])

  typecheck-if-templ :
    IfTempl(e1, elems1) -> IfTempl(e2, elems2)
    where e2 := <typecheck-expression> e1
        ; elems2 := <typecheck-page-elements> elems1
        ; <?_{Type(e2t)}> e2
        ; if not(<eq>(e2t, SimpleSort("Bool"))) then
            typecheck-error(|["Expression ", e1, " should be of type Bool, but instead is of type ", e2t])
          end
  
strategies

  should-have-collection-type = 
    try(
      ?e{Type(t)}
      ; if not(<is-collection-type> t) then
          typecheck-error(|["type of iterator should be a collection (and not ", t, ")"])
        end
    )
  
  is-collection-type =
    ?GenericSort("List", [SimpleSort(_)])
    
  is-collection-type =
    ?GenericSort("Set", [SimpleSort(_)])
    
  should-have-list-type = 
    try(
      ?e{Type(t)}
      ; if not(<is-list-type> t) then
          typecheck-error(|["type of iterator should be a List (hint: every collection property f has also a property fList)"])
        end
    )
  
  is-list-type =
    ?GenericSort("List", [SimpleSort(_)])

rules // typechecking actions

  typecheck-action :
    Action(f, args, body1) -> Action(f, args, body2)
    where {| TypeOf
           : in-tc-context(
               <map(declare-typeof-arg)> args
               ; body2 := <typecheck-block> body1
             |["action ", f, "/"])
           |}

rules // typechecking inits

  typecheck-init :
    InitAction(body1) -> InitAction(body2)
    where {| TypeOf
           : in-tc-context(
               body2 := <typecheck-block> body1
             |["init /"])
           |}
           
rules // typechecking statements

  typecheck-stat =
    typecheck-block
    <+ typecheck-assignment-stat
    <+ typecheck-vardecl
    <+ typecheck-if
    <+ typecheck-for
    <+ typecheck-return
    <+ typecheck-email
    <+ Stat(typecheck-expression)
    <+ dbg(|"warning: not typechecking statement: ")
  
  typecheck-block =
    Block({| TypeOf : in-tc-context(map(typecheck-stat)|["block/"]) |})
    
  typecheck-assignment-stat :
    Assign(Assignment(qid, e1)) -> Assign(Assignment(qid, e2))
    where e2 := <typecheck-expression> e1
    
  typecheck-vardecl :
    VarDeclInit(x, s, e1) -> VarDeclInit(x, s, e2)
    where rules( TypeOf : x -> s )
        ; e2 := <typecheck-expression> e1
        
        // @todo check that s is valid type
        
  typecheck-vardecl :
    VarDecl(x, s) -> VarDecl(x, s)
    where rules( TypeOf : x -> s )
    
  typecheck-if :
    If(e1, bit1, bif1) -> If(e2, bit2, bif2)
    where e2 := <typecheck-expression> e1
        ; e2t := <?_{Type(<id>)}> e2
        ; if not(<?_{Type(SimpleSort("Bool"))}> e2) then
            typecheck-error(|["expression ", e2, " should be of type Bool"])
          end
        ; bit2 := <typecheck-stat> bit1
        ; bif2 := <typecheck-stat> bif1

  typecheck-for :
    ForColl(v, s, e1, bstm1) -> ForColl(v, s, e2, bstm2)
    where {| TypeOf :
              rules(TypeOf : v -> s)
              ; e2 := <typecheck-expression> e1
              ; if not(<?_{Type(GenericSort(_, [<sort-literal> s]))}> e2) then // TODO: This only accepts List<SimpleSort>-like lists, not List<List<Int>> for example.
                  typecheck-error(|["expression ", e2, " should be of type [SomeGenerichType]<", s, ">"])
                end
              ; bstm2 := <typecheck-block> bstm1
          |}

  sort-literal :
    SimpleSort(x) -> x

  typecheck-return :
    Return(e1) -> Return(e2)
    where e2 := <typecheck-link> e1
    
  typecheck-email :
    Stat(e1@ThisCall("email", elems1)) -> Stat(e2)
    where e2 := <typecheck-call-email> e1
    
rules // typechecking expressions
   
   typecheck-expression = dbg(|"tc expression: "); (
     typecheck-variable   
     <+ typecheck-literal
     <+ typecheck-length-field
     <+ typecheck-fieldaccess
     <+ typecheck-cast
     <+ typecheck-in-coll
     <+ typecheck-object-creation
     <+ typecheck-set-creation
     <+ typecheck-list-creation
     <+ typecheck-typed-set-creation
     <+ typecheck-typed-list-creation
     <+ typecheck-call
     <+ typecheck-for-expr
     <+ typecheck-query
     <+ typecheck-operator
     <+ typecheck-expression-error
   )
   
   typecheck-literal :
     String(x) -> String(x){Type(SimpleSort("String"))}
     
   typecheck-literal :
     Int(x) -> Int(x){Type(SimpleSort("Int"))}

   typecheck-literal :
     Float(x) -> Float(x){Type(SimpleSort("Float"))}
     
   typecheck-literal :
     True() -> True() {Type(SimpleSort("Bool"))}
     
   typecheck-literal :
     False() -> False() {Type(SimpleSort("Bool"))}
     
   typecheck-literal :
     Null() -> Null() {Type(SimpleSort("Null"))}
     
   typecheck-variable :
     Var(x) -> Var(x){Type(t)}
     where if not(t := <TypeOf> x) then
             typecheck-error(|["variable ", x, " has no declared type"])
             ; t := "Error"
           end

   typecheck-in-coll :
     InColl(e1, e2) -> InColl(e3, e4) {Type(SimpleSort("Bool"))}
     where e3 := <typecheck-expression> e1
         ; e4 := <typecheck-expression> e2
         ; <?_{Type(t)}> e3
         ; <?_{Type(GenericSort(_, [lt]))}> e4
         ; if not(<type-compatible> (t, lt)) then // Or other way around?
             typecheck-error(|["Expression ", e3, " should be of type ", lt])
           end

   typecheck-cast :
     Cast(e1, s) -> Cast(e2, s) { Type(s) }
     where e2 := <typecheck-expression> e1
         ; <?_{Type(e2t)}> e2
         ; if not(<type-compatible> (e2t, s)) ;  not(<type-compatible> (s, e2t)) then
              typecheck-error(|["You cannot cast something of type ", e2t, " to ", s])
           end

   typecheck-set-creation :
     SetCreation(e1*) -> SetCreation(e2*){Type(GenericSort("Set", [t]))}
     where dbg(|"typecheck-set-creation a: ")
         ; e2* := <map(typecheck-expression)> e1*
         ; dbg(|"typecheck-set-creation b: ")
         ; [_{Type(t)},e3*] := e2*
         ; dbg(|"typecheck-set-creation c: ")
         ; if not(<map(?_{Type(<id>)}; <eq>(<id>, t))> e3*) then
             typecheck-error(|["arguments of set creation should have same type"])
           end
         ; dbg(|"typecheck-set-creation d: ")
     
   typecheck-typed-set-creation :
     TypedSetCreation(s, e1*) -> TypedSetCreation(s, e2*) {Type(GenericSort("Set", [s]))}
     where e2* := <map(typecheck-expression)> e1*
         ; if not(<map(?_{Type(<id>)}; <type-compatible>(s, <id>))> e2*) then
             typecheck-error(|["arguments of set creation should have same type."])
           end

   typecheck-typed-list-creation :
     TypedListCreation(s, e1*) -> TypedListCreation(s, e2*) {Type(GenericSort("List", [s]))}
     where e2* := <map(typecheck-expression)> e1*
         ; if not(<map(?_{Type(<id>)}; <type-compatible>(<id>, s))> e2*) then
             typecheck-error(|["arguments of list creation should have same type"])
           end
         
   typecheck-list-creation :
     ListCreation(e1*) -> ListCreation(e2*){Type(GenericSort("List", [t]))}
     where dbg(|["typecheck-set-creation a: ", <id>])
         ; e2* := <map(typecheck-expression)> e1*
         ; dbg(|"typecheck-set-creation b: ")
         ; [_{Type(t)},e3*] := e2*
         ; dbg(|"typecheck-set-creation c: ")
         ; if not(<map(?_{Type(<id>)}; <eq>(<id>, t))> e3*) then
             typecheck-error(|["arguments of set creation should have same type"])
           end
         ; dbg(|"typecheck-set-creation d: ")
                  
   typecheck-object-creation :
     ObjectCreation(x_Class, assign1*) -> ObjectCreation(x_Class, assign2*){Type(SimpleSort(x_Class))}
     where dbg(|"typecheck-object creation a: ")
         ; in-tc-context(
             if not(<IsEntity> x_Class) then
               typecheck-error(|["object creation for undeclared entity ", x_Class])
             end
             ; dbg(|"typecheck-object creation b: ")
             ; assign2* := <map(typecheck-field-initialization(|x_Class))> assign1*
             ; dbg(|"typecheck-object creation c: ")
           |["create ", x_Class, "/"])
     
   typecheck-field-initialization(|x_Class) :
     Assignment(y, e1) -> Assignment(y, e2)
     where dbg(|"typecheck-assign a: ");
           e2{Type(t2)} := <typecheck-expression> e1
           // @todo
         ; dbg(|"typecheck-assign b: ")
         ; if not(t1 := <TypeOfProperty> (x_Class, y)) then
             typecheck-error(|["entity ", x_Class, " has no field ", y])
             ; t1 := SimpleSort("void")
           end
         ; dbg(|"typecheck-assign c: ")
         ; if not(<type-compatible>(t1,t2)) then
             typecheck-error(|["assignment to field ", y, " of ", x_Class, " with type ", t2, " should be ", t1])
           end
         ; dbg(|"typecheck-assign d: ")
     
   typecheck-fieldaccess :
     FieldAccess(e1, f) -> FieldAccess(e2, f){Type(t1)}
     where e2{Type(t2@SimpleSort(s))} := <typecheck-expression> e1
         ; if not(t1 := <TypeOfProperty> (s, f)) then
             typecheck-error(|["entity '", s, "' has no property '", f, "'"])
	     ; t1 := "Error"
 	   end
     
   typecheck-length-field :
     FieldAccess(e1, "length") -> FieldAccess(e2, "length"){Type(SimpleSort("Int"))}
     where e2{Type(GenericSort(_,_))} := <typecheck-expression> e1
         
   typecheck-for-expr :
     ForExp(oe1, x, s, ie1) -> ForExp(oe2, x, s, ie2) {Type(t)}
     where ie2 := <typecheck-expression> ie1
         ; {| TypeOf :
                rules(TypeOf : x -> s)
                ; oe2 := <typecheck-expression> oe1
           |}
         ; if <?_{Type(GenericSort("List", _))}> ie2 then
             t := GenericSort("List", [<?_{Type(<id>)}> oe2])
           else
             t := GenericSort("Set", [<?_{Type(<id>)}> oe2])
           end
//         ; info(|["The type of ",  ForExp(oe2, x, s, ie2), " is ", t])
// TODO: A check needs to be done checking s with the type of items in ie2
//         ; if not(<type-compatible>(<?_{Type(<id>)}> oe2, s)) then
//             typecheck-error(|["expression ", oe2, " is not of type ", s])
//           end

   typecheck-for-expr :
     ForWhereExp(oe1, x, s, ie1, we1) -> ForWhereExp(oe2, x, s, ie2, we2) {Type(t)}
     where ie2 := <typecheck-expression> ie1
         ; {| TypeOf :
                rules(TypeOf : x -> s)
                ; oe2 := <typecheck-expression> oe1
                ; we2 := <typecheck-expression> we1
           |}
         ; if <?_{Type(GenericSort("List", _))}> ie2 then
             t := GenericSort("List", [<?_{Type(<id>)}> oe2])
           else
             t := GenericSort("Set", [<?_{Type(<id>)}> oe2])
           end
         ; if not(<type-compatible>(<?_{Type(<id>)}> oe2, s)) then
             typecheck-error(|["expression ", oe2, " is not of type ", s])
           end
         ; if not(<?_{Type(SimpleSort("Bool"))}> we2) then
             typecheck-error(|["expression ", we2, " is not a Bool."])
           end

   typecheck-call :
     Call(e1, f, e2*) -> Call(e3, f, e4*){Type(t)}
     where e3{Type(t3)} := <typecheck-expression> e1
         ; e4* := <map(typecheck-expression)> e2*
         ; t := <check-signature> (t3, f, e4*)
         
   typecheck-call :
     ThisCall(f, e1*) -> ThisCall(f, e2*){Type(t)}
     where e2* := <map(typecheck-expression)> e1*
         ; t := <check-signature> (None(), f, e2*)
 
 // Exp operators, can this be done in a shorter way?
 // TODO: Make sure these are numeric types (in case of mul, div and sub)
   typecheck-operator :
     Add(x, y) -> Add(x2, y2) { Type(xt) }
     where
           x2 := <typecheck-expression> x
         ; y2 := <typecheck-expression> y
         ; xt := <?_{Type(<id>)}> x2
         ; yt := <?_{Type(<id>)}> y2
         ; if not(<type-compatible>(xt, yt)) then
             typecheck-error(|["Addition of ", x, " type: ", xt, " and ", y, " type: ", yt, " is not allowed, due to incompatible types."])
           end

   typecheck-operator :
     Sub(x, y) -> Sub(x2, y2) { Type(xt) }
     where
           x2 := <typecheck-expression> x
         ; y2 := <typecheck-expression> y
         ; <?_{Type(xt)}> x2
         ; <?_{Type(yt)}> y2
         ; if not(<type-compatible>(xt, yt)) then
             typecheck-error(|["Substraction of ", x, " and ", y, " is not allowed, due to incompatible types."])
           end

   typecheck-operator :
     Mul(x, y) -> Mul(x2, y2) { Type(xt) }
     where
           x2 := <typecheck-expression> x
         ; y2 := <typecheck-expression> y
         ; xt := <?_{Type(<id>)}> x2
         ; yt := <?_{Type(<id>)}> y2
         ; if not(<type-compatible>(xt, yt)) then
             typecheck-error(|["Multiplication of ", x, " and ", y, " is not allowed, due to incompatible types."])
           end

   typecheck-operator :
     Div(x, y) -> Div(x2, y2) { Type(xt) }
     where
           x2 := <typecheck-expression> x
         ; y2 := <typecheck-expression> y
         ; xt := <?_{Type(<id>)}> x2
         ; yt := <?_{Type(<id>)}> y2
         ; if not(<type-compatible>(xt, yt)) then
             typecheck-error(|["Division of ", x, " and ", y, " is not allowed, due to incompatible types."])
           end
           
   typecheck-operator :
     Eq(x, y) -> Eq(x2, y2) { Type(SimpleSort("Bool")) }
     where x2 := <typecheck-expression> x
         ; y2 := <typecheck-expression> y
         ; xt := <?_{Type(<id>)}> x2
         ; yt := <?_{Type(<id>)}> y2
         ; if not(<type-compatible>(xt, yt)) then
             typecheck-error(|["Comparison of ", x, " and ", y, " is not allowed, due to incompatible types."])
           end

   typecheck-operator :
     NotEq(x, y) -> NotEq(x2, y2) { Type(SimpleSort("Bool")) }
     where x2 := <typecheck-expression> x
         ; y2 := <typecheck-expression> y
         ; xt := <?_{Type(<id>)}> x2
         ; yt := <?_{Type(<id>)}> y2
         ; if not(<type-compatible>(xt, yt)) then
             typecheck-error(|["Comparison of ", x, " and ", y, " is not allowed, due to incompatible types."])
           end

   typecheck-operator :
     LargerThan(x, y) -> LargerThan(x2, y2) { Type(SimpleSort("Bool")) }
     where x2 := <typecheck-expression> x
         ; y2 := <typecheck-expression> y
         ; xt := <?_{Type(<id>)}> x2
         ; yt := <?_{Type(<id>)}> y2
         ; if not(xt := SimpleSort("Int") <+ xt := SimpleSort("Flaot")) then
             typecheck-error(|["Expression ", xt, " should be of numeric type, but is not."])
           end
         ; if not(yt := SimpleSort("Int") <+ yt := SimpleSort("Flaot")) then
             typecheck-error(|["Expression ", yt, " should be of numeric type, but is not."])
           end

   typecheck-operator = // Reusing checks of LargerThan
     ?LargerThanOrEqual(x, y)
     ; <typecheck-operator> LargerThan(x, y)
     ; \ LargerThan(x2, y2) -> LargerThanOrEqual(x2, y2) {Type(SimpleSort("Bool"))} \

   typecheck-operator = // Reusing checks of LargerThan
     ?SmallerThan(x, y)
     ; <typecheck-operator> LargerThan(x, y)
     ; \ LargerThan(x2, y2) -> SmallerThan(x2, y2) {Type(SimpleSort("Bool"))} \

   typecheck-operator = // Reusing checks of LargerThan
     ?SmallerThanOrEqual(x, y)
     ; <typecheck-operator> LargerThan(x, y)
     ; \ LargerThan(x2, y2) -> SmallerThanOrEqual(x2, y2) {Type(SimpleSort("Bool"))} \

   typecheck-operator :
     Not(x) -> Not(x2) { Type(SimpleSort("Bool")) }
     where x2 := <typecheck-expression> x
         ; xt := <?_{Type(<id>)}> x2
         ; if not(<eq>(xt, SimpleSort("Bool"))) then
             typecheck-error(|[x, " should be an expression of type Bool, but is of type ", xt])
           end         

   typecheck-operator :
     And(x, y) -> And(x2, y2) { Type(SimpleSort("Bool")) }
     where x2 := <typecheck-expression> x
         ; y2 := <typecheck-expression> y
         ; xt := <?_{Type(<id>)}> x2
         ; yt := <?_{Type(<id>)}> y2
         ; if not(<eq>(xt, SimpleSort("Bool"))) then
             typecheck-error(|[x, " should be an expression of type Bool, but is of type ", xt])
           end         
         ; if not(<eq>(yt, SimpleSort("Bool"))) then
             typecheck-error(|[y, " should be an expression of type Bool, but is of type ", yt])
           end         

   typecheck-operator :
     Or(x, y) -> Or(x2, y2) { Type(SimpleSort("Bool")) }
     where x2 := <typecheck-expression> x
         ; y2 := <typecheck-expression> y
         ; xt := <?_{Type(<id>)}> x2
         ; yt := <?_{Type(<id>)}> y2
         ; if not(<eq>(xt, SimpleSort("Bool"))) then
             typecheck-error(|[x, " should be an expression of type Bool, but is of type ", xt])
           end         
         ; if not(<eq>(yt, SimpleSort("Bool"))) then
             typecheck-error(|[y, " should be an expression of type Bool, but is of type ", yt])
           end         

   typecheck-operator :
     IsA(e1, s) -> IsA(e2, s) { Type(SimpleSort("Bool")) }
     where e2 := <typecheck-expression> e1   
  
   typecheck-query :
     HqlQuery(q) -> HqlQuery(q){Type(t)}
     where t := <type-of-query> q
         ; dbg(|"type of query: ")

   typecheck-expression-error =
     ?e
     ; typecheck-error(|["expression ", e, " has type error"])
     
rules // signature

  check-signature :
    (t3, f, e*) -> t
    where t* := <map(?_{Type(<id>)})> e*
        ; t := <check-signature-aux> (t3, f, t*)
        
  check-signature-aux = 
    ?sig
    ; (CheckActionSignature
       <+ CheckFunctionSignature
       <+ CheckGlobalFunctionSignature
       <+ check-builtin-signature
       <+ typecheck-error(|["type error in call ", sig]))
    
  check-builtin-signature :
    (_, "toString", []) -> SimpleSort("String")
    
  check-builtin-signature :
    (GenericSort("List", [s]), "add", [s]) -> SimpleSort("void")

  check-builtin-signature :
    (GenericSort("List", [s]), "remove", [s]) -> SimpleSort("void")
    
  check-builtin-signature :
    (GenericSort("Set", [s]), "add", [s]) -> SimpleSort("void")
    
  check-builtin-signature :
    (GenericSort("Set", [s]), "remove", [s]) -> SimpleSort("void") 
    
  check-builtin-signature :
    (s@SimpleSort(_), "delete", []) -> SimpleSort("void")
    where <defined-java-type> s
    
  check-builtin-signature :
    (s@SimpleSort(_), "save", []) -> SimpleSort("void")
    where <defined-java-type> s
    
  check-builtin-signature :
    (s@SimpleSort(_), "persist", []) -> SimpleSort("void")
    where <defined-java-type> s
    
  check-builtin-signature :
    (s@SimpleSort(_), "digest", []) -> SimpleSort("Secret")
    where SimpleSort("Secret") := s

  check-builtin-signature :
    (SimpleSort("Patch"), "applyPatch", [s]) -> s
    where <type-compatible> (s, SimpleSort("String"))

  check-builtin-signature :
    (s1, "makePatch", [s2]) -> SimpleSort("Patch")
    where <type-compatible> (s1, SimpleSort("String"))
 	    ; <type-compatible> (s2, SimpleSort("String"))

  check-builtin-signature :
    (s, "check", [s]) -> SimpleSort("Bool")
    where SimpleSort("Secret") := s

  check-builtin-signature :
    (GenericSort(Z, [s@SimpleSort(_)]), "persist", []) -> SimpleSort("void")
    where <defined-java-type> s
        ; <?"List" <+ ?"Set"> Z
        
  check-builtin-signature :
    (None(), "email", [_]) -> SimpleSort("void")
            
rules // type compatibility

  /**
   * <type-compatible> (t1, t2) if a value of type t2 can be assigned
   * to a variable of type t1
   */

  type-compatible =
    ?(t, t)
   
  type-compatible =
    ?(SimpleSort("Email"), SimpleSort("String"))
    
  type-compatible =
    ?(SimpleSort("WikiText"), SimpleSort("String"))

  type-compatible =
    ?(SimpleSort("Text"), SimpleSort("String"))

  type-compatible =
    ?(SimpleSort("URL"), SimpleSort("String"))
    
  type-compatible =
    ?(SimpleSort("Image"), SimpleSort("String"))
    
  type-compatible =
    ?(SimpleSort("Secret"), SimpleSort("String"))
    
  type-compatible =
    ?(t1, t2)
    ; where(<subtype-of> (t2, t1))
    
  type-compatible =
    ?(t1, SimpleSort("Null"))
    ; where(<defined-java-type> t1)
rules 

  type-of-query :
    QueryRule(
      SelectFrom(Some(Select(_,[AliasedExpression(Path([x]),_)])), FromClause(ranges)),
      _, _, _) -> GenericSort("List", [t])
    where t := <fetch-elem(get-type-from-range(|x))> ranges
    
  get-type-from-range(|x) :
    FromRangeJoin(FromClass(Path([x_Class]),Some(AsAlias(Alias(x))),_),_) -> SimpleSort(x_Class)
    
/*
 HqlQuery(
   QueryRule(
     SelectFrom(
       Some(Select(None,[AliasedExpression(Path(["pub"]),None)])),
       FromClause([
         FromRangeJoin(FromClass(Path(["Publication"]),Some(AsAlias(Alias("pub"))),None),None),
         FromRangeJoin(FromClass(Path(["Person"]),Some(AsAlias(Alias("pers"))),None),None)
       ])
      ),
      Some(WhereClause(
             QueryAnd(
                Paren([EQ(Path(["pers","id"]),DslExp(FieldAccess(Var("person"),"id")))]),
                Paren([MemberOf(Path(["pers"]),Path(["pub","_authors"]))])))),
      None,
      None))
*/
    