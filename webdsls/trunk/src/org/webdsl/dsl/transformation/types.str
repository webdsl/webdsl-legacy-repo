/**

  Type rules for WebDSL
  
*/

module org/webdsl/dsl/transformation/types

imports 
  libstrategolib 
  Java-15 
  libjava-front 
  
imports 
  org/webdsl/dsl/syntax/WebDSL

signature
  constructors
    Type : Sort -> Annotation
    
strategies // register all declared entities

  inherit-object :
    EntityNoSuper(x_class, props, functions) -> Entity(x_class, "Object", props, functions)
        
  declare-entity = where(
    try(inherit-object)
    ; ?Entity(x_class, x_super, props, functions)
    ; rules(
        IsEntity : 
          x_class
          
        Properties :
          x_class -> props
               
        Functions :
          x_class -> functions

        Extends :
          x_class -> x_super
          
        DefinedJavaType : 
          SimpleSort(x_class) -> type|[ x_class ]|
        
        DefinedJavaTypeString :
          SimpleSort(x_class) -> <concat-strings> [<packagename-to-string> <DomainPackage>, ".", x_class]
      )
    ; where( 
        <map(declare-property(|x_class))> [NameProperty() | <inherited-properties> x_class]
        ; <map(declare-function(|x_class))> <inherited-functions> x_class
      )
  )
  
  declare-entity : SessionEntity(nm, ent) -> SessionEntity(nm, <declare-entity> ent)
    where rules(
      TypeOf : nm -> < ?Entity(ident,_,_,_);!SimpleSort(ident) 
      					<+ ?EntityNoSuper(ident,_,_);!SimpleSort(ident) > ent
      IsSessionVariable : nm
    )
  
  inherited-properties =
    <conc>(<Properties>, <Extends; inherited-properties>)
    
  inherited-functions =
    <conc>(<Functions>, <Extends; inherited-functions>)

  inherited-properties :
    "Object" -> []

  inherited-functions :
    "Object" -> []
   
  /**
   * @obsolete
   */
   
  properties = Properties 
  
  declare-property(|x_class) =
    ?Property(x, k, s, annos)
    ; rules(
        TypeOfProperty : (x_class, x) -> s
      )
    ; where(try(declare-list-property(|x_class)))
    
  declare-list-property(|x_class) =
    ?Property(x, k, GenericSort(coll, [s@SimpleSort(_)]), annos)
    ; where(
             y := <concat-strings>[x, "List"] 
           ; t := GenericSort("List", [s])
           )
        ; rules(
            TypeOfProperty : (x_class, y) -> t
          )
  
  declare-property(|x_class) =
    ?DerivedProperty(x, k, s, annos, e)
    ; rules(
        TypeOfProperty : (x_class, x) -> s
      )
    ; where(try(declare-list-property(|x_class)))

  declare-list-property(|x_class) =
    ?DerivedProperty(x, k, GenericSort(coll, [s@SimpleSort(_)]), annos, e)
    ; where( 
        y := <concat-strings>[x, "List"] 
      ; t := GenericSort("List", [s])
      )
    ; rules(
        TypeOfProperty : (x_class, y) -> t
      )
      
  declare-function(|x_class) =
     ?Function(f, args, sort, body1)
     ; t1* := <map(?Arg(_,<id>))> args
     ; rules( CheckFunctionSignature :
                   (None(), f, t2*) -> sort
                       where <zip(type-compatible)> (t1*, t2*)
                   )

overlays 

  NameProperty =
    Property("name", Simple(), SimpleSort("String"), [])
      
strategies // register top-level template definitions

  declare-template-definitions =
    alltd(declare-template-definition)
  
  declare-template-definition =
    ?def@Define(mods, name, fargs, body)
    ; rules(
        TemplateDefinition : name -> def
        TemplateArguments  : name -> fargs
      )
    ; try(declare-page-definition)

  declare-page-definition =
    ?Define([Page()], name, args, body)
    ; rules(
        IsPage : name
      )

strategies

  declare-action =
    ?def@Action(name, fargs, body)
    ; where( t1* := <map(?Arg(_,<id>))> fargs )
    ; rules(
        ActionDefinition  : name -> def
        ActionArguments  : name -> fargs
        
        CheckActionSignature : 
          (None(), name, t2*) -> SimpleSort("void")
          where <zip(type-compatible)> (t1*, t2*)
      )

strategies
  
  declare-globals =
    ?gd@GlobalsDefinition(vardecls)
	; <map(try(declare-global-vars))> vardecls
    ; !gd
     
  declare-global-vars =
  	?VarDeclInit(ident,sort,_)	
  	;rules
  	(
  		TypeOf : ident -> sort
  		IsGlobal : ident
  	)
  	
strategies

  java-type =
    defined-java-type <+ builtin-java-type <+ object-type

  java-wrapper-type =
    defined-java-type <+ builtin-wrapper-java-type <+ builtin-java-type <+ object-type
    
  defined-java-type =
    DefinedJavaType
  
  defined-java-type :
    SimpleSort(x) -> <DefinedJavaType> x

  persistence-annotations =
    builtin-persistence-annotations <+ ![]
    
  java-type-default-value =
    defined-java-type-default-value 
    <+ builtin-java-type-default-value
    
  defined-java-type-default-value :
    s@SimpleSort(y) -> |[ new y() ]|
    where <defined-java-type> s

rules

  sort-to-java-type-string : SimpleSort("Object") -> "java.lang.Object"
  sort-to-java-type-string : SimpleSort("String") -> "java.lang.String"
  sort-to-java-type-string : SimpleSort("Int") -> "int"
  sort-to-java-type-string : SimpleSort("Bool") -> "boolean"
  sort-to-java-type-string : SimpleSort("Float") -> "double"
  sort-to-java-type-string : SimpleSort("Text") -> "java.lang.String"
  sort-to-java-type-string : SimpleSort("Secret") -> "java.lang.String"
  sort-to-java-type-string : SimpleSort("Email") -> "java.lang.String"
  sort-to-java-type-string : SimpleSort("Image") -> "java.lang.String"  
  sort-to-java-type-string : GenericSort("List", [x]) -> <concat-strings> ["java.util.List<", <sort-to-java-type-string> x, ">"]
  sort-to-java-type-string : GenericSort("Set", [x]) -> <concat-strings> ["java.util.Set<", <sort-to-java-type-string> x, ">"]
  sort-to-java-type-string : GenericSort("Map", [x, y]) -> <concat-strings> ["java.util.Map<", <sort-to-java-type-string> x, ",", <sort-to-java-type-string> y, ">"]
  sort-to-java-type-string : x -> <DefinedJavaTypeString> x

  object-type :
    SimpleSort("Object") -> type|[ Object ]|

  builtin-java-type : 
    SimpleSort("Int") -> type|[ int ]|

  builtin-wrapper-java-type :
    SimpleSort("Int") -> type|[ Integer ]|

  builtin-java-type : 
    SimpleSort("Float") -> type|[ double ]| // Not sure, maybe float?

  builtin-wrapper-java-type :
    SimpleSort("Float") -> type|[ Double ]|
   
  builtin-java-type-default-value :
    SimpleSort("Int") -> |[ 0 ]|

  builtin-java-type-default-value :
    SimpleSort("Float") -> |[ 0.0 ]|

  builtin-java-type : 
    SimpleSort("Bool") -> type|[ boolean ]|

  builtin-wrapper-java-type : 
    SimpleSort("Bool") -> type|[ Boolean ]|
    
  builtin-java-type-default-value :
    SimpleSort("Bool") -> |[ false ]|
    
  builtin-java-type : 
    SimpleSort("String") -> type|[ String ]|

  builtin-java-type-default-value :
    SimpleSort("String") -> |[ "" ]|

  builtin-java-type : 
    SimpleSort("Secret") -> type|[ String ]|

  builtin-java-type-default-value :
    SimpleSort("Secret") -> |[ "" ]|

  builtin-java-type : 
    SimpleSort("Text") -> type|[ String ]|
    
  builtin-java-type-default-value :
    SimpleSort("Text") -> |[ ""  ]|

  builtin-persistence-annotations :
    SimpleSort("Text") -> [anno|[ @Column(length = 1000000) ]|]

  builtin-java-type : 
    SimpleSort("Date") -> type|[ java.util.Date ]|
    
  builtin-java-type-default-value :
    SimpleSort("Date") -> |[ new java.util.Date() ]|

  builtin-java-type : 
    SimpleSort("URL") -> type|[ String  ]|
    
  builtin-java-type-default-value :
    SimpleSort("URL") -> |[ "" ]|

  builtin-java-type : 
    SimpleSort("Image") -> type|[ String ]|
    
  builtin-java-type-default-value :
    SimpleSort("Image") -> |[ "" ]|

  builtin-java-type : 
    SimpleSort("Email") -> type|[ String ]|
            
  builtin-java-type-default-value :
    SimpleSort("Email") -> |[ "" ]|

  builtin-java-type :
    GenericSort("List", [s]) -> type|[ java.util.List<t> ]|
    where t := <java-wrapper-type> s

  builtin-java-type-default-value :
    GenericSort("List", [s]) -> |[ new java.util.ArrayList<t>() ]|
    where t := <java-wrapper-type> s

  builtin-java-type :
    GenericSort("Set", [s]) -> type|[ java.util.Set<t> ]|
    where t := <java-wrapper-type> s

  builtin-java-type-default-value :
    GenericSort("Set", [s]) -> |[ new java.util.HashSet<t>() ]|
    where t := <java-wrapper-type> s

  builtin-java-type :
    GenericSort("Map", [s1, s2]) -> type|[ java.util.Map<t1, t2> ]|
    where t1 := <java-wrapper-type> s1
        ; t2 := <java-wrapper-type> s2
        
  builtin-java-type-default-value :
    GenericSort("Map", [s1,s2]) -> |[ new java.util.HashMap<t1,t2>() ]|
    where t1 := <java-wrapper-type> s1
        ; t2 := <java-wrapper-type> s2
        
rules // typechecking context

  tc-context =
    TcContext <+ !"" 
    
  add-tc-context = ?msg; 
    if x := <TcContext> then
      <concat-strings>[x | msg]
    else 
      <concat-strings>msg
    end
    
  in-tc-context(s|msg) =
    {| TcContext
     : rules( TcContext := <add-tc-context> msg )
     ; s
     |}
    
  typecheck-error(|msg) =
    err-msg(|["module ", <Module>, "/", <tc-context>, ": " | msg])
    ; rules( TypecheckError := True() )
    
rules 

  type-of :
    e{t*} -> t
    where t := <fetch-elem(?Type(<id>))> t*
  
rules

  typecheck =
    typecheck-application
    ; if TypecheckError then
        typecheck-error(|["typechecking failed; repair errors above"])
        ; fail
      end
  
  typecheck-application =
    Application(?qid, {| Module : rules( Module := qid ); map(typecheck-section) |})
    <+ ?x; typecheck-error(|["application expected: ", x])
    
  typecheck-section =
    Section(id, map(typecheck-definition))
    <+ typecheck-module
    <+ Description(id)
    <+ Note(id)
    <+ ?x; typecheck-error(|["section expected: ", x])
    
  typecheck-module :
    Module(mod, section1*) -> Module(mod, section2*)
    where {| Module
           : rules( Module := mod )
           ; section2* := <map(typecheck-section)> section1*
           |}
    
  typecheck-definition =
    typecheck-template-definition
    <+ typecheck-entity
    <+ typecheck-globals
    <+ ?def; typecheck-error(|["definition not typechecked: ", def])
      
rules // typechecking entity declarations

  typecheck-entity :
    EntityNoSuper(x_class, props, function*) -> EntityNoSuper(x_class, props, function2*)
    where {| TypeOf
          : in-tc-context(
              where( <map(typecheck-property)> props)
              ; function2* := <map(typecheck-function)> function*
              | ["entity declaration ", x_class]) |}
    
    
  typecheck-entity :
    Entity(x_class, s, props, functions) -> Entity(x_class, s, props, functions2)
    where in-tc-context(
        where( <typecheck-supertype> s )
        ; where( <map(typecheck-property)> props )
        ; functions2 := <map(typecheck-function)> functions
      | ["entity declaration ", x_class])
      
  typecheck-entity :
    SessionEntity(nm,ent) -> SessionEntity(nm,<typecheck-entity>ent)
    
  typecheck-supertype = 
    ?s
    ; if not(<IsEntity> s) then
        typecheck-error(|["supertype ", s, " is not a defined entity"])
      end
    ; <map(declare-super-property)> <Properties> s

  declare-super-property =
    ?Property(x, k, s, annos)
    ; rules( TypeOf : x -> s )
    ; rules( IsProperty : x )

  declare-super-property =
    ?DerivedProperty(x, k, s, annos, e)
    ; rules( TypeOf : x -> s )
    ; rules( IsProperty : x )
    
  typecheck-property =
    ?Property(x, k, s, annos)
    ; if not(<java-type> s) then
        typecheck-error(|["property ", x, " has invalid type"])
      end
    ; rules( TypeOf : x -> s )
    ; rules( IsProperty : x )
    ; <map(try(typecheck-annos))> annos
  
  typecheck-property :
    DerivedProperty(x, k, s, annos, e) -> DerivedProperty(x, k, s, annos, e2)
    where e2 := <typecheck-expression> e
        ; <?_{Type(e2t)}> e2
        ; if not(<type-compatible>(e2t, s)) then
             typecheck-error(|["The expression of the derived type ", x, " should have type ", s, " but instead has type ", e2t])
          end
        ; rules( TypeOf : x -> s )
        ; rules( IsProperty : x )

  typecheck-annos =
    ?InverseAnno(ent, fld)
    ; if not(<IsEntity> ent) then
        typecheck-error(|["The entity ", ent, " does not exist."])
      end
    ; if not(t := <TypeOfProperty> (ent, fld)) then
        typecheck-error(|["The field ", ent, ".", fld, " is not of the right type."])
      end
    ; if not(<?GenericSort(_, _)> t) then
        typecheck-error(|["The property refered to is not a collection: ", ent, ".", fld])
      end
  
rules // typechecking entity functions
  typecheck-function :
    Function(f, args, sort, body1) -> Function(f, args, sort, body2)
    where( {| TypeOf, ReturnType
           : in-tc-context(
               rules( ReturnType := sort )
               ; <map(declare-typeof-arg)> args
               ; body2 := <typecheck-function-block> body1
             |["function ", f, "/"])
           |} )
           
  typecheck-function-stat =
    typecheck-function-block
    <+ typecheck-assignment-stat
    <+ typecheck-vardecl
    <+ typecheck-if
    <+ typecheck-for
    <+ typecheck-function-return
    <+ Stat(typecheck-expression)
    <+ warn(|"warning: not typechecking statement: ")
  
  typecheck-function-block =
    Block({| TypeOf : in-tc-context(map(typecheck-function-stat)|["block/"]) |})
  
  typecheck-function-return :
    Return(e1) -> Return(e2)
    where e2 := <typecheck-expression> e1
        ; <?_{Type(e2t)}> e2
        ; rt := <ReturnType>
        ; if not(<type-compatible>(e2t, rt)) then
             typecheck-error(|["The return statement expression of the derived type ", e2t, " should have type ", rt])
           end

rules //typechecking globals

  typecheck-globals :
    GlobalsDefinition(body1) -> GlobalsDefinition(body2)
    where {| TypeOf
           : in-tc-context(
               body2 := 
               <map(typecheck-vardecl-extra-global;typecheck-vardecl)> body1
             |["globals /"])
           |}

  typecheck-vardecl-extra-global :
    VarDeclInit(x, s, e1) -> VarDeclInit(x, s, e1)
    where if not( <defined-java-type> s )
			then
				typecheck-error(|["type not allowed or unknown in global declaration ", s])
			end

  typecheck-vardecl-extra-global :
    VarDecl(x, s) -> VarDecl(x, s)
    where typecheck-error(|["var needs to be initialized in global declaration ", x])

rules // typechecking template definitions

  typecheck-template-definition :
    Define(mods, f, args, elems1) -> Define(mods, f, args, elems2)
    where dbg(|"typecheck-definition in: ")
        ; {| TypeOf, TemplateDefinition, TemplateArguments, IsPage
           : in-tc-context(id
               ; dbg(|"typecheck-definition a: ")
               ; <map(declare-typeof-arg)> args
               ; dbg(|"typecheck-definition b: ")
               ; <alltd(declare-action <+ declare-template-definition <+ typecheck-vardecl)> elems1
               ; dbg(|"typecheck-definition c: ")
               ; elems2 := <typecheck-page-elements> elems1
               ; dbg(|"typecheck-definition d: ")
             |["definition ", f, "/"])
           |}
         ; dbg(|"typecheck-definition out: ")
  
  declare-typeof-arg = 
    ?Arg(x, s)
    ; if not(<java-type> s) then 
        typecheck-error(|["parameter ", x, " has invalid type"])
      else 
        rules( TypeOf : x -> s )
      end

rules // typechecking page elements 
      
  typecheck-page-elements =
    map(typecheck-page-element)
    <+ ?elems; typecheck-error(|["not a list of elements: ", elems])
    
  typecheck-page-element = dbg(|"typecheck-page-element in: "); (
    typecheck-template-definition
    <+ typecheck-text  
    <+ typecheck-select
    <+ typecheck-action 
    <+ typecheck-init
    <+ typecheck-if-templ
    <+ typecheck-call-action 
    <+ typecheck-call-navigate
    <+ typecheck-template-call
    <+ typecheck-iterator
    <+ typecheck-vardecl
    <+ dbg(|"unknown page element? ")
       ; all(typecheck-page-element)
  ); dbg(|"typecheck-page-element out: ")
    
  typecheck-text =
    Text(is-string)
    
  typecheck-call-action :
    TemplateCall(f, [e1,e2], []) -> TemplateCall(f, [e1',e2'], [])
    where !f; (?"action" + ?"actionLink")
        ; in-tc-context(id
            ; e1' := <typecheck-expression> e1
            ; e2' := <typecheck-expression> e2
          | [f, "/"])

    
  typecheck-call-navigate :
    TemplateCall("navigate", [e], elems1) -> TemplateCall("navigate", [e'], elems2)
    where in-tc-context(id
            ; e' := <typecheck-link> e
            ; elems2 := <typecheck-page-elements> elems1
          | ["navigate/"])

  typecheck-call-navigate :
    TemplateCall("navigate", [e1,e2], []) -> TemplateCall("navigate", [e1', e2'], [])
    where in-tc-context(id
            ; e1' := <typecheck-expression> e1
            ; e2' := <typecheck-link> e2
          | ["navigate/"])
             
  typecheck-link :
    ThisCall("url", [e1]) -> ThisCall("url", [e2])
    where e2 := <typecheck-expression> e1

  typecheck-link :
    ThisCall(p, args1) -> ThisCall(p, args2)
    where not("url" := p)
        ; if not(<IsPage> p) then
            typecheck-error(|["link to undefined page ", p])
          else
            TemplateCall(p, args2, []) := <typecheck-template-call> TemplateCall(p, args1, [])
          end

  typecheck-template-call :
    TemplateCall(f, args1, elems1) -> TemplateCall(f, args2, elems2)
    where in-tc-context(id
            ; args2 := <map(typecheck-expression)> args1
            ; try(<zip(try(match-argument))> (<TemplateArguments> f, args2))
            ; elems2 := <typecheck-page-elements> elems1
            | [f, "/"])
        
        // @todo account for arguments of built-in templates (for which TemplateArguments fails)
                
   match-argument =
    ?(Arg(x, t1), e{Type(t2)})
    ; if not(<subtype-of>(t2, t1)) then
        typecheck-error(|["type ", t2, " of argument ", e{}, " does not match formal parameter '", x, "' (", t1, ")"])
      end
   
   subtype-of =
     eq
     
   subtype-of = 
     ?(SimpleSort(t1), SimpleSort(t2))
     ; where( <extends>(t1, t2) )
   
   extends = 
     while-not(eq, (Extends, id))
  
   typecheck-iterator :
     For(x, s, e1, elems1) -> For(x, s, e2, elems2)
     where in-tc-context(
             e2 := <typecheck-expression> e1
             ; <should-have-list-type> e2
             ; {| TypeOf
                : if not(<java-type> s) then
                    typecheck-error(|["index ", x, " has invalid type ", s])
                    // @todo check that type of x corresponds to element type of collection s
                  else
                    rules( TypeOf : x -> s )
                  end
                ; elems2 := <typecheck-page-elements> elems1
                |}
             | ["iterator ", x, "/"] )
             
   typecheck-iterator :
     ForAll(x, s, elems1) -> ForAll(x, s, elems2)
     where in-tc-context(
               {| TypeOf
                : if not(<defined-java-type> s) then
                    typecheck-error(|["index ", x, " has invalid type ", s])
                    // @todo check that type of x corresponds to element type of collection s
                  else
                    rules( TypeOf : x -> s )
                  end
                ; elems2 := <typecheck-page-elements> elems1
                |}
             | ["for all iterator ", x, "/"] ) 
                         
  typecheck-select :
    Select(x,s@SimpleSort(_),label,e1) -> Select(x,s,label,e2)
    where in-tc-context(id
            ; if not(<defined-java-type> s) then
                typecheck-error(|["index ", x, " should have a defined entity type, is ", s])
              else
                rules( TypeOf : x -> s )
              end
            ; e2 := <typecheck-expression> e1
          | ["select/"])

  typecheck-if-templ :
    IfTempl(e1, elems1) -> IfTempl(e2, elems2)
    where e2 := <typecheck-expression> e1
        ; elems2 := <typecheck-page-elements> elems1
        ; <?_{Type(e2t)}> e2
        ; if not(<eq>(e2t, SimpleSort("Bool"))) then
            typecheck-error(|["Expression ", e1, " should be of type Bool, but instead is of type ", e2t])
          end
  
strategies

  should-have-collection-type = 
    try(
      ?e{Type(t)}
      ; if not(<is-collection-type> t) then
          typecheck-error(|["type of iterator should be a collection (and not ", t, ")"])
        end
    )
  
  is-collection-type =
    ?GenericSort("List", [SimpleSort(_)])
    
  is-collection-type =
    ?GenericSort("Set", [SimpleSort(_)])
    
  should-have-list-type = 
    try(
      ?e{Type(t)}
      ; if not(<is-list-type> t) then
          typecheck-error(|["type of iterator should be a List (hint: every collection property f has also a property fList)"])
        end
    )
  
  is-list-type =
    ?GenericSort("List", [SimpleSort(_)])

rules // typechecking actions

  typecheck-action :
    Action(f, args, body1) -> Action(f, args, body2)
    where {| TypeOf
           : in-tc-context(
               <map(declare-typeof-arg)> args
               ; body2 := <typecheck-block> body1
             |["action ", f, "/"])
           |}

rules // typechecking inits

  typecheck-init :
    InitAction(body1) -> InitAction(body2)
    where {| TypeOf
           : in-tc-context(
               body2 := <typecheck-block> body1
             |["init /"])
           |}
           
rules // typechecking statements

  typecheck-stat =
    typecheck-block
    <+ typecheck-assignment-stat
    <+ typecheck-vardecl
    <+ typecheck-if
    <+ typecheck-for
    <+ typecheck-return
    <+ Stat(typecheck-expression)
    <+ dbg(|"warning: not typechecking statement: ")
  
  typecheck-block =
    Block({| TypeOf : in-tc-context(map(typecheck-stat)|["block/"]) |})
    
  typecheck-assignment-stat :
    Assign(Assignment(qid, e1)) -> Assign(Assignment(qid, e2))
    where e2 := <typecheck-expression> e1
    
  typecheck-vardecl :
    VarDeclInit(x, s, e1) -> VarDeclInit(x, s, e2)
    where rules( TypeOf : x -> s )
        ; e2 := <typecheck-expression> e1
        
        // @todo check that s is valid type
        
  typecheck-vardecl :
    VarDecl(x, s) -> VarDecl(x, s)
    where rules( TypeOf : x -> s )
    
	typecheck-if :
		If(e1, sit1*, sif1*) -> If(e2, sit2*, sif2*)
		where e2 := <typecheck-expression> e1
        ; e2t := <?_{Type(<id>)}> e2
        ; if not(<?_{Type(SimpleSort("Bool"))}> e2) then
            typecheck-error(|["expression ", e2, " should be of type Bool"])
          end
        ; sit2* := <map(typecheck-stat)> sit1*
        ; sif2* := <map(typecheck-stat)> sif1*

  typecheck-for :
    ForColl(v, s, e1, stm1*) -> ForColl(v, s, e2, stm2*)
    where {| TypeOf :
              rules(TypeOf : v -> s)
              ; e2 := <typecheck-expression> e1
              ; if not(<?_{Type(GenericSort(_, [<sort-literal> s]))}> e2) then // TODO: This only accepts List<SimpleSort>-like lists, not List<List<Int>> for example.
                  typecheck-error(|["expression ", e2, " should be of type [SomeGenerichType]<", s, ">"])
                end
              ; stm2* := <map(typecheck-stat)> stm1*
          |}

  sort-literal :
    SimpleSort(x) -> x

  typecheck-return :
    Return(e1) -> Return(e2)
    where e2 := <typecheck-link> e1
    
rules // typechecking expressions
   
   typecheck-expression = dbg(|"tc expression: "); (
     typecheck-variable   
     <+ typecheck-literal
     <+ typecheck-fieldaccess
     <+ typecheck-cast
     <+ typecheck-object-creation
     <+ typecheck-set-creation
     <+ typecheck-list-creation
     <+ typecheck-typed-set-creation
     <+ typecheck-typed-list-creation
     <+ typecheck-call
     <+ typecheck-for-expr
     <+ typecheck-query
     <+ typecheck-operator
     <+ typecheck-expression-error
   )
   
   typecheck-literal :
     String(x) -> String(x){Type(SimpleSort("String"))}
     
   typecheck-literal :
     Int(x) -> Int(x){Type(SimpleSort("Int"))}

   typecheck-literal :
     Float(x) -> Float(x){Type(SimpleSort("Float"))}
     
   typecheck-literal :
     True() -> True() {Type(SimpleSort("Bool"))}
     
   typecheck-literal :
     False() -> False() {Type(SimpleSort("Bool"))}
     
   typecheck-variable :
     Var(x) -> Var(x){Type(t)}
     where if not(t := <TypeOf> x) then
             typecheck-error(|["variable ", x, " has no declared type"])
             ; t := "Error"
           end

   typecheck-cast :
     Cast(e1, s) -> Cast(e2, s) { Type(s) }
     where e2 := <typecheck-expression> e1

   typecheck-set-creation :
     SetCreation(e1*) -> SetCreation(e2*){Type(GenericSort("Set", [t]))}
     where dbg(|"typecheck-set-creation a: ")
         ; e2* := <map(typecheck-expression)> e1*
         ; dbg(|"typecheck-set-creation b: ")
         ; [_{Type(t)},e3*] := e2*
         ; dbg(|"typecheck-set-creation c: ")
         ; if not(<map(?_{Type(<id>)}; <eq>(<id>, t))> e3*) then
             typecheck-error(|["arguments of set creation should have same type"])
           end
         ; dbg(|"typecheck-set-creation d: ")
     
   typecheck-typed-set-creation :
     TypedSetCreation(s, e1*) -> TypedSetCreation(s, e2*) {Type(GenericSort("Set", [s]))}
     where e2* := <map(typecheck-expression)> e1*
         ; if not(<map(?_{Type(<id>)}; <type-compatible>(s, <id>))> e2*) then
             typecheck-error(|["arguments of set creation should have same type."])
           end

   typecheck-typed-list-creation :
     TypedListCreation(s, e1*) -> TypedListCreation(s, e2*) {Type(GenericSort("List", [s]))}
     where e2* := <map(typecheck-expression)> e1*
         ; if not(<map(?_{Type(<id>)}; <type-compatible>(<id>, s))> e2*) then
             typecheck-error(|["arguments of list creation should have same type"])
           end
         
   typecheck-list-creation :
     ListCreation(e1*) -> ListCreation(e2*){Type(GenericSort("List", [t]))}
     where dbg(|["typecheck-set-creation a: ", <id>])
         ; e2* := <map(typecheck-expression)> e1*
         ; dbg(|"typecheck-set-creation b: ")
         ; [_{Type(t)},e3*] := e2*
         ; dbg(|"typecheck-set-creation c: ")
         ; if not(<map(?_{Type(<id>)}; <eq>(<id>, t))> e3*) then
             typecheck-error(|["arguments of set creation should have same type"])
           end
         ; dbg(|"typecheck-set-creation d: ")
                  
   typecheck-object-creation :
     ObjectCreation(x_Class, assign1*) -> ObjectCreation(x_Class, assign2*){Type(SimpleSort(x_Class))}
     where dbg(|"typecheck-object creation a: ")
         ; in-tc-context(
             if not(<IsEntity> x_Class) then
               typecheck-error(|["object creation for undeclared entity ", x_Class])
             end
             ; dbg(|"typecheck-object creation b: ")
             ; assign2* := <map(typecheck-field-initialization(|x_Class))> assign1*
             ; dbg(|"typecheck-object creation c: ")
           |["create ", x_Class, "/"])
     
   typecheck-field-initialization(|x_Class) :
     Assignment(y, e1) -> Assignment(y, e2)
     where dbg(|"typecheck-assign a: ");
           e2{Type(t2)} := <typecheck-expression> e1
           // @todo
         ; dbg(|"typecheck-assign b: ")
         ; if not(t1 := <TypeOfProperty> (x_Class, y)) then
             typecheck-error(|["entity ", x_Class, " has no field ", y])
             ; t1 := SimpleSort("void")
           end
         ; dbg(|"typecheck-assign c: ")
         ; if not(<type-compatible>(t1,t2)) then
             typecheck-error(|["assignment to field ", y, " of ", x_Class, " with type ", t2, " should be ", t1])
           end
         ; dbg(|"typecheck-assign d: ")
     
   typecheck-fieldaccess :
     FieldAccess(e1, f) -> FieldAccess(e2, f){Type(t1)}
     where e2{Type(t2@SimpleSort(s))} := <typecheck-expression> e1
         ; t1 := <TypeOfProperty> (s, f)
         
   typecheck-for-expr :
     ForExp(x, s, ie1, oe1) -> ForExp(x, s, ie2, oe2) {Type(t)}
     where ie2 := <typecheck-expression> ie1
         ; t := <?_{Type(<id>)}> ie2
         ; {| TypeOf :
                rules(TypeOf : x -> s)
                ; oe2 := <typecheck-expression> oe1
           |}
         ; if not(<type-compatible>(<?_{Type(<id>)}> oe2, s)) then
             typecheck-error(|["expression ", oe2, " is not of type ", s])
           end

   typecheck-call :
     Call(e1, f, e2*) -> Call(e3, f, e4*){Type(t)}
     where e3{Type(t3)} := <typecheck-expression> e1
         ; e4* := <map(typecheck-expression)> e2*
         ; t := <check-signature> (t3, f, e4*)
         
   typecheck-call :
     ThisCall(f, e1*) -> ThisCall(f, e2*){Type(t)}
     where e2* := <map(typecheck-expression)> e1*
         ; t := <check-signature> (None(), f, e2*)
 
 // Exp operators, can this be done in a shorter way?
 // TODO: Make sure these are numeric types (in case of mul, div and sub)
   typecheck-operator :
     Add(x, y) -> Add(x2, y2) { Type(xt) }
     where
           x2 := <typecheck-expression> x
         ; y2 := <typecheck-expression> y
         ; xt := <?_{Type(<id>)}> x2
         ; yt := <?_{Type(<id>)}> y2
         ; if not(<type-compatible>(xt, yt)) then
             typecheck-error(|["Addition of ", x, " type: ", xt, " and ", y, " type: ", yt, " is not allowed, due to incompatible types."])
           end

   typecheck-operator :
     Sub(x, y) -> Sub(x2, y2) { Type(xt) }
     where
           x2 := <typecheck-expression> x
         ; y2 := <typecheck-expression> y
         ; <?_{Type(xt)}> x2
         ; <?_{Type(yt)}> y2
         ; if not(<type-compatible>(xt, yt)) then
             typecheck-error(|["Substraction of ", x, " and ", y, " is not allowed, due to incompatible types."])
           end

   typecheck-operator :
     Mul(x, y) -> Mul(x2, y2) { Type(xt) }
     where
           x2 := <typecheck-expression> x
         ; y2 := <typecheck-expression> y
         ; xt := <?_{Type(<id>)}> x2
         ; yt := <?_{Type(<id>)}> y2
         ; if not(<type-compatible>(xt, yt)) then
             typecheck-error(|["Multiplication of ", x, " and ", y, " is not allowed, due to incompatible types."])
           end

   typecheck-operator :
     Div(x, y) -> Div(x2, y2) { Type(xt) }
     where
           x2 := <typecheck-expression> x
         ; y2 := <typecheck-expression> y
         ; xt := <?_{Type(<id>)}> x2
         ; yt := <?_{Type(<id>)}> y2
         ; if not(<type-compatible>(xt, yt)) then
             typecheck-error(|["Division of ", x, " and ", y, " is not allowed, due to incompatible types."])
           end
           
   typecheck-operator :
     Eq(x, y) -> Eq(x2, y2) { Type(SimpleSort("Bool")) }
     where x2 := <typecheck-expression> x
         ; y2 := <typecheck-expression> y
         ; xt := <?_{Type(<id>)}> x2
         ; yt := <?_{Type(<id>)}> y2
         ; if not(<type-compatible>(xt, yt)) then
             typecheck-error(|["Comparison of ", x, " and ", y, " is not allowed, due to incompatible types."])
           end

   typecheck-operator :
     NotEq(x, y) -> NotEq(x2, y2) { Type(SimpleSort("Bool")) }
     where x2 := <typecheck-expression> x
         ; y2 := <typecheck-expression> y
         ; xt := <?_{Type(<id>)}> x2
         ; yt := <?_{Type(<id>)}> y2
         ; if not(<type-compatible>(xt, yt)) then
             typecheck-error(|["Comparison of ", x, " and ", y, " is not allowed, due to incompatible types."])
           end

   typecheck-operator :
     Not(x) -> Not(x2) { Type(SimpleSort("Bool")) }
     where x2 := <typecheck-expression> x
         ; xt := <?_{Type(<id>)}> x2
         ; if not(<eq>(xt, SimpleSort("Bool"))) then
             typecheck-error(|[x, " should be an expression of type Bool, but is of type ", xt])
           end         

   typecheck-operator :
     And(x, y) -> And(x2, y2) { Type(SimpleSort("Bool")) }
     where x2 := <typecheck-expression> x
         ; y2 := <typecheck-expression> y
         ; xt := <?_{Type(<id>)}> x2
         ; yt := <?_{Type(<id>)}> y2
         ; if not(<eq>(xt, SimpleSort("Bool"))) then
             typecheck-error(|[x, " should be an expression of type Bool, but is of type ", xt])
           end         
         ; if not(<eq>(yt, SimpleSort("Bool"))) then
             typecheck-error(|[y, " should be an expression of type Bool, but is of type ", yt])
           end         

   typecheck-operator :
     Or(x, y) -> Or(x2, y2) { Type(SimpleSort("Bool")) }
     where x2 := <typecheck-expression> x
         ; y2 := <typecheck-expression> y
         ; xt := <?_{Type(<id>)}> x2
         ; yt := <?_{Type(<id>)}> y2
         ; if not(<eq>(xt, SimpleSort("Bool"))) then
             typecheck-error(|[x, " should be an expression of type Bool, but is of type ", xt])
           end         
         ; if not(<eq>(yt, SimpleSort("Bool"))) then
             typecheck-error(|[y, " should be an expression of type Bool, but is of type ", yt])
           end         

   typecheck-operator :
     IsA(e1, s) -> IsA(e2, s) { Type(SimpleSort("Bool")) }
     where e2 := <typecheck-expression> e1   
  
   typecheck-query :
     HqlQuery(q) -> HqlQuery(q){Type(t)}
     where t := <type-of-query> q
         ; dbg(|"type of query: ")

   typecheck-expression-error =
     ?e
     ; typecheck-error(|["expression ", e, " has type error"])
     
rules // signature

  check-signature :
    (t3, f, e*) -> t
    where t* := <map(?_{Type(<id>)})> e*
        ; t := <check-signature-aux> (t3, f, t*)
        
  check-signature-aux = 
    ?sig
    ; (CheckActionSignature
       <+ CheckFunctionSignature
       <+ check-builtin-signature
       <+ typecheck-error(|["type error in call ", sig]))
    
  check-builtin-signature :
    (GenericSort("List", [s]), "add", [s]) -> SimpleSort("void")

  check-builtin-signature :
    (GenericSort("List", [s]), "remove", [s]) -> SimpleSort("void")
    
  check-builtin-signature :
    (GenericSort("Set", [s]), "add", [s]) -> SimpleSort("void")
    
  check-builtin-signature :
    (GenericSort("Set", [s]), "remove", [s]) -> SimpleSort("void") 
    
  check-builtin-signature :
    (s@SimpleSort(_), "delete", []) -> SimpleSort("void")
    where <defined-java-type> s
    
  check-builtin-signature :
    (s@SimpleSort(_), "save", []) -> SimpleSort("void")
    where <defined-java-type> s
    
  check-builtin-signature :
    (s@SimpleSort(_), "persist", []) -> SimpleSort("void")
    where <defined-java-type> s

  check-builtin-signature :
    (GenericSort(Z, [s@SimpleSort(_)]), "persist", []) -> SimpleSort("void")
    where <defined-java-type> s
        ; <?"List" <+ ?"Set"> Z
            
rules // type compatibility

  /**
   * <type-compatible> (t1, t2) if a value of type t2 can be assigned
   * to a variable of type t1
   */

  type-compatible =
    ?(t, t)
   
  type-compatible =
    ?(SimpleSort("Email"), SimpleSort("String"))
    
  type-compatible =
    ?(SimpleSort("Text"), SimpleSort("String"))

  type-compatible =
    ?(SimpleSort("URL"), SimpleSort("String"))
    
  type-compatible =
    ?(SimpleSort("Image"), SimpleSort("String"))
    
  type-compatible =
    ?(SimpleSort("Secret"), SimpleSort("String"))
    
  type-compatible =
    ?(t1, t2)
    ; where(<subtype-of> (t2, t1))

rules 

  type-of-query :
    QueryRule(
      SelectFrom(Some(Select(_,[AliasedExpression(Path([x]),_)])), FromClause(ranges)),
      _, _, _) -> GenericSort("List", [t])
    where t := <fetch-elem(get-type-from-range(|x))> ranges
    
  get-type-from-range(|x) :
    FromRangeJoin(FromClass(Path([x_Class]),Some(AsAlias(Alias(x))),_),_) -> SimpleSort(x_Class)
    
/*
 HqlQuery(
   QueryRule(
     SelectFrom(
       Some(Select(None,[AliasedExpression(Path(["pub"]),None)])),
       FromClause([
         FromRangeJoin(FromClass(Path(["Publication"]),Some(AsAlias(Alias("pub"))),None),None),
         FromRangeJoin(FromClass(Path(["Person"]),Some(AsAlias(Alias("pers"))),None),None)
       ])
      ),
      Some(WhereClause(
             QueryAnd(
                Paren([EQ(Path(["pers","id"]),DslExp(FieldAccess(Var("person"),"id")))]),
                Paren([MemberOf(Path(["pers"]),Path(["pub","_authors"]))])))),
      None,
      None))
*/
    