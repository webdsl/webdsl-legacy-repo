/**

 Desugaring rules for WebDSL

*/

module org/webdsl/dsl/transformation/desugar

imports
  libstrategolib
  Java-15
  libjava-front

imports
  libwebdsl-front

signature
  constructors
    RemoveMe : Annotation

strategies

  all-consnil(s) = ?[_ | _] < [s | s] + all(s)

  innermost-rep(s) =
    {| InnermostNormalForm, InnermostApplied
     : rules(InnermostApplied := False())
     ; innermost-rep-aux(s)
     ; where(InnermostApplied => True())
     |}

  //rules used to determine whether any desugar was applied (might have only changed dynamic rule but not the AST)
  innermost-rep-aux(s) =
    InnermostNormalForm
    <+ all-consnil(innermost-rep-aux(s))
       ; try(s; rules( InnermostApplied := True() ); innermost-rep-aux(s))
       ; {?q; rules( InnermostNormalForm : q )}

  desugar-top =
    //{| AspectWeavingRules ... :
     repeat(innermost-rep(desugar))
   //  |}

strategies

  desugar = desugar-util

rules //extend entity functions create dr
  
  rename-all-vars :
    (t, []) -> (t, [])

  rename-all-vars :
    (t, [(from, to)|rst]) -> <rename-all-vars> (t2, rst)
    where t2 := <rename-var(|from, to)> t

rules

  desugar :
    [RemoveMe()|lst] -> lst
 

  /*
  create-extend-entity-dynamic-rules:
    ExtendSessionEntity(ident, props, funcs) -> ExtendEntity(ident, props, funcs)//easy cleanup
    where <create-extend-entity-dynamic-rules> ExtendEntity(ident, props, funcs)//reuse exising mechanism

  attach-properties-to-entity:
    Entity(ident,superident,props,funcs) ->
    Entity(ident,superident,<once-Extend-Entity-Properties(|props)> ident,<once-Extend-Entity-Functions(|funcs)> ident)

  attach-properties-to-entity:
    EntityNoSuper(ident,props,funcs) ->
    EntityNoSuper(ident,<once-Extend-Entity-Properties(|props)> ident,<once-Extend-Entity-Functions(|funcs)> ident)

  attach-properties-to-entity:
    SessionEntity(ident,props,funcs) ->
      SessionEntity(ident,<once-Extend-Entity-Properties(|props)> ident,<once-Extend-Entity-Functions(|funcs)> ident)

  cleanup-extend-entity-section-defs:
    Application(ident,sections) -> Application(ident,<alltd(cleanup-extend-entity-section-defs)> sections)

  cleanup-extend-entity-section-defs:
    Section(ident,defs) -> Section(ident,<filter(not(?ExtendEntity(_,_,_)))>defs)
*/
  create-email-argument-list:
   Define(mods, name, args, body1) -> Define(mods, name, args, body1)
   where try (if <oncetd(?ThisCall("email", [_]))> body1 then
           if not(<GetEmailArgumentsList> name) then
             x := <newname> "email_arguments"
             ; rules ( GetEmailArgumentsList : name -> x )
           end
         end )

/*
rules // Desugaring rules only executed once

  desugar-var-decl-stm =
    not(?VarDeclInit(_, _, _))
    ; try(sometd(DesugarOnce))
    ; ![<id>]

  desugar-var-decl-stm :
    VarDeclInit(x, s, e1) -> [VarDecl(x, s), Assign(Assignment(x, e1))]

  DesugarOnce : // Its purpose is to translate VarDeclInits to VarDecls with separate assignment (only within Blocks, not within globals {...} statements)
    Block(stms1) -> Block(stms2)
    where stms2 := <map(desugar-var-decl-stm); concat> stms1
rules

  Desugar : // Provide some context for desugaring rules
    EntityNoSuper(nm, b, c) -> EntityNoSuper(nm, b2, c2)
    where {| InEntity
           : rules ( InEntity := nm )
           ; b2 := <topdown-l(repeat(Desugar))> b
           ; c2 := <topdown-l(repeat(Desugar))> c
           |}
           ; if b := b2; c := c2 then
               fail
             end

  Desugar :
    Entity(nm, b, c, d) -> Entity(nm, b2, c2, d2)
    where {| InEntity
           : rules ( InEntity := nm )
           ; b2 := <topdown-l(repeat(Desugar))> b
           ; c2 := <topdown-l(repeat(Desugar))> c
           ; d2 := <topdown-l(repeat(Desugar))> d
           |}
           ; if b := b2; c := c2; d := d2 then
               fail
             end

*/
rules

  find-expression-params =
    ?fa@FieldAccess(v, _)
    ; not(<IgnoreVars> v)
    ; rules( Param :+= fa )
    ; rules( IgnoreVars : v )

  find-expression-params =
    ?v@Var(x)
    ; not(<IgnoreVars> v)
    ; not("Component" := <type-of> v)
    ; rules( Param :+= v )
    ; rules( IgnoreVars : v )

  find-expression-params = // Have to filter this one out later, but point is to ignore everything inside for-exps
    ?ForExp(oe, x, srt, ie, Filter(we, obe, l))
    ; {| IgnoreVars
       : rules ( IgnoreVars : Var(x) )
       ; <alltd(find-expression-params)> we
       ; <alltd(find-expression-params)> oe
       ; <alltd(find-expression-params)> l
       |}
    ; <try(sometd(find-expression-params))> ie

  forexp-function-param-to-farg :
     f@FieldAccess(_, x) -> farg|[ x : srt ]|
     where srt := <type-of> f
     ; rules( RewriteFieldAccessToFarg : f -> Var(x) ) //we need a rewrite rule that rebinds f  to  x, because the context is away due to lifting

  forexp-function-param-to-farg :
    Var(x) -> farg|[ x : srt ]|
    where srt := <type-of> Var(x)

  find-params =
    ?fa@FieldAccess(v, _)
    ; not(<IgnoreVars> fa) // v
    ; rules( Param :+= fa )
    ; rules( IgnoreVars :  fa) // v

  find-params =
    ?v@Var(x)
    ; not(<IgnoreVars> v)
    ; not("Component" := <type-of> v)
    ; rules( Param :+= v )
    ; rules( IgnoreVars : v )

  find-params = //ignore the identifier of the for-exp iteration in the param lookup
    ?ForExp(oe, x, srt, ie, Filter(we, obe, l))
    ; {| IgnoreVars
       : rules ( IgnoreVars : Var(x) 
                 IgnoreVars : FieldAccess(Var(x), _) )
       ; <alltd(find-params)> we
       ; <alltd(find-params)> oe
       ; <alltd(find-params)> l
       |}
    ; <alltd(find-params)> ie


  fix-forexp-in-entity-function=
    alltd({\FieldAccess(Var("this"{anno*}),rest) -> Var(rest)\})

  // style comments (EV)
  // can this not be factored into smaller steps?
  // @TODO: factor out param extraction from all the following rules into a single strategy

rules //Desugar helpers 

  auto-surround-with-template(|childname) : //ensures that all elements are a templatecall to 'childname', 
    elems -> elems2                       //fails if this was the case already (so disugar knows it can continue)
    where not(<all(?TemplateCall(childname,_,_,_) <+ ?TemplateCall("form",_,_,_) <+ not(?TemplateCall(_,_,_,_)))> elems)
    with  elems2:= <map(try(auto-surround-with-template-replace(|childname)))> elems

  /*
  auto-surround-with-template-replace(|childname) :
    t -> TemplateCall(childname, [],[],[t])
    where not(TemplateCall(_,_,_,_) := t); not(ForAll(_, _, _) := t); not(For(_, _, _, _) := t)
  */
  
  auto-surround-with-template-replace(|childname) :
    t@TemplateCall(x,_,_,_) -> TemplateCall(childname, [],[],[t])
    where not(childname := x); not("form" := x)

  /*
  auto-surround-with-template-replace(|childname) :
    t -> t
    where TemplateCall(childname,_,_,_) := t
  */

