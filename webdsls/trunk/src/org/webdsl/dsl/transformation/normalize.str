/**

 Syntactic normalization rules for WebDSL

*/

// @todo : transform all rules to use concrete syntax

module org/webdsl/dsl/transformation/normalize

imports
  libstrategolib
  Java-15
  libjava-front

imports
  libwebdsl-front

strategies
    
  /**
   * syntactically normalize WebDSL constructs
   */
  
  /*normalize-any = 
    topdown-l(repeat(normalize))
  */
  desugar = normalize

/*rules 

  normalize-action :
    [VarDeclInit(x, s, e) | stm*] -> [VarDecl(x, s), Assign(Assignment(x, e)) | stm*]
*/
rules // functions

  normalize-action : 
    FunctionNoReturn(x, farg*, stat*) -> Function(x, farg*, SimpleSort("Void"), stat*)
    //|[ function x(farg*) { stat* } ]| -> |[ function x(farg*) : Void { stat* } ]|

  normalize-action :
    IfNoElse(e, bit) -> If(e, bit, Block([]))
    //stat|[ if(e) { stat* } ]| -> stat|[ if(e) { stat* } else { } ]|

  normalize-ui :
    IfNoElseTempl(e, elem*) -> IfTempl(e, elem*, [])

rules // literals

  normalize-action :
    String(x) -> String(<un-double-quote> x)
   
  normalize-ui :
    Text(x) -> Text(<un-double-quote> x)

rules // case statement

  // TODO: Try rename-all here?
  normalize-action :
    stat|[ case(e) { alt* } ]| -> <rename-closed> stat|[ { var x : srt := e; stat } ]|
    where srt := <type-of> e
        ; x := <newname> "caseval"
        ; stat := <case-to-if(|x)> alt*

  case-to-if(|x) :
    [] -> stat|[ { } ]|

  case-to-if(|x) :
    [ |[ const { stat1* } ]|, alt* ] -> stat|[ if(x == const) { stat1* } else { stat2 } ]|
    where stat2 := <case-to-if(|x)> alt*

  case-to-if(|x) :
    [ |[ default { stat1* } ]|, alt* ] -> stat|[ { stat1* } ]|

rules // case template element

  // TODO: Try rename-all here?
  normalize-ui :
    elem|[ case(e) { talt* } ]| -> <rename-closed> elem|[ dummy(){ var x : srt := e; elem } ]|
    where srt  := <type-of> e
        ; x    := <newname> "caseval"
        ; elem := <template-case-to-if(|x)> talt*

  template-case-to-if(|x) :
    [] -> elem|[ dummy(){ } ]|

  template-case-to-if(|x) :
    [ TemplateCaseAlt(const, elem1*), talt* ] -> elem|[ if(x == const) { elem1* } else { elem2 } ]|
    where elem2 := <template-case-to-if(|x)> talt*

  template-case-to-if(|x) :
    [ TemplateCaseAltDefault(elem1*), talt* ] -> elem|[ dummy(){ elem1* } ]|

rules // templates

  normalize-ui :
    def |[ define x(farg*) { elem* } ]| -> def |[ define template x(farg*) { elem* } ]|
    where not(<EnclosingDefinition> x)        

  normalize-ui :
    def |[ define x(farg*) { elem* } ]| -> def |[ define local x(farg*) { elem* } ]|
    where <EnclosingDefinition> x

rules // template elements

  normalize-ui :
    elem|[ navigate(url(e))[passign*]{} ]| -> elem|[ navigate(url(e))[passign*]{url(e)} ]|

//MW: those two should be necessary?
  normalize-ui :
    elem|[ navigate(url(e))[] ]| -> elem|[ navigate(url(e))[]{url(e)} ]|

  normalize-ui :
    elem|[ navigate(url(e)) ]| -> elem|[ navigate(url(e))[]{url(e)} ]|

  normalize-ui :
    elem|[ navigate(e1, e2)[passign*]{} ]| -> elem|[ navigate(e2)[passign*]{text(e1)} ]|

  normalize-ui :
    elem|[ select( x : srt, str1, e) ]| -> elem|[ select( x : srt, str2, e ) ]|
    where str2 := <un-double-quote> str1

  // section("Header") {...} => section() { header{"Header"} }
  // Works only for strings. Making generic is difficult, because argument to a 
  // TemplateCall are Exp* and the body of a TemplateCall is TemplateElement*
  normalize-ui :
    elem|[ section(e){elem*} ]| -> elem|[ section()[]{ header{output(e)} elem* } ]|

  normalize-ui :
    elem|[ x ]| -> elem|[ x()[]{} ]|

  normalize-ui :
    elem|[ x(e*) ]| -> elem|[ x(e*)[]{} ]|

  normalize-ui :
    elem|[ x(e*)[passign*] ]| -> elem|[ x(e*)[passign*]{} ]|
 
  normalize-ui :
    elem|[ x(e*){elem*} ]| -> elem|[x(e*)[]{elem*}]|
    
 normalize-ui :
    elem|[ x[passign*] ]| -> elem|[ x()[passign*]{} ]|

 normalize-ui :
    elem|[ x[passign*]{elem*} ]| -> elem|[ x()[passign*]{elem*} ]|

  normalize-ui :
    elem|[ x{elem*} ]| -> elem|[ x()[]{elem*} ]|

  normalize-ui :
    elem|[ text(x) ]| -> elem|[ text(y)[]{} ]| 
    with y := <un-double-quote> x
    
  normalize-ui :
    elem*|[ text(e1,e2,e*){} elem* ]| -> elem*|[ text(e1)[]{} text(e2,e*)[]{ } elem* ]|

  normalize-ui :
    elem|[ menubar()[passign*]{ elem* } ]| -> elem|[ menubar("horizontal")[passign*]{ elem* } ]|

  normalize-ui :
    elem|[ from(e1){} ]| -> elem|[ from(e1,e1){} ]|

rules // for normalization

  normalize-ui :
    ForSepNoFilter(x, s, e, te1*, te2*) -> ForSep(x, s, e, Filter(True(), OrderAscending(Null()), Limit(Int("1000"), Int("0"))), te1*, te2*)

  normalize-ui :
    ForNoFilter(x, s, e, te*) -> For(x, s, e, Filter(True(), OrderAscending(Null()), Limit(Int("1000"), Int("0"))), te*)

  normalize-ui :
    ForAllNoFilter(x, s, te*) -> ForAll(x, s, Filter(True(), OrderAscending(Null()), Limit(Int("1000"), Int("0"))), te*)

  normalize-action :
    ForStmtNoFilter(x, s, e, block) -> ForStmt(x, s, e, Filter(True(), OrderAscending(Null()), Limit(Int("1000"), Int("0"))), block)

  normalize-action :
    ForAllStmtNoFilter(x, s, block) -> ForAllStmt(x, s, Filter(True(), OrderAscending(Null()), Limit(Int("1000"), Int("0"))), block)

  normalize-action :
    ForExpNoFilter(oe, x, s, ie) -> ForExp(oe, x, s, ie, Filter(True(), OrderAscending(Null()), Limit(Int("1000"), Int("0"))))

rules //normalize Ajax
  normalize-ajax :
    AjaxActionIdParam(a, d, v) -> AjaxAction(a, d, String(v))
    
  normalize-ajax : 
    AjaxActionNoParam(a, d) -> AjaxAction(a, d, String(""))
    
  normalize-ajax :
    AjaxActionNoTarget(a, v) -> AjaxAction(a, "this", v)
