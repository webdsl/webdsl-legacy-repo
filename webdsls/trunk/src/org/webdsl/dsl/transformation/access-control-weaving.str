/**

 Security rules for WebDSL

*/

module org/webdsl/dsl/transformation/access-control-weaving

imports
  libstrategolib

imports
  org/webdsl/dsl/syntax/WebDSL
  org/webdsl/dsl/transformation/-
rules

  access-control-weaving=
    try(sometd(apply-checks-to-page))
  ; try(sometd(apply-checks-to-template-defs-actions))
  ; try(sometd(apply-checks-to-functions))
  ; try(sometd(apply-checks-to-navigate))
  
  access-control-weaving-after-template-expansion=
    try(sometd(apply-checks-to-forms))
  ; try(sometd(apply-checks-to-menu-headers-items))

  apply-checks-to-page:
    Define(modifier,ident,formargs,tempelement) -> Define(modifier,ident,formargs,newtempelement)
    where <elem> (Page(),modifier)
        ; checks := <generate-access-control-checks(|"page",ident,formargs,[],[])>
        ; if [] := checks then 
          e0 := False(){Type(SimpleSort("Bool"))}
        else
          e0 := checks
        end
        ; newtempelement2 := <concat> [tempelement , [InitAction(Block([IfNoElse(Not(e0),Block([ |[ goto(accessDenied()); ]| ]))]))]]
        ; previousrules := <once-Previous-Selected-Rules>
        ; previousname := <once-Previous-Decision-Name>
          // enforce access control on actions in page definitions
        ; newtempelement3 := <bottomup(try(apply-checks-to-action(|previousname,previousrules)))> newtempelement2
          // enforce access control on template calls in page definitions
        ; newtempelement4 := <bottomup(try(apply-checks-to-template-call(|previousname,previousrules)))> newtempelement3
          // enforce access control on forms in page definitions
        ; {| ActionDefinition,ActionArguments:
             <alltd(declare-action)> tempelement
           ; newtempelement := <try(sometd(apply-checks-to-form-submits(|previousname,previousrules)))> newtempelement4
           |}
        
  apply-checks-to-action(|previousname,previousrules):
    Action(ident,formargs,Block(statements)) -> Action(ident,formargs,Block(newstatements))
    where
         checks := <generate-access-control-checks(|"action",ident,formargs,previousname,previousrules)>
         ; if [] := checks then 
            e0 := False(){Type(SimpleSort("Bool"))}
          else
            e0 := checks
          end
         ; returnstat := <collect(?Return(_))> statements
         ; if returnstat := [] then returnstats := [|[ goto(accessDenied()); ]|] else  returnstats := [|[ return(accessDenied()); ]|] end
         ; newstatements := [If(e0,Block(statements),Block(returnstats))]

  apply-checks-to-template-call(|previousname,previousrules):
    tc@TemplateCall(ident, args, telems) -> result
    where
    if def := <TemplateDefinition> ident
    then
            (
            // this case can be removed, maybe make the distinction between template (call) explicit
            Define(modifier,dident,formargs,tempelement) := def

             // this is handled inside the definition now
             //; checks := <generate-access-control-checks(|"template",ident,formargs,previousname,previousrules)>
             )
          else
            checks := <generate-access-control-checks(|"template",ident,args,previousname,previousrules)>
          end
        ; if checks := []
          then
            result := tc
          else
            result := IfTempl(checks,[tc])
          end


  apply-checks-to-template-defs-actions:  //this is for template calls and actions inside template defs
    def@Define(modifier,ident,formargs,tempelement) -> Define(modifier,ident,formargs,result)
    where modifier := []
        ; checks := <generate-access-control-checks(|"template",ident,formargs,[],[])>
        ; if checks := []
          then
             (newtempelement0 := <bottomup(try(apply-checks-to-action(|[],[])))> tempelement
             ; newtempelement1 := <bottomup(try(apply-checks-to-template-call(|[],[])))> newtempelement0
               // enforce access control on forms in template definitions
             ; {| ActionDefinition,ActionArguments:
                  <alltd(declare-action)> tempelement
                ; newtempelement := <try(sometd(apply-checks-to-form-submits(|[],[])))> newtempelement1
                |}
             ; result := newtempelement
             )
          else
            (
              previousrules := <once-Previous-Selected-Rules>
              ; previousname := <once-Previous-Decision-Name>
              ; newtempelement0 := <bottomup(try(apply-checks-to-action(|previousname,previousrules)))> tempelement
              ; newtempelement1 := <bottomup(try(apply-checks-to-template-call(|previousname,previousrules)))> newtempelement0
                // enforce access control on forms in template definitions
              ; {| ActionDefinition,ActionArguments:
                   <alltd(declare-action)> tempelement
                 ; newtempelement := <try(sometd(apply-checks-to-form-submits(|previousname,previousrules)))> newtempelement1
                 |}
              ; result := [IfTempl(checks,newtempelement)]
            )
          end

  //ignore the defs inside pages
  apply-checks-to-template-defs-actions:
    Define(modifier,ident,formargs,tempelement) -> Define(modifier,ident,formargs,tempelement)
    where <elem> (Page(),modifier)
    
  apply-checks-to-functions:
    Function(ident,formargs,s,blck) -> Function(ident,formargs,s,newblck)
    where checks := <generate-access-control-checks(|"function",ident,formargs,[],[])>
        ; if [] := checks
          then
            newblck := blck
          else
            newblck := Block([If(checks,blck,Block(|[ goto(accessDenied());return null;]|))])
          end

  apply-checks-to-navigate:
    tc@TemplateCall("navigate",_,_) -> newtc
    where newtc := <wrap-in-iftempl-using-navigate-call(|tc)> tc
           
  wrap-in-iftempl-using-navigate-call(|navigatecall):
    tc -> newtc
    where TemplateCall("navigate",[ThisCall(p,args)],_) := navigatecall
        ; fargs := <TemplateArguments> p
        ; newtc := <wrap-in-iftempl(|p,args,fargs,"page",[],[])> tc
  
  apply-checks-to-menu-headers-items:
    tc@TemplateCall(tempname, [], elems) -> newtc
    where <?"menuheader" <+ ?"menuitem"> tempname
        ; checks := <collect(collect-template-call-checks(|["navigate"]))> elems
        ; newtc := IfTempl(<generate-disjunction-exp> checks,[tc]) // disjunction-exp fails on []
  
  apply-checks-to-forms:
    tc@TemplateCall("form", [], elems) -> newtc
    where checks := <collect(collect-template-call-checks(|["actionLink","action"]))> elems
        ; newtc := IfTempl(<generate-disjunction-exp> checks,[tc]) // disjunction-exp fails on []
        
  collect-template-call-checks(|tempnames)=
    \ fa@ForAll(x, SimpleSort(s), filt, elems) -> InColl(True(){Type(SimpleSort("Bool"))}, ForExp(thecheck,x,SimpleSort(s),thequery,filt)){Type(SimpleSort("Bool"))}
      where thecheck := <generate-disjunction-exp> <collect(collect-template-call-checks(|tempnames))> elems
          ; selectField := <newname> "queryVar"
          ; thequery := Cast(HqlQuery(QueryRule(SelectFrom(Some(Select(None(),[AliasedExpression(Path([selectField]),None())])),FromClause([FromRangeJoin(FromClass(Path([s]),Some(AsAlias(Alias(selectField))),None()),None())])),None(),None(),None()))
                            ,GenericSort("List",[SimpleSort(s)]))\
    <+ \ fr@For(x, s, e, filt, elems) -> InColl(True(){Type(SimpleSort("Bool"))}, ForExp(thecheck,x,s,e,filt)){Type(SimpleSort("Bool"))}
         where thecheck := <generate-disjunction-exp> <collect(collect-template-call-checks(|tempnames))> elems \
    <+ \ IfTempl(check,[TemplateCall(tname,_,_)]) -> check where <elem>(tname,tempnames) \
        
  apply-checks-to-form-submits(|previousname,previousrules)=
    apply-checks-to-actionLink(|previousname,previousrules)
    <+ apply-checks-to-action(|previousname,previousrules)
             
  apply-checks-to-actionLink(|previousname,previousrules):
    tc@TemplateCall("actionLink",[_,thiscall@ThisCall(p,args)],_) -> newtc
    where newtc := <wrap-in-iftempl-using-action-call(|thiscall,previousname,previousrules)> tc
    
  apply-checks-to-action(|previousname,previousrules):
    tc@TemplateCall("action",listoftempelems,_) -> newtc
    where thiscall@ThisCall(p,args) := <index> (2,listoftempelems) //can be list of 2 or 3, but the ThisCall is the 2nd element
        ; newtc := <wrap-in-iftempl-using-action-call(|thiscall,previousname,previousrules)> tc
        ; <not(is-cancel-action)> thiscall 
        
  wrap-in-iftempl-using-action-call(|actioncall,previousname,previousrules):
    tc -> newtc
    where ThisCall(p,args) := actioncall
        ; fargs := <ActionArguments> p
        ; newtc := <wrap-in-iftempl(|p,args,fargs,"action",previousname,previousrules)> tc

  wrap-in-iftempl(|ident,args,fargs,checktype,previousname,previousrules):
    tc -> newtc
    where argsorts := <map(\ Arg(ident,thesort) -> thesort \)> fargs
        ; matchingargs := <zip(\ (anexpr,thesort) -> Arg(anexpr,thesort) \)> (args,argsorts) // make suitable for checks strategy
        ; checks := <generate-access-control-checks(|checktype,ident,matchingargs,previousname,previousrules)>
        ; if [] := checks
          then
            newtc := [] //IfTempl(False(){Type(SimpleSort("Bool"))},[tc])
          else
            if True() := checks // don't generate overhead
            then
              newtc := tc
            else
              newtc := IfTempl(checks,[tc])
            end
          end