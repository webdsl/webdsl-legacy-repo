/**

 Security rules for WebDSL

*/

module org/webdsl/dsl/transformation/access-control-weaving

imports
  libstrategolib

imports
  org/webdsl/dsl/syntax/WebDSL
  org/webdsl/dsl/transformation/-
rules

  access-control-weaving=
    try(sometd(apply-checks-to-page))
  ; try(sometd(apply-checks-to-template-defs-actions))
  ; try(sometd(apply-checks-to-functions))
  ; try(sometd(apply-checks-to-menu))



  apply-checks-to-page:
    Define(modifier,ident,formargs,tempelement) -> Define(modifier,ident,formargs,newtempelement)
    where <elem> (Page(),modifier)
        ; checks := <generate-access-control-checks(|"page",ident,formargs,[],[])>
        ; if [] := checks then 
          e0 := False(){Type(SimpleSort("Bool"))}
        else
          e0 := checks
        end
        ; newtempelement2 := <concat> [tempelement , [InitAction(Block([IfNoElse(Not(e0),Block([ |[ goto(accessDenied()); ]| ]))]))]]
        ; previousrules := <once-Previous-Selected-Rules>
        ; previousname := <once-Previous-Decision-Name>
        ; newtempelement3 := <bottomup(try(apply-checks-to-action(|previousname,previousrules)))> newtempelement2
        ; newtempelement := <bottomup(try(apply-checks-to-template-call(|previousname,previousrules)))> newtempelement3

  apply-checks-to-action(|previousname,previousrules):
    Action(ident,formargs,Block(statements)) -> Action(ident,formargs,Block(newstatements))
    where
         checks := <generate-access-control-checks(|"action",ident,formargs,previousname,previousrules)>
         ; if [] := checks then 
            e0 := False(){Type(SimpleSort("Bool"))}
          else
            e0 := checks
          end
         ; returnstat := <collect(?Return(_))> statements
         ; if returnstat := [] then returnstats := [|[ goto(accessDenied()); ]|] else  returnstats := [|[ return(accessDenied()); ]|] end
         ; newstatements := [If(e0,Block(statements),Block(returnstats))]

  apply-checks-to-template-call(|previousname,previousrules):
    tc@TemplateCall(ident, args, telems) -> result
    where
    if def := <TemplateDefinition> ident
    then
            (
            // this case can be removed, maybe make the distinction between template (call) explicit
            Define(modifier,dident,formargs,tempelement) := def

             // this is handled inside the definition now
             //; checks := <generate-access-control-checks(|"template",ident,formargs,previousname,previousrules)>
             )
          else
            checks := <generate-access-control-checks(|"template",ident,args,previousname,previousrules)>
          end
        ; if checks := []
          then
            result := tc
          else
            result := IfTempl(checks,[tc])
          end


  apply-checks-to-template-defs-actions:  //this is for template calls and actions inside template defs
    def@Define(modifier,ident,formargs,tempelement) -> Define(modifier,ident,formargs,result)
    where modifier := []
        ; checks := <generate-access-control-checks(|"template",ident,formargs,[],[])>
        ; if checks := []
          then
             (newtempelement0 := <bottomup(try(apply-checks-to-action(|[],[])))> tempelement
             ; newtempelement := <bottomup(try(apply-checks-to-template-call(|[],[])))> newtempelement0
             )
          else
            (
              previousrules := <once-Previous-Selected-Rules>
              ; previousname := <once-Previous-Decision-Name>
              ; newtempelement0 := <bottomup(try(apply-checks-to-action(|previousname,previousrules)))> tempelement
              ; newtempelement := <bottomup(try(apply-checks-to-template-call(|previousname,previousrules)))> newtempelement0
            )
          end
        ; if checks := []
          then
            result := newtempelement
          else
            result := [IfTempl(checks,newtempelement)]
          end

  //ignore the defs inside pages
  apply-checks-to-template-defs-actions:
    Define(modifier,ident,formargs,tempelement) -> Define(modifier,ident,formargs,tempelement)
    where <elem> (Page(),modifier)
    
  apply-checks-to-functions:
    Function(ident,formargs,s,blck) -> Function(ident,formargs,s,newblck)
    where checks := <generate-access-control-checks(|"function",ident,formargs,[],[])>
        ; if [] := checks
          then
            newblck := blck
          else
            newblck := Block([If(checks,blck,Block(|[ goto(accessDenied());return null;]|))])
          end
          
  apply-checks-to-menu:
    tc@TemplateCall(tempname, [], elems) -> newtc
    where <?"menuheader" <+ ?"menuitem"> tempname
        ; navigationlinks := <collect(?TemplateCall("navigate",_,_))> elems
          // only taking into account first navigate element (should be only one)
        ; nav := <?[x|xs];!x> navigationlinks
        ; TemplateCall("navigate",[ThisCall(p,args)],_) := nav
        ; fargs := <TemplateArguments> p
        ; argsorts := <map(\ Arg(ident,thesort) -> thesort \)> fargs
        ; matchingargs := <zip(\ (Var(ident),thesort) -> Arg(ident,thesort) \)> (args,argsorts)
        ; checks := <generate-access-control-checks(|"page",p,matchingargs,[],[])>
        ; if [] := checks
          then
            newtc := IfTempl(False(),[tc])
          else
            newtc := IfTempl(checks,[tc])
          end