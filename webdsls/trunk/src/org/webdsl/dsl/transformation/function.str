module org/webdsl/dsl/transformation/function

imports
  libstrategolib
  Java-15
  libjava-front

imports
  libwebdsl-front

signature
  constructors
    EntityClass : String * List(EntityClass) -> Entity

rules

  aggregate-and-combine-functions =
    ?app@Application(qid, sections)
    ; hierarchy := <build-entity-hierarchy> "Object"
    ; <alltd(find-entity-functions)> app
    ; entityglobalfuncs := <collect(build-global-functions);concat> hierarchy
    ; globalfuncs := <collect( \ Section(_,defs) -> <filter(?Function(_, _, _, _))> defs\) ;concat> sections
    //; info(|["List: ", <collect-hierarchy-tree> hierarchy])
    //; <order-functions(|<collect-hierarchy-tree> hierarchy)> globalfuncs
    //; (_, newglobalfuncs) := <merge-functions> (globalfuncs, globalfuncs)
    ; rules ( AllGlobalFunctions := <concat> [globalfuncs, entityglobalfuncs] )
    ; !Application(qid, sections)


  /**
   * This rule desugars entities with functions into entities without functions, the functions
   * are translated to global functions and later injected back into the code
   */
  find-entity-functions :
    Entity(x, s, prop*, [f|r]) -> Entity(x, s, prop*, r)
    where f2 := <topdown(try(\ "this" -> "this"{} \));procedure-rename-var(|"this", "this0")> f
        ; f3 := <entity-function-as-global(|x)> f2
        ; rules ( EntityFunction :+ x -> f3 )

  find-entity-functions :
    EntityNoSuper(x, prop*, [f|r]) -> EntityNoSuper(x, prop*, r)
    where f2 := <topdown(try(\ "this" -> "this"{} \));procedure-rename-var(|"this", "this0")> f
        ; f3 := <entity-function-as-global(|x)> f2
        ; rules ( EntityFunction :+ x -> f3 )

  entity-function-as-global(|x_class) :
    Function(nm, args, rt, body) -> Function(nm, [Arg("this0", SimpleSort(x_class))|args], rt, body)

rules
  build-entity-hierarchy :
    x_class -> EntityClass(x_class, <map(build-entity-hierarchy)> subentities)
    where subentities := <filter(where(x_class := <Extends>))> <bagof-Entities>

  build-global-functions =
    ?EntityClass(nm, subclasses)
    ; entfunctions := <bagof-EntityFunction> nm
    ; ?[_|_]
    ; order := <collect-hierarchy-tree> EntityClass(nm, subclasses)
    ; morefuncs := <map(try(bagof-EntityFunction)); concat> order
    ; newfuncs := <order-functions(|order)> <concat> [entfunctions, morefuncs]
    ; (_, finalfuncs) := <merge-functions> (newfuncs, newfuncs)
    ; !finalfuncs

  collect-hierarchy-tree :
    EntityClass(nm, l*) -> lst
    where lst := <concat> [<map(collect-hierarchy-tree); concat> l*, [nm]]

  order-functions(|order) =
    where([] := order)

  order-functions(|order) =
    ?funcs
    ; [nm|rest] := order
    ; if f := <fetch-elem(?Function(_, [Arg(_, SimpleSort(nm))|_], _, _))> funcs then
        tail := <order-functions(|rest)> <remove-all(?f)> funcs
        ; ![f|tail]
      else
        !<order-functions(|rest)> funcs
      end

  merge-functions :
    ([], lst) -> ([], lst)

  merge-functions :
    ([f@Function(fun, args, rt, Block(stms))|rest], lst) -> <merge-functions> (rest, lst2)
    where argtypes := <map(\ Arg(_, srt) -> srt \)> args
        ; others := <filter(overloaded-function(|fun, argtypes); not(?f))> lst
        ; rest2 := <filter(not(overloaded-function(|fun, argtypes); not(?f)))> lst
        ; if not([] := others) then // Has more definitions
            if SimpleSort("Void") := rt then
              newproc := Function(fun, args, rt, Block(<map(fun-to-overload-stm)> <concat> [others, [f]]))
            else
              newproc := Function(fun, args, rt, Block(<concat> [<map(fun-to-overload-stm)> <concat> [others, [f]], [Return(<type-default-value> rt)]]))
            end
            ; lst3 := <diff> (lst, others)
            ; lst2 := <map(try(\ f -> newproc \))> lst3
          else
            lst2 := lst
          end
          
  fun-to-overload-stm :
    Function(_,args@[Arg(_, srt2)|rest],_,Block(stat*)) -> stm
    where e := <map(\ Arg(x, srt) -> exp|[ x is a srt ]| \); foldr(!exp|[ true ]|, exp-and)> args
        ; stat2* := <procedure-rename-var(|"this0", "this1")> stat*
        ; stm := <rename-all <+ debug> webdsl|[ if(e) { var this1 : srt2 := this0 as srt2; stat2* } else {} ]|

  overloaded-function(|fun, argtypes) :
    Function(fun2, args2, rt2, body) -> Function(fun2, args2, rt2, body)
    where argtypes2 := <map(\ Arg(_, srt) -> srt \)> args2
        ; fun := fun2
        ; <zip(type-compatible)> (argtypes, argtypes2)

rules

  desugar :
    Call(e, f, e*) -> ThisCall(f, [e|e*])
    where SimpleSort(s) := <type-of> e
        ; <IsFunction> (s, f)
