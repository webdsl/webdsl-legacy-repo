module org/webdsl/dsl/transformation/function

imports
  libstrategolib
  Java-15
  libjava-front

imports
  libwebdsl-front

signature
  constructors
    EntityClass : String * List(EntityClass) -> Entity

rules

  aggregate-and-combine-functions =
    ?app@Application(qid, sections)
    ; globalfuncs := <collect( \ Section(_,defs) -> <filter(?Function(_, _, _, _))> defs\) ;concat> sections
    ; hierarchy := <build-entity-hierarchy> "Object"
    ; info(|["List: ", <collect-hierarchy-tree> hierarchy])
    ; <debug> <order-functions(|<collect-hierarchy-tree> hierarchy)> globalfuncs
    ; (_, newglobalfuncs) := <merge-functions> (globalfuncs, globalfuncs)
    ; rules ( AllGlobalFunctions := globalfuncs )
    ; !Application(qid, sections)

  build-entity-hierarchy :
    x_class -> EntityClass(x_class, <map(build-entity-hierarchy)> subentities)
    where subentities := <filter(where(x_class := <Extends>))> <bagof-Entities>
        ; debug(!["All entities inheriting from ", x_class])
 
  collect-hierarchy-tree :
    EntityClass(nm, l*) -> lst
    where lst := <concat> [<map(collect-hierarchy-tree); concat> l*, [nm]]

  order-functions(|order) =
    where([] := order)

  order-functions(|order) =
    ?funcs
    ; [nm|rest] := order
    ; <debug> order
    ; f := <fetch(?Function(nm, _, _, _))> funcs
    ; ![f|<order-functions(|rest)> <remove-all(?f)> funcs]

  merge-functions :
    ([], lst) -> ([], lst)

  merge-functions :
    ([f@Function(fun, args, rt, Block(stms))|rest], lst) -> <merge-functions> (rest, lst2)
    where argtypes := <map(\ Arg(_, srt) -> srt \)> args
        ; others := <filter(overloaded-function(|fun, argtypes); not(?f))> lst
        ; rest2 := <filter(not(overloaded-function(|fun, argtypes); not(?f)))> lst
        ; if not([] := others) then // Has more definitions
            // @TODO what about Void functions, there should be no return then
            newproc := Function(fun, args, rt, Block(<concat> [<map(fun-to-overload-stm)> <concat> [others, [f]], [Return(<type-default-value> rt)]]))
            ; lst3 := <diff> (lst, others)
            ; lst2 := <map(try(\ f -> newproc \))> lst3
          else
            lst2 := lst
          end
          
  fun-to-overload-stm :
    Function(_,args,_,Block(stat*)) -> stm
    where e := <map(\ Arg(x, srt) -> exp|[ x is a srt ]| \); foldr(!exp|[ true ]|, exp-and)> args
        ; stm := webdsl|[ if(e) { stat* } else {} ]|

  overloaded-function(|fun, argtypes) :
    Function(fun2, args2, rt2, body) -> Function(fun2, args2, rt2, body)
    where argtypes2 := <map(\ Arg(_, srt) -> srt \)> args2
        ; fun := fun2
        ; <zip(type-compatible)> (argtypes, argtypes2)
