module org/webdsl/dsl/transformation/function

imports
  libstrategolib
  Java-15
  libjava-front

imports
  libwebdsl-front

signature
  constructors
    EntityClass : String * List(EntityClass) -> Entity

rules

  aggregate-and-combine-functions =
    ?app@Application(qid, sections)
    ; hierarchy := <build-entity-hierarchy> "Object"
    ; info(|"Let's combine some functions.")
    //; <alltd(find-entity-functions)> app
    ; entityfunctions := <collect(is-entity-function)> app
    ; rules ( EntityFunctions := entityfunctions )
    ; entityglobalfuncs := <collect(build-global-functions);concat> hierarchy
    ; globalfuncs := <collect(\ Section(_,defs) -> <filter(?Function(_, _, _, _); not(is-entity-function))> defs \) ;concat> sections
    //; info(|["List: ", <collect-hierarchy-tree> hierarchy])
    //; <order-functions(|<collect-hierarchy-tree> hierarchy)> globalfuncs
    //; (_, newglobalfuncs) := <merge-functions> (globalfuncs, globalfuncs)
    ; rules ( AllGlobalFunctions := <concat> [globalfuncs, entityglobalfuncs] )
    ; <debug(!"globalfuncs")> globalfuncs
    ; <debug(!"entityglobalfuncs")> entityglobalfuncs
    ; !Application(qid, sections)


  /**
   * This rule desugars entities with functions into entities without functions, the functions
   * are translated to global functions and later injected back into the code
   */
  desugar :
    Entity(x, s, prop*, [f|r]) -> Entity(x, s, prop*, r)
    with f2 := <topdown(try(\ "this" -> "this"{} \));procedure-rename-var(|"this", "this0")> f
       ; f3 := <entity-function-as-global(|x)> f2
       ; <emit-webdsl-code> f3
       //; rules ( EntityFunction :+ x -> f3 )

  desugar :
    EntityNoSuper(x, prop*, [f|r]) -> EntityNoSuper(x, prop*, r)
    where f2 := <topdown(try(\ "this" -> "this"{} \));procedure-rename-var(|"this", "this0")> f
        ; f3 := <entity-function-as-global(|x)> f2
        ; <emit-webdsl-code> f3
        //; rules ( EntityFunction :+ x -> f3 )

  entity-function-as-global(|x_class) :
    Function(nm, args, rt, body) -> Function(nm, [Arg("this0", SimpleSort(x_class))|args], rt, body)
    where info(|["nm: ", nm, "; args: ", args])

rules
  build-entity-hierarchy :
    x_class -> EntityClass(x_class, <map(build-entity-hierarchy)> subentities)
    where subentities := <filter(where(x_class := <Extends>))> <bagof-Entities>

  is-entity-function =
    ?Function(nm, [Arg(_, SimpleSort(srt))|_], _, _)
    ; where(<IsFunction> (srt, nm))

  build-global-functions =
    ?EntityClass(nm, subclasses)
    ; entfunctions := <EntityFunctions> nm
    ; ?[_|_]
    ; order := <collect-hierarchy-tree> EntityClass(nm, subclasses)
    ; morefuncs := <map(try(EntityFunctions)); concat> order
    ; newfuncs := <order-functions(|order)> <concat> [entfunctions, morefuncs]
    ; (_, finalfuncs) := <merge-functions> (newfuncs, newfuncs)
    ; !finalfuncs

  collect-hierarchy-tree :
    EntityClass(nm, l*) -> lst
    where lst := <concat> [<map(collect-hierarchy-tree); concat> l*, [nm]]

  order-functions(|order) =
    where([] := order)

  order-functions(|order) =
    ?funcs
    ; [nm|rest] := order
    ; if f := <fetch-elem(?Function(_, [Arg(_, SimpleSort(nm))|_], _, _))> funcs then
        tail := <order-functions(|rest)> <remove-all(?f)> funcs
        ; ![f|tail]
      else
        !<order-functions(|rest)> funcs
      end

  merge-functions :
    ([], lst) -> ([], lst)
  
  merge-functions :
    ([f@Function(fun, args, rt, Block(stms))|rest], lst) -> <merge-functions> (rest, lst2)
    where argtypes := <map(\ Arg(_, srt) -> srt \)> args
        ; others := <filter(overloaded-function(|fun, argtypes); not(?f))> lst
        ; if not([] := others) then // Has more definitions
            if SimpleSort("Void") := rt then
              newproc := Function(fun, args, rt, Block(<map(fun-to-overload-stm)> <concat> [others, [f]]))
            else
              newproc := Function(fun, args, rt, Block(<concat> [<map(fun-to-overload-stm)> <concat> [others, [f]], [Return(<type-default-value> rt)]]))
            end
            ; lst3 := <diff> (lst, others)
            //; rest2 := <filter(not(overloaded-function(|fun, argtypes); not(?f)))> lst
            //; info(|["Found double: ", fun, ": ", rest2])
            ; lst2 := <map(try(( f -> newproc )))> lst3
          else
            lst2 := lst
          end
          
  fun-to-overload-stm :
    Function(_,args@[Arg(_, srt2)|rest],_,Block(stat*)) -> stm
    where e := <map(\ Arg(x, srt) -> exp|[ x is a srt ]| \); foldr(!exp|[ true ]|, exp-and)> args
        ; stat2* := <procedure-rename-var(|"this0", "this1")> stat*
        ; stm := <rename-all <+ debug> webdsl|[ if(e) { var this1 : srt2 := this0 as srt2; stat2* } else {} ]|

  overloaded-function(|fun, argtypes) :
    f@Function(fun2, args2, rt2, body) -> f
    where argtypes2 := <map(\ Arg(_, srt) -> srt \)> args2
        ; fun := fun2
        ; <zip(type-compatible)> (argtypes, argtypes2)

rules

  desugar :
    Call(e, f, e*) -> ThisCall(f, [e|e*])
    where SimpleSort(s) := <type-of> e
        ; <is-function> (s, f)

rules // function stuff

   functions-to-el =
     where ( try(sometd(translate-template-expression))
           ; functions := <repeat(once-ConditionExpressions)> []
           ; rules ( AllTemplateFunctions := functions ) )

   create-template-function(|fn, e) =
     where ( {| Param, IgnoreVars
              : <alltd(find-params)> e
              ; params := <bagof-Param>
              |}
           ; expr-string := <concat-strings> [<ThisPage>, ".", fn, "(", <map(arg-to-el); separate-by(|","); concat-strings> params, ")"]
           ; el := <concat-strings> ["#{", expr-string, "}"]
           ; pn := <ThisPage>
           ; args := <ThisPageArguments>
           ; rules( ConditionExpressions :+ l -> [(pn, args, fn, params, e)|l]
                    ConditionExpressionToEL : (pn, e) -> el
                    ConditionExpressionToString : (pn, e) -> expr-string ) )

   translate-template-expression = // Store some context information
     ?Define(mods, name, args, body)
     ; where ( {| ThisPage, ThisPageArguments
                :  rules ( ThisPage := name
                           ThisPageArguments := args )
                ; <try(sometd(translate-template-expression))> body
                |} )

   translate-template-expression =
     ?IfTempl(e, elems1*)
     ; where ( fn := <newname> "ifCondFun"
             ; create-template-function(|fn, e)
             ; <try(sometd(translate-template-expression))> elems1* )

   // Do the same iffy thing for for-loops (for the "where" clause)
   translate-template-expression =
     ?For(x, s, e, Filter(we, obe), elem1*)
     ; where ( not(True() := we)
             ; fn := <newname> "forWhereCondFun"
             ; fn2 := <newname> "forInExprFun"
             ; create-template-function(|fn, we)
             ; create-template-function(|fn2, e)
             ; <try(sometd(translate-template-expression))> elem1* )

   translate-template-expression =
     ?For(x, s, e, Filter(True(), obe), elem1*)
     ; where ( fn := <newname> "forInExprFun"
               ; create-template-function(|fn, e)
               ; <try(sometd(translate-template-expression))> elem1* )

   translate-template-expression =
     ?ForAll(x, s, Filter(we, obe), elem1*)
     ; where ( not(True() := we)
               ; fn := <newname> "forAllWhereCondFun"
               ; create-template-function(|fn, we)
               ; elem2* := <try(sometd(translate-template-expression))> elem1* )

   translate-template-expression =
     ?TemplateCall("text", [arg], [])
     ; where ( not(<arg-to-value-string> arg) ; not(<elem-to-xhtml> arg) // Not a simple expression
             ; fn := <newname> "textExprFun"
             ; create-template-function(|fn, arg) )

   translate-template-expression =
     ?VarDeclInit(x, s, expr)
     ; where ( not(<IsPage> <ThisPage>)
             ; fn := <newname> "varDeclFun"
             ; create-template-function(|fn, expr) )

