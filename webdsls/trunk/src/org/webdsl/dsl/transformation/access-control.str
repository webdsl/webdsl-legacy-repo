/**

 Security rules for WebDSL
 
*/

module org/webdsl/dsl/transformation/access-control

imports 
  libstrategolib 
  Java-15 
  libjava-front 
  
imports 
  org/webdsl/dsl/syntax/WebDSL
  
rules
  process-security=
    desugar-security
    ; declare-security
    ; typecheck-security  
    ; generate-security
    ; if AccessControlEnabled then
    ( try(sometd(apply-checks-to-page))  
    ; try(attach-decision-classes-to-application)
    ; add-access-denied-page
    )
    end

    
  add-access-denied-page:
    Application(qid, sections) -> Application(qid, <concat>[sections, deniedpage])
    where deniedpage := 
      [ |[ section access denied page. 			    
                define page accessDenied()
			    {
			      title("Access Denied")
			      text("Access Denied")
			    } 
	    ]| 
	  ]
     
  generate-security:
  	Application(qid, sections) -> Application(qid, <concat>[ <collect(generate-security-defs);concat> sections, <map(try(remove-security-decs))>sections] )

  remove-security-decs:
    Module(ident,defs) -> Module(ident,<map(try(remove-security-decs))>defs)

  remove-security-decs:
    Section(ident,defs) -> Section(ident,<filter(not(?AccessControlDefinition(_)))>defs)

  generate-security-defs:
	AccessControlDefinition(defs) -> 
		<collect(security-subject
					<+ create-rule-classes
				)
				> defs
	where rules (
	  AccessControlEnabled := True()
	)

  // there can be only one of these (not yet checked)
  security-subject:
	AccessControlPrincipal($ident,props) -> 
			|[ 	
				section generated security.
				
				session securityContext {
				  	loggedIn	:: Bool
				    principal   -> $ident
				}
			  
			  	entity AccessControlRule
				{
					name :: String
					decisions -> Set<AccessControlDecision>
					checks -> Set<AccessControlCheck>
			    }
				
				entity AccessControlCheck
				{
					description :: String
					results -> Set<AccessControlCheckResult>
					rule -> AccessControlRule (inverse=AccessControlRule.checks)
				}
				
				entity AccessControlCheckResult
				{
					check -> AccessControlCheck (inverse=AccessControlCheck.results)
					result :: Bool
					decision -> AccessControlDecision (inverse=AccessControlDecision.results)
				}
				 
				entity AccessControlDecision{
					rule -> AccessControlRule (inverse=AccessControlRule.decisions)
					endResult :: Bool
					principal -> $ident
					time :: Date
					results -> Set<AccessControlCheckResult>
				}
				
				/*
                define page login()
				{
                  var subject : $ident := $ident{};
				
                  form { 
                  table {
                    elem0*
                    row{ "username: " input(subject.username) }
				    row{ "password: " input(subject.password) }
				         
				  }
				  action("login", login())
				  action login() {
				      
				    var subjects : List<$ident> :=
				    select s from $ident as s 
				    where (s._username = ~subject.username) and (s._password = ~subject.password);
				          	
				    for sub : $ident in subjects do
				    securityContext.subject:=sub;
				    securityContext.loggedIn:=true;
				    end
				            
				  }
				          
				  action("logout", logout())
				  action logout() {
				    securityContext.loggedIn:=false;
				  }
				  }
			    }*/
			]|
			//where elem0* := <map(property-to-input-row)> props
 
  //property-to-input-row:
    //PropertyNoAnno($ident,kind,xsort) -> elem|[ row{ "$ident: " input(subject.$ident) } ]|

  create-rule-classes:
    st@AccessControlRule(checktype,matchstring,fargs,checks,acrules) -> []
    			/*|[ 	
				section generated rule entities $random.
			  	def0*
			]|*/
	where //$random := <new>
	   def0* := <create-rule-classes-helper> st
			
  create-rule-classes-helper:
	st@AccessControlRule(checktype,matchstring,fargs,checks,acrules) -> <fail>
			/*<concat>[
			[def|[ 		  
			  	globals { 
			  		var $varname : AccessControlRule := AccessControlRule
					{
						
					};	
				}
			]|]
			,
			  <filter(create-rule-classes-helper);concat> acrules
			]*/
	where //$varname := <concat-strings> ["ACRule",checktype,<remove-wildcards>matchstring]
	    
		 newlistfromtype :=  <concat> [<Security-Rules-List-From-Type <+ ![]> checktype , [st] ]
		; rules(
			Security-Rules-List-From-Type : checktype -> newlistfromtype
			//Security-Rule-Name : (checktype,matchstring) -> $varname
		)
		;<filter(create-rule-classes-helper);concat> acrules

  remove-wildcards=
  	explode-string;map(try(?'*';!'1'));implode-string
  	
  generate-access-control-checks(|checktype,name,vars,previousname,previousrules)=
    if previousname := []
    then
  	  possibleTargets := <Security-Rules-List-From-Type> checktype
  	else
  	  possibleTargets := <filter(?AccessControlRule(checktype,_,_,_,_))> previousrules
  	end
  	; filteredrules := <filter(find-most-applicable-target-filter(|name,vars))> possibleTargets
  	; if filteredrules := [] 
  	  then
  	    pt := [AccessControlRule(checktype,"*",[],[AccessControlCheckExpression(False())],[])]
  	  else
  	    pt := filteredrules
  	  end 
  	; if previousname := []
  	then
  	 ( $decisionclassname := <concat-strings> ["ACDecision",checktype,name]
  	   ; $acrulename := <concat-strings> ["ACRule",checktype,name] )
  	else
  	 ( $decisionclassname := <concat-strings> ["ACDecision",previousname,checktype,name]
  	   ; $acrulename := <concat-strings> ["ACRule",previousname,checktype,name] )
  	end
  	; selectedchecks := <map(\AccessControlRule(_,_,_,checks,_) -> checks\);concat> pt
  	; selectedrules := <map(\AccessControlRule(_,_,_,_,acrules) -> acrules\);concat> pt
  	; rulecheckactions := <generate-security-checks-from-target(|$decisionclassname,vars,$acrulename)> selectedchecks
  	; otherclasses := <Generated-Decision-Classes <+ ![]>
  	; prop0* := <map(try(vars-to-props))> vars
  	; str0 := <double-quote> $acrulename
  	//; e0* := <add-indices;map(generate-listinits-from-check(|$acrulename))> selectedchecks
  	; def0* := <add-indices;map(generate-definition-from-check(|$acrulename))> selectedchecks
  	; rules (
		Generated-Decision-Classes := 
			<concat>[
				def* |[
				entity $decisionclassname : AccessControlDecision{	
					prop0*
				}  

				globals {
					var $acrulename : AccessControlRule := AccessControlRule { 
					  name:=str0
					  
					  //checks:= { e0* }
		        	};
			    }
			    
			    def0*
				]|
			, otherclasses ]
			
		Access-Control-Decision-Class: (checktype,name) -> $decisionclassname

		Previous-Selected-Rules := selectedrules
		Previous-Decision-Name := <concat-strings> [checktype,name]
  	
  	)
  	; !rulecheckactions

  generate-definition-from-check(|$rulename):
    (index,check) -> def|[ 
                        globals{
                          var $varname :AccessControlCheck := AccessControlCheck{ 
                          rule := $rulename
                          description := str0 }; 
                          
                        }
                     ]| 
   where $varname := <concat-strings> ["check",$rulename,<int-to-string> index]
   ; str0 := <pp-webdsl-to-string; double-quote; explode-string; filter(not(?'\n')); implode-string> check
   
 // generate-listinits-from-check(|rulename):
  //  (index,check)->  Var ( $varname )
  // where $varname := <concat-strings> ["check",rulename,<int-to-string> index]
            	
  vars-to-props:
	Arg($ident,$argsort) -> |[ $ident -> $classname]|
	where <defined-java-type> $argsort  
		; SimpleSort($classname) := $argsort	

  vars-to-props:
	Arg($ident,$argsort) -> |[ $ident :: $typename]|
	where <builtin-java-type> $argsort
	    ; SimpleSort($typename) := $argsort

  vars-to-props:
	Arg($ident,$argsort) -> |[ $ident -> $gentype<$thesort>]|
	where GenericSort($gentype,$thesort) := $argsort	
	    ; <defined-java-type> $thesort
		
  // only supports tail wildcards (*) so far
  find-most-applicable-target-filter(|name,vars):
	AccessControlRule(checktype,matchstring,fargs,checks,acrules) -> AccessControlRule(checktype,matchstring,fargs,newchecks,acrules)
	where 
	if not(matchstring := "*")
	then
	    (
		leftmatcher := <explode-string;reverse;drop-until(?'*');drop-while(?'*');reverse> matchstring
		; if leftmatcher := []
			then  
				(matchresulttemp := <left-match;implode-string> (<explode-string> name,<explode-string> matchstring)
				//still need to check whether it is precisely the name or something longer
				; if equal(|<explode-string;length> name, <explode-string;length> matchstring)
				  then matchresult := matchresulttemp
				  else matchresult := matchstring
				  end
				)
			else
				matchresult := <left-match;implode-string> (<explode-string> name,leftmatcher)
			end
		; not(matchresult := matchstring) //if equal, left-match failed
		)
	end
	//check arguments
	; newfargs := <?MatchArgs(args,wc);!args> fargs
	; getWC := <?MatchArgs(args,wc);!wc> fargs
	; if getWC := None() then
	  newvars := vars
	else
	  newvars := <take(<length> newfargs)> vars
	end
	; <zip(dynamic-rule-check-vars ; extract-sort-from-arg ; eq)> (newfargs,newvars)
	; newchecks := <map(try(fix-var-names-in-check))> checks

  dynamic-rule-check-vars:
    (Arg(ident1,thesort1),Arg(ident2,thesort2)) -> (Arg(ident1,thesort1),Arg(ident2,thesort2)) 
    where rules(
             FixVarsInCheck : Var(ident1) -> Var(ident2)
          )
   
  fix-var-names-in-check:
    AccessControlCheckExpression(expr) -> AccessControlCheckExpression(newexpr)
    where newexpr:= <try(alltd(FixVarsInCheck))> expr

  extract-sort-from-arg:
	(Arg(ident1,thesort1),Arg(ident2,thesort2)) -> (thesort1,thesort2) 
	 
  generate-security-checks-from-target(|$acdclassname,vars,$acrulename):
	xs ->
  		|[
  		    var acdecision : $acdclassname := $acdclassname{
  		      rule :=$acrulename
  		    };    
  			
  			if(securityContext.loggedIn) {
  			  acdecision.principal :=  securityContext.principal;
  			}
  			
  			stat2*
  			//stat0*
  			stat1*
  				
  			acdecision.endResult := e0 ;
  			acdecision.save();
  			if ( acdecision.endResult = false )
  			{
  			  goto(accessDenied());
  			}
  			
  		]|	
  	where //$rulename := <Security-Rule-Name> (checktype,matchstring)
  		numberedchecks := <add-indices> xs
  		//; stat0* := <map(generate-bool-var-decs)> numberedchecks
  		; stat1* := <map(generate-security-checks-from-target-element(|$acrulename));concat> numberedchecks
  		; stat2* := <map(generate-security-checks-from-target-var)> vars
  		; e0 := <map(fix-var-name-in-check);generate-final-exp> numberedchecks
 
  generate-final-exp : 
    [x|xs] ->  |[  $varname && e0  ]| 
    where ($varname,_) := x
        ; e0 := <generate-final-exp> xs 
  
  generate-final-exp :  
    [x] -> Var($varname)
    where ($varname,_) := x
 
  fix-var-name-in-check:
    (index,anything) -> (newindex,anything)
    where newindex := <concat-strings> ["check",<int-to-string> index]
 
  generate-security-checks-from-target-element(|rulename):
	(index,AccessControlCheckExpression(e0)) ->  |[ 
													var $varname : Bool := e0;
													 
													var $anyname : AccessControlCheckResult := AccessControlCheckResult{};
													$anyname.decision := acdecision;
													$anyname.result := $varname;
													$anyname.check := $varnamecheck;
													$anyname.save();
													//acdecision.results.add($anyname); //this shouldn't be necessary, fix needed in manytoone generation, owning side needs to add to the list when setdecision is called
												 ]|
	where $varname := <concat-strings> ["check",<int-to-string> index]
	    ; $varnamecheck := <concat-strings> ["check",rulename,<int-to-string> index]
	    ; $anyname := <newname> "accessControlCheckResult"
	
  generate-security-checks-from-target-var:
    Arg($ident,_) -> |[ acdecision.$ident := $ident; ]|
