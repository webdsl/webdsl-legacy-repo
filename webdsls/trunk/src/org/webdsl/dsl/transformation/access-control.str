/**

 Security rules for WebDSL
 
*/

module org/webdsl/dsl/transformation/access-control

imports 
  libstrategolib 
  Java-15 
  libjava-front 
  
imports 
  org/webdsl/dsl/syntax/WebDSL
  
rules
  process-security=
    desugar-security
    ; declare-security
    ; typecheck-security  
    ; generate-security 
    ; try(sometd(apply-checks-to-page))  
    ; try(attach-decision-classes-to-application)
    
  generate-security:
  	Application(qid, sections) -> Application(qid, <concat>[ <collect(generate-security-defs);concat> sections, <map(try(remove-security-decs))>sections] )

  remove-security-decs:
    Section(ident,defs) -> Section(ident,<filter(not(?AccessControlDefinition(_)))>defs)

  generate-security-defs:
	AccessControlDefinition(defs) -> 
		<collect(security-subject
					<+ create-rule-classes
				)
				> defs

  // there can be only one of these (not yet checked)
  security-subject:
	AccessControlPrincipal($ident,props) -> 
			|[ 	
				section generated security.
				
				session securityContext {
				  	loggedIn	:: Bool
				    subject     -> $ident
				}
			  
			  	entity AccessControlRule
				{
					info :: String
					//checks -> Set<AccessControlCheck>
			    }
				
				/*entity AccessControlCheck
				{
					info :: String
				}
				
				entity AccessControlCheckResult
				{
					check -> AccessControlCheck
					result :: Bool
				}*/
				 
				entity AccessControlDecision{
					//rule -> AccessControlRule
					endResult :: Bool
					subject -> User
					time :: Date
					//results -> Set<AccessControlCheckResult>
				}
				
				/*
                define page login()
				{
                  var subject : $ident := $ident{};
				
                  form { 
                  table {
                    elem0*
                    row{ "username: " input(subject.username) }
				    row{ "password: " input(subject.password) }
				         
				  }
				  action("login", login())
				  action login() {
				      
				    var subjects : List<$ident> :=
				    select s from $ident as s 
				    where (s._username = ~subject.username) and (s._password = ~subject.password);
				          	
				    for sub : $ident in subjects do
				    securityContext.subject:=sub;
				    securityContext.loggedIn:=true;
				    end
				            
				  }
				          
				  action("logout", logout())
				  action logout() {
				    securityContext.loggedIn:=false;
				  }
				  }
			    }*/
			]|
			//where elem0* := <map(property-to-input-row)> props
 
  //property-to-input-row:
    //PropertyNoAnno($ident,kind,xsort) -> elem|[ row{ "$ident: " input(subject.$ident) } ]|

  create-rule-classes:
    st@AccessControlRule(checktype,matchstring,fargs,checks,acrules) -> 
    			|[ 	
				section generated rule entities $random.
			  
			  	def0*
			]|
	where $random := <new>
	    ; def0* := <create-rule-classes-helper> st
			
  create-rule-classes-helper:
	st@AccessControlRule(checktype,matchstring,fargs,checks,acrules) -> 
			<concat>[
			[def|[ 	
			  
			  	globals { 
			  		var $varname : AccessControlRule := AccessControlRule
					{
						info := "checks get listed here"
					};
					
					
				}
			]|]
			,
			  <filter(create-rule-classes-helper);concat> acrules
			]
	where $varname := <concat-strings> ["ACRule",checktype,<remove-wildcards>matchstring]
		; newlistfromtype :=  <concat> [<Security-Rules-List-From-Type <+ ![]> checktype , [st] ]
		; rules(
			Security-Rules-List-From-Type : checktype -> newlistfromtype
			Security-Rule-Name : (checktype,matchstring) -> $varname
		)

  remove-wildcards=
  	explode-string;map(try(?'*';!'1'));implode-string
  	
  generate-access-control-checks(|checktype,name,vars,previousrules)=
    if target := []
    then
  	  possibleTargets := <Security-Rules-List-From-Type> checktype
  	else
  	  possibleTargets := <filter(?AccessControlRule(checktype,_,_,_,_))> previousrules
  	end
  	; pt := <filter(find-most-applicable-target-filter(|name,vars))> possibleTargets
  	; if pt := [] then fail end // TODO if no applicable rules found, deny access
  	; $decisionclassname := <concat-strings> ["ACDecision",checktype,name]
  	; selectedchecks := <map(extract-checks-from-rule);concat> pt
  	; selectedrules := <map(extract-rules-from-rule);concat> pt
  	; rulecheckactions := <generate-security-checks-from-target(|$decisionclassname,vars)> selectedchecks
  	; otherclasses := <Generated-Decision-Classes <+ ![]>
  	; prop0* := <map(try(vars-to-props))> vars
  	; rules (
		Generated-Decision-Classes := 
			<concat>[
				[def |[
				entity $decisionclassname : AccessControlDecision{
					
					prop0*
					
				}
				]|]
			
			, otherclasses ]
			
			
		Access-Control-Decision-Class: (checktype,name) -> $decisionclassname

		Previous-Selected-Rules := selectedrules
  	
  	)
  	; !rulecheckactions
 
  extract-checks-from-rule :
    AccessControlRule(_,_,_,checks,_) -> checks
     
  extract-rules-from-rule :
    AccessControlRule(_,_,_,_,acrules) -> acrules
       	
  vars-to-props:
	Arg($ident,$argsort) -> |[ $ident -> $classname]|
	where <defined-java-type> $argsort  
		; SimpleSort($classname) := $argsort	

  vars-to-props:
	Arg($ident,$argsort) -> |[ $ident :: $typename]|
	where <builtin-java-type> $argsort
	    ; SimpleSort($typename) := $argsort

  vars-to-props:
	Arg($ident,$argsort) -> |[ $ident -> $gentype<$thesort>]|
	where GenericSort($gentype,$thesort) := $argsort	
	    ; <defined-java-type> $thesort 	
		
  // only supports tail wildcards (*) so far
  find-most-applicable-target-filter(|name,vars):
	AccessControlRule(checktype,matchstring,fargs,checks,acrules) -> AccessControlRule(checktype,matchstring,fargs,newchecks,acrules)
	where leftmatcher := <explode-string;reverse;drop-until(?'*');drop-while(?'*');reverse> matchstring
	; if leftmatcher := []
		then  
			(matchresulttemp := <left-match;implode-string> (<explode-string> name,<explode-string> matchstring)
			//still need to check whether it is precisely the name or something longer
			; if equal(|<explode-string;length> name, <explode-string;length> matchstring)
			  then matchresult := matchresulttemp
			  else matchresult := matchstring
			  end
			)
		else
			matchresult := <left-match;implode-string> (<explode-string> name,leftmatcher)
		end
	; not(matchresult := matchstring) //if equal, left-match failed
	//check arguments
	; newfargs := <?MatchArgs(args,wc);!args> fargs
	; getWC := <?MatchArgs(args,wc);!wc> fargs
	; if getWC := None then
	  newvars := vars
	else
	  newvars := <take(<length> newfargs)> vars
	end
	; <zip(dynamic-rule-check-vars ; extract-sort-from-arg ; eq)> (newfargs,newvars)
	; newchecks := <map(try(fix-var-names-in-check))> checks

  dynamic-rule-check-vars:
    (Arg(ident1,thesort1),Arg(ident2,thesort2)) -> (Arg(ident1,thesort1),Arg(ident2,thesort2)) 
    where rules(
             FixVarsInCheck : Var(ident1) -> Var(ident2)
          )
   
  fix-var-names-in-check:
    AccessControlCheckExpression(expr) -> AccessControlCheckExpression(newexpr)
    where newexpr:= <try(alltd(FixVarsInCheck))> expr

  extract-sort-from-arg:
	(Arg(ident1,thesort1),Arg(ident2,thesort2)) -> (thesort1,thesort2) 
	 
  generate-security-checks-from-target(|$acdclassname,vars):
	xs ->
  		|[
  		    var acdecision : $acdclassname := $acdclassname{};    //{rule :=$rulename};
  			
  			if(securityContext.loggedIn) {
  			  acdecision.subject :=  securityContext.subject;
  			}
  			
  			stat2*
  			stat0*
  			stat1*
  				
  			acdecision.endResult := e0 ;
  			acdecision.save();
  			
  		]|	
  	where //$rulename := <Security-Rule-Name> (checktype,matchstring)
  		numberedchecks := <add-indices;map(fix-var-name-in-check)> xs
  		; stat0* := <map(generate-bool-var-decs)> numberedchecks
  		; stat1* := <map(generate-security-checks-from-target-element);concat> numberedchecks
  		; stat2* := <map(generate-security-checks-from-target-var)> vars
  		; e0 := <generate-final-exp> numberedchecks
 
  generate-final-exp : 
    [x|xs] ->  |[  $varname && e0  ]| 
    where ($varname,_) := x
        ; e0 := <generate-final-exp> xs 
  
  generate-final-exp :  
    [x] -> Var($varname)
    where ($varname,_) := x
   
  generate-bool-var-decs:
    ($varname,_) -> 	
    |[ 
	 	var $varname : Bool := false;
	]|
 
  fix-var-name-in-check:
    (index,anything) -> (newindex,anything)
    where newindex := <concat-strings> ["check",<int-to-string> index]
 
  generate-security-checks-from-target-element:
	($varname,AccessControlCheckExpression(e0)) -> [ |[ $varname := e0; ]| ]
	
  generate-security-checks-from-target-var:
    Arg($ident,_) -> |[ acdecision.$ident := $ident; ]|
