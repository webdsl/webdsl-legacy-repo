 module expressions 
 
 imports entities
 
 signature
  constructors
    Constructor    : ID -> Exp
    MethodCall     : Exp * ID * List(Exp) -> Exp
    PropertyAccess : Exp * ID -> Exp
    Var            : ID -> Exp
    StringLit      : STRING -> Exp

 rules // type-of
 
type-of : StringLit(x)              -> SimpleType("String")
type-of : Constructor(x)            -> SimpleType(x)
type-of : PropertyAccess(e, f)      -> <type-of; lookup-property(|f); type-of> e
type-of : PropertyAccess(e, "name") -> <type-of; lookup-name-property; type-of> e
type-of : MethodCall(e, f, e*)      -> <method-type> (<type-of>e, f, <map(type-of)> e*)

//method-type : (t1, x, t*) -> <type of method x applied to type t1 with arguments of type t*>

rules // checks

check :
  e1@PropertyAccess(e2, f) -> (f, $[[<pp>t] has no property '[f]])
  where t := <type-of> e2
  where not(<type-of>e1)

check :
  Constructor(x) -> (x, $[Constructor for undefined type '[x]'])
  where not(type-of; is-entity-type)
  
check :
  Constructor(x) -> (x, $[Cannot construct objects for non-entity types])
  where type-of
  where not(is-entity-type)

check :
  MethodCall(e, f, e*) -> (f, $[Method not defined])
  where not(type-of)
  


// cut here
rules // method type

method-type :
  (t, "save", []) -> SimpleType("Void")
  where <is-entity-type> t
  
method-type :
  (SimpleType("Int"), "inc", []) -> SimpleType("Int")
  
method-type :
  (SimpleType("Int"), "add", [SimpleType("Int")]) -> SimpleType("Int")
  
rules

hover-help : e -> <pp> t where t := <type-of> e

  
  