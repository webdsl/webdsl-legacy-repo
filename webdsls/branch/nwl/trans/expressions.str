 module expressions 
 
rules

  hover-help :
    e -> <pp> t
    where t := <type-of> e
 
 rules
 
   is-lvalue = 
     ?Var(_) <+ ?PropertyAccess(_, _)
 
 rules // string literals
 
   type-of :
     StringLit(x) -> SimpleType("String")
     
 rules // renaming and declaring (local) variables

  rename-var : 
     (x, t) -> y
     where y := x{<new>};
           rules(
             TypeOf   : y -> t 
             RenameId : x -> y
           )

  rename :
    Var(x) -> Var(y)
    where y := <RenameId> x

  type-of :
    Var(x) -> t
    where t := <TypeOf> x
    
  check :
    Var(x) -> (<id>, $[Variable '[x]' not declared])
    where not(type-of)

 rules // expressions
 
  type-of :
    PropertyAccess(e, f) -> t
    where t := <type-of; lookup-property-type(|f)> e
    
  type-of :
    PropertyAccess(e, "name") -> t
    where t := <type-of; lookup-name-property; type-of> e
          
  check :
    PropertyAccess(e, f) -> (<id>, $[[<pp>t] has no property '[f]])
    where not(type-of); t := <type-of> e
    
rules // constructors

  type-of :
    Constructor(x) -> SimpleType(x)
    
  check :
    Constructor(x) -> (x, $[Constructor for undefined type '[x]'])
    where not(type-of; is-entity-type)
    
  check :
    Constructor(x) -> (x, $[Cannot construct objects for primitive types])
    where type-of; is-primitive-type

rules // method calls

  type-of :
    MethodCall(e, f, e*) -> t
    where t := <method-type> (<type-of>e, f, <map(type-of)> e*)
    
  method-type :
    (t, "save", []) -> SimpleType("Void")
    where <is-entity-type> t
    
  method-type :
    (EntityType(x), "all", []) -> SetType(SimpleType(x))
    
  check :
    MethodCall(e, f, e*) -> (f, $[Method not defined])
    where not(type-of)