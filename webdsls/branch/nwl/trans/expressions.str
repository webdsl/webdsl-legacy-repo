 module expressions 

imports include/nwl
imports entities
imports properties
imports modules
imports utils

signature
  constructors
    BinOp : Exp * Op * Exp -> Exp
    
rules // desugaring
   
  desugar :
    Lt(e1, e2) -> BinOp(e1, "<", e2)

  desugar :
    Plus(e1, e2) -> BinOp(e1, "+", e2) 
    
rules // type-of
 
  type-of : 
    StringLit(x) -> SimpleType("String" )
    
  type-of : 
    IntLit(x) -> SimpleType("Int")
    
  type-of : 
    Constructor(x) -> SimpleType(x) 
    where <EntityDeclaration> x
    
  type-of : 
    PropertyAccess(e, f) -> <type-of; lookup-property(|f); type-of> e
    
  type-of : 
    PropertyAccess(e, "name") -> <type-of; lookup-name-property; type-of> e
    
  type-of :
     MethodCall(e, f, e*) -> <method-type> (<type-of>e, f, <map(type-of)> e*)

  //method-type : (t1, x, t*) -> <type of method x applied to type t1 with arguments of type t*>
  
  type-of :
    BinOp(e1, op, e2) -> t
    where t := <function-type> (op, [<type-of> e1, <type-of> e2])

rules // checks

  check :
    e1@PropertyAccess(e2, f) -> (f, $[[<pp>t] has no property '[f]])
    where t := <type-of> e2
    where require(<type-of>e1)

  check :
    Constructor(x) -> (x, $[Constructor for non-entity type '[x]'])
    where require(type-of)

  check :
    MethodCall(e, f, e*) -> (f, $[Method not defined])
    where require(type-of)
 
rules // method type
  
  method-type :
    (t, "save", []) -> SimpleType("Void")
    where <is-entity-type> t
  
  method-type :
    (SimpleType("Int"), "inc", []) -> SimpleType("Int")
 
  method-type :
    (SetType(t), "length", []) -> SimpleType("Int")
  
  method-type :
    (SimpleType("Int"), "add", [SimpleType("Int")]) -> SimpleType("Int")
    
rules // function types
  
  function-type :
    ("+", [SimpleType("Int"), SimpleType("Int")]) -> SimpleType("Int")
    
  function-type :
    ("<", [SimpleType("Int"), SimpleType("Int")]) -> SimpleType("Bool")
    
rules

  hover-help : 
    e -> <pp> t 
    where t := <type-of> e
  
  
