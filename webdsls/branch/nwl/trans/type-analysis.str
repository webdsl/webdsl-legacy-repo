module type-analysis

imports libstratego-aterm libstratego-gpp
imports include/nwl
imports pretty-print rename primitives

rules
  
  module-name : Module(x, d*) -> x
    
rules // property access
  
  type-of : 
    Var(x) -> t where t := <TypeOf> x
  
  type-of : 
    PropertyAccess(e, f) -> t2
    where t1 := <type-of> e
    where ent := <declaration-of> t1
    where Property(f, t2) := <lookup-property(|f)> ent

  lookup-property(|f) :  
    Entity(x, prop*) -> <fetch-elem(?Property(f,_))> prop*
         
  is-lvalue = ?Var(_) <+ ?PropertyAccess(_,_)
      
rules // types

  declaration-of : SimpleType(x) -> <EntityDeclaration> x
  is-entity-type = where(SimpleType(EntityDeclaration))
  is-simple-type = is-primitive-type <+ is-entity-type
   
//rules // declaring entities

  //name-of : Entity(x, prop*) -> x 
  //type-of : Entity(x, prop*) -> SimpleType(x)

rules // projections

  param-types =  is-list; map(?Param(_,<id>))
    
rules // projection
 
  is-page-def = ?TemplateDef([Page()],_,_,_)
    
  param-types    : TemplateDef(mod*, x, param*, elem*) -> <param-types> param*
  signature-of   : TemplateDef(mod*, x, param*, elem*) -> (x, <param-types>param*)

  declaration-of : TemplateDef(mod*, x, param*, elem*) -> <signature-of; Template>
  declaration-of : TemplateRef(x, e*) -> <Template> x
  declaration-of : PageRef(r) -> <declaration-of> r
  declaration-of : Navigate(ref, elems) -> <declaration-of> ref
  
  declaration-of :  Var(x) -> <VariableDeclaration> x

rules // projection

  is-primitive-template =  
    ?"input" <+ ?"output" <+ ?"form"

rules
  
  type-of : 
    MethodCall(e, f, e*) -> <method-type> (<type-of>e, f, <map(type-of)> e*)
      
  method-type : 
    (t, "save", []) -> SimpleType("Void")
    where <is-entity-type> t

