module parameters

 rules // renaming and declaring (local) variables

  rename-var : 
     (x, t) -> y
     with y := x{<new>};
           rules(
             TypeOf   : y -> t 
             RenameId : x -> y
           )
           
  declare-var(|x) :
    decl -> decl
    with rules( VariableDeclaration : x -> decl )
    
  rename :
    Var(x) -> Var(y)
    where y := <RenameId> x

  type-of :
    Var(x) -> t
    where t := <TypeOf> x
    
  declaration-of :
    Var(x) -> decl
    where decl := <VariableDeclaration> x
    
  check :
    Var(x) -> (<id>, $[Variable '[x]' not declared])
    where not(type-of)
    
rules // parameters

  param-types =
    is-list; map(?Param(_,<id>))
    
  rename : 
    Param(x, t) -> <declare-var(|y)> Param(y, t)
    with y := <rename-var>(x, t)
    
  check-args =
    !(<call-of>, <declaration-of>); 
    (check-arg-types <+ check-args-arity)
  
  check-arg-types :
    ((f, e*), def) -> errors
    where errors := <zip; filter(check-arg); not(?[])> (e*, <param-types> def)
    
  check-arg :
    (e, t) -> (e, $[Argument of type '[<pp>t]' expected (not of type '[<pp>t2]')])
    where t2 := <type-of> e
    where not(<eq>(t, t2))
    
  check-args-arity :
    ((f, e*), def) -> [(f, $['[f]' expects [<int-to-string>l] arguments; [<int-to-string>k] provided])]
    with k := <length>e*
    with l := <param-types; length> def
    where not(<eq>(k, l))
    
    