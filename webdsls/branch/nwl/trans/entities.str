module entities

rules // declaring entities

  declare-entity:
    Entity(x, prop*) -> Entity(x, prop*)
    with ?ent; rules( GetEntity: x -> ent )
    
  declaration-of :
    SimpleType(x) -> <GetEntity> x
    
  is-entity-type =
    where(SimpleType(GetEntity))
    
  is-primitive-type =
     ?"String" <+ ?"Int" <+ ?"WikiText" <+ ?"Secret"
     
  is-string-type =
    ?SimpleType("String")
    
  name-of :
    Entity(x, prop*) -> x
    
rules // entity constraints

  constraint-warning :
    Entity(x, _) -> (x, "Entity names must start with a capital letter") 
    where not(<explode-string; Hd; is-upper> x)
      
  constraint-error :
    Entity(x, prop*) -> (x, ["Entity ", x, " defined more than once"])
    where ?ent; not(<GetEntity> x => ent)

  constraint-error :
    SimpleType(type) -> (type, ["Type ", type, " is not defined"])
    where not(<is-primitive-type <+ GetEntity> type)
    
  constraint-error :
    SetType(type) -> (t, ["Set should have entity type as argument"])
    where ?t; not(<is-entity-type> type)
    
rules // finding properties

  lookup-property(s) :
    Entity(x, prop*) -> <fetch-elem(s)> prop*
    
  lookup-property(s) :
    SimpleType(x) -> <declaration-of; lookup-property(s)>

  lookup-property(|name) =
    lookup-property(?Property(name,_,_))
    
  is-id-property   = 
    Property(id,id,Some(Annotations(fetch(?Id()))))
  is-name-property = 
    Property(id,id,Some(Annotations(fetch(?Name()))))
    
  lookup-id-property   = 
    lookup-property(is-id-property)
  lookup-name-property = 
    lookup-property(is-name-property)
   
  lookup-property-type(|name) = 
    lookup-property(|name); type-of
    
  type-of :
    Property(_, type, _) -> type
    
rules // entities: constraints

  constraint-error:
    Entity(x, prop*) -> errors
    where ?ent; errors := <filter(constraint-error-property(|ent))> prop*
    
  constraint-error-property(|ent) :
    Property(name, type, annos) -> (name, ["Property ", name, " defined more than once"])
    where not(<lookup-property-type(|name)>ent => type)
   
  constraint-error-property(|ent) :
    Property(name, type, annos) -> (annos, ["More than one property with annotation id"])
    where ?prop; is-id-property; not(<eq>(<lookup-id-property>ent,prop))
     
  constraint-error-property(|ent) :
    Property(name, type, annos) -> (annos, ["More than one property with annotation name"])
    where ?prop; is-name-property; not(<lookup-name-property>ent => prop)
 
  constraint-error-property(|ent) :
    Property(name, type, annos) -> (type, ["Name property should have type String"])
    where ?prop; is-name-property; not(<is-string-type>type)
    
  constraint-error-property(|ent) : 
     Property(name, type, annos) -> (annos, ["Multiple inverse annotations"])
     where <gt>(<filter(?Inverse(_)); length> annos, 1) 
    
  constraint-error-property(|ent) : 
     Property(name, type, annos) -> (anno, [type, " has no property ", f])
     where anno := <fetch(?Inverse(f))> annos;
           not(<lookup-property(|f)> type)
         
  // note: [foo "bla" ] causes stackoverflow in parser (missing comma)
   
  // name: type (inverse:name2) => type has property g of type E or Set<E>
  constraint-error-property(|ent) : 
     Property(name, type, annos) -> (anno, ["Type of ", type, ".", name2, " is not ", type', " or Set<", type', ">"])
     where anno := <fetch-elem(?Inverse(name2))> annos;
           not(<lookup-property(|name); type-of; try(?SetType(<id>)); declaration-of> type => ent);
           type' := <name-of> ent
