module entities

rules // declaring entities

  declare-entity:
    Entity(x, prop*) -> Entity(x, prop*)
    with ?ent; rules( GetEntity: x -> ent )
    
  declaration-of :
    SimpleType(x) -> <GetEntity; debug(!" = ")> x
    where debug(!"declaration-of: ")
    
  is-entity-type =
    where(SimpleType(GetEntity))
    
  is-primitive-type =
     ?"String" <+ ?"Int" <+ ?"WikiText" <+ ?"Secret"
     
  is-string-type =
    ?SimpleType("String")
    
  name-of :
    Entity(x, prop*) -> x
    
rules // entity constraints

  constraint-warning :
    Entity(x, _) -> (x, "Entity names must start with a capital letter")
    where not(<explode-string; Hd; is-upper> x)
      
  check :
    Entity(x, prop*) -> (x, ["Entity ", x, " defined more than once"])
    where ?ent; not(<GetEntity> x => ent)

  check :
    SimpleType(type) -> (type, ["Type ", type, " is not defined"])
    where not(<is-primitive-type <+ GetEntity> type)
    
  check :
    SetType(type) -> (t, ["Set should have entity type as argument"])
    where ?t; not(<is-entity-type> type)
    
rules // finding properties

  desugar : Property(x, t) -> Property(x, t, [])

  lookup-property(s) : Entity(x, prop*) -> <fetch-elem(s)> prop*
  lookup-property(s) : SimpleType(x) -> <declaration-of; lookup-property(s)>

  lookup-property(|name) = lookup-property(?Property(name,_,_))
    
  is-id-property   = Property(id,id,fetch(?Id()))
  is-name-property = Property(id,id,fetch(?Name()))
    
  lookup-id-property   = lookup-property(is-id-property)
  lookup-name-property = lookup-property(is-name-property)
   
  lookup-property-type(|name) = lookup-property(|name); type-of
    
  type-of : Property(_, type, _) -> type
    
rules // entities: constraints

  check:
    Entity(x, prop*) -> errors
    where ?ent; errors := <filter(check-property(|ent))> prop*
    
  check-property(|ent) :
    Property(name, type, annos) -> (name, ["Property ", name, " defined more than once"])
    where not(<lookup-property-type(|name)>ent => type)
   
  check-property(|ent) :
    Property(name, type, annos) -> (annos, ["More than one property with annotation id"])
    where ?prop; is-id-property; not(<eq>(<lookup-id-property>ent,prop))
     
  check-property(|ent) :
    Property(name, type, annos) -> (annos, ["More than one property with annotation name"])
    where ?prop; is-name-property; not(<lookup-name-property>ent => prop)
 
  check-property(|ent) :
    Property(name, type, annos) -> (type, ["Name property should have type String"])
    where ?prop; is-name-property; not(<is-string-type>type)
    
  check-property(|ent) : 
     Property(name, type, annos) -> (annos, ["Multiple inverse annotations"])
     where <gt>(<filter(?Inverse(_)); length> annos, 1)
    
  check-property(|ent) : 
     Property(name, type, annos) -> (anno, ["'", <pp>type, "' has no property '", f, "'"])
     where anno := <fetch(?Inverse(f))> annos;
           not(<lookup-property(|f)> type)
         
  // name: type (inverse:name2) => type has property g of type E or Set<E>
  check-property(|ent) : 
     Property(name, type, annos) -> (anno, ["Type of '", <pp>type, ".", name2, "' is not ", <pp>type', " or ", <pp>SetType(type')])
     where anno := <fetch-elem(?Inverse(name2))> annos;
           not(<lookup-property(|name2); type-of; try(?SetType(<id>)); declaration-of> type => ent);
           type' := SimpleType(<name-of>ent)

  pp : SimpleType(x) -> x
  pp : SetType(t) -> <concat-strings>[ "Set<", <pp> t, ">"]









