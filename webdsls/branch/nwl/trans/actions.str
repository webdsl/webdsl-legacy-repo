module actions

rules // actions

  declare-action :
    act1@Action(f, param*, stat*) -> act2
    where if <Action> f then
            g := f; act2 := act1
          else 
            g    := f{<newname>f};
            act2 := Action(g, param*, stat*);
            rules( RenameAction : f -> g )
          end;
          rules( Action : g -> act2 )
          
  rename :
    Action(f, param1*, stat1*) -> <declare-action> Action(f, param2*, stat2*)
    where {| RenameId 
           : param2* := <rename-all> param1*
           ; stat2* := <rename-all> stat1*
           |}
          
  rename :
    Submit(f, e1*, elem1*) -> Submit(g, e2*, elem2*)
    where g := <try(RenameAction)> f;
          e2* := <rename-all> e1*;
          elem2* := <rename-all> elem1*     
      
  declaration-of : 
    Action(f, param*, stat*) -> <Action> f
           
  param-types :
    Action(f, param*, stat*) -> <param-types> param*
    
  signature-of :
    Submit(f, e*, elem*) -> (f, <map(type-of)> e*)
    
  declaration-of :
    Submit(f, e*, elem*) -> <Action> f
    
rules
   
  check :
    elem@Submit(f, e*, elem*) -> (elem, $[Action '[f]' not defined])
    where not(<declaration-of> f)
    
  check :
    Submit(f, e*, elem*) -> <check-args>
    
rules // assignment

  check :
    Assign(e1, e2) -> (e1, ["Left-hand side of assignment should be variable or property access"])
    where not(<is-lvalue> e1)

  check :
    Assign(lval, e) -> (<id>, ["Type of lhs ('", <pp>t1, "') does not match type of rhs ('", <pp>t2, "')"])
    where t1 := <type-of>lval; t2 := <type-of> e; not(<eq>(t1, t2))

rules // return

  // no checks needed for return
  // should an action always have a return?
  // check for hidden return in action, i.e. shadowed by earlier return