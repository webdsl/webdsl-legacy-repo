module templates

rules // declare pages

  declare-template :
    TemplateDef(mod*, x, params, elems) -> TemplateDef(mod*, x, params, elems)
    where ?def; rules( Template : x -> def )
    
   rename :
     TemplateDef(mod*, x, param1*, elem1*) -> TemplateDef(mod*, x, param2*, elem2*)
     where {| RenameId
            : param2* := <rename-all> param1*
            ; elem2* := <rename-all> elem1*
           |}

   rename :
     Param(x, t) -> Param(y, t)
     where debug(!"rename: "); y := x{<new>}; debug(!"to: ");
           e := Id(y);
           rules(
             TypeOf : e -> t 
             Rename : Id(x) -> e
           )

  is-page-def =
    ?TemplateDef([Page()],_,_,_)
    
  template-of :
    Navigate(x, args, elems) -> <Template> x
    
rules // page elements

  check :
    Navigate(x, args, elems) -> (x, ["Navigation to non-existing page"])
    where not(<Template> x)
    
  check :
    Navigate(x, args, elems) -> (x, ["Navigation to (non-page) template definition"])
    where def := <Template> x;
          not(<is-page-def> def)
  
  // type of argument does not match declaration
