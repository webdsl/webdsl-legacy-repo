module templates

rules // template definitions

  declare-template :
    TemplateDef(mod*, x, params, elems) -> TemplateDef(mod*, x, params, elems)
    with ?def; rules( Template : x -> def )
             
  is-page-def =
    ?TemplateDef([Page()],_,_,_)
    
  param-types :
    TemplateDef(mod*, x, params, elems) -> <map(?Param(_,<id>))> params 
    
  rename :
    TemplateDef(mod*, x, param1*, elem1*) -> TemplateDef(mod*, x, param2*, elem2*)
    with {| RenameId
          : param2* := <rename-all> param1*
          ; elem2*  := <rename-all> elem1*
          |}
 
  rename : 
    Param(x, t) -> Param(y, t)
    with y := <rename-var>(x, t) 
     
rules // template variables

  rename :
    VarDeclElem(x, t, e1) -> VarDeclElem(y, t, e2)
    with e2 := <rename-all> e1; 
         y := <rename-var> (x, t)
         
  check :
    VarDeclElem(x, t, e) -> (e, ["Expression should have type '", <pp>t, "'"])
    where not(<type-of> e => t)
    
rules // template element iteration 
         
  rename :
    ForElem(x, t, e1, elem1*) -> ForElem(y, t, e2, elem2*)
    with e2 := <rename-all> e1;
          {| RenameId 
           : y := <rename-var>(x, t)
           ; elem2* := <rename-all> elem1*
           |}
           
  check :
    ForElem(x, t, e, elem*) -> (e, ["Should have type '", <pp>SetType(t), "'"])
    where not(<type-of> e => SetType(t))
    
rules // navigation

  template-of :
    Navigate(ref, elems) -> <template-of> ref
    
  template-of :
    PageRef(x, e*) -> <Template> x
      
  check :
    PageRef(x, e*) -> (x, ["Navigation to non-existing page"])
    where not(template-of)
 
  check :
    PageRef(x, e*) -> [(x, ["Navigation to (non-page) template definition"])]
    where not(template-of; is-page-def)
  
  check :
    PageRef(x, e*) -> [(e*, ["Page '", x, "' expects ", k, " arguments, not ", l])]
    where k := <template-of; param-types; length>;
          l := <length> e*;
          not(<eq>(k,l))
          
  check :
    PageRef(x, e*) -> errors 
    where t* := <template-of; param-types>; 
          errors := <zip(check-arg)> (e*, t*)

  check-arg :
    (e, t) -> (e, ["Type of argument should be '", <pp>t, "'"])
    where not(<type-of> e => t)

rules // Template calls

  desugar :
    CallArgs(x, e*) -> Call(x, e*, [])
    
  desugar :
    CallElems(x, elem*) -> Call(x, [], elem*)
    
  desugar :
    Call(x) -> Call(x, [], [])

  // check that argument of input is an lvalue (syntactic constraint gives bad error message)
  
  check :
    Call("input", [e], []) -> (e, ["Argument of input should be variable or property access"])
    where not(<is-lvalue> e)
  
rules

  // element composition validation
  // input should occur in form
  // listitem should occur in list
  
rules

  // calling tempaltes in pages ?
  
  // navigation is like a regular template call
  
  // navigate TemplateCall
  
  
    
