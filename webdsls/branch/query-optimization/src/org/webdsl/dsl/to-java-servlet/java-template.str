module org/webdsl/dsl/to-java-servlet/java-template

imports 
  libstrategolib 
  libwebdsl-front

imports
  org/webdsl/dsl/to-java-servlet/to-java-servlet

rules

  generate-java-servlet-template-partial =
    ? cbds
    //; where(not(ThisEmail)) also used for common parts in email
    ; with(
        pkgname    := <TemplatePackage>
      ; x_Page  := <ThisTemplateClassName>
      ; if <is-list> cbds then cbds* := cbds else cbds* := [cbds] end
      ; <emit-java-code-local>
          compilation-unit|[
            package pkgname;
            @Partial
            public class x_Page{
              ~*cbds*
            }
          ]|
      )


rules
    
  GenerateCodeJavaServlet =  
    where(not(ThisEmail)); generate-java-servlet-template; fail

  generate-java-servlet-template :
    def@def |[ define mod* x(farg*) req* { elem* } ]| ->
    <emit-java-code-local> compilation-unit|[
        package pkgname;
        
        import java.io.IOException;
        import java.io.PrintWriter;
        import java.util.HashMap;
        import java.util.Iterator;
        import java.util.Map;
        
        
        import javax.servlet.ServletException;
        import javax.servlet.http.HttpServletRequest;
        import javax.servlet.http.HttpServletResponse;
        import javax.servlet.http.HttpSession;
        
        import org.hibernate.Session;
        import org.apache.commons.lang.ArrayUtils;
        
        import utils.*;
        import org.webdsl.tools.Utils;
        import org.webdsl.lang.Environment;
        import org.webdsl.WebDSLEntity;
        
        import pkgname2.*;
        import pkgname3.*;

        @Partial
        @SuppressWarnings("all")
        public class x_Page extends TemplateServlet
        {
          protected void storeArguments(Object[] args) {
            bstm1*
            bstm2*
          } 
        
          @Partial
          protected void storeInputsInternal() {
          }
                 
          @Partial
          protected void validateInputsInternal() {
          }
          
          @Partial
          protected void initialize() {}
          
          @Partial
          protected void initSubmitActions(){}
          
          @Partial 
          protected void initActions() {}

          @Partial
          protected void initializeLocalVars() {}
          
          @Partial
          protected void initializeLocalVarsOnce() {}
          
          @Partial
          protected void handleActionsInternal() { }
          
          @Partial
          private void callTemplates() { }

          public void setPageArguments(String[] pa) {
            pageArguments = pa;
          }
          public String[] getPageArguments() {
            return pageArguments;
          }
         
          @Partial 
          protected void renderInternal(){ }
          
          public String getUniqueName() {
            return "~x";
          }
          
          public String getTemplateClassName(){
            return "~x_Page";
          }
          
          public String getStateEncodingOfArgument(){
            return e_argrepr;
          }
          
          public String debugStateEncodingAll(){
            return "TemplateClass: "+getTemplateClassName()+"\n"+
              "TemplateArgument: "+getStateEncodingOfArgument()+"\n"+
              "ContextString: "+getTemplateContext()+"\n"+
              "UniqueId: "+getUniqueId()+"\n";
          }
          
          public String getTemplateSignature(){
            return "~x_TemplateSig";
          }
          
          protected void tryWriteSpanOpen(PrintWriter outtemp){
            bstm_so*
          }
          protected void tryWriteSpanClose(PrintWriter outtemp){
            bstm_sc*
          }

          protected void putLocalDefinesInEnv(){
            bstm*
          }
          
          protected boolean isAjaxTemplate(){
            return e_isajaxtemplate;
          }
          
          protected String getElementsContext(){
            if(calledName==null){
            ~*<if <fetch(?TemplateDefineNameBeforeLifting(namebeforelift))> mod* 
               then !bstm* |[ return "~namebeforelift"; ]|
               else !bstm* |[ return "~x"; ]|
               end>
             }
             else{
               return calledName;
             }
          }
        }
      ]|
    with pkgname    := <TemplatePackage>
       ; pkgname2   := <DomainPackage>
       ; pkgname3   := <ActionPackage>
       ; x_Page  := <ThisTemplateClassName>
       ; x_TemplateName := <get-original-name> x
       ; x_TemplateSig := <concat-strings> [x_TemplateName,"(",<map(\Arg(nm,srt)->Arg(<get-original-name> nm,srt)\);pp-args> farg*,")"]
       ; if <fetch(?TemplateModSpan())> mod*; not(JavaThisPage) then //only add span to templates with 'span' modifier
            x_actualname := <newname> "name"
          ; x_uniquename := <newname> "uniqname"
          ; bstm_so* := bstm* |[ 
              if(ThreadLocalPage.get().templateSpans()){
                String x_actualname = "~x_TemplateName";
                String x_uniquename = "~x";
                if(ltas != null){
                  x_actualname = ltas.spanName;
                  x_uniquename = ltas.spanNameUnique;
                }
                outtemp.write("<span id=\""+ x_uniquename + "\" class=\"scopediv "); //@TODO this could generate duplicate ids in resulting html
                if(x_uniquename.equals(x_actualname)){
                   outtemp.write(x_uniquename);
                }
                else{
                   outtemp.write(x_uniquename +" "+ x_actualname);
                }
                outtemp.write("\">"); 
              }
            ]| 
          ; bstm_sc* := bstm* |[ 
              if(ThreadLocalPage.get().templateSpans()){
                outtemp.write("</span>"); 
              }
            ]|
          else
            bstm_so* := []
          ; bstm_sc* := []
          end
       ; bstm* := <local-defined-templates-to-hashmap> elem*
       ; bstm1* := <formal-arguments-to-store-statements> farg*
       ; bstm2* := <filter(formal-arguments-to-query-optimizations(|elem*)); flatten-list> farg*
       ; e_argrepr := <formal-action-args-to-state-enc> farg*
       ; if <fetch(AjaxTemplate)> mod* 
         then e_isajaxtemplate := java:expr |[ true ]|
         else e_isajaxtemplate := java:expr |[ false ]|
         end
       
rules
  
  local-defined-templates-to-hashmap :
    elem* -> result
    with  localtemplates := <collect(local-defined-templates-to-hashmap-helper)> elem*
        ; result := <map(add-template-binding); concat> localtemplates
                          
  local-defined-templates-to-hashmap-helper :
    def@webdsl|[ define mod* x(farg*)  req* { elem* } ]| -> (x,clsname)
    with  clsname := <get-template-class-name> def
    
  add-template-binding:        
    (x,xclass) -> bstm* |[ env.putTemplate(x_key, x_value); ]| 
    with  x_key := <concat-strings> ["\"",x,"\""]
        ; x_value := <concat-strings> [xclass,".class"]
  
  //local template redef
  local-defined-templates-to-hashmap-helper :
    def@LocalRedefine(mod*,x,farg*,y,extraArg*) -> (xWithOverloadRenaming,clsname, argwithref*, spanname1, spanname2)
    with  xWithOverloadRenaming := <generate-template-name-fargs> (x,farg*)
        ; ( <get-anno(?ExtraLocalDefineArgs(extraFormalArg*))> def <+ extraFormalArg* := [] )
        ; ( <?LocalRedefineArgs(eArg*)> extraArg* <+ eArg* := [] )
        ; ( <get-anno(?SpanNames(spanname1,spanname2))> def <+ spanname1 := ""; spanname2 := "")
        ; clsname := <generate-template-name-fargs; template-name-to-classname> (y,[farg*,extraFormalArg*])
        ; argwithref* := <handle-ref-arg> (extraFormalArg*,eArg*)

  add-template-binding:        
    (x,xclass,e_argswithref*, spanname1, spanname2) -> 
      bstm* |[ 
        env.putTemplate(x_key, x_value);
        Object[] x_array = { e_argswithref* };
        env.putExtraLocalTemplateArguments(x_key, new utils.LocalTemplateArguments(x_array,"~spanname1","~spanname2")); 
      ]| 
    with  x_key := <concat-strings> ["\"",x,"\""]
        ; x_value := <concat-strings> [xclass,".class"]
        ; x_array := <newname> "arg" //doesn't need to be globally unique, no issue for caching when using newname here

rules 
 
  formal-arguments-to-store-statements :
    farg* -> result
    where  result := <add-indices;filter({\(index,arg@farg|[ x : srt ]|) -> bstm|[ x = (x_arg) args[x_index]; ]|
                                            where x_index := <subti;int-to-string> (index,1)
                                                ; if <?Arg(_,RefSort(_))> arg 
                                                  then x_arg := "utils.RefArg"
                                                  else x_arg := <argument-java-servlet-type> arg end
                                          \})> farg* //variables are generated in java-template-vars


  formal-arguments-to-query-optimizations(|b) :
    Arg(x, srt){anno*} -> bstm_optimization*
    where <has-entity-anno> srt
        ; AtArguments() := <QueryOptimizationMode>
        ; not(SimpleSort("Entity") := srt)
        ; prefetch := <get-prefetch-for(|x)> b
    with bstm_optimization* := <get-batch-fetches-single(|x, srt) <+ ![]> prefetch

  formal-arguments-to-query-optimizations(|b) :
    Arg(x, srt){anno*} -> bstm_optimization*
    where <has-entity-anno> srt
        ; QueryOptimizationMode; (?GuidedBatch() <+ ?QueryOptimization() <+ ?QueryOptimizationNoJoins())
        ; not(SimpleSort("Entity") := srt)
        ; prefetch := <get-prefetch-for(|x)> b
        ; bstm_optimization* := <get-batch-fetches-single-simple(|x, srt) <+ ![]> prefetch

/*  formal-arguments-to-store-statements-with-optimization :
    farg* -> result
    where result2 := <filter({\ arg@Arg(x, srt){anno*} -> bstm* |[
																  bstm_criteria*
                                  bstm_criterias*
                              ]|
                             where <has-entity-anno> srt
                             ; <not(fetch-elem(?QueryOptimizations([], [], _, _)))> anno*
                             ; <fetch-elem(?QueryOptimizations(joinproperties, joinpropertiesgen, _, _))> anno*
                             ; <conc; flatten-list; length; not(?1)> (joinproperties, joinpropertiesgen) // If we only eagerly fetch one property then we might as well leave it to Hibernate to do it the lazy way
                             with
                             x_class := <java-type-name> srt
                             ; if <gt> (<length>joinproperties, 1)
                               then
                                e_allprops := <map(fieldaccess-to-fetchmode); string-list-to-java-servlet> joinproperties
                                ; x_set := <concat-strings; newname> [x, "Props"]
                                //; bstm_build* := <map(!(<repeat(oncetd(add-fake-entity-anno)); fieldaccess-to-condition>, <fieldaccess-to-fetchmode>); query-build-step(|x_set))> joinproperties
                                ; bstm_build* := <map(repeat(oncetd(add-fake-entity-anno))); build-query-next(|x_set,Var(x))> joinproperties
                                ; bstm_criteria* := bstm* |[
                                      if(x instanceof org.hibernate.proxy.HibernateProxy && ((org.hibernate.proxy.HibernateProxy)x).getHibernateLazyInitializer().isUninitialized()) {
                                        utils.QueryOptimization.prefetchProperties(
                                            ThreadLocalPage.get().getHibSession().createCriteria(x_class.class),
                                            ((org.hibernate.proxy.HibernateProxy)x).getHibernateLazyInitializer().getIdentifier(),
                                            e_allprops
                                          );
                                      }
                                      else if(x != null) {
                                        java.util.Set<String> x_set = new java.util.HashSet<String>();
                                        bstm_build*
                                        if(x_set.size() > 1) {
	                                        utils.QueryOptimization.prefetchProperties(
	                                            ThreadLocalPage.get().getHibSession().createCriteria(x_class.class),
	                                            x.getId(),
	                                            x_set
	                                          );
                                        }
                                      }
                                  ]|
                               else
                                 bstm_criteria* := []//<transform-opt-generic(|x, x_class) <+ ![]> (joinproperties, joinpropertiesgen)
                               end
                             ; bstm_criterias* := <filter(hibernate-extra-generic-criteria(hibernate-extra-generic-criteria-template-cond|expr|[ ThreadLocalPage.get().getHibSession() ]|))> joinpropertiesgen
                           \})> farg*
    ; result1 := <formal-arguments-to-store-statements> farg*
    ; result := <conc; flatten-list> (result1, result2)
*/    
/*transform-opt-special(|x, x_class):
  ([subjoin], [[genjoin]]) -> bstm |[ if(e_Cond) utils.QueryOptimization.prefetchProperties(ThreadLocalPage.get().getHibSession().createCriteria(x_class.class), x.getId(), e_props); ]|
  where subjoin := <collect(?subjoin)> genjoin
  with e_get := <repeat(oncetd(add-fake-entity-anno)); expression-to-java-servlet> subjoin
  ; e_props := <map(fieldaccess-to-query); string-list-to-java-servlet> [subjoin, genjoin]
*/
/*transform-opt-generic:
  lst@[head|tail] -> bstm |[ if(!org.hibernate.Hibernate.isInitialized(e_Col)) utils.QueryOptimization.prefetchProperties(ThreadLocalPage.get().getHibSession().createCriteria(x_class.class), e_owner.getId(), e_props); ]|
  where <gt>(<length> lst, 1)
  with FieldAccess(Cast(p, SimpleSort(srt)), f){anno*} := head
  ; x_class := <java-type-entity-name> srt 
  ; e_owner := <repeat(oncetd(add-fake-entity-anno)); expression-to-java-servlet> p
  ; root := FieldAccess(p, f){anno*}
  ; e_Col := <repeat(oncetd(add-fake-entity-anno)); expression-to-java-servlet> root
  ; e_props := <alltd(?p; !Var("owner")); map(fieldaccess-to-fetchmode); string-list-to-java-servlet> [root|tail]*/
/*
  hibernate-extra-generic-criteria-template-cond:
    (owner, e_owner, x_ownerclass, root) -> expr |[ e_Cond && !org.hibernate.Hibernate.isInitialized(e_Col) ]|
    where e_Cond := <hibernate-extra-generic-criteria-default-cond>
    ; e_Col := <repeat(oncetd(add-fake-entity-anno)); expression-to-java-servlet> root
      */
/*
fieldaccess-to-condition =
  ?fa@FieldAccess(p, f)
  ; e_fa := <expression-to-java-servlet> fa
  ; <fieldaccess-to-condition(|expr|[ !org.hibernate.Hibernate.isInitialized(e_fa)]|)> p

fieldaccess-to-condition(|e_prev) =
  ?fa@FieldAccess(p, f)
  ; e_fa := <expression-to-java-servlet> fa
  ; <fieldaccess-to-condition(|expr|[ !org.hibernate.Hibernate.isInitialized(e_fa) || e_prev ]|)> p

fieldaccess-to-condition(|e_prev) =
  ?Cast(p, SimpleSort(x_class))
  ; e_p := <expression-to-java-servlet> p
  ; <fieldaccess-to-condition(|expr|[ (e_p.instanceOf("~x_class") && (e_prev)) ]|)> p

fieldaccess-to-condition(|e_prev):
  Var(_) -> e_prev

query-build-step(|x_set) :
  (e_cond, prop) -> bstm  |[ if(e_cond) x_set.add("~prop"); ]|
*/
add-fake-entity-anno :
  type@SimpleSort(_) -> x
  where <has-no-anno(?EntityAnno(_,_,_))> type
  with x := <add-anno(|EntityAnno("", "", ""))> type
/*
build-query(|x_set) :
  (path@FieldAccess(p, x), subpaths) -> stm_out
  with e_Path := <expression-to-java-servlet> p
  ; stm_addall* := <map(fieldaccess-to-fetchmode; \ str -> stm |[ x_set.add("~str"); ]|\)> subpaths
  ; stm_buildsub* := <build-query-next(|x_set,path)> subpaths
  ; stm_out := <if-else-java-servlet> (expr |[ e_Path.is#x#Uninitialized() ]|, stm_addall*, stm_buildsub*)

if-else-java-servlet:
  (e_Cond, bstm_true*, bstm_false*) -> stm |[ if(e_Cond) stm_true else stm_false ]|
  where stm_true := <java-statement-from-list> bstm_true*
  ; stm_false := <java-statement-from-list> bstm_false*

if-else-java-servlet:
  (e_Cond, bstm_true*, []) -> stm |[ if(e_Cond) stm_true ]|
  where stm_true := <java-statement-from-list> bstm_true*

if-else-java-servlet:
  (e_Cond, [], bstm_false*) -> stm |[ if(!(e_Cond)) stm_false ]|
  where stm_false := <java-statement-from-list> bstm_false*

java-statement-from-list:
  bstm_block* -> stm |[ { bstm_block* } ]|
  where <gt>(<length>bstm_block*, 1)
  
java-statement-from-list:
  bstm_block* -> stm_single
  where [stm_single] := bstm_block*

build-query(|x_set) :
  (path@Cast(p, SimpleSort(x_class)), subpaths) -> stm |[ if(e_Path.instanceOf("~x_class")) stm_buildsub ]|
  with e_Path := <expression-to-java-servlet> p
  ; bstm_buildsub* := <build-query-next(|x_set,path)> subpaths
  where stm_buildsub := <java-statement-from-list> bstm_buildsub*
*//*
build-query-next(get-next|x_set) =
  ?paths
  ; collect(get-next)
  ; make-set
  ; map(get-sub-paths(|paths))

build-query-next(|x_set) = build-query-next(?FieldAccess(Var(_), _) <+ ?Cast(Var(_), _)|x_set)

build-query-next(|x_set,current) = build-query-next(?FieldAccess(current, _) <+ ?Cast(current, _)|x_set)
*/
/*
build-query-next(|x_set,current) =
  ?paths
  ; collect(?FieldAccess(current, _) <+ ?Cast(current, _))
  ; make-set
  ; map(get-sub-paths(|paths); build-query(|x_set))

get-sub-paths(|paths) :
  path -> (path, subpaths)
  with subpaths := <filter(where(collect(?path); ?[_]))> paths
*/