module org/webdsl/dsl/to-java-servlet/java-entity-main

imports
  libstrategolib
  libjava-front

imports
  libwebdsl-front
  org/webdsl/dsl/to-java-servlet/core-to-java-servlet

strategies
  entity-inverse-to-java-class = 
     where( get-entity-def; ?(x_class, entbodydecs) )
     ; <filter(collection-inverse-type-to-java-class(|x_class))> entbodydecs

rules

  collection-inverse-type-to-java-class(|x_entclass) :
    prop@Property(x_prop, k, s@GenericSort(x_coltyp, [y_srt@SimpleSort(y)]), annos) ->
    <map(emit-java-code-local)> [compilation-unit|[
			package pkgname;
			
			import org.hibernate.HibernateException;
			import org.hibernate.collection.PersistentCollection;
			import org.hibernate.engine.SessionImplementor;
			import org.hibernate.persister.collection.CollectionPersister;

			@SuppressWarnings("unchecked")
			public class x_entclass#x_prop#x_coltyp#Type extends utils.AbastractInverse#x_coltyp#Type {
			
			  @Override
			  public Object instantiate(int anticipatedSize) {
			    return new x_entclass#x_prop#x_coltyp(anticipatedSize < 1 ? 0 : anticipatedSize );
			  }
			
			  @Override
			  public PersistentCollection instantiate(SessionImplementor session, CollectionPersister persister) throws HibernateException {
			    return new x_entclass#x_prop#Persistent#x_coltyp(session);
			  }
			
			  @Override
			  public PersistentCollection wrap(SessionImplementor session, Object collection) {
			    if ( session.getEntityMode() == org.hibernate.EntityMode.DOM4J ) {
			      throw new IllegalStateException("dom4j not supported");
			    }
			    else {
			      return new x_entclass#x_prop#Persistent#x_coltyp( session, (java.util.x_coltyp) collection );
			    }
			  }
			}
    ]|,compilation-unit|[
      package pkgname;
      
      import org.hibernate.collection.Persistent#x_coltyp;
			import org.hibernate.engine.SessionImplementor;
			
			@SuppressWarnings({ "unchecked", "serial" })
			public class x_entclass#x_prop#Persistent#x_coltyp extends utils.AbstractPersistentInverse#x_coltyp {
			
			  public x_entclass#x_prop#Persistent#x_coltyp(SessionImplementor session) {
			    super(session);
			  }
			
			  public x_entclass#x_prop#Persistent#x_coltyp(SessionImplementor session, java.util.x_coltyp col) {
			    super(session, col);
			  }
			
			  @Override
        public utils.Owned#x_coltyp newOwned#x_coltyp#FromCollectionEntry(org.hibernate.engine.CollectionEntry entry) {
				  x_entclass owner = (x_entclass) utils.HibernateUtilConfigured.getSessionFactory().getCurrentSession().load(x_entclass.class, entry.getLoadedKey());
				  return new x_entclass#x_prop#x_coltyp(owner);
        }
			}
    ]|,compilation-unit|[
      package pkgname;
      
      @SuppressWarnings("unchecked")
      public class x_entclass#x_prop#x_coltyp extends utils.Owned#x_coltyp<t_y> {
			  public x_entclass#x_prop#x_coltyp() { super(); }
			  public x_entclass#x_prop#x_coltyp(int anticipatedSize) { super(anticipatedSize); }
			  public x_entclass#x_prop#x_coltyp(java.util.List<t_y> list) { super(list); }
			  public x_entclass#x_prop#x_coltyp(Object owner) { super(owner); }
			  public x_entclass#x_prop#x_coltyp(Object owner, int anticipatedSize) { super(owner, anticipatedSize); }
			  public x_entclass#x_prop#x_coltyp(Object owner, java.util.List<t_y> list) { super(owner, list); }

			  @Override
			  public boolean add(t_y item) {
			    //if(!beingSet) System.out.print("Inverse" + "~x_coltyp" + "::add");
          if(!updateInverse) {
            //System.out.println("(skip)");
            return super.add(item);
          }
			    else if(this.owner == null) {
			      //System.out.println("(owner == null)");
			      return super.add(item);
			    }
			    else if(item != null && !beingSet && updateInverse)
			    {
			      //try{throw new Exception();}catch(Exception a){a.printStackTrace();}
			      x_entclass owner = (x_entclass)this.owner;
			      owner.setChanged();
			      beingSet = true;
            t_y oldthing = new x_y(); // just for compatibility with generated code in bstm1*
			      boolean result = super.add(item);
            bstm1*
            bstm_addextension*
			      beingSet = false;
            //System.out.println("(inverse)");
			      return result;
			    }
			    //if(!beingSet) System.out.println("(default)");
			    return false;
			  }
			
        ~*<where("List":=x_coltyp)<+![]> class-body-dec* |[ 
        @Override
	      public t_y set(int index, t_y newitem) {
	        //if(!beingSet) System.out.print("Inverse" + "~x_coltyp" + "::set");
          if(!updateInverse) {
            //System.out.println("(skip)");
            return super.set(index, newitem);
          }
	        else if(this.owner == null) {
	          //System.out.println("(owner == null)");
	          return super.set(index, newitem);
	        }
	        else if(newitem != null && !beingSet && updateInverse && index >= 0 && index < size() ) {
	          beingSet = true;
	          x_entclass owner = (x_entclass)this.owner;
	          owner.setChanged();
	          
	          // hold old value
	          t_y olditem = get(index); 
	          t_y item = olditem;
	          
	          //update old value if necessary
	          if(!contains(item)){ // only remove if there are no longer any copies in this list
	            bstm0*
	            bstm_removeextension*
	          }
	          
	          // look at new value now
	          item = newitem;
	          
	          //add events
	          bstm1*
	          bstm_addextension*
	          
	          // the actual set
	          super.set(index,item);
	
	          beingSet = false;
	          //System.out.println("(inverse)");
	          return olditem;
	        }
	        //if(!beingSet) System.out.println("(default)");
	        return null;
	      }
      
        @Override
        public void add(int index, t_y item) {
          //if(!beingSet) System.out.print("Inverse" + "~x_coltyp" + "::addI");
          if(!updateInverse) {
            //System.out.println("(skip)");
            super.add(index, item);
          }
          else if(this.owner == null) {
            //System.out.println("(owner == null)");
            super.add(index, item);
          }
          else if(item != null && !beingSet)
          {
            //System.out.println("(inverse)");
            //try{throw new Exception();}catch(Exception a){a.printStackTrace();}
            x_entclass owner = (x_entclass)this.owner;
            owner.setChanged();
            beingSet = true;
            t_y oldthing = new x_y(); // just for compatibility with generated code in bstm1*
            super.add(index, item);
            bstm1*
            bstm_addextension*
            beingSet = false;
          }// else if(!beingSet) System.out.println("(default)");
        }

        @Override
	      public t_y remove(int index) {
	        //if(!beingSet) System.out.print("Inverse" + "~x_coltyp" + "::removeI");
          if(!updateInverse) {
            //System.out.println("(skip)");
            return super.remove(index);
          }
	        else if(this.owner == null) {
	          //System.out.println("(owner == null)");
            return super.remove(index);
          }
          else if(index >= 0 && index < size() && !beingSet && updateInverse) {
            //System.out.println("(inverse)");
	          beingSet = true;
	          x_entclass owner = (x_entclass)this.owner;
	          owner.setChanged();
	          
	          t_y item = super.remove(index);
	      
	          if(!contains(item)){ // only remove if there are no longer any copies (in case the collection allows duplicates, eg List)
	            bstm0*
	            bstm_removeextension*
	          }
	
	          beingSet = false;
	          return item;
          }
          //if(!beingSet) System.out.println("(default)");
          return null;
	      }
        ]|
      
			  @Override
			  public boolean remove(Object obj) {
			    //if(!beingSet) System.out.print("Inverse" + "~x_coltyp" + "::remove");
          if(!updateInverse) {
            //System.out.println("(skip)");
            return super.remove(obj);
          }
          else if(this.owner == null) {
            //System.out.println("(owner == null)");
            return super.remove(obj);
          }
			    else if(obj != null && !beingSet && updateInverse && obj instanceof x_y)
			    {
			      //System.out.println("(inverse)");
            x_y item = (x_y)obj;
			      x_entclass owner = (x_entclass)this.owner;
			      beingSet = true;
			      owner.setChanged();
			      boolean result = super.remove(item);
	          if(!contains(item)){ // only remove if there are no longer any copies (in case the collection allows duplicates, eg List)
	            bstm0*
	            bstm_removeextension*
	          }
			      beingSet = false;
			      return result;
			    }
			    //if(!beingSet) System.out.println("(default)");
			    return false;
			  }
      }
    ]|]
    where <fetch(?InverseSlaveAnno(_, _) <+ ?InverseAnno(_, _))> annos
    with pkgname := <DomainPackage>
        ; t_y       := <java-type> y_srt
        ; x_y       := <java-type-name> y_srt
        ; bstm0* := <association-update-statements(remove-bidirectional-reference(|"owner"))> annos
        ; bstm1* := <association-update-statements(add-bidirectional-reference(|"owner"))> annos
        ; bstm_addextension*    := <entity-bstm-property-events> (x_entclass,x_prop,y_srt,"addTo","item","owner")
        ; bstm_removeextension* := <entity-bstm-property-events> (x_entclass,x_prop,y_srt,"removeFrom","item","owner")

  inverse-collection-transform-list-to-genericset(|x_Class, prop, x_listvar) :
    GenericSort(_, [_]) -> |[ new x_ColType(this, x_listvar) ]|
    where x_ColType := <inverse-collection-java-type(|x_Class)> prop

  inverse-collection-default-value-override-java(|x_Class, prop) :
    GenericSort(_, [_]) -> |[ new x_ColType(this) ]|
    where x_ColType := <inverse-collection-java-type(|x_Class)> prop

  inverse-collection-java-type(|x_Class) :
    Property(x_prop, _, GenericSort(coll, [_]), annos) -> x_ColType
    where <?"Set" <+ ?"List"> coll
        ; <fetch(?InverseSlaveAnno(_, _) <+ ?InverseAnno(_, _))> annos
        ; x_ColType := <concat-strings> [<DomainPackage;pp-java5-to-string>,".",x_Class,<capitalize-string>x_prop,coll]
