module org/webdsl/dsl/utils/query-utils

signature constructors

  TemplateArgs : List(Annotation) -> Annotation
  TemplateName : Term -> Annotation
  FunctionArgs : List(Annotation) -> Annotation
  FunctionEntity : Term -> Annotation
  HasQueryOptimizedVersion : Annotation
  QueryOptimizationVars : Term * Term * Term * Term -> Annotation
  QueryOptimizations : Term * Term * Term -> Annotation
  QueryOptimizations : List(String) * Term * Term * Term * Term * Term -> Annotation
  IsNaturalId : Annotation
  MultipleDefinitionsInSubclasses : Annotation
  RequiresAlias : Annotation
  DeclaringEntity : Term -> Term
  IsLazyFetch : Term
  QueryAnalysis : Term * Term * Term * Term -> Term
  WaitingFor : Term -> Annotation

  // Query optimization modes
  // Used just to easily update other test cases
  NoQueryOptimization : Term
  QueryOptimization : Term
  HibernateBatch : Term
  GuidedBatch : Term
  AllJoins : Term
  AtArguments : Term

strategies

  get-empty-query-optimization = !QueryOptimizations([], [], True())     

  is-empty-query-optimization = ?QueryOptimizations([], [], True())

  is-query-optimization = ?QueryOptimizations(_, _, _)

  // Succeeds only if an empty query optimization annotation is present
  no-query-optimizations-strict = where(fetch-elem(is-empty-query-optimization))

  // Succeed if no query optimization is available
  no-query-optimizations = where(get-query-optimization-anno; is-empty-query-optimization)

  // Always returns a query optimization, but it returns an empty one if it fails to locate one
  get-query-optimization-anno = fetch-elem(is-query-optimization) <+ get-empty-query-optimization

  is-query-analysis = ?QueryAnalysis(_, _, _, _)

rules

  remove-casts = repeat(oncetd(?Cast(<id>, _)))

  and-query-condition = fold-query-condition(and-query-condition-helper)
  or-query-condition = fold-query-condition(or-query-condition-helper)

  fold-query-condition(s) :
    [] -> True()

  fold-query-condition(s) =
    ?[x|xs]
    ; <foldr(!x, s)> xs

  and-query-condition-helper :
    (cond, e) -> And(cond, e)

  or-query-condition-helper :
    (cond, e) -> Or(cond, e)

  property-to-string :
    Var(_) -> ""

  property-to-string :
    FieldAccess(p, f) -> str
    with prefix := <property-to-string> p
    ; if "" := prefix then
        str := <concat-strings> ["_", f]
      else
        str := <concat-strings> [prefix, "._", f]
      end

  property-to-string :
    Cast(p, _) -> str
    with str := <property-to-string> p

  property-to-alias :
    Var(_) -> ""

  property-to-alias :
    FieldAccess(p, f) -> str
    with prefix := <property-to-alias> p
    ; str := <concat-strings> [prefix, "__", f]

  property-to-alias :
    Cast(p, _) -> str
    with str := <property-to-alias> p

  condition-to-alias-string(|x) :
    FieldAccess(p, f) -> str
    where <collect(?Var(x)); not(?[])> p
    with str := <property-to-alias> p

strategies

  /*collect-potential-joins =
    collect(an-potential-joins)
    ; flatten-list

  collect-effectful-potential-joins =
    where(IsEffectful; ?False())
    ; rules( IsEffectful := True())
    ; collect(an-potential-joins)
    ; flatten-list
    ; rules( IsEffectful := False() )

  an-potential-joins =
    ?FieldAccess(l, _)
    ; oncetd(where(IteratedVar); not(IteratedVarValue))
    ; is-accessible-from(RootVar)
    ; !(<Fst>, <Snd>, <QueryConditions <+ !True()>, <IsEffectful>)

  an-potential-joins =
    ?fa@FieldAccess(l, _)
    ; repeat(oncetd(IteratedSubListValue <+ IteratedVarValue))
    ; not(?fa)
    ; is-accessible-from(RootVar)
    ; !(<Fst>, <Snd>, <QueryConditions <+ !True()>, <IsEffectful>)

  an-potential-joins =
    ?Var(_)
    ; repeat(oncetd(IteratedSubListValue <+ IteratedVarValue))
    ; is-accessible-from(RootVar)
    ; !(<Fst>, <Snd>, <QueryConditions <+ !True()>, <IsEffectful>)

    an-potential-joins =
    ?Call(e, nm, arg*){anno*}
    ; where(<is-accessible-from(IteratedVar <+ IteratedSubList); ?(e2, <is-entity-type; ?SimpleSort(ent)>)> e)
    ; genname := <generate-template-name-args> (<concat-strings>[ent, nm], arg*)
    ; where(not(<PassedFunction> genname)) // This prevents an infinite loop when following a recursive function
    ; (fent, Function(_, fargs, _, body)) := <try-resolve-entity-call> (ent, nm, <map(query-optimization-type-of)> arg*)
    // Here we get the properties of the entity and insert them as extra parameters for the function call
    // We also have to rename the Var("prop") to Var("prop"{Entity_myfunctionArg1Arg2}) to prevent creating a loop in IteratedVar or IteratedSubList
    ; thissafe := "this"{<concat-strings>[genname, "_this"]}
    ; {| RenamePropInFunction // Here we temporarily rename the Var()s in the function body for our analysis
        : (args, fargs2) := <get-all-entity-properties-for-rename(|genname); map({name,uniquename,safename,srt:\
                                (name, uniquename, safename, srt) -> (FieldAccess(e2, name), Arg(safename, srt))
                                where rules( RenamePropInFunction : Var(uniquename) -> Var(safename) )
                            \}); ![(e2, Arg(thissafe, SimpleSort(fent)))|<id>]; unzip> ent
        ; rules( RenamePropInFunction : Var("this") -> Var(thissafe) )
        ; body2 := <alltd(RenamePropInFunction)> body
      |}
    ; {| PassedFunction
       : rules( PassedFunction : genname )
       ; <an-potential-joins-with-args(|<conc>(args, arg*), <conc>(fargs2, fargs))> body2 // We add the properties of the entity as leading arguments of the function, this prevents them to be mistaken for local variables, which currently are ignored completely
       |}

  an-potential-joins =
    (?Call(_, _, _) <+ ?VarDeclInit(_, _, _) <+ ?VarDeclInitInferred(_, _) <+ ?Assignment(_, _) <+ ?PropertyAssignment(_, _) <+ ?PageCall(_, _) <+ ?ThisCall(_, _))
    ; collect-effectful-potential-joins

  an-potential-joins = // Skip actions (because they are only called after a postback) and local redefines (because they are already analyzed when called)
    (?Action(_, _, _, _) <+ ?LocalRedefine(_, _, _, _, _) <+ ?Define(_, _, _, _, _) <+ ?TemplateCase(_, _))
    ; ![]
*/
/*
  // If statements possibly contribute if they have only an if or else block
  an-potential-joins =
    (?IfNoElseTempl(condExp, trueBlock) <+ ?IfNoElse(condExp, trueBlock) <+ ?IfTempl(condExp, trueBlock, []) <+ ?If(condExp, trueBlock, []))
    ; newCondExp := <repeat(innermost-rep(desugar)); repeat(oncetd(IteratedVarValue)); extract-query-cond; where(not(?True()))> condExp 
    ; listC := <collect-potential-joins> condExp
    ; OldQueryCond := <QueryConditions>
    ; rules( QueryConditions := <append-condition>(newCondExp, OldQueryCond) )
    ; listT := <collect-potential-joins> trueBlock
    ; rules( QueryConditions := OldQueryCond )
    ; !<concat>[listC, listT]

  an-potential-joins =
    (?IfTempl(condExp, [], falseBlock) <+ ?If(condExp, [], falseBlock))
    ; newCondExp := Not(<repeat(innermost-rep(desugar)); repeat(oncetd(IteratedVarValue)); extract-query-cond; where(not(?True()))> condExp)
    ; listC := <collect-potential-joins> condExp
    ; OldQueryCond := <QueryConditions>
    ; rules( QueryConditions := <append-condition>(newCondExp, OldQueryCond) )
    ; listF := <collect-potential-joins> falseBlock
    ; rules( QueryConditions := OldQueryCond )
    ; !<concat>[listC, listF]

  define-local-redefine =
    ?LocalRedefine(mods, tname, fargs, tname2, extraArgs)
    ; fargsredef := <local-redefine-arg-types(|fargs,extraArgs)>
    ; LocalRedefineArgs(argsredef) := extraArgs
    ; gennameredef := <generate-template-name> (<strip-annos>tname2, fargsredef)
    ; gennamecall := <generate-template-name-fargs> (tname, fargs)
    ; rules (
        LocalRedefName: gennamecall -> gennameredef
        LocalRedefArgs: gennamecall -> argsredef
      )

  define-local-redefine =
    ?def@Define(mods, tname{tname2}, fargs, targs, elems1){anno*}
    ; where(is-local-template-def)
    ; where(<fetch(?EnclosingDefine(templatekey, encltemplatename, encltemplateargs, _))> anno*)
    ; where((argsredef,fargs2) := <get-args-fargs-from-closure-in-anno-filtered> (anno*,[elems1,<map(get-varname-from-formarg)>encltemplateargs]))
    ; fargsredef := <conc>(fargs, fargs2)
    ; gennameredef := <normalize-signature; generate-template-name> (tname, fargsredef)
    ; gennamecall := <generate-template-name-fargs> (tname, fargs)
    ; rules (
        LocalRedefDef: gennameredef -> Define(mods, tname{tname2}, fargsredef, targs, elems1){anno*} // Desugar has not been called on local redefine, so CurrentTemplateDecl will fail, we define a local version here 
        LocalRedefName: gennamecall -> gennameredef
        LocalRedefArgs: gennamecall -> argsredef
      )

  // Follow a template call
  an-potential-joins =
    (?TemplateCall(_, _, [tc@TemplateCall(name,args,_,TemplateBody([]))|_], TemplateBody([])) <+ ?tc@TemplateCallNoBody(name, args) <+ ?tc@TemplateCall(name, args, _, TemplateBody([])))
    ; not([] := <filter(is-accessible-from(IteratedVar <+ IteratedSubList); ?(_, <try-strip-generic-sort; is-entity-type>))> args)
    ; (genname, args2, def, redefined) := <get-local-template-redefine(|args)> tc
    ; <?Define(_, _, fargs, _, body)> def
    ; where(not(<PassedTemplate> genname)) // Prevents an infinite loop when following a recursive template
    ; {| PassedTemplate
       : rules( PassedTemplate : genname )
       ; <an-potential-joins-with-args(|args2, fargs)> body
       |}

  an-potential-joins = // If the above rule fails to lookup the template then we try to collect effectful joins from the call
    (?TemplateCall(_, _, [tc@TemplateCall(name,args,_,TemplateBody([]))|_], TemplateBody([])) <+ ?tc@TemplateCallNoBody(name, args) <+ ?tc@TemplateCall(name, args, _, TemplateBody([])))
    ; not([] := <filter(is-accessible-from(IteratedVar <+ IteratedSubList); ?(_, <try-strip-generic-sort; is-entity-type>))> args)
    ; not(
        (genname, args2, def, redefined) := <get-local-template-redefine(|args)> tc
        ; <?Define(_, _, fargs, _, body)> def
      )
    ; <collect-effectful-potential-joins> tc

  an-potential-joins =
    (?call@TemplateCallNoBody(name, args) <+ ?call@TemplateCall(name, args, _, TemplateBody([])))
    ; [] := <filter(is-accessible-from(IteratedVar <+ IteratedSubList); ?(_, <try-strip-generic-sort; is-entity-type>))> args // Contains no arguments that are of interest to us
    ; fromlocalredefs := <collect-from-local-redefines> call // Still we need to follow the call, just to see if a local redefine is called, which may have extra arguments which are of interest to us
    ; fromcallargs := <collect-effectful-potential-joins> args
    ; <conc> (fromlocalredefs, fromcallargs)

  an-potential-joins =
    (?TemplateCallNoAssigns(_,args,TemplateBody(body)) <+ ?TemplateCallPropsNoArgs(_,p,TemplateBody(body)) <+ ?TemplateCallBody(_,TemplateBody(body)) <+ ?TemplateCall(_,args,p,TemplateBody(body)))
    ; fromargs := <collect-effectful-potential-joins <+ ![]> args
    ; fromprops := <collect-effectful-potential-joins <+ ![]> p
    ; frombody := <collect-potential-joins> body
    ; <concat>[fromargs, fromprops, frombody]

  collect-from-local-redefines =
    (?tc@TemplateCallNoBody(name, args) <+ ?tc@TemplateCall(name, args, _, TemplateBody([])))
    ; (genname, _, def, False()) := <get-local-template-redefine(|args)> tc // Not a local redefine
    ; where(not(<PassedTemplate> genname))
    ; <?Define(_, _, _, _, body)> def
    ; calls := <collect(?TemplateCallNoBody(_, _) <+ ?TemplateCall(_, _, _, TemplateBody([])))> body
    ; {| PassedTemplate, LocalRedefDef, LocalRedefName, LocalRedefArgs
       : rules( PassedTemplate : genname )
       ; <alltd(define-local-redefine)> body
       ; <filter(collect-from-local-redefines)> calls // Just follow the calls
       |}

  collect-from-local-redefines =
    (?tc@TemplateCallNoBody(name, args) <+ ?tc@TemplateCall(name, args, _, TemplateBody([])))
    ; (genname, args2, def, True()) := <get-local-template-redefine(|args)> tc // This is a call to a redefined template
    ; where(not(<PassedTemplate> genname))
    ; <?Define(_, _, fargs, _, body)> def
    ; {| PassedTemplate
       : rules( PassedTemplate : genname )
       ; <an-potential-joins-with-args(|args2, fargs)> body // Analyze the call normally
       |}

  // Redirects attention to the local redefine and augments the arguments accordingly
  get-local-template-redefine(|args) =
    is-defined-tc-get-called-tc
    ; ?genname
    ; localname := <LocalRedefName> genname
    ; !(localname, <conc>(args, <LocalRedefArgs> genname), <CurrentTemplateDecl <+ LocalRedefDef> localname, True())

  get-local-template-redefine(|args) =
    is-defined-tc-get-called-tc
    ; where(not(LocalRedefName))
    ; !(<id>, args, <CurrentTemplateDecl>, False())

  an-potential-joins =
    ?Derive(deriveType, e, props*)
    ; <map(\ DeriveDefault(f) -> FieldAccess(e, f) \); collect-effectful-potential-joins> props*

  an-potential-joins =
    (?ForNoFilter(x, srt, e, _, _) <+ ?For(x, srt, e, f, _, _) <+ ?ForStmtNoFilter(x, srt, e, _) <+ ?ForStmt(x, srt, e, f, _))
    ; ?for
    ; not([] := <filter(is-accessible-from(IteratedVar <+ IteratedSubList))> e)
    ; not(<IteratedSubList> Var(x))
    ; {| IteratedSubList, IteratedSubListValue // Different from IteratedVar, because the path represents a collection and thus may not be used in query conditions, but can still be used to find additional joins
       : rules( IteratedSubListValue : Var(x) -> e
                IteratedSubList      : Var(x) -> srt
              )
       ; <collect-potential-joins> for
       |}

  //an-potential-joins = debug(!"NoMatch:  "); fail
  //an-potential-joins = where(not(should-skip)); debug(!"NoMatch:  "); fail

  // The following terms do not contain interesting info themselves, but their sub-terms possibly do, so they may be skipped
  should-skip = ?[] <+ ?[_] <+ ?[_|_]
  should-skip = ?SimpleSort(_)
  should-skip = (is-query-condition-constant <+ ?None() <+ ?Null())
  should-skip = (?Or(_, _) <+ ?And(_, _) <+ ?Eq(_, _) <+ ?NotEq(_, _) <+ ?LargerThan(_, _) <+ ?LargerThanOrEqual(_, _) <+ ?SmallerThan(_, _) <+ ?SmallerThanOrEqual(_, _) <+ ?Not(_))
  should-skip = is-string
  should-skip = (?Text(_) <+ ?XMLEmptyElement(_, _) <+ ?XMLElement(_, _, _, _) <+ ?InitAction(_) <+ ?Block(_) <+ ?Stat(_) <+ ?Page() <+ ?TemplateBody(_))
  should-skip = (?Filter(_, _, _) <+ ?OrderNonSpecific(_) <+ ?OrderAscending(_) <+ ?OrderAscending(_) <+ ?Limit(_, _) <+ ?LimitNoOffset(_) <+ ?LimitNoLimit(_) <+ ?ForSeparator(_))
  should-skip = ?IfTempl(_, trueBlock, falseBlock); where(not([] := trueBlock); not([] := falseBlock)) // If an if statement has both a true and false code block then the condition is irrelevant and thus should be skipped over

  // Following terms need more attention
  should-skip = ?AccessControlImportRules(_, _) <+ ?ResolvedRequireKey(_)

  // The following matches call collect-effectful-potential-joins, so the second time they match IsEffectful should be true, and thus collect-effectful-potential-joins will fail.
  // This will result in collecting all sub-term FieldAccesses and Vars containing some variable respresenting RootVar, with their Effectful property set to true.
  should-skip = (?TemplateCallNoBody(_, _) <+ ?TemplateCall(_, _, _, _) <+ ?Call(_, _, _) <+ ?VarDeclInit(_, _, _) <+ ?VarDeclInitInferred(_, _) <+ ?Assignment(_, _) <+ ?PropertyAssignment(_, _) <+ ?PageCall(_, _) <+ ?ThisCall(_, _)); where(IsEffectful; ?True())

  // The following line prevents FieldAccesses and Vars not related to the var we are analyzing from showing up. An extra check could be added to make sure they are indeed not related
  should-skip = (?FieldAccess(_, _) <+ ?Var(_))
*/
  // This strategy defines rules to keep track of template / function arguments
/*  an-potential-joins-with-args(|args, fargs) =
    ?body
    ; {| IteratedVar, IteratedVarValue, IteratedSubList, IteratedSubListValue, LocalRedefDef, LocalRedefName, LocalRedefArgs
       : with(id
         ; <alltd(define-local-redefine)> body
         // Here we mark the arguments as interesting, because they are in some way related to the persisten root or are constants which we can use in query conditions
         // Removed the warnings, because a loop could occur when following a local redefine, because then some variables inside the redefine can belong to the caller and thus have the same name. This warning can be safely ignored.
         ; <filter({vars:
                     \ (e, Arg(x, srt)) ->  <id>
                       where [] := <collect(IteratedSubList)> e; <is-var-accessible> e; not(<is-generic-sort> srt)
*///                       where not(<IteratedVarValue/*; warn(|["Ignoring variable ", x, ", because it would create a loop in IteratedVarValue"])*/> Var(x))
/*                       with rules( IteratedVarValue : Var(x) -> e     // Helps when expressing a Var into the Var or constant passed by the caller 
                                   IteratedVar      : Var(x) -> srt
                                 )
                     \})> <zip> (args, fargs)
         ; <filter({vars: 
                     \ (e, Arg(x, srt)) ->  <id>
                       where not([] := <collect(IteratedSubList)> e) <+ (<is-generic-sort> srt; <is-var-accessible> e)
*///                       where not(<IteratedSubListValue/*; warn(|["Ignoring variable ", x, ", because it would create a loop in IteratedSubListValue"])*/> Var(x))
/*                       with rules( IteratedSubListValue  : Var(x) -> e
                                   IteratedSubList       : Var(x) -> srt
                                 )
                     \})> <zip> (args, fargs)
         )
       ; <collect-potential-joins> body
     |}
*/

/*  generate-template-name-args :
  	(n, args) -> genname
  	with t* := <map(query-optimization-type-of; strip-annos)> args
    ; name := <strip-annos> n
    ; genname := <generate-template-name> (name,t*)
*/

  //query-optimization-type-of = (is-accessible-from(IteratedVar <+ IteratedSubList); Snd) <+ type-of

/*
  add-backend-annotation =
    (?Arg(_, _) <+ ?ForAll(_, _, _, _, _) <+ ?For(_, _, _, _, _, _) <+ ?ForAllStmt(_, _, _, _) <+ ?ForStmt(_, _, _, _, _))
    ; add-backend-annotations-to-query-optimization

  add-backend-annotations-to-query-optimization :
    term@_{anno*} -> term{newanno*}
    where qo := <fetch-elem(?QueryOptimizations(_, _, _, _))> anno*
    ; newqo := <add-lazy-property-annos; add-backend-annotations> qo
    ; not(qo := newqo)
    ; toKeep := <remove-all(?QueryOptimizations(_, _, _, _))> anno*
    ; newanno* := [newqo | toKeep]

  add-lazy-property-annos:
    QueryOptimizations(joins1, genjoins1, cond, condjoins){anno*} -> QueryOptimizations(joins2, genjoins2, cond, condjoins){anno*}
    where joins2 := <map(add-lazy-property-annos-to-expr)> joins1
    ; genjoins2 := <map(add-lazy-property-annos-to-expr)> genjoins1

  add-lazy-property-annos-to-expr:
	  expr@FieldAccess(p, f){anno*} -> FieldAccess(p2{annop2*}, f){newanno*}
	  where not(<fetch-elem(?IsLazyFetch())> anno*)
	  ; p2{annop2*} := <add-lazy-property-annos-to-expr> p 
	  with SimpleSort(x_classp) := <fetch-elem(?SimpleSort(_) <+ ?GenericSort(_, [<id>]))> annop2*
	  ; x_class := <class-of-property> (x_classp, f)
	  ; newanno* := <try(add-lazy-anno(|x_class, f))> anno*
*/
/*
	add-lazy-property-annos-to-expr:
	  c@Cast(_, _) -> c

	add-lazy-property-annos-to-expr:
	  v@Var(_) -> v
*/