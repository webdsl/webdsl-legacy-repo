module org/webdsl/dsl/languages/query-helpers

imports // imports only needed for pp-aterm-box and box2text-string
  libstratego-gpp
  libstratego-aterm

strategies

  rename-query-optimization-annos = rename-query-optimization-annos(rename-all)

  add-query-optimization-to-argument(|analysis,bindableargs) :
    arg@Arg(x, srt){anno*} -> arg{qo,anno*} 
    where [] := <filter(?arg)> bindableargs 
    ; qo := <query-analysis-to-query-optimizition(|x,srt,bindableargs)> analysis

  template-body-ready = // Local redefines, derives and output lists should have been lifted
    where(
      collect(?Define(_, _, _, _, _) <+ ?Derive(_, _, _) <+ ?TemplateCall("dummy",_,_,TemplateBody(_)) <+ is-call-to-output-generic-sort)
      ; ?[]
    )

  action-body-ready =
    where(
      collect(is-property-access-without-this <+ ?ForExp(_, _, _, _, _))
      ; ?[]
    )

  is-property-access-without-this = // We wait for desugar-property-access so we can follow all properties by following Var("this")
    ?Var(_); type-of; is-property-type

rules

  rename-query-optimization-annos(rename-strategy) :
    anno* -> newanno*
    with toKeep* := <remove-all(is-query-optimization <+ is-query-analysis <+ ?QueryOptimizationVars(_, _, _, _))> anno*
      ; qo* := <(fetch-elem(is-query-optimization); rename-strategy; ![<id>]) <+ ![]> anno*
      ; qa* := <(fetch-elem(is-query-analysis); rename-strategy; ![<id>]) <+ ![]> anno*
      ; qovars* := <(fetch-elem(?QueryOptimizationVars(_, _, _, _)); rename-strategy; ![<id>]) <+ ![]> anno*
      ; newanno* := [qo*, qa*, qovars*, toKeep*]

	keep-least-specific-casts =
	  ?allcandidates
	  ; collect-all(?FieldAccess(Cast(_, _), _))
	  ; make-set
	  ; {| ToLessSpecificCast
	    : filter(declare-to-less-specific-cast-rules(|allcandidates))
	    ; <repeat(oncetd(ToLessSpecificCast))> allcandidates
	  |}
	  ; make-set

  filter-traversal-summary = filter(where(Fst; is-accessible-from(RootVar)))

	declare-to-less-specific-cast-rules(|allcandidates) :
	  fa1@FieldAccess(Cast(p, srt), f) -> (fa1, lessSpecific)
	  where allLessSpecific := <collect(is-less-specific-cast(|p, srt, f)); make-set> allcandidates
	  ; lessSpecific := <foldr(!fa1, is-less-specific-cast); not(?fa1)> allLessSpecific
	  ; rules( ToLessSpecificCast : fa1 -> lessSpecific )

	is-less-specific-cast(|p, srt, f) :
	  fa2@FieldAccess(Cast(p, srt2), f) -> fa2
	  where not(srt := srt2); <subtype-of>(srt, srt2)

	is-less-specific-cast(|p, srt, f) :
	  fa2@FieldAccess(p, f) -> fa2

	is-less-specific-cast:
	  (fa1@FieldAccess(Cast(p, srt), f), fa2) -> fa2
	  where <is-less-specific-cast(|p, srt, f)> fa2

	is-less-specific-cast:
	  (fa1, fa2@FieldAccess(Cast(p, srt), f)) -> fa1
	  where <is-less-specific-cast(|p, srt, f)> fa1

  traversal-summary-to-branches(|x,xsrt,requiresalias) =
    //map(prepare-traversal)
    //; filter(\ (fst, snd, trd, True()) ->  with <clean-joincandidate> fst \)
    //; with(conditions := <filter(prepare-condition(|x,xsrt))>)
    //; filter(!(<Fst>, <Snd>); an-requires-joining-fa; try(?Cast(<id>, _)))
    filter(prepare-traversal)
    ; ?conditions
    ; map(Fst)
    ; make-set
    ; map(add-conditions(|conditions))
    ; map(traversal-to-joins(|x,xsrt,requiresalias); joins-to-optimization-branch)

  add-conditions(|conditions) :
    traversal{anno*} -> traversal{JoinCondition(conds), anno*}
    with conds := <filter(?(traversal, <id>, True())); make-set> conditions // The condition list always has an element. If that element is an empty list then that means that there was no condition.

  prepare-traversal :
    (traversal1, srt, cond1, eff) -> (traversal3, cond2, eff)
    with traversal2 := <is-accessible-from(RootVar); Fst> traversal1 // This removes any unnecessary casts
    ; cond2 := <revalidate-query-condition(get-accessible-expr(try-strip-generic-sort))> cond1
    where traversal3 := <an-requires-joining-fa; try(?Cast(<id>, _))> (traversal2, srt)

  traversal-summary-to-query-condition =
    filter(?(_, _, <revalidate-query-condition(get-accessible-expr(id));and-query-condition>, True())) // We revalidate the conditions, to ensure that one side of the conditions contains the RootVar
    ; make-set
    ; try(?[]; ![True()]) // No condition means true
    ; or-query-condition

  is-accessible-condition-expr(|p,castsrt) :
    (expr1, expr2) -> (newexpr1, newexpr2)
    where newexpr1 := <is-accessible-condition-expr-helper(|p,castsrt)> expr1
    ; newexpr2 := <is-accessible-condition-expr-helper(|p,castsrt)> expr2

  is-accessible-condition-expr-helper(|p,castsrt) :
    expr -> RelativeFieldAccess(relcastsrt, f)
    where (e, srt) := <is-accessible-from(RootVar)>
    ; <try(strip-ref-sort); try-strip-generic-sort; not(is-entity-type)> srt // If it is an entity type, then the value is not prefetched yet.
    ; FieldAccess(f_expr, f) := <try(?Cast(<id>, _))> e
    ; <(?Cast(p_expr, condcastsrt); <subtype-of> (castsrt, condcastsrt); !condcastsrt; topdown(add-type-annotations); ?relcastsrt) <+ (?p_expr; relcastsrt := None())> f_expr
    ; <expr-matches-path(|p)> p_expr

  expr-matches-path(|p) :
    FieldAccess(e, f) -> fsrt
    where [(f, SimpleSort(dec_class))|nextp] := p
    ; esrt := <expr-matches-path(|nextp)> e
    ; SimpleSort(e_class) := <try(strip-ref-sort); try-strip-generic-sort> esrt
    ; dec_class := <class-of-property> (e_class, f) // If dec_class is not the same as that on the path, then the expression does not match the path.
    ; fsrt := <get-prop-type; strip-ref-sort; topdown(add-type-annotations)> (dec_class, f)

  expr-matches-path(|p) :
    Cast(e, srt) -> srt
    where <expr-matches-path(|p)> e

  expr-matches-path(|p) :
    v@Var(_) -> srt
    where [] := p
    ; srt := <RootVar> v

  is-accessible-condition-expr-helper(|p,castsrt) = where(is-query-condition-constant)
  is-accessible-condition-expr-helper(|p,castsrt) = where(is-accessible-from(BindableVar))

  revalidate-join-condition(|p,castsrt) =
    map(filter(extract-query-cond(is-accessible-condition-expr(|p,castsrt))); and-query-condition)
    ; or-query-condition
    ; (?True() < ![] + ![JoinCondition(<id>)])

  revalidate-join-conditions(|p) :
    (f, decsrt, castsrt, fsrt, subtree1){anno1*} -> (f, decsrt, castsrt, fsrt, subtree2){anno2*}
    with
      if <fetch-elem(?JoinCondition(joins))> anno1* then
        keep* := <remove-all(?JoinCondition(_))> anno1*
        ; joins* := <revalidate-join-condition(|p,castsrt)> joins
        ; anno2* := [joins*,keep*]
      else
        anno2* := anno1*
      end
      ; newp := [(f, decsrt)|p]
      ; subtree2 := <map(revalidate-join-conditions(|newp))> subtree1

  traversal-to-joins(|x,xsrt,requiresalias):
    expr@FieldAccess(e, f{annof*}){anno*} -> [(f{}, decsrt, castsrt, fsrt){newanno*} | prev]
    with <?Cast(p, _) <+ ?p> e
    ; castsrt := <(?Cast(_, <id>); add-type-annotations) <+ !None()> e
    ; prev@[(_, _, _, p_fsrt)|_] := <traversal-to-joins(|x,xsrt,requiresalias)> p
    ; SimpleSort(e_class) := <(?SimpleSort(_) <+ !p_fsrt); try(strip-ref-sort); try-strip-generic-sort> castsrt
    ; dec_class := <class-of-property> (e_class, f)
    ; decsrt := <add-type-annotations> SimpleSort(dec_class)
    ; fsrt := <get-prop-type; strip-ref-sort; topdown(add-type-annotations)> (dec_class, f)
    ; newanno* := <filter(keep-anno-in-query-optimization <+ ?JoinCondition(_)); try(add-lazy-anno(|dec_class, f, fsrt)); try(add-alias-anno(|expr,requiresalias))> anno*

  traversal-to-joins(|x,xsrt,requiresalias):
    Var(x) -> [(None(), None(), None(), srt)]
    with srt := <strip-ref-sort> xsrt

  // Does the same as below
  joins-to-optimization-branch = reverse; ?[_|<id>]; foldr(![], \ ((f, decsrt, castsrt, fsrt){anno*}, sub) -> [(f, decsrt, castsrt, fsrt, sub){anno*}] \); ?[<id>]

  /*joins-to-optimization-branch(|sub) :
    [(f, decsrt, castsrt, fsrt){anno*}|xs] -> res
    where not([] := xs)
    with newsub := (f, decsrt, castsrt, fsrt, sub){anno*}
    ; res := <joins-to-optimization-branch(|[newsub])> xs

  joins-to-optimization-branch(|sub) :
    [_] -> tree
    with [tree] := sub*/

  combine-branch-anno :
    (anno1*, anno2*) -> (anno3*, anno4*)
    where <fetch-elem(?JoinCondition(joins1))> anno1*
    ; <fetch-elem(?JoinCondition(joins2))> anno2*
    ; joins3 := <conc; make-set> (joins1, joins2)
    ; anno3* := <remove-all(?JoinCondition(_)); ![JoinCondition(joins3)|<id>]> anno1*
    ; anno4* := <remove-all(?JoinCondition(_))> anno2*

  merge-optimization-branches :
    (branch@(f, decsrt, _, _, _), tree) -> [subtree | keep]
    with keep := <remove-all(?(f, decsrt, _, _, _))> tree
    ; subtree := <fetch-elem(?(f, decsrt, _, _, _)) < combine-optimization-branches(|branch) + !branch> tree

  combine-optimization-branches(|branch) :
    (f, decsrt, castsrt1, fsrt, subtree1){anno1*} -> (f, decsrt, newcastsrt, fsrt, newsubtree){anno3*}
    where (f, decsrt, castsrt2, fsrt, [subtree2]){anno2*} := branch
    with anno3* := <repeat(combine-branch-anno); Fst> (anno1*, anno2*)
    ; newcastsrt := <combine-cast-sort(|decsrt)> (castsrt1, castsrt2)
    ; newsubtree := <merge-optimization-branches> (subtree2, subtree1)

  combine-optimization-branches(|branch) :
    (f, decsrt, castsrt1, fsrt, subtree){anno1*} -> (f, decsrt, newcastsrt, fsrt, subtree){anno3*}
    where (f, decsrt, castsrt2, fsrt, []){anno2*} := branch
    with anno3* := <repeat(combine-branch-anno); Fst> (anno1*, anno2*)
    ; newcastsrt := <combine-cast-sort(|decsrt)> (castsrt1, castsrt2)

  combine-cast-sort(|decsrt) :
    (None(), _) -> None()

  combine-cast-sort(|decsrt) :
    (_, None()) -> None()

  combine-cast-sort(|decsrt) :
    (srt1, srt2) -> srt2
    where <subtype-of> (srt1, srt2)

  combine-cast-sort(|decsrt) :
    (srt1, srt2) -> srt1
    where <subtype-of> (srt2, srt1)

  combine-cast-sort(|decsrt) :
    (srt1, srt2) -> decsrt
    where <not(subtype-of)> (srt1, srt2)
    ; <not(subtype-of)> (srt2, srt1)

  merge-conditional-optimization-branches :
    ((cond, branches), tree) -> newtree
    with newtree := <foldr(!tree, merge-conditional-optimization-branch(|cond))> branches

  merge-conditional-optimization-branch(|cond) :
    (branch@(f, decsrt, _, _, _), tree) -> [subtree | keep]
    with keep := <remove-all(?(f, decsrt, _, _, _))> tree
    ; subtree := <fetch-elem(?(f, decsrt, _, _, _)) < combine-conditional-optimization-branches(|cond, branch) + <add-condition-to-branch(|cond)>branch> tree

  combine-conditional-optimization-branches(|cond, branch) :
    (f, decsrt, castsrt, fsrt, subtree1){anno1*} -> (f, decsrt, castsrt, fsrt, newsubtree){anno3*}
    where (f, decsrt, _, _, [subtree2]){anno2*} := branch
    with newsubtree := <merge-conditional-optimization-branch(|cond)> (subtree2, subtree1)
    ; anno3* := <repeat(combine-branch-anno); Fst; try(add-condition-to-branch-anno(|cond))> (anno1*, anno2*)

  combine-conditional-optimization-branches(|cond, branch) :
    (f, decsrt, castsrt, fsrt, subtree){anno1*} -> (f, decsrt, castsrt, fsrt, subtree){anno3*}
    where (f, decsrt, _, _, []){anno2*} := branch
    ; anno3* := <repeat(combine-branch-anno); Fst; try(add-condition-to-branch-anno(|cond))> (anno1*, anno2*)

  add-condition-to-branch(|cond) :
    (f, decsrt, castsrt, fsrt, [subtree]){anno*} -> (f, decsrt, castsrt, fsrt, newsubtree){cond, anno*}
    with newsubtree := <add-condition-to-branch(|cond)> subtree

  add-condition-to-branch(|cond) :
    (f, decsrt, castsrt, fsrt, []){anno*} -> (f, decsrt, castsrt, fsrt, []){cond, anno*}

  add-condition-to-branch-anno(|cond) :
    anno1* -> [new*, keep*]
    where oldconds := <filter(?IfDefaultTemplateImplementation(_))> anno1*
    ; not([] := oldconds) // Do not place conditions on unconditional joins
    ; keep* := <remove-all(?IfDefaultTemplateImplementation(_))> anno1*
    ; new* := <make-set> [cond | oldconds]

	log-query-optimization-collect-basic =
	  make-set
	  ; map(info(|["Traversal: ", <id>]))

	log-query-optimization-collect-table(|col1,col2,col3) =
	  info(|["+-", <align-helper(|'-', col1)>"", "-+-", <align-helper(|'-', col2)>"", "-+-", <align-helper(|'-', col3)>"", "-+"])
	  ; info(|["| Path", <align-helper(|' ', col1)>"Path", " | Condition", <align-helper(|' ', col2)>"Condition", " | Need", <align-helper(|' ', col3)>"Need", " |"])
	  ; info(|["|-", <align-helper(|'-', col1)>"", "-+-", <align-helper(|'-', col2)>"", "-+-", <align-helper(|'-', col3)>"", "-|"])
	  ; make-set
	  ; map({col1Val, col2Val, col3Val, str1, str2, str3, align1, align2, align3:?(col1Val, _, col2Val, col3Val)
	    ; str1 := <webdsl-to-abox; box2text-string(|col1)> col1Val
	    ; str2 := <?[] < !"" + (map(webdsl-to-abox; box2text-string(|col2)); separate-by(|" && "); concat-strings)> col2Val
	    ; str3 := <?True() < !"true" + !"false"> col3Val
	    ; align1 := <align-helper(|' ', col1)> str1
	    ; align2 := <align-helper(|' ', col2)> str2
	    ; align3 := <align-helper(|' ', col3)> str3
	    ; <concat-strings>["| ", str1, align1, " | ", str2, align2, " | ", str3, align3, " |"]
	      }
	      //<concat-strings>["| ", <Fst;pp-webdsl-to-string>, <Fst;pp-webdsl-to-string;align-helper(|' ', col1)>, " | ", <Third;pp-webdsl-to-string>, <Third;pp-webdsl-to-string; align-helper(|' ', col2)>, " | ", <?(_, _, _, <id>);pp-webdsl-to-string>, <?(_, _, _, <id>);pp-webdsl-to-string;align-helper(|' ', col3)>, " |"]
	    )
	  ; make-set
	  ; string-sort
	  ; map(info(|<id>))
	  ; info(|["+-", <align-helper(|'-', col1)>"", "-+-", <align-helper(|'-', col2)>"", "-+-", <align-helper(|'-', col3)>"", "-+"])

	add-alias-anno(|expr,requiresalias) :
	  anno* -> newanno*
	  where alias := <property-to-alias> expr
	  ; <fetch-elem(?alias)> requiresalias
	  ; newanno* := [RequiresAlias()|anno*]

	sub-paths :
	  fa@FieldAccess(p, _) -> [fa | subpaths]
	  with subpaths := <sub-paths> p

	sub-paths :
	  Cast(p, _) -> subpaths
	  with subpaths := <sub-paths> p

	sub-paths :
	  Var(_) -> []

  keep-anno-in-query-optimization = fail//?MultipleDefinitionsInSubclasses()

  an-requires-joining-fa :
    (fa@FieldAccess(_, _), srt) -> cleanfa
    where <is-generic-sort <+ is-entity-type> srt
    ; cleanfa := <clean-joincandidate> fa

  an-requires-joining-fa :
    (FieldAccess(expr, _), srt) -> cleanexpr
    where(<not(is-generic-sort <+ is-entity-type)> srt)
    ; not([] := <collect(?FieldAccess(_, _))> expr) // The expression must contain at least another FieldAccess, otherwise it's just a Var with a value type fieldaccess
    ; cleanexpr := <clean-joincandidate> expr

  clean-joincandidate :
    FieldAccess(p, f){anno*} -> FieldAccess(cleanp, f{}){newanno*}
    where newanno* := <filter(keep-anno-in-query-optimization); make-set> anno*
    ; cleanp := <clean-joincandidate> p

  clean-joincandidate :
    Cast(p, srt) -> Cast(cleanp, srt{}){}
    where cleanp := <clean-joincandidate> p

  clean-joincandidate :
    v@Var(_) -> v{}

  add-lazy-anno(|ent,f, srt) :
    anno* -> [IsLazyFetch() | anno*]
    where SimpleSort(invEnt) := srt
    ; invProp := <InverseProperty; PropertyDecl> (ent, f)
    ; SimpleSort(ent) := <get-property-type> invProp
    ; <get-property-annos; fetch-elem(?InverseAnno(ent, f))> invProp // Is the inverse side the owning side?
      
  is-accessible-from-allow-calls(s) =
    replace-calls-to-return-values(s)
    //; debug(!"replace-calls-to-return-values:")
    ; filter(is-accessible-from(s))
    //; debug(!"is-accessible-from:")
    ; not(?[])

  replace-calls-to-return-values(s) :
    FieldAccess(p, f){anno*} -> results
    where subpaths := <replace-calls-to-return-values(s)> p
    ; results := <map(!FieldAccess(<id>, f){anno*})> subpaths

  replace-calls-to-return-values(s) :
    Cast(p, srt){anno*} -> results
    where subpaths := <replace-calls-to-return-values(s)> p
    ; results := <map(!Cast(<id>, srt){anno*})> subpaths

  replace-calls-to-return-values(s) :
    v@Var(_) -> [v]

  replace-calls-to-return-values(s) :
    Call(e, nm, args) -> results
    where subpaths := <replace-calls-to-return-values(s)> e
    ; results := <filter(expand-call-to-return-values(s|nm, args)); flatten-list; make-set> subpaths

  expand-call-to-return-values(s|nm, args) :
    e -> results
    where <is-accessible-from(s); ?(e2, <is-entity-type; ?SimpleSort(ent)>)> e
    ; (n, targs) := <normalize-signature> (nm, args)
    ; (fent, Function(_, defargs, _, _){defanno*}) := <try-resolve-entity-call> (ent, n, targs)
    ; returns := <fetch-elem(get-returns-from-query-analysis)> defanno*
    with argmapping := <zip> (args, defargs)
    ; varmapping := <add-this-vars-to-mapping(|returns, e, ent)> argmapping
    ; results := <foldr(!returns, rename-vars-in-analysis(RootVar))> varmapping

  // The default generic sort handler is try-strip-generic-sort, to allow fieldaccesses on collections
  // For query conditions this is not allowed, so there id should be used to deal with generic sorts
  is-accessible-from(s) = is-accessible-from(s,try-strip-generic-sort)//; try(where(collect(?Cast(Cast(_, _), _)); not(?[])); debug(!"dbl:"))

  /*is-accessible-from(s,gen): // Cast where the cast is not needed
    Cast(f, srt){anno*} -> (p, srt)
    where (p, srt2) := <is-accessible-from(s,gen)> f
    ; <subtype-of> (<gen>srt2, srt) // up-cast or cast to same type*/

  is-accessible-from(s,gen):
    Cast(Cast(f, srt), srt2){anno*} -> (p, srt3)
    where <not(eq); subtype-of> (<gen>srt2, <gen>srt) // srt2 is more specific (subtype of srt)
    ; (p, srt3) := <is-accessible-from(s,gen)> Cast(f, srt2){anno*}

  is-accessible-from(s,gen):
    Cast(Cast(f, srt){anno*}, srt2) -> (p, srt3)
    where <subtype-of> (<gen>srt, <gen>srt2) // srt is more specific (subtype of srt2 or eq)
    ; (p, srt3) := <is-accessible-from(s,gen)> Cast(f, srt){anno*}

  is-accessible-from(s,gen): // Cast where the cast is needed
    Cast(f, srt){anno*} -> (Cast(p, srt){srt2, keepanno*}, srt)
    where not(Cast(_, _) := f)
    ; (p, srt2) := <is-accessible-from(s,gen)> f
    ; not(<gen;?srt> srt2) 
    ; <subtype-of> (srt, <gen>srt2) // down-cast
    ; keepanno* := <remove-all(?GenericSort(_, _) <+ ?SimpleSort(_))> anno*

  add-mutiple-definitions-anno: // srt is a sub entity of srt2
    fa@FieldAccess(Cast(p, srt){castanno*}, f){anno*} -> fa2
    where fa2 := <add-new-anno(|MultipleDefinitionsInSubclasses())> fa
    ; <fetch-elem(?srt2@SimpleSort(superent))> castanno*
    ; not(<get-prop-type> (superent, f)) // If the property is already defined on the source/super entity then there is no property clash
    //; info(|["Finding ", f, " from ", superent, " to ", srt])
    ; all-keys-EntDecl
    ; filter({x_sub: // We find out on which sub entities property f is defined
                ?x_sub
                ; where(
                    <not(eq)>(x_sub, superent)
                    ; <subtype-of>(SimpleSort(x_sub), srt2)
                    ; <TypeOfProperty> (x_sub, f) // Deliberate use of TypeOfProperty instead of type-of-property
                )
             })
    ; not(?[_]) // If not defined on exactly one sub entity
    //; debug(!"Match:")

  update-iterator-context :
    anno* -> [IteratorContext(ic)|keep]
    with keep := <remove-all(?IteratorContext(_))> anno*
    ; ic := <bigbagof-IteratorContext>

  remove-top-level-cast:
    Cast(f, _) -> f

  is-accessible-from(s,gen):
    FieldAccess(v, f){anno*} -> (fa, srt)
    where /*debug(!"is-accessible-from-fa-begin:");*/(p, psrt) := <is-accessible-from(s,gen)> v
    ; <gen; ?SimpleSort(x_class)> psrt
    ; not(<is-derived-property> (x_class, f))
    ; srt := <get-prop-type; strip-ref-sort> (x_class, f)
    ; f2 := <try(get-real-col-prop-name(|x_class, srt))> f
    ; fa := <try(add-naturalid-anno(|x_class)); try(add-mutiple-definitions-anno)> FieldAccess(p, f2){anno*}
    //; <debug(!"is-accessible-from-fa-end:")> (fa, srt)

  is-accessible-from(s,gen):
    v@Var(_) -> (v, srt)
    where /*debug(!"is-accessible-from-v-begin:");*/srt := <s; strip-ref-sort> v//; <debug(!"is-accessible-from-v-end:")> (v, srt)

  get-real-col-prop-name(|x_class, srt) =
    where(GenericSort("List", lsrt) := srt)
    ; where(string-ends-with(|"List"))
    ; string-as-chars(take(!(<length>, 4); subt)) // Get the real property name
    ; where(<get-prop-type> (x_class, <id>); ?GenericSort(_, lsrt)) // Check if the simple sort of the collections match

  add-naturalid-anno(|x_class) :
    fa@FieldAccess(_, f){anno*} -> fa2
    where f := <natural-id-name-include-superclass> x_class
    ; fa2 := <add-new-anno(|IsNaturalId())> fa 
/*// Replaced by: or-query-condition
  join-conditions:
    (cond, []) -> cond

  join-conditions:
    (cond, True()) -> cond

  join-conditions:
    (cond, prevCond) -> Or(prevCond, cond)
    where <not(?True()); not(?[])> prevCond
*/
/*// Replaced by: and-query-condition-helper
  append-condition:
    (newCond, oldCond) -> And(newCond, oldCond)
    where <not(?True())>newCond; <not(?True())>oldCond

  append-condition:
    (newCond, True()) -> newCond

  append-condition:
    (True(), oldCond) -> oldCond
*/

  add-this-vars-to-mapping(|from, e, ent) :
    mapping -> newmapping
    with thisargs := <get-this-args(|ent)> from
    ; thismapping := <map(!(e, <id>))> thisargs
    ; newmapping := <conc> (mapping, thismapping)
    
  get-this-args(|ent) :
    from -> thisargs
    with thisvars := <collect(?Var("this")); make-set> from
    ; thisargs := <map(?Var(<id>); !Arg(<id>, SimpleSort(ent)))> thisvars

  get-prop-type: (x_class, prop) -> <type-of-property>

  get-prop-type: (x_class, prop) -> <EntityIdType> x_class
    where <EntityIdName; ?prop> x_class

  get-all-entity-properties-as-fargs =
    get-all-entity-properties-as-mapping(|None())
    ; map(Snd)

  get-all-entity-properties-as-mapping(|e) =
    all-entity-properties-tuples
    ; map(entity-property-tuple-to-mapping(|e))

  entity-property-tuple-to-mapping(|e) :
    (ent, prop) -> ( FieldAccess(e, name), Arg(name{uniquename}, srt))
    with name := <get-property-name> prop
    ; uniquename := <PropertyNameToUniqueName> (ent, name)
    ; srt := <get-property-type> prop

  get-all-entity-properties-for-rename(|prefix) =
    all-entity-properties-tuples
    ; {|OverridePropName
       : map({\ (ent, prop) -> <id> with propname := <get-property-name> prop; rules(OverridePropName : propname -> (ent, prop)) \})
       ; dr-all-keys(|"OverridePropName")
       ; map(OverridePropName; {ent,prop,name,uniquename,safename,srt:\ (ent, prop) -> (name, uniquename, safename, srt) where name := <get-property-name> prop; uniquename := <PropertyNameToUniqueName> (ent, name); safename := name{<concat-strings>[prefix, "_", name]}; srt := <get-property-type> prop \})
       |}

  // Same as resolve-entity-call, except here we allow failure
  // It also does not return functions that have an overridden version and it is unsure which version will be used
  try-resolve-entity-call = ?(ent, nm, targ*); try-resolve-entity-call-without-override-check; ?(fent, f); where(<subentities-do-no-override> (fent, nm, targ*))

  try-resolve-entity-call-without-override-check: (ent, nm, targ*) -> result
    where not("Entity" := ent)
    ; f := <resolve-function-call-to-decl> (SimpleSort(ent), nm, targ*)
      < result := (ent, f)
      + result := <try-resolve-entity-call-without-override-check> (<Extends> ent, nm, targ*)

  subentities-do-no-override =
    ?(ent, nm, targ*)
    ; all-keys-EntDecl
    ; filter({x_sub:
                ?x_sub
                ; where(
                    <not(eq)>(x_sub, ent)
                    ; <subtype-of>(SimpleSort(x_sub), SimpleSort(ent))
                    ; <resolve-function-call-to-decl>(SimpleSort(x_sub), nm, targ*)
                )
             })
    //; (?[] <+ debug(!<concat-strings>[ent, "::", nm, " already defined for: "]))
    ; ?[]
