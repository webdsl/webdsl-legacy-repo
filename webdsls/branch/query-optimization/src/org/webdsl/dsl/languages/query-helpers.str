module org/webdsl/dsl/languages/query-helpers

imports // imports only needed for pp-aterm-box and box2text-string
  libstratego-gpp
  libstratego-aterm

strategies
  
  add-backend-annotation :
    PrefetchNode(castsrt, name{PrefetchPropAnno(decsrt,fsrt)}, templ, cond, children){anno*} ->
    PrefetchNode(castsrt, name{PrefetchPropAnno(decsrt2,fsrt2)}, templ, cond, children){anno*}
    where decsrt2 := <add-type-annotations> decsrt
    ; fsrt2 := <topdown(add-type-annotations)> fsrt
    ; not(decsrt := decsrt2; fsrt := fsrt2)

  rename :
    PrefetchFor(x, tree1){anno*} -> PrefetchFor(y, tree2){anno*}
    with y := <rename-all> x
    ; srt := <type-of; strip-immutable-anno> y
    ; tree2 := <rename-prefetch(|srt)> tree1
    //; <debug(!"out:")> PrefetchFor(y, tree2){anno*}

  rename-prefetch(|srt):
    PrefetchChildren(children){anno*} -> PrefetchChildren(children2){anno*}
    with children2 := <map(try(rename-prefetch(|srt)))> children

  rename-prefetch(|srt): None(){anno*} -> None(){anno*}

  rename-prefetch(|srt):
    PrefetchNode(castsrt, name, templ, cond, children){anno*} -> PrefetchNode(castsrt, name{PrefetchPropAnno(decsrt,fsrt)}, templ, cond2, children2){newanno*}
    where SimpleSort(x_class) := <try(?Some(<id>)); (?SimpleSort(_) <+ !srt); try(strip-ref-sort); try-strip-generic-sort> castsrt
    ; n := <strip-annos> name
    ; dec_class := <class-of-property> (x_class, n)
    ; decsrt := SimpleSort(dec_class)
    ; fsrt := <get-prop-type; strip-ref-sort> (dec_class, n)
    ; cond2 := <alltd(add-type-anno-to-relative-fa(|srt))> cond
    ; children2 := <rename-prefetch(|fsrt)> children
    ; newanno* := <try(where(not(fetch-elem(?IsLazyFetch()))); add-lazy-anno(|dec_class,n, fsrt))> anno*

  add-type-anno-to-relative-fa(|srt) :
    fa@RelativeFieldAccess(castsrt, f){anno*} -> fa{fasrt,anno*}
    where <not(fetch-elem(is-webdsl-type))> anno*
    ; SimpleSort(x_class) := <(?SimpleSort(_) <+ !srt); try(strip-ref-sort); try-strip-generic-sort> castsrt
    ; fn := <strip-annos> f
    ; fasrt := <get-prop-type> (x_class, fn)

  type-of :
    RelativeFieldAccess(_, _){anno*} -> srt
    where srt := <fetch-elem(is-webdsl-type)> anno*

  constraint-error-data =
    ?PrefetchChildren(children)
    ; keys := <map(\ PrefetchNode(_, name, _, _, _) -> name \)> children
    ; key{PrefetchPropAnno(decsrt,fsrt)} := <make-set; fetch-elem(has-duplicates(|keys))> keys
    ; <filter(?PrefetchNode(_, key, _, _, _))> children
    ; add-error(|["Multiple prefetches defined for ", <pp-type>decsrt, ".", key, " of type ", <pp-type> fsrt])

  constraint-error-data =
    ?PrefetchFor(x, _)
    ; where(<not(?Var(_)) <+ (?Var(_); not(type-of))> x)
    ; add-error(|["Prefetching can only be defined for variables of an entity type"])

  constraint-error-data =
    ?PrefetchFor(x, tree)
    ; where(
        Var(_) := x
        ; srt := <type-of; try(strip-ref-sort); strip-immutable-anno; try-strip-generic-sort; is-entity-type> x
      )
    ; <constrain-prefetch-helper(|srt)> tree

  constrain-prefetch-helper(|srt) =
    ?PrefetchChildren(children){anno*}
    ; <fetch-elem(constrain-prefetch-helper(|srt))> children

  constrain-prefetch-helper(|srt) =
    ?PrefetchNode(castsrt, name, templ, cond, children){anno*}
    ; where(<?Some(castsrt2); !(castsrt2, srt); not(subtype-of)> castsrt)
    ; add-error(|["Cannot cast from type ", <pp-type> srt, " to type ", <pp-type> castsrt2])

  constrain-prefetch-helper(|srt) =
    ?PrefetchNode(castsrt, name, templ, cond, children){anno*}
    ; where(
        SimpleSort(x_class) := <try(?Some(<id>)); (?SimpleSort(_) <+ !srt)> castsrt
        ; <subtype-of> (SimpleSort(x_class), srt)
        ; n := <strip-annos> name
      )
    ; if where(dec_class := <class-of-property> (x_class, n)) then
        fsrt := <get-prop-type> (dec_class, n)
        ; elemsrt := <try-strip-generic-sort> fsrt
        ; res := <constrain-prefetch-helper(|elemsrt);debug(!"children:")> children
      else
        add-error(|["No property ", n, " defined for ",<pp-type> SimpleSort(x_class)])
      end

  constrain-prefetch-helper(|srt) =
    ?PrefetchNode(castsrt, name, templ, cond, children){anno*}
    ; where(
        SimpleSort(x_class) := <try(?Some(<id>)); (?SimpleSort(_) <+ !srt)> castsrt
        ; <subtype-of> (SimpleSort(x_class), srt)
      )
    ; <?PrefetchCondition(<id>)> cond
    ; constrain-prefetch-condition-cast(|srt)

  constrain-prefetch-condition-cast(|srt) =
    collect(?RelativeFieldAccess(_, _))
    ; fetch-elem(constrain-prefetch-relative-fa-cast(|srt))

  constrain-prefetch-condition(|srt) =
    ?PrefetchCondition(e)
    ; where(
        not(SimpleSort("Bool") := <type-of> e)
        ; <type-of> e // don't report when sub-expression was already wrong
      )
    ; add-error(|["expression ", <pp-webdsl> e, " should be of type Bool"])

  constrain-prefetch-relative-fa-cast(|srt) =
    ?RelativeFieldAccess(castsrt, _)
    ; where(
        not(None() := castsrt)
        ; <not(subtype-of)> (castsrt, srt)
      )
    ; add-error(|["Cannot cast from type ", <pp-type> srt, " to type ", <pp-type> castsrt])

  /*constraint-error-data =
    ?PrefetchFor(x, _)
    ?PrefetchNode(_, name{}, _, _, _)
    ; debug(!"unknown?")
    ; add-error(|["Cannot define prefetch for unknown property"])*/

  

  has-duplicates(|list) :
    key -> key
    where <filter(?key); not(length => 1)> list

  rename-query-optimization-annos = rename-query-optimization-annos(rename-all)

  rename-query-condition-anno :
    term@_{anno*} -> term{qc2,keep*}
    where qc1 := <fetch-elem(?QueryCondition(_))> anno*
    ; qc2 := <rename-all> qc1
    ; keep* := <remove-all(?QueryCondition(_))> anno*

  add-query-optimization-to-argument(|analysis,bindableargs) :
    (arg@Arg(x, srt),b) -> b 
    where <not(filter(?arg); ?[])> bindableargs 

  add-query-optimization-to-argument(|qa,bindableargs) :
    (arg@Arg(x, srt),b1) -> b2 
    where [] := <filter(?arg)> bindableargs 
    ; (qc, b2) := <query-analysis-to-query-optimizition(|qa,x,srt,bindableargs)> b1

  template-body-ready = // Local redefines, derives and output lists should have been lifted
    where(
      collect(?Define(_, _, _, _, _) <+ ?Derive(_, _, _) <+ ?TemplateCall("dummy",_,_,TemplateBody(_)) <+ is-call-to-output-generic-sort)
      ; ?[]
    )

  action-body-ready =
    where(
      collect(is-property-access-without-this <+ ?ForExp(_, _, _, _, _))
      ; ?[]
    )

  is-property-access-without-this = // We wait for desugar-property-access so we can follow all properties by following Var("this")
    ?Var(_); type-of; is-property-type

  with-thisentity(s|anno*) =
    where(<fetch-elem(?FunctionEntity(x_class))> anno*)
    ; {| ThisEntity
       : rules( ThisEntity := x_class )
       ; s
       |}

  with-thisentity(s|anno*) =
    where(<not(fetch-elem(?FunctionEntity(_)))> anno*)
    ; s

rules

  rename-query-optimization-annos(rename-strategy) :
    anno* -> newanno*
    with toKeep* := <remove-all(is-query-optimization <+ is-query-analysis <+ ?QueryOptimizationVars(_, _, _, _))> anno*
      ; qo* := <(fetch-elem(is-query-optimization); rename-strategy; ![<id>]) <+ ![]> anno*
      ; qa* := <(fetch-elem(is-query-analysis); rename-strategy; ![<id>]) <+ ![]> anno*
      ; qovars* := <(fetch-elem(?QueryOptimizationVars(_, _, _, _)); rename-strategy; ![<id>]) <+ ![]> anno*
      ; newanno* := [qo*, qa*, qovars*, toKeep*]

	keep-least-specific-casts =
	  ?allcandidates
	  ; collect-all(?FieldAccess(Cast(_, _), _))
	  ; make-set
	  ; {| ToLessSpecificCast
	    : filter(declare-to-less-specific-cast-rules(|allcandidates))
	    ; <repeat(oncetd(ToLessSpecificCast))> allcandidates
	  |}
	  ; make-set

  filter-traversal-summary = filter(where(Fst; is-accessible-from(RootVar)))

	declare-to-less-specific-cast-rules(|allcandidates) :
	  fa1@FieldAccess(Cast(p, srt), f) -> (fa1, lessSpecific)
	  where allLessSpecific := <collect(is-less-specific-cast(|p, srt, f)); make-set> allcandidates
	  ; lessSpecific := <foldr(!fa1, is-less-specific-cast); not(?fa1)> allLessSpecific
	  ; rules( ToLessSpecificCast : fa1 -> lessSpecific )

	is-less-specific-cast(|p, srt, f) :
	  fa2@FieldAccess(Cast(p, srt2), f) -> fa2
	  where not(srt := srt2); <subtype-of>(srt, srt2)

	is-less-specific-cast(|p, srt, f) :
	  fa2@FieldAccess(p, f) -> fa2

	is-less-specific-cast:
	  (fa1@FieldAccess(Cast(p, srt), f), fa2) -> fa2
	  where <is-less-specific-cast(|p, srt, f)> fa2

	is-less-specific-cast:
	  (fa1, fa2@FieldAccess(Cast(p, srt), f)) -> fa1
	  where <is-less-specific-cast(|p, srt, f)> fa1

  traversal-summary-to-branches(|x,xsrt,requiresalias) =
    //map(prepare-traversal)
    //; filter(\ (fst, snd, trd, True()) ->  with <clean-joincandidate> fst \)
    //; with(conditions := <filter(prepare-condition(|x,xsrt))>)
    //; filter(!(<Fst>, <Snd>); an-requires-joining-fa; try(?Cast(<id>, _)))
    filter(prepare-traversal)
    ; ?conditions
    ; map(Fst)
    ; make-set
    ; map(add-conditions(|conditions))
    ; map(traversal-to-joins(|x,xsrt,requiresalias); joins-to-optimization-branch(|x))

  add-conditions(|conditions) :
    traversal{anno*} -> traversal{JoinCondition(conds), anno*}
    with conds := <filter(?(traversal, <id>, True())); make-set> conditions // The condition list always has an element. If that element is an empty list then that means that there was no condition.

  prepare-traversal :
    (traversal1, srt, cond1, eff) -> (traversal3, cond2, eff)
    with traversal2 := <is-accessible-from(RootVar); Fst> traversal1 // This removes any unnecessary casts
    ; cond2 := <revalidate-query-condition(get-accessible-expr(try-strip-generic-sort,not(RootVar)))> cond1
    where traversal3 := <an-requires-joining-fa; try(?Cast(<id>, _))> (traversal2, srt)

  traversal-summary-to-query-condition =
    filter(?(_, _, <revalidate-query-condition(get-accessible-expr(id,not(RootVar)));and-query-condition>, True())) // We revalidate the conditions, to ensure that one side of the conditions contains the RootVar
    ; make-set
    ; try(?[]; ![True()]) // No condition means true
    ; or-query-condition

  is-accessible-condition-expr(|p) :
    (expr1, expr2) -> (newexpr1, newexpr2)
    where newexpr1 := <is-accessible-condition-expr-helper(|p)> expr1
    ; newexpr2 := <is-accessible-condition-expr-helper(|p)> expr2

  is-accessible-condition-expr-helper(|p) :
    expr -> RelativeFieldAccess(condcastsrt, f)
    where (e, srt) := <is-accessible-from(RootVar)>
    ; <try(strip-ref-sort); try-strip-generic-sort; not(is-entity-type)> srt // If the property has an entity type, then the value is not prefetched yet, so avoid using it in the prefetch specification.
    ; FieldAccess(f_expr, f) := <try(?Cast(<id>, _))> e
    //; <(?Cast(p_expr, condcastsrt); debug(!"cast:"); <debug(!"issub:");subtype-of;info(|"yes")> (<strip-annos>castsrt, <strip-annos>condcastsrt); !condcastsrt; topdown(add-type-annotations); ?relcastsrt) <+ (?p_expr; info(|"nocast");relcastsrt := None())> f_expr
    ; (p_expr, condcastsrt) := <(\ Cast(castexpr, castsrt) -> (castexpr, newsrt) with newsrt := <topdown(add-type-annotations)> castsrt \) <+ !(<id>, None())> f_expr
    ; psrt := <expr-matches-path(|p)> p_expr
    with <?(None(), _) <+ subtype-of> (<strip-annos> condcastsrt, <try(strip-ref-sort); try-strip-generic-sort; strip-annos> psrt) // The cast should always be valid

  expr-matches-path(|p) :
    FieldAccess(e, f) -> fsrt
    where [(f, SimpleSort(dec_class))|nextp] := p
    ; esrt := <expr-matches-path(|nextp)> e
    ; SimpleSort(e_class) := <try(strip-ref-sort); try-strip-generic-sort> esrt
    ; dec_class := <class-of-property> (e_class, f) // If dec_class is not the same as that on the path, then the expression does not match the path.
    ; fsrt := <get-prop-type; strip-ref-sort; topdown(add-type-annotations)> (dec_class, f)

  expr-matches-path(|p) :
    Cast(e, srt) -> srt
    where <expr-matches-path(|p)> e

  expr-matches-path(|p) :
    v@Var(_) -> srt
    where [] := p
    ; srt := <RootVar> v

  is-accessible-condition-expr-helper(|p) = where(is-query-condition-constant)
  is-accessible-condition-expr-helper(|p) = where(is-accessible-from(BindableVar))

  revalidate-join-condition(|p) =
    map(filter(extract-query-cond(is-accessible-condition-expr(|p))); and-query-condition)
    ; or-query-condition
    ; (?True() < !None() + !PrefetchCondition(<id>))

  revalidate-join-conditions(|p) :
    PrefetchNode(castsrt, f{PrefetchPropAnno(decsrt,fsrt)}, templ, cond, children){anno1*}
    -> PrefetchNode(castsrt, f{PrefetchPropAnno(decsrt,fsrt)}, templ, newcond, newchildren){anno2*}
    with
      anno2* := <remove-all(?JoinCondition(_))> anno1*
      ; cond2 := <(fetch-elem(?JoinCondition(<revalidate-join-condition(|p)>))) <+ !None()> anno1*
      ; newcond := <combine-prefetch-conditions> (cond, cond2)
      ; newp := [(f{}, decsrt)|p]
      ; newchildren := <get-prefetch-children; map(revalidate-join-conditions(|newp)); wrap-prefetch-children> children

  traversal-to-joins(|x,xsrt,requiresalias):
    expr@FieldAccess(e, f{annof*}){anno*} -> [PrefetchNode(castsrt, f{PrefetchPropAnno(decsrt,fsrt)}, None(), None(), None()){newanno*} | prev]
    with <?Cast(p, _) <+ ?p> e
    ; castsrt := <(?Cast(_, <id>); add-type-annotations; !Some(<id>)) <+ !None()> e
    ; prev@[PrefetchNode(_, _{PrefetchPropAnno(_,p_fsrt)}, _, _, _)|_] := <traversal-to-joins(|x,xsrt,requiresalias)> p
    ; SimpleSort(e_class) := <(?Some(<id>) <+ !p_fsrt); try(strip-ref-sort); try-strip-generic-sort> castsrt
    ; dec_class := <class-of-property> (e_class, f)
    ; decsrt := <add-type-annotations> SimpleSort(dec_class)
    ; fsrt := <get-prop-type; strip-ref-sort; topdown(add-type-annotations)> (dec_class, f)
    ; newanno* := <filter(keep-anno-in-query-optimization <+ ?JoinCondition(_)); try(add-lazy-anno(|dec_class, f, fsrt)); try(add-alias-anno(|expr,requiresalias))> anno*

  traversal-to-joins(|x,xsrt,requiresalias):
    Var(x) -> [PrefetchNode(None(), None(){PrefetchPropAnno(None(),srt)}, None(), None(), None())]
    with srt := <strip-ref-sort> xsrt

  // Does the same as below
  joins-to-optimization-branch(|x) =
    reverse
    ; ?[_|<id>]
    ; foldr(!None(), joins-to-optimization-branch-helper)
    ; ?PrefetchChildren([<id>])

  joins-to-optimization-branch-helper :
    (PrefetchNode(castsrt, name, templ, cond, None()){anno*}, children)
    ->
    PrefetchChildren([PrefetchNode(castsrt, name, templ, cond, children){anno*}])
    

  combine-branch-anno :
    (anno1*, anno2*) -> (anno3*, anno4*)
    where <fetch-elem(?JoinCondition(joins1))> anno1*
    ; <fetch-elem(?JoinCondition(joins2))> anno2*
    ; joins3 := <conc; make-set> (joins1, joins2)
    ; anno3* := <remove-all(?JoinCondition(_)); ![JoinCondition(joins3)|<id>]> anno1*
    ; anno4* := <remove-all(?JoinCondition(_))> anno2*

  merge-optimization-branches :
    (branch@PrefetchNode(_, name, _, _, _), tree) -> [subtree | keep]
    with keep := <remove-all(?PrefetchNode(_, name, _, _, _))> tree
    ; subtree := <fetch-elem(?PrefetchNode(_, name, _, _, _)) < combine-optimization-branches(|branch) + !branch> tree

  combine-optimization-branches(|branch) :
    PrefetchNode(castsrt1, f{PrefetchPropAnno(decsrt,fsrt)}, templ1, cond1, children1){anno1*}
    -> PrefetchNode(newcastsrt, f{PrefetchPropAnno(decsrt,fsrt)}, newtempl, newcond, newchildren){anno3*}
    where PrefetchNode(castsrt2, f{PrefetchPropAnno(decsrt,fsrt)}, templ2, cond2, PrefetchChildren([subtree2])){anno2*} := branch
    with anno3* := <repeat(combine-branch-anno); Fst> (anno1*, anno2*)
    ; newcastsrt := <combine-cast-sort(|decsrt)> (castsrt1, castsrt2)
    ; newtempl := <combine-prefetch-if-default> (templ1, templ2)
    ; newcond := <combine-prefetch-conditions> (cond1, cond2)
    ; subtree1 := <get-prefetch-children> children1
    ; newchildren := <merge-optimization-branches; wrap-prefetch-children> (subtree2, subtree1)

  combine-optimization-branches(|branch) :
    PrefetchNode(castsrt1, f{PrefetchPropAnno(decsrt,fsrt)}, templ1, cond1, children){anno1*}
    -> PrefetchNode(newcastsrt, f{PrefetchPropAnno(decsrt,fsrt)}, newtempl, newcond, children){anno3*}
    where PrefetchNode(castsrt2, f{PrefetchPropAnno(decsrt,fsrt)}, templ2, cond2, None()){anno2*} := branch
    with anno3* := <repeat(combine-branch-anno); Fst> (anno1*, anno2*)
    ; newcastsrt := <combine-cast-sort(|decsrt)> (castsrt1, castsrt2)
    ; newtempl := <combine-prefetch-if-default> (templ1, templ2)
    ; newcond := <combine-prefetch-conditions> (cond1, cond2)

  combine-prefetch-if-default : (None(), templ) -> templ
  combine-prefetch-if-default : (templ, None()) -> templ
  combine-prefetch-if-default :
    (PrefetchIfDefault(templ1), PrefetchIfDefault(templ2)) -> PrefetchIfDefault(templ)
    with templ := <conc; make-set> (templ1, templ2)

  combine-prefetch-conditions : (None(), cond) -> cond
  combine-prefetch-conditions : (cond, None()) -> cond
  combine-prefetch-conditions :
    (PrefetchCondition(cond1), PrefetchCondition(cond2)) -> cond
    with cond := <or-query-condition-helper; (?True() < !None() + !PrefetchCondition(<id>))> (cond1, cond2)

  wrap-prefetch-children : [] -> None()
  wrap-prefetch-children : lst -> PrefetchChildren(lst) where <is-list> lst; not([] := lst)

  combine-cast-sort(|decsrt) :
    (None(), _) -> None()

  combine-cast-sort(|decsrt) :
    (_, None()) -> None()

  combine-cast-sort(|decsrt) :
    (Some(srt1), Some(srt2)) -> Some(srt2)
    where <subtype-of> (srt1, srt2)

  combine-cast-sort(|decsrt) :
    (Some(srt1), Some(srt2)) -> Some(srt1)
    where <subtype-of> (srt2, srt1)

  combine-cast-sort(|decsrt) :
    (Some(srt1), Some(srt2)) -> Some(decsrt)
    where <not(subtype-of)> (srt1, srt2)
    ; <not(subtype-of)> (srt2, srt1)

  merge-conditional-optimization-branches :
    ((cond, branches), tree) -> newtree
    with newtree := <foldr(!tree, merge-conditional-optimization-branch(|cond))> branches

  merge-conditional-optimization-branch(|cond) :
    (branch@PrefetchNode(_, name, _, _, _), tree) -> [subtree | keep]
    with keep := <remove-all(?PrefetchNode(_, name, _, _, _))> tree
    ; subtree := <fetch-elem(?PrefetchNode(_, name, _, _, _)) < combine-conditional-optimization-branches(|cond, branch) + <add-condition-to-branch(|cond)>branch> tree

  combine-conditional-optimization-branches(|templcond, branch) :
    PrefetchNode(castsrt, f{PrefetchPropAnno(decsrt,fsrt)}, templ, cond, children1){anno1*}
    -> PrefetchNode(castsrt, f{PrefetchPropAnno(decsrt,fsrt)}, newtempl, cond, newchildren){anno3*}
    where PrefetchNode(_, f{PrefetchPropAnno(decsrt,fsrt)}, _, _, PrefetchChildren([subtree2])){anno2*} := branch
    with subtree1 := <get-prefetch-children> children1
    ; newchildren := <merge-conditional-optimization-branch(|templcond); wrap-prefetch-children> (subtree2, subtree1)
    ; anno3* := <repeat(combine-branch-anno); Fst> (anno1*, anno2*)
    ; newtempl := <try(add-template-condition-to-branch-if-not-first(|templcond))> templ

  combine-conditional-optimization-branches(|templcond, branch) :
    PrefetchNode(castsrt, f{PrefetchPropAnno(decsrt,fsrt)}, templ, cond, children){anno1*}
    -> PrefetchNode(castsrt, f{PrefetchPropAnno(decsrt,fsrt)}, newtempl, cond, children){anno3*}
    where PrefetchNode(_, f{PrefetchPropAnno(decsrt,fsrt)}, _, _, None()){anno2*} := branch
    with anno3* := <repeat(combine-branch-anno); Fst> (anno1*, anno2*)
    ; newtempl := <try(add-template-condition-to-branch-if-not-first(|templcond))> templ

  add-condition-to-branch(|templcond) :
    PrefetchNode(castsrt, f{PrefetchPropAnno(decsrt,fsrt)}, templ, cond, PrefetchChildren([subtree])){anno*}
    -> PrefetchNode(castsrt, f{PrefetchPropAnno(decsrt,fsrt)}, newtempl, cond, PrefetchChildren([newsubtree])){anno*}
    with newsubtree := <add-condition-to-branch(|templcond)> subtree
    ; newtempl := <combine-prefetch-if-default> (templ, PrefetchIfDefault([templcond]))

  add-condition-to-branch(|templcond) :
    PrefetchNode(castsrt, f{PrefetchPropAnno(decsrt,fsrt)}, templ, cond, None()){anno*}
    -> PrefetchNode(castsrt, f{PrefetchPropAnno(decsrt,fsrt)}, newtempl, cond, None()){anno*}
    with newtempl := <combine-prefetch-if-default> (templ, PrefetchIfDefault([templcond]))

  add-template-condition-to-branch-if-not-first(|cond) :
    PrefetchIfDefault(oldcond) -> PrefetchIfDefault(newcond) 
    with newcond := <make-set>[cond|oldcond]

	log-query-optimization-collect-basic =
	  make-set
	  ; map(info(|["Traversal: ", <id>]))

	log-query-optimization-collect-table(|col1,col2,col3) =
	  info(|["+-", <align-helper(|'-', col1)>"", "-+-", <align-helper(|'-', col2)>"", "-+-", <align-helper(|'-', col3)>"", "-+"])
	  ; info(|["| Path", <align-helper(|' ', col1)>"Path", " | Condition", <align-helper(|' ', col2)>"Condition", " | Need", <align-helper(|' ', col3)>"Need", " |"])
	  ; info(|["|-", <align-helper(|'-', col1)>"", "-+-", <align-helper(|'-', col2)>"", "-+-", <align-helper(|'-', col3)>"", "-|"])
	  ; make-set
	  ; map({col1Val, col2Val, col3Val, str1, str2, str3, align1, align2, align3:?(col1Val, _, col2Val, col3Val)
	    ; str1 := <webdsl-to-abox; box2text-string(|col1)> col1Val
	    ; str2 := <?[] < !"" + (map(webdsl-to-abox; box2text-string(|col2)); separate-by(|" && "); concat-strings)> col2Val
	    ; str3 := <?True() < !"true" + !"false"> col3Val
	    ; align1 := <align-helper(|' ', col1)> str1
	    ; align2 := <align-helper(|' ', col2)> str2
	    ; align3 := <align-helper(|' ', col3)> str3
	    ; <concat-strings>["| ", str1, align1, " | ", str2, align2, " | ", str3, align3, " |"]
	      }
	      //<concat-strings>["| ", <Fst;pp-webdsl-to-string>, <Fst;pp-webdsl-to-string;align-helper(|' ', col1)>, " | ", <Third;pp-webdsl-to-string>, <Third;pp-webdsl-to-string; align-helper(|' ', col2)>, " | ", <?(_, _, _, <id>);pp-webdsl-to-string>, <?(_, _, _, <id>);pp-webdsl-to-string;align-helper(|' ', col3)>, " |"]
	    )
	  ; make-set
	  ; string-sort
	  ; map(info(|<id>))
	  ; info(|["+-", <align-helper(|'-', col1)>"", "-+-", <align-helper(|'-', col2)>"", "-+-", <align-helper(|'-', col3)>"", "-+"])

	add-alias-anno(|expr,requiresalias) :
	  anno* -> newanno*
	  where alias := <property-to-alias> expr
	  ; <fetch-elem(?alias)> requiresalias
	  ; newanno* := [RequiresAlias()|anno*]

	sub-paths :
	  fa@FieldAccess(p, _) -> [fa | subpaths]
	  with subpaths := <sub-paths> p

	sub-paths :
	  Cast(p, _) -> subpaths
	  with subpaths := <sub-paths> p

	sub-paths :
	  Var(_) -> []

  keep-anno-in-query-optimization = fail//?MultipleDefinitionsInSubclasses()

  an-requires-joining-fa :
    (fa@FieldAccess(_, _), srt) -> cleanfa
    where <is-generic-sort <+ is-entity-type> srt
    ; cleanfa := <clean-joincandidate> fa

  an-requires-joining-fa :
    (FieldAccess(expr, _), srt) -> cleanexpr
    where(<not(is-generic-sort <+ is-entity-type)> srt)
    ; not([] := <collect(?FieldAccess(_, _))> expr) // The expression must contain at least another FieldAccess, otherwise it's just a Var with a value type fieldaccess
    ; cleanexpr := <clean-joincandidate> expr

  clean-joincandidate :
    FieldAccess(p, f){anno*} -> FieldAccess(cleanp, f{}){newanno*}
    where newanno* := <filter(keep-anno-in-query-optimization); make-set> anno*
    ; cleanp := <clean-joincandidate> p

  clean-joincandidate :
    Cast(p, srt) -> Cast(cleanp, srt{}){}
    where cleanp := <clean-joincandidate> p

  clean-joincandidate :
    v@Var(_) -> v{}

  add-lazy-anno(|ent,f, srt) :
    anno* -> [IsLazyFetch() | anno*]
    where SimpleSort(invEnt) := srt
    ; invProp := <InverseProperty; PropertyDecl> (ent, f)
    ; SimpleSort(ent) := <get-property-type> invProp
    ; <get-property-annos; fetch-elem(?InverseAnno(ent, f))> invProp // Is the inverse side the owning side?
      
  is-accessible-from-allow-calls(s) =
    replace-calls-to-return-values(s)
    //; debug(!"replace-calls-to-return-values:")
    ; filter(is-accessible-from(s))
    //; debug(!"is-accessible-from:")
    ; not(?[])

  replace-calls-to-return-values(s) :
    FieldAccess(p, f){anno*} -> results
    where subpaths := <replace-calls-to-return-values(s)> p
    ; results := <map(!FieldAccess(<id>, f){anno*})> subpaths

  replace-calls-to-return-values(s) :
    Cast(p, srt){anno*} -> results
    where subpaths := <replace-calls-to-return-values(s)> p
    ; results := <map(!Cast(<id>, srt){anno*})> subpaths

  replace-calls-to-return-values(s) :
    v@Var(_) -> [v]

  replace-calls-to-return-values(s) :
    Call(e, nm, args) -> results
    where subpaths := <replace-calls-to-return-values(s)> e
    ; results := <filter(expand-call-to-return-values(s|nm, args)); flatten-list; make-set> subpaths

  expand-call-to-return-values(s|nm, args) :
    e -> results
    where <is-accessible-from(s); ?(e2, <is-entity-type; ?SimpleSort(ent)>)> e
    ; (n, targs) := <normalize-signature> (nm, args)
    ; (fent, Function(_, defargs, _, _){defanno*}) := <try-resolve-entity-call> (ent, n, targs)
    ; returns := <fetch-elem(get-returns-from-query-analysis)> defanno*
    with argmapping := <zip> (args, defargs)
    ; varmapping := <add-this-vars-to-mapping(|returns, e, ent)> argmapping
    ; results := <foldr(!returns, rename-vars-in-analysis(RootVar))> varmapping

  // The default generic sort handler is try-strip-generic-sort, to allow fieldaccesses on collections
  // For query conditions this is not allowed, so there id should be used to deal with generic sorts
  is-accessible-from(s) = is-accessible-from(s,try-strip-generic-sort)//; try(where(collect(?Cast(Cast(_, _), _)); not(?[])); debug(!"dbl:"))

  /*is-accessible-from(s,gen): // Cast where the cast is not needed
    Cast(f, srt){anno*} -> (p, srt)
    where (p, srt2) := <is-accessible-from(s,gen)> f
    ; <subtype-of> (<gen>srt2, srt) // up-cast or cast to same type*/

  is-accessible-from(s,gen):
    Cast(Cast(f, srt), srt2){anno*} -> (p, srt3)
    where <not(eq); subtype-of> (<gen>srt2, <gen>srt) // srt2 is more specific (subtype of srt)
    ; (p, srt3) := <is-accessible-from(s,gen)> Cast(f, srt2){anno*}

  is-accessible-from(s,gen):
    Cast(Cast(f, srt){anno*}, srt2) -> (p, srt3)
    where <subtype-of> (<gen>srt, <gen>srt2) // srt is more specific (subtype of srt2 or eq)
    ; (p, srt3) := <is-accessible-from(s,gen)> Cast(f, srt){anno*}

  is-accessible-from(s,gen): // Cast where the cast is needed
    Cast(f, srt){anno*} -> (Cast(p, srt){srt2, keepanno*}, srt)
    where not(Cast(_, _) := f)
    ; (p, srt2) := <is-accessible-from(s,gen)> f
    ; not(<gen;?srt> srt2) 
    ; <subtype-of> (srt, <gen>srt2) // down-cast
    ; keepanno* := <remove-all(?GenericSort(_, _) <+ ?SimpleSort(_))> anno*

  add-mutiple-definitions-anno: // srt is a sub entity of srt2
    fa@FieldAccess(Cast(p, srt){castanno*}, f){anno*} -> fa2
    where fa2 := <add-new-anno(|MultipleDefinitionsInSubclasses())> fa
    ; <fetch-elem(?srt2@SimpleSort(superent))> castanno*
    ; not(<get-prop-type> (superent, f)) // If the property is already defined on the source/super entity then there is no property clash
    //; info(|["Finding ", f, " from ", superent, " to ", srt])
    ; all-keys-EntDecl
    ; filter({x_sub: // We find out on which sub entities property f is defined
                ?x_sub
                ; where(
                    <not(eq)>(x_sub, superent)
                    ; <subtype-of>(SimpleSort(x_sub), srt2)
                    ; <TypeOfProperty> (x_sub, f) // Deliberate use of TypeOfProperty instead of type-of-property
                )
             })
    ; not(?[_]) // If not defined on exactly one sub entity
    //; debug(!"Match:")

  update-iterator-context :
    anno* -> [IteratorContext(ic)|keep]
    with keep := <remove-all(?IteratorContext(_))> anno*
    ; ic := <bigbagof-IteratorContext>

  remove-top-level-cast:
    Cast(f, _) -> f

  is-accessible-from(s,gen):
    FieldAccess(v, f){anno*} -> (fa, srt)
    where /*debug(!"is-accessible-from-fa-begin:");*/(p, psrt) := <is-accessible-from(s,gen)> v
    ; <gen; ?SimpleSort(x_class)> psrt
    ; not(<is-derived-property> (x_class, f))
    ; srt := <get-prop-type; strip-ref-sort> (x_class, f)
    ; f2 := <try(get-real-col-prop-name(|x_class, srt))> f
    ; fa := <try(add-naturalid-anno(|x_class)); try(add-mutiple-definitions-anno)> FieldAccess(p, f2){anno*}
    //; <debug(!"is-accessible-from-fa-end:")> (fa, srt)

  is-accessible-from(s,gen):
    v@Var(_) -> (v, srt)
    where /*debug(!"is-accessible-from-v-begin:");*/srt := <s; strip-ref-sort> v//; <debug(!"is-accessible-from-v-end:")> (v, srt)

  get-real-col-prop-name(|x_class, srt) =
    where(GenericSort("List", lsrt) := srt)
    ; where(string-ends-with(|"List"))
    ; string-as-chars(take(!(<length>, 4); subt)) // Get the real property name
    ; where(<get-prop-type> (x_class, <id>); ?GenericSort(_, lsrt)) // Check if the simple sort of the collections match

  add-naturalid-anno(|x_class) :
    fa@FieldAccess(_, f){anno*} -> fa2
    where f := <natural-id-name-include-superclass> x_class
    ; fa2 := <add-new-anno(|IsNaturalId())> fa 
/*// Replaced by: or-query-condition
  join-conditions:
    (cond, []) -> cond

  join-conditions:
    (cond, True()) -> cond

  join-conditions:
    (cond, prevCond) -> Or(prevCond, cond)
    where <not(?True()); not(?[])> prevCond
*/
/*// Replaced by: and-query-condition-helper
  append-condition:
    (newCond, oldCond) -> And(newCond, oldCond)
    where <not(?True())>newCond; <not(?True())>oldCond

  append-condition:
    (newCond, True()) -> newCond

  append-condition:
    (True(), oldCond) -> oldCond
*/

  add-this-vars-to-mapping(|from, e, ent) :
    mapping -> newmapping
    with thisargs := <get-this-args(|ent)> from
    ; thismapping := <map(!(e, <id>))> thisargs
    ; newmapping := <conc> (mapping, thismapping)
    
  get-this-args(|ent) :
    from -> thisargs
    with thisvars := <collect(?Var("this")); make-set> from
    ; thisargs := <map(?Var(<id>); !Arg(<id>, SimpleSort(ent)))> thisvars

  get-prop-type: (x_class, prop) -> <type-of-property>

  get-prop-type: (x_class, prop) -> <EntityIdType> x_class
    where <EntityIdName; ?prop> x_class

  get-all-entity-properties-as-fargs =
    get-all-entity-properties-as-mapping(|None())
    ; map(Snd)

  get-all-entity-properties-as-mapping(|e) =
    all-entity-properties-tuples
    ; map(entity-property-tuple-to-mapping(|e))

  entity-property-tuple-to-mapping(|e) :
    (ent, prop) -> ( FieldAccess(e, name), Arg(name{uniquename}, srt))
    with name := <get-property-name> prop
    ; uniquename := <PropertyNameToUniqueName> (ent, name)
    ; srt := <get-property-type> prop

  get-all-entity-properties-for-rename(|prefix) =
    all-entity-properties-tuples
    ; {|OverridePropName
       : map({\ (ent, prop) -> <id> with propname := <get-property-name> prop; rules(OverridePropName : propname -> (ent, prop)) \})
       ; dr-all-keys(|"OverridePropName")
       ; map(OverridePropName; {ent,prop,name,uniquename,safename,srt:\ (ent, prop) -> (name, uniquename, safename, srt) where name := <get-property-name> prop; uniquename := <PropertyNameToUniqueName> (ent, name); safename := name{<concat-strings>[prefix, "_", name]}; srt := <get-property-type> prop \})
       |}

  // Same as resolve-entity-call, except here we allow failure
  // It also does not return functions that have an overridden version and it is unsure which version will be used
  try-resolve-entity-call = ?(ent, nm, targ*); try-resolve-entity-call-without-override-check; ?(fent, f); where(<subentities-do-no-override> (fent, nm, targ*))

  try-resolve-entity-call-without-override-check: (ent, nm, targ*) -> result
    where not("Entity" := ent)
    ; f := <resolve-function-call-to-decl> (SimpleSort(ent), nm, targ*)
      < result := (ent, f)
      + result := <try-resolve-entity-call-without-override-check> (<Extends> ent, nm, targ*)

  subentities-do-no-override =
    ?(ent, nm, targ*)
    ; all-keys-EntDecl
    ; filter({x_sub:
                ?x_sub
                ; where(
                    <not(eq)>(x_sub, ent)
                    ; <subtype-of>(SimpleSort(x_sub), SimpleSort(ent))
                    ; <resolve-function-call-to-decl>(SimpleSort(x_sub), nm, targ*)
                )
             })
    //; (?[] <+ debug(!<concat-strings>[ent, "::", nm, " already defined for: "]))
    ; ?[]
