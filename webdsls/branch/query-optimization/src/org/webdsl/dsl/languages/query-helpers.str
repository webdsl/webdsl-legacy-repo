module org/webdsl/dsl/languages/query-helpers

imports // imports only needed for pp-aterm-box and box2text-string
  libstratego-gpp
  libstratego-aterm

strategies
  
  add-backend-annotation :
    PrefetchNode(castsrt, name{PrefetchPropAnno(decsrt,fsrt)}, neb, templ, cond, elemcond, children){anno*} ->
    PrefetchNode(castsrt, name{PrefetchPropAnno(decsrt2,fsrt2)}, neb, templ, cond, elemcond, children){anno*}
    where decsrt2 := <add-type-annotations> decsrt
    ; fsrt2 := <topdown(add-type-annotations)> fsrt
    ; not(decsrt := decsrt2; fsrt := fsrt2)

  add-backend-annotation :
    TemplateArgOrThis(n, args){anno*} -> TemplateArgOrThis(n, args){TemplateName(genname),anno*}
    where <not(fetch-elem(?TemplateName(_)))> anno*
    with targs := <map(try(get-prefetch-this-type)/*where(collect(?PrefetchThis()); ?[]) <+ type-of*/); prepare-type-list-for-compare> args
    ; genname := <generate-template-name> (n, targs)

  get-prefetch-this-type : Cast(PrefetchThis(), srt) -> srt
  get-prefetch-this-type : PrefetchThis(){anno*} -> srt
    where <fetch-elem(?PrefetchAnno(srt))> anno*


  add-query-condition-filter-annotation :
    PrefetchNode(castsrt, name{PrefetchPropAnno(decsrt,fsrt)}, neb, templ, cond, PrefetchWhere(elemcond){pwanno*}, children){anno*} ->
    PrefetchNode(castsrt, name{PrefetchPropAnno(decsrt,fsrt)}, neb, templ, cond, PrefetchWhere(elemcond){fltr,pwanno*}, children){anno*}
    where not(<fetch-elem(?QueryConditionFilter(_, _, _))> pwanno*)
    ; not(True() := elemcond)
    ; GenericSort(_, [elemsrt@SimpleSort(_)]) := fsrt
    with fltrs := <or-to-list; make-set; map(get-filters-for-conditions(|elemsrt))> elemcond
    ; fltr@QueryConditionFilter(_, _, _) := <combine-query-condition-filters> fltrs

  add-filter-anno-to-prefetch-where(|srt) :
    pw@PrefetchWhere(cond){anno*} -> pw{fltr,anno*} 
    where SimpleSort(_) := srt
    ; not(<fetch-elem(?QueryConditionFilter(_, _, _))> anno*)
    ; not(True() := cond)
    with fltrs := <or-to-list; make-set; map(get-filters-for-conditions(|srt))> cond
    ; fltr@QueryConditionFilter(_, _, _) := <combine-query-condition-filters> fltrs

  rename :
    PrefetchFor(x, templ1, fltr1, tree1){anno*} -> PrefetchFor(y, templ2, fltr2, tree2){anno*}
    with y := <rename-all> x
    ; srt := <type-of; strip-immutable-anno> y
    ; templ2 := <rename-all; rename-prefetch(|srt)> templ1
    ; fltr2 := <rename-all; rename-prefetch(|srt)> fltr1
    ; tree2 := <rename-all; rename-prefetch(|srt)> tree1
    //; <debug(!"out:")> PrefetchFor(y, templ2, fltr2, tree2){anno*}

  rename-prefetch(|srt):
    PrefetchChildren(children){anno*} -> PrefetchChildren(children2){anno*}
    with children2 := <map(try(rename-prefetch(|srt)))> children

  rename-prefetch(|srt): None(){anno*} -> None(){anno*}

  rename-prefetch(|srt):
    PrefetchNode(castsrt, name, neb, templ, cond, elemcond, children){anno*} -> PrefetchNode(castsrt, name{PrefetchPropAnno(decsrt,fsrt)}, neb, templ2, cond2, elemcond2, children2){newanno*}
    where SimpleSort(x_class) := <try(?Some(<id>)); (?SimpleSort(_) <+ !srt); try(strip-ref-sort); try-strip-generic-sort> castsrt
    ; n := <strip-annos> name
    ; dec_class := <class-of-property> (x_class, n)
    ; decsrt := SimpleSort(dec_class)
    ; fsrt := <get-prop-type; strip-ref-sort> (dec_class, n)
    ; ssrt := <try-strip-generic-sort> srt
    ; sfsrt := <try-strip-generic-sort> fsrt
    ; templ2 := <rename-prefetch(|fsrt)> templ
    ; cond2 := <rename-prefetch(|ssrt)> cond
    ; elemcond2 := <rename-prefetch(|sfsrt)> elemcond
    ; children2 := <rename-prefetch(|fsrt)> children
    ; newanno* := <try(where(not(fetch-elem(?IsLazyFetch()))); add-lazy-anno(|dec_class,n, fsrt))> anno*

  rename-prefetch(|srt):
    PrefetchCondition(cond){anno*} -> PrefetchCondition(cond2){anno*}
    where cond2 := <alltd(add-type-anno-to-relative-fa(|srt))> cond

  rename-prefetch(|srt):
    PrefetchWhere(cond){anno*} -> PrefetchWhere(cond2){anno*}
    where cond2 := <alltd(add-type-anno-to-relative-fa(|srt))> cond

  rename-prefetch(|srt):
    PrefetchTemplateArgs(templ1){anno*} -> PrefetchTemplateArgs(templ2){anno*}
    where templ2 := <alltd(add-type-anno-to-prefetch-this(|srt))> templ1

  /*add-type-anno-to-prefetch-this(|srt) :
    Cast(PrefetchThis(){anno*}, castsrt){canno*} -> Cast(PrefetchThis(){PrefetchAnno(srt),anno*}, castsrt){canno*}
    where not(<fetch-elem(?PrefetchAnno(_))> anno*)*/

  add-type-anno-to-prefetch-this(|srt) :
    PrefetchThis(){anno*} -> PrefetchThis(){PrefetchAnno(ssrt),anno*}
    where not(<fetch-elem(?PrefetchAnno(_))> anno*)
    ; ssrt := <try-strip-generic-sort> srt

  add-type-anno-to-relative-fa(|srt) :
    fa@RelativeFieldAccess(castsrt, f){anno*} -> fa{PrefetchPropAnno(decsrt,fsrt),anno*}
    where <not(fetch-elem(?PrefetchPropAnno(_, _)))> anno*
    ; SimpleSort(x_class) := <(?SimpleSort(_) <+ !srt); try(strip-ref-sort); try-strip-generic-sort> castsrt
    ; fn := <strip-annos> f
    ; dec_class := <class-of-property> (x_class, fn)
    ; decsrt := SimpleSort(dec_class)
    ; fsrt := <get-prop-type> (x_class, fn)

  type-of :
    PrefetchThis(){anno*} -> srt
    where <fetch-elem(?PrefetchAnno(srt))> anno*

  type-of :
    RelativeFieldAccess(_, _){anno*} -> srt
    where <fetch-elem(?PrefetchPropAnno(_, srt))> anno*

  constraint-error-data =
    ?PrefetchChildren(children)
    ; keys := <map(\ PrefetchNode(_, name, _, _, _, _, _) -> name \)> children
    ; key{PrefetchPropAnno(decsrt,fsrt)} := <make-set; fetch-elem(has-duplicates(|keys))> keys
    ; <filter(?PrefetchNode(_, key, _, _, _, _, _))> children
    ; add-error(|["Multiple prefetches defined for ", <pp-type>decsrt, ".", key, " of type ", <pp-type> fsrt])

  constraint-error-data =
    ?PrefetchFor(x, _, _, _)
    ; where(<not(?Var(_)) <+ (?Var(_); not(type-of; is-entity-type))> x)
    ; add-error(|["Prefetching can only be defined for variables of an entity type"])

  constraint-error-data =
    ?PrefetchFor(x, _, _, tree)
    ; where(
        Var(_) := x
        ; srt := <type-of; try(strip-ref-sort); strip-immutable-anno; try-strip-generic-sort; is-entity-type> x
      )
    ; <constrain-prefetch-helper(|srt)> tree

  constrain-prefetch-helper(|srt) =
    ?PrefetchChildren(children){anno*}
    ; <fetch-elem(constrain-prefetch-helper(|srt))> children

  constrain-prefetch-helper(|srt) =
    ?PrefetchNode(castsrt, name, neb, templ, cond, elemcond, children){anno*}
    ; where(<?Some(castsrt2); !(castsrt2, srt); not(subtype-of)> castsrt)
    ; add-error(|["Cannot cast from type ", <pp-type> srt, " to type ", <pp-type> castsrt2])

  constrain-prefetch-helper(|srt) =
    ?PrefetchNode(castsrt, name, neb, templ, cond, elemcond, children){anno*}
    ; where(
        SimpleSort(x_class) := <try(?Some(<id>)); (?SimpleSort(_) <+ !srt)> castsrt
        ; <subtype-of> (SimpleSort(x_class), srt)
        ; n := <strip-annos> name
      )
    ; if where(dec_class := <class-of-property> (x_class, n)) then
        fsrt := <get-prop-type> (dec_class, n)
        ; elemsrt := <try-strip-generic-sort> fsrt
        ; res := <constrain-prefetch-helper(|elemsrt)> children
      else
        add-error(|["No property ", n, " defined for ",<pp-type> SimpleSort(x_class)])
      end

  constrain-prefetch-helper(|srt) =
    ?PrefetchNode(castsrt, name, neb, templ, cond, elemcond, children){anno*}
    ; where(
        SimpleSort(x_class) := <try(?Some(<id>)); (?SimpleSort(_) <+ !srt)> castsrt
        ; <subtype-of> (SimpleSort(x_class), srt)
      )
    ; <?PrefetchCondition(<id>)> cond
    ; constrain-prefetch-condition-cast(|srt)

  constrain-prefetch-condition-cast(|srt) =
    collect(?RelativeFieldAccess(_, _))
    ; fetch-elem(constrain-prefetch-relative-fa-cast(|srt))

  constrain-prefetch-condition(|srt) =
    ?PrefetchCondition(e)
    ; where(
        not(SimpleSort("Bool") := <type-of> e)
        ; <type-of> e // don't report when sub-expression was already wrong
      )
    ; add-error(|["expression ", <pp-webdsl> e, " should be of type Bool"])

  constrain-prefetch-relative-fa-cast(|srt) =
    ?RelativeFieldAccess(castsrt, _)
    ; where(
        not(None() := castsrt)
        ; <not(subtype-of)> (castsrt, srt)
      )
    ; add-error(|["Cannot cast from type ", <pp-type> srt, " to type ", <pp-type> castsrt])

  /*constraint-error-data =
    ?PrefetchFor(x, _, _, _)
    ?PrefetchNode(_, name{}, _, _, _, _)
    ; debug(!"unknown?")
    ; add-error(|["Cannot define prefetch for unknown property"])*/

      
  /*define-filter-for-query-condition(|x,e) :
    QueryCondition(cond) -> fltr
    where not(True() := cond)
    ; FieldAccess(v, f) := e
    ; SimpleSort(v_class) := <type-of> v
    ; f_class := <class-of-property> (v_class, f)
    //; SimpleSort(elem_class) := <get-prop-type; try-strip-generic-sort> (f_class, f)
    ; not(<is-derived-property> (f_class, f))
    with fltrs := <or-to-list; map(get-filters-for-conditions(|x, f_class, f))> cond
    ; fltr := <combine-query-condition-filters> fltrs*/

  define-filter-for-query-condition(|x,srt) :
    qc@QueryCondition(cond) -> fltr
    where not(True() := cond)
    ; PrefetchWhere(cond2) := <query-condition-to-prefetch-where(|x)> qc
    ; not(True() := cond2)
    with fltrs := <or-to-list; map(get-filters-for-conditions(|srt))> cond2
    ; fltr := <combine-query-condition-filters> fltrs

  add-query-condition-to-prefetch-where(|x) : // Manually specified condition precedes any detected condition
    (_, pw@PrefetchWhere(_)) -> pw

  add-query-condition-to-prefetch-where(|x) : // If no condition was detected then use whatever was specified manually
    (qc@QueryCondition(True()), pw) -> pw

  add-query-condition-to-prefetch-where(|x) :
    (qc@QueryCondition(cond), None()) -> pw
    where not(True() := cond)
    with pw := <query-condition-to-prefetch-where(|x); try(?PrefetchWhere(True()); !None())> qc

  get-filters-for-conditions(|srt) :
    cond -> fltr
    with (strcond, parammap) := <condition-expr-to-filter-condition(get-relative-prop-string)> (cond, [])
    ; fltr := <common-get-filters(|srt)> (strcond, parammap)

  /*get-filters-for-conditions(|x, srt) :
    cond -> fltr
    with (strcond, parammap) := <condition-expr-to-filter-condition(get-relative-prop-string(|x))> (cond, [])
    ; fltr := <common-get-filters(|srt)> (strcond, parammap)*/

  common-get-filters(|srt) =
    ?(strcond, parammap)
    ; SimpleSort(class) := srt
    ; ordered_parammap := <reverse> parammap // Because new parameter mappings are added to the front of the list, a reverse gives an ascending parammap
    ; vars := <map(Fst)> ordered_parammap
    ; types := <map(Third)> ordered_parammap
    ; name := <get-filter-name-for-condition> (class, strcond, types)
    //; vars := <collect(?Var(_)); make-set; filter(not(?Var(x)))> cond
    //; types := <map(type-of)> vars
    //; parammap := <add-indices> vars
    //; newcond := <alltd(replace-vars-with-param(|parammap))> cond
    ; fltr := QueryConditionFilter(name, vars, types)
    //; fltrdef := QueryConditionFilterDef(name, types, strcond, [])
    //; <declare-query-condition-filter> (f_class, f, fltrdef)

  get-relative-prop-string(|x) =
    where(collect(?Var(x)); not(?[]))
    ; property-to-string

  get-relative-prop-string :
    RelativeFieldAccess(_, e) -> str
    where not(type-of; is-entity-type)
    with str := <concat-strings>["`_",e,"`"]

  get-relative-prop-string :
    RelativeFieldAccess(_, e){anno*} -> str
    where <fetch-elem(?PrefetchPropAnno(decsrt,fsrt))> anno*
    ; SimpleSort(x_class) := decsrt
    ; <is-entity-type> fsrt
    with str := <concat-strings>["`", x_class, "_",e,"`"]

  get-filter-name-for-condition :
    (class, cond, types) -> name
    where name := <FilterFromCondition> (class, cond, types)

  get-filter-name-for-condition :
    (class, cond, types) -> name
    where <not(FilterFromCondition)> (class, cond, types)
    ; name := <concat-strings; newname> [class, "_fltr"]
    ; fltrdef := QueryConditionFilterDef(name, types, cond, [])
    ; <declare-query-condition-filter> (class, fltrdef)
    ; rules( FilterFromCondition : (class, cond, types) -> name )

  declare-query-condition-filter =
    ?(class, fltrdef@QueryConditionFilterDef(name, _, _, _))
    //; <debug(!"regfltr:")> (class, name)
    ; rules(  EntityFilters :+ class -> fltrdef
              CollectionFilterDef : name -> (class, fltrdef)
           )

  get-condition-filter-param : // Reuse existing parameter mapping
    (e, srt, parammap) -> (strparam, parammap)
    where (_, param, _) := <fetch-elem(?(e, _, srt))> parammap
    ; strparam := <concat-strings> [":param", <int-to-string> param] 

  get-condition-filter-param : // Create new parameter mapping
    (e, srt, parammap) -> (strparam, [newmap | parammap])
    where <not(fetch-elem(?(e, _, srt)))> parammap
    ; param := <length> parammap
    ; strparam := <concat-strings> [":param", <int-to-string> param] 
    ; newmap := (e, param, srt)

  condition-to-filter-string(dbprop-to-string) :
    (e, parammap) -> (str, parammap)
    where str := <dbprop-to-string> e

  condition-to-filter-string(dbprop-to-string) :
    (e, parammap) -> (paramstr, parammap2)
    where not(Null() := e)
    ; not(<dbprop-to-string> e)
    with srt := <type-of> e
    ; (paramstr, parammap2) := <get-condition-filter-param> (e, srt, parammap)

  condition-expr-to-filter-condition(dbprop-to-string):
    (Not(expr1), parammap) -> (str, parammap2)
    with (str1, parammap2) := <condition-expr-to-filter-condition(dbprop-to-string)> (expr1, parammap)
    ; str := <concat-strings> [ "not (", str1, ")" ]

  condition-expr-to-filter-condition(dbprop-to-string):
    (Or(expr1, expr2), parammap) -> (str, parammap3)
    with (str1, parammap2) := <condition-expr-to-filter-condition(dbprop-to-string)> (expr1, parammap)
    ; (str2, parammap3) := <condition-expr-to-filter-condition(dbprop-to-string)> (expr2, parammap2)
    ; str := <concat-strings> [ "(", str1, " or ", str2, ")" ]

  condition-expr-to-filter-condition(dbprop-to-string):
    (And(expr1, expr2), parammap) -> (str, parammap3)
    with (str1, parammap2) := <condition-expr-to-filter-condition(dbprop-to-string)> (expr1, parammap)
    ; (str2, parammap3) := <condition-expr-to-filter-condition(dbprop-to-string)> (expr2, parammap2)
    ; str := <concat-strings> [ "(", str1, " and ", str2, ")" ]

  condition-expr-to-filter-condition(dbprop-to-string):
    (SmallerThanOrEqual(expr1, expr2), parammap) -> (str, parammap2)
    where (str1, str2, parammap2) := <transform-both-props-for-filter(dbprop-to-string)>(expr1, expr2, parammap)
    ; str := <concat-strings> [ str1, " <= ", str2 ]

  condition-expr-to-filter-condition(dbprop-to-string):
    (SmallerThan(expr1, expr2), parammap) -> (str, parammap2)
    where (str1, str2, parammap2) := <transform-both-props-for-filter(dbprop-to-string)>(expr1, expr2, parammap)
    ; str := <concat-strings> [ str1, " < ", str2 ]

  condition-expr-to-filter-condition(dbprop-to-string):
    (LargerThanOrEqual(expr1, expr2), parammap) -> (str, parammap2)
    where (str1, str2, parammap2) := <transform-both-props-for-filter(dbprop-to-string)>(expr1, expr2, parammap)
    ; str := <concat-strings> [ str1, " >= ", str2 ]

  condition-expr-to-filter-condition(dbprop-to-string):
    (LargerThan(expr1, expr2), parammap) -> (str, parammap2)
    where (str1, str2, parammap2) := <transform-both-props-for-filter(dbprop-to-string)>(expr1, expr2, parammap)
    ; str := <concat-strings> [ str1, " > ", str2 ]

  condition-expr-to-filter-condition(dbprop-to-string) = ?(NotEq(expr1, expr2), parammap); !(expr1, expr2, parammap); condition-expr-to-filter-condition(dbprop-to-string|" <> ", " is not ")

  condition-expr-to-filter-condition(dbprop-to-string) = ?(Eq(expr1, expr2), parammap); !(expr1, expr2, parammap); condition-expr-to-filter-condition(dbprop-to-string|" = ", " is ")

  condition-expr-to-filter-condition(dbprop-to-string|op,nullop):
    (expr1, Null(), parammap) -> (str, parammap2)
    where not(Null() := expr1)
    ; (str1, parammap2) := <condition-to-filter-string(dbprop-to-string)> (expr1, parammap)
    ; str := <concat-strings> [str1, nullop, "null"]

  condition-expr-to-filter-condition(dbprop-to-string|op,nullop):
    (Null(), expr1, parammap) -> (str, parammap2)
    where not(Null() := expr1)
    ; (str1, parammap2) := <condition-to-filter-string(dbprop-to-string)> (expr1, parammap)
    ; str := <concat-strings> [str1, nullop, "null"]

  condition-expr-to-filter-condition(dbprop-to-string|op,nullop):
    (expr1, expr2, parammap) -> (str, parammap2)
    where not(Null() := expr1); not(Null() := expr2)
    ; (str1, str2, parammap2) := <transform-both-props-for-filter(dbprop-to-string)>(expr1, expr2, parammap)
    ; str := <concat-strings> [ str1, op, str2 ]

  transform-both-props-for-filter(dbprop-to-string):
    (expr1, expr2, parammap) -> (str1, str2, parammap3)
    where (str1, parammap2) := <condition-to-filter-string(dbprop-to-string)> (expr1, parammap)
    ; (str2, parammap3) := <condition-to-filter-string(dbprop-to-string)> (expr2, parammap2)

  revalidate-query-condition-filters :
    PrefetchNode(castsrt, f{PrefetchPropAnno(decsrt,fsrt)}, neb, templ, cond, elemcond, children){anno*} -> PrefetchNode(castsrt, f, neb, templ, cond, elemcond2, children){keep*}
    with cond1 := <fetch-elem(?PrefetchWhere(<or-to-list>)) <+ ![]> anno*
    ; cond2 := <?PrefetchWhere(<or-to-list>) <+ ![]> elemcond
    ; if <not(is-generic-sort)> fsrt <+ (<fetch-elem(?True())> cond1; not([] := cond2)) then // Do not add an automatic True() condition, when a manual condition was provided
        elemcond2 := elemcond
      else
        elemcond2 := <conc; make-set; or-query-condition; !PrefetchWhere(<id>)> (cond1, cond2)
      end
    ; keep* := <remove-all(?PrefetchWhere(_))> anno*
    //; fltrs := <or-to-list; map(get-filters-for-conditions)> cond
    //; fltr* := <combine-query-condition-filters < (debug(!"comb:");![<id>]) + ![]> fltrs

  combine-query-condition-filters :
    [fltr] -> fltr

  combine-query-condition-filters :
    fltrs -> fltr
    where <is-list; not(?[] <+ ?[_])> fltrs // A list with at least two filters
    with names := <map(get-query-condition-filter-name); make-set; string-sort> fltrs
    ; ordered := <map(combine-query-condition-filters-helper(|fltrs));flatten-list> names
    ; newargs := <map(get-query-condition-filter-args); concat> ordered
    ; QueryConditionFilterDef(name, types, _, _) := <get-def-for-filters> ordered
    ; <eq> (<length> newargs, <length> types)
    ; fltr := QueryConditionFilter(name, newargs, types)

  get-def-for-filters :
    ordered -> def
    where combinedname := <map(get-query-condition-filter-name); separate-by(!"_"); concat-strings> ordered
    ; fltrname := <CombinedFilterName> combinedname
    with (_, def) := <CollectionFilterDef> fltrname

  get-def-for-filters :
    ordered -> fltrdef
    where names := <map(get-query-condition-filter-name)> ordered
    ; combinedname := <separate-by(!"_"); concat-strings> names
    ; <not(CombinedFilterName)> combinedname
    with defs := <map(get-query-condition-filter-name; CollectionFilterDef; ?(class, <id>))> ordered // All filters should belong to the same property
    ; fltrname := <concat-strings; newname> [class, "_combined"]
    ; types := <map(get-query-condition-filter-def-types)> defs
    ; cond := <combine-conditions-of-filter-defs(|0)> defs
    //; subfltrs := <zip> (names, <map(length)> types)
    ; fltrdef := QueryConditionFilterDef(fltrname, <concat>types, cond, defs)
    ; rules(
        CombinedFilterName : combinedname -> fltrname
     )
    ; <declare-query-condition-filter> (class, fltrdef)

  combine-conditions-of-filter-defs(|prevtypes) :
    [QueryConditionFilterDef(_, types, cond, _)|other] -> newcond
    //with tmpcond := <alltd(add-to-query-condition-filter-param(|prevtypes));debug(!"this:")> cond
    with tmpcond := <length; range; foldr(!cond, add-to-query-condition-filter-param(|prevtypes))> types
    ; if [] := other then
        newcond := tmpcond
      else
        newtypes := <addi> (prevtypes, <length> types)
        ; othercond := <combine-conditions-of-filter-defs(|newtypes)> other
        //; newcond := Or(tmpcond, othercond)
        ; newcond := <concat-strings> ["(", tmpcond, " or ", othercond, ")"]
      end

  add-to-query-condition-filter-param(|prevtypes) :
    (i, cond) -> cond
    where <eq> (prevtypes, 0)

  add-to-query-condition-filter-param(|prevtypes) :
    (i, cond) -> newcond
    where <not(eq)> (prevtypes, 0)
    ; old := <concat-strings> [":param", <int-to-string> i]
    ; new := <concat-strings> [":param", <addi; int-to-string> (i, prevtypes)]
    ; newcond := <string-replace(|old, new)> cond

  /*add-to-query-condition-filter-param(|toadd) :
    QueryConditionFilterParam(i){anno*} -> QueryConditionFilterParam(newi){anno*}
    with newi := <addi> (i, toadd)*/

  combine-query-condition-filters-helper(|fltrs) :
    name -> fltrswithname
    with fltrswithname := <filter(where(get-query-condition-filter-name; ?name))> fltrs

  replace-vars-with-param(|parammap) :
    v@Var(_) -> QueryConditionFilterParam(i)
    where (i, v) := <fetch-elem(?(_, v))> parammap  

  add-filter-to-analysis(|x,anno*) =
    where(pw := <fetch-elem(?QueryCondition(_)) < query-condition-to-prefetch-where(|x) + !PrefetchWhere(True())> anno*)
    ; try(ensure-effectful-traversal-for-var(|x))
    ; map(try(add-filter-to-analysis-helper(|x, pw)))

  ensure-effectful-traversal-for-var(|x) =
    where(filter(?(Var(x), _, _, True())); ?[])
    ; ![(Var(x), <type-of> Var(x), <QueryConditions>, True()) | <id>]

  add-filter-to-analysis-helper(|x,pw) :
    (traversal, srt, condition, effectful){anno*} -> (traversal, srt, [pw|condition], effectful){anno*}
    where Var(x) := traversal

  query-condition-to-prefetch-where(|x) :
    QueryCondition(cond) -> PrefetchWhere(cond3)
    with cond2 := <or-to-list; make-set; or-query-condition; alltd(make-field-access-relative(|x))> cond
    ; cond3 := <where(collect(?FieldAccess(RelativeFieldAccess(_, _), _)); ?[]) <+ !True()> cond2 // If a joins would be needed, then change condition to true (do no use filter), because joins are not supported for filters

  make-field-access-relative(|x) :
    e@FieldAccess(Var(x), f) -> RelativeFieldAccess(None(), f){PrefetchPropAnno(decsrt,fsrt)}
    where SimpleSort(x_class) := <type-of; try(strip-ref-sort); try-strip-generic-sort> Var(x)
    ; fn := <strip-annos> f
    ; dec_class := <class-of-property> (x_class, fn)
    ; decsrt := SimpleSort(dec_class)
    ; fsrt := <get-prop-type> (x_class, fn)

  make-field-access-relative(|x) :
    e@FieldAccess(Cast(Var(x), castsrt), f) -> RelativeFieldAccess(castsrt, f){PrefetchPropAnno(decsrt,fsrt)}
    where srt := <type-of> Var(x)
    ; SimpleSort(x_class) := <(?SimpleSort(_) <+ !srt); try(strip-ref-sort); try-strip-generic-sort> castsrt
    ; fn := <strip-annos> f
    ; dec_class := <class-of-property> (x_class, fn)
    ; decsrt := SimpleSort(dec_class)
    ; fsrt := <get-prop-type> (x_class, fn)

  has-duplicates(|list) :
    key -> key
    where <filter(?key); not(length => 1)> list

  rename-query-optimization-annos = rename-query-optimization-annos(rename-all)

  rename-query-condition-anno :
    term@_{anno*} -> term{qc2,keep*}
    where qc1 := <fetch-elem(?QueryCondition(_))> anno*
    ; qc2 := <rename-all> qc1
    ; keep* := <remove-all(?QueryCondition(_))> anno*
      
  rename-query-condition-anno :
    term@_{anno*} -> term{qcf2,keep*}
    where qcf1 := <fetch-elem(?QueryConditionFilter(_, _, _))> anno*
    ; qcf2 := <rename-all> qcf1
    ; keep* := <remove-all(?QueryConditionFilter(_, _, _))> anno*

  add-query-optimization-to-argument(|analysis,bindableargs) :
    (arg@Arg(x, srt),b) -> b 
    where <not(filter(?arg); ?[])> bindableargs 

  add-query-optimization-to-argument(|qa,bindableargs) :
    (arg@Arg(x, srt),b1) -> b2
    where [] := <filter(?arg)> bindableargs
    ; (qc, b2) := <query-analysis-to-query-optimizition(|qa,x,srt,bindableargs)> b1

  template-body-ready = // Local redefines, derives and output lists should have been lifted
    where(
      collect(?Define(_, _, _, _, _) <+ ?Derive(_, _, _) <+ ?TemplateCall("dummy",_,_,TemplateBody(_)) <+ is-call-to-output-generic-sort)
      ; ?[]
    )

  action-body-ready =
    where(
      collect(is-property-access-without-this <+ ?ForExp(_, _, _, _, _))
      ; ?[]
    )

  is-property-access-without-this = // We wait for desugar-property-access so we can follow all properties by following Var("this")
    ?Var(_); type-of; is-property-type

  with-thisentity(s|anno*) =
    where(<fetch-elem(?FunctionEntity(x_class))> anno*)
    ; {| ThisEntity
       : rules( ThisEntity := x_class )
       ; s
       |}

  with-thisentity(s|anno*) =
    where(<not(fetch-elem(?FunctionEntity(_)))> anno*)
    ; s

rules

  rename-query-optimization-annos(rename-strategy) :
    anno* -> newanno*
    with toKeep* := <remove-all(is-query-optimization <+ is-query-analysis <+ ?QueryOptimizationVars(_, _, _, _))> anno*
      ; qo* := <(fetch-elem(is-query-optimization); rename-strategy; ![<id>]) <+ ![]> anno*
      ; qa* := <(fetch-elem(is-query-analysis); rename-strategy; ![<id>]) <+ ![]> anno*
      ; qovars* := <(fetch-elem(?QueryOptimizationVars(_, _, _, _)); rename-strategy; ![<id>]) <+ ![]> anno*
      ; newanno* := [qo*, qa*, qovars*, toKeep*]

	keep-least-specific-casts =
	  ?allcandidates
	  ; collect-all(?FieldAccess(Cast(_, _), _))
	  ; make-set
	  ; {| ToLessSpecificCast
	    : filter(declare-to-less-specific-cast-rules(|allcandidates))
	    ; <repeat(oncetd(ToLessSpecificCast))> allcandidates
	  |}
	  ; make-set

  filter-traversal-summary = filter(where(Fst; is-accessible-from(RootVar)))

	declare-to-less-specific-cast-rules(|allcandidates) :
	  fa1@FieldAccess(Cast(p, srt), f) -> (fa1, lessSpecific)
	  where allLessSpecific := <collect(is-less-specific-cast(|p, srt, f)); make-set> allcandidates
	  ; lessSpecific := <foldr(!fa1, is-less-specific-cast); not(?fa1)> allLessSpecific
	  ; rules( ToLessSpecificCast : fa1 -> lessSpecific )

	is-less-specific-cast(|p, srt, f) :
	  fa2@FieldAccess(Cast(p, srt2), f) -> fa2
	  where not(srt := srt2); <subtype-of>(srt, srt2)

	is-less-specific-cast(|p, srt, f) :
	  fa2@FieldAccess(p, f) -> fa2

	is-less-specific-cast:
	  (fa1@FieldAccess(Cast(p, srt), f), fa2) -> fa2
	  where <is-less-specific-cast(|p, srt, f)> fa2

	is-less-specific-cast:
	  (fa1, fa2@FieldAccess(Cast(p, srt), f)) -> fa1
	  where <is-less-specific-cast(|p, srt, f)> fa1

  traversal-summary-to-branches(|x,xsrt,requiresalias) =
    //map(prepare-traversal)
    //; filter(\ (fst, snd, trd, True()) ->  with <clean-joincandidate> fst \)
    //; with(conditions := <filter(prepare-condition(|x,xsrt))>)
    //; filter(!(<Fst>, <Snd>); an-requires-joining-fa; try(?Cast(<id>, _)))
    filter(prepare-traversal)
    ; ?conditions
    ; map(Fst)
    ; make-set
    ; map(add-conditions(|conditions))
    ; map(traversal-to-joins(|x,xsrt,requiresalias); joins-to-optimization-branch(|x))

  add-conditions(|conditions) :
    traversal{anno*} -> traversal{JoinCondition(conds), PrefetchWhere(filter), anno*}
    with conds := <filter(?(traversal, <id>, _, True())); make-set> conditions // The condition list always has an element. If that element is an empty list then that means that there was no condition.
    ; filter := <filter(?(traversal, _, <id>, True())); flatten-list; map(?PrefetchWhere(<id>)); or-query-condition> conditions // If a list with an [] element is returned, it means that there is an effectful use of the collection that should not be filtered
    //; <map(?PrefetchWhere(<id>)); or-query-condition> filters
    //; qcfs* := <get-filters-for-traversal < debug(!"suc:") + ![QueryConditionFilters([])]> filters

  get-filters-for-traversal =
    fetch-elem(?None()); ![]

  get-filters-for-traversal =
    where(not(fetch-elem(?[] <+ ?None())))
    ; flatten-list
    ; make-set
    ; where(map(has-valid-filter-arguments))
    ; ![QueryConditionFilters(<id>)]

  has-valid-filter-arguments :
    qcf@QueryConditionFilter(name, args, cond) -> qcf
    where <map(is-bindable-expr(id))> args

  prepare-traversal :
    (traversal1, srt, cond1, eff) -> (traversal3, cond2, filters, eff)
    with traversal2 := <is-accessible-from(RootVar); Fst> traversal1 // This removes any unnecessary casts
    ; cond2 := <revalidate-query-condition(get-accessible-expr(try-strip-generic-sort,not(RootVar)))> cond1
    ; filters := <where(<is-generic-sort> srt) < (filter(?PrefetchWhere(_)); try(\[] -> [PrefetchWhere(True())]\)) + ![]> cond1
    where traversal3 := <an-requires-joining-fa; try(?Cast(<id>, _))> (traversal2, srt)
    //; <debug(!"preped:")> (traversal3, filters)

  traversal-summary-to-query-condition =
    filter(?(_, _, <revalidate-query-condition(get-accessible-expr(id,not(RootVar)), field-with-column)>, True())) // We revalidate the conditions, to ensure that one side of the conditions contains the RootVar
    ; make-set
    ; try(?[]; ![True()]) // No condition means true
    ; ?set
    ; filter(has-no-strict-subset(|set); and-query-condition)
    ; or-query-condition

  field-with-column = 
    where(
      ?FieldAccess(v@Var(x), f)
      //; type-of; is-entity-type
      ; SimpleSort(x_class) := <RootVar> v
	    ; dec_class := <class-of-property> (x_class, f)
      ; <not(InverseSlaveOf)> (dec_class, f)
    )

  has-no-strict-subset(|set) =
    ?elem
    ; where(not(<fetch-elem(is-strict-subset-of(|elem))> set))

  is-strict-subset-of(|set) = <subset> (<id>, set)

  is-accessible-condition-expr(|p) :
    (expr1, expr2) -> (newexpr1, newexpr2)
    where newexpr1 := <is-accessible-condition-expr-helper(|p)> expr1
    ; newexpr2 := <is-accessible-condition-expr-helper(|p)> expr2

  is-accessible-condition-expr-helper(|p) :
    expr -> rfa
    where (e, srt) := <is-accessible-from(RootVar)>
    ; <try(strip-ref-sort); try-strip-generic-sort; not(is-entity-type)> srt // If the property has an entity type, then the value is not prefetched yet, so avoid using it in the prefetch specification.
    ; FieldAccess(f_expr, f) := <try(?Cast(<id>, _))> e
    //; <(?Cast(p_expr, condcastsrt); debug(!"cast:"); <debug(!"issub:");subtype-of;info(|"yes")> (<strip-annos>castsrt, <strip-annos>condcastsrt); !condcastsrt; topdown(add-type-annotations); ?relcastsrt) <+ (?p_expr; info(|"nocast");relcastsrt := None())> f_expr
    ; (p_expr, condcastsrt) := <(\ Cast(castexpr, castsrt) -> (castexpr, newsrt) with newsrt := <topdown(add-type-annotations)> castsrt \) <+ !(<id>, None())> f_expr
    ; psrt := <expr-matches-path(|p)> p_expr
    with rfa := <add-type-anno-to-relative-fa(|<try-strip-generic-sort>psrt)> RelativeFieldAccess(condcastsrt, f)
    ; <?(None(), _) <+ subtype-of> (<strip-annos> condcastsrt, <try(strip-ref-sort); try-strip-generic-sort; strip-annos> psrt) // The cast should always be valid

  expr-matches-path(|p) :
    FieldAccess(e, f) -> fsrt
    where [(f, SimpleSort(dec_class))|nextp] := p
    ; esrt := <expr-matches-path(|nextp)> e
    ; SimpleSort(e_class) := <try(strip-ref-sort); try-strip-generic-sort> esrt
    ; dec_class := <class-of-property> (e_class, f) // If dec_class is not the same as that on the path, then the expression does not match the path.
    ; fsrt := <get-prop-type; strip-ref-sort; topdown(add-type-annotations)> (dec_class, f)

  expr-matches-path(|p) :
    Cast(e, srt) -> srt
    where <expr-matches-path(|p)> e

  expr-matches-path(|p) :
    v@Var(_) -> srt
    where [] := p
    ; srt := <RootVar> v

  is-accessible-condition-expr-helper(|p) = where(is-query-condition-constant)
  is-accessible-condition-expr-helper(|p) = where(is-accessible-from(BindableVar))

  field-with-column(|p) :
    expr -> rfa
    where (e, srt) := <is-accessible-from(RootVar)>
    ; FieldAccess(f_expr, f) := <try(?Cast(<id>, _))> e
    ; (p_expr, condcastsrt) := <(\ Cast(castexpr, castsrt) -> (castexpr, newsrt) with newsrt := <topdown(add-type-annotations)> castsrt \) <+ !(<id>, None())> f_expr
    ; psrt := <expr-matches-path(|p)> p_expr
    ; SimpleSort(x_class) := <?SimpleSort(_) <+ (!psrt; try-strip-generic-sort)> condcastsrt
    ; dec_class := <class-of-property> (x_class, f)
    ; decsrt := SimpleSort(dec_class)
    ; <not(InverseSlaveOf)> (dec_class, f)
    ; fsrt := <get-prop-type; try(strip-ref-sort)> (dec_class, f)
    ; rfa := RelativeFieldAccess(condcastsrt, f){PrefetchPropAnno(decsrt,fsrt)}

  revalidate-join-condition(|p) =
    map(filter(extract-query-cond(is-accessible-condition-expr(|p), field-with-column(|p))); and-query-condition)
    ; or-query-condition
    ; (?True() < !None() + !PrefetchCondition(<id>))

  revalidate-join-conditions(|p) :
    PrefetchNode(castsrt, f{PrefetchPropAnno(decsrt,fsrt)}, neb, templ, cond, elemcond, children){anno1*}
    -> PrefetchNode(castsrt, f{PrefetchPropAnno(decsrt,fsrt)}, neb, templ, newcond, elemcond, newchildren){anno2*}
    with
      anno2* := <remove-all(?JoinCondition(_))> anno1*
      ; cond2 := <(fetch-elem(?JoinCondition(<revalidate-join-condition(|p); try(simplify-condition)>))) <+ !None()> anno1*
      ; newcond := <combine-prefetch-conditions> (cond, cond2)
      ; newp := [(f{}, decsrt)|p]
      ; newchildren := <get-prefetch-children; map(revalidate-join-conditions(|newp)); wrap-prefetch-children> children

  simplify-condition = repeat(oncetd(simplify-or <+ simplify-and))

  /*simplify-condition =
    or-to-list
    ; map(and-to-list; make-set; and-query-condition)
    ; make-set
    ; or-query-condition*/

  simplify-or :
    old@Or(_, _) -> new
    with lst := <or-to-list> old
    ; newlst := <make-set> lst
    where <not(eq)> (<length> lst, <length> newlst)
    with new := <or-query-condition> newlst

  simplify-and :
    old@And(_, _) -> new
    with lst := <and-to-list> old
    ; newlst := <make-set> lst
    where <not(eq)> (<length> lst, <length> newlst)
    with new := <and-query-condition> newlst

  or-to-list :
    expr -> [expr]
    where not(Or(_, _) := expr)

  or-to-list :
    Or(expr1, expr2) -> lst
    with lst1 := <or-to-list <+ ![<id>]> expr1
    ; lst2 := <or-to-list <+ ![<id>]> expr2
    ; lst := <conc> (lst1, lst2)

  and-to-list :
    And(expr1, expr2) -> lst
    with lst1 := <and-to-list <+ ![<id>]> expr1
    ; lst2 := <and-to-list <+ ![<id>]> expr2
    ; lst := <conc> (lst1, lst2)

  traversal-to-joins(|x,xsrt,requiresalias):
    expr@FieldAccess(e, f{annof*}){anno*} -> [PrefetchNode(castsrt, f{PrefetchPropAnno(decsrt,fsrt)}, None(), None(), None(), None(), None()){newanno*} | prev]
    with <?Cast(p, _) <+ ?p> e
    ; castsrt := <(?Cast(_, <id>); add-type-annotations; !Some(<id>)) <+ !None()> e
    ; prev@[PrefetchNode(_, _{PrefetchPropAnno(_,p_fsrt)}, _, _, _, _, _)|_] := <traversal-to-joins(|x,xsrt,requiresalias)> p
    ; SimpleSort(e_class) := <(?Some(<id>) <+ !p_fsrt); try(strip-ref-sort); try-strip-generic-sort> castsrt
    ; dec_class := <class-of-property> (e_class, f)
    ; decsrt := SimpleSort(dec_class)
    ; fsrt := <get-prop-type; strip-ref-sort> (dec_class, f)
    ; newanno* := <filter(keep-anno-in-query-optimization <+ ?JoinCondition(_) <+ ?PrefetchWhere(_)); try(add-lazy-anno(|dec_class, f, fsrt)); try(add-alias-anno(|expr,requiresalias))> anno*

  traversal-to-joins(|x,xsrt,requiresalias):
    Var(x) -> [PrefetchNode(None(), None(){PrefetchPropAnno(None(),srt)}, None(), None(), None(), None(), None())]
    with srt := <strip-ref-sort> xsrt

  // Does the same as below
  joins-to-optimization-branch(|x) =
    reverse
    ; ?[_|<id>]
    ; foldr(!None(), joins-to-optimization-branch-helper)
    ; ?PrefetchChildren([<id>])

  joins-to-optimization-branch-helper :
    (PrefetchNode(castsrt, name, neb, templ, cond, elemcond, None()){anno*}, children)
    ->
    PrefetchChildren([PrefetchNode(castsrt, name, neb, templ, cond, elemcond, children){anno*}])
    
  /*combine-branch-anno :
    (anno1*, anno2*) -> (anno3*, anno4*)
    where <fetch-elem(?QueryConditionFilters(fltrs1))> anno1*
    ; <fetch-elem(?QueryConditionFilters(fltrs2))> anno2*
    ; fltrs3 := <(?([], _) <+ ?(_, [])) < ![] + (conc; make-set)> (fltrs1, fltrs2)
    ; anno3* := <remove-all(?QueryConditionFilters(_)); ![QueryConditionFilters(fltrs3)|<id>]> anno1*
    ; anno4* := <remove-all(?QueryConditionFilters(_))> anno2**/

  combine-branch-anno :
    (anno1*, anno2*) -> (anno3*, anno4*)
    where <fetch-elem(?PrefetchWhere(fltrs1))> anno1*
    ; <fetch-elem(?PrefetchWhere(fltrs2))> anno2*
    ; fltrs3 := <conc; make-set; or-query-condition> (<or-to-list>fltrs1, <or-to-list>fltrs2)
    ; anno3* := <remove-all(?PrefetchWhere(_)); ![PrefetchWhere(fltrs3)|<id>]> anno1*
    ; anno4* := <remove-all(?PrefetchWhere(_))> anno2*

  combine-branch-anno :
    (anno1*, anno2*) -> (anno3*, anno2*)
    where <fetch-elem(?IsRecursive(_))> anno1*
    ; <not(fetch-elem(?IsRecursive(_)))> anno2*
    ; anno3* := <remove-all(?IsRecursive(_))> anno1*

  combine-branch-anno :
    (anno1*, anno2*) -> (anno1*, anno4*)
    where <not(fetch-elem(?IsRecursive(_)))> anno1*
    ; <fetch-elem(?IsRecursive(_))> anno2*
    ; anno4* := <remove-all(?IsRecursive(_))> anno2*

  combine-branch-anno :
    (anno1*, anno2*) -> (anno3*, anno4*)
    where <fetch-elem(?IsRecursive(d1))> anno1*
    ; <fetch-elem(?IsRecursive(d2))> anno2*
    ; <not(eq)> (d1, d2)
    ; d3 := <min> (d1, d2)
    ; anno3* := <remove-all(?IsRecursive(_)); ![IsRecursive(d3)|<id>]> anno1*
    ; anno4* := <remove-all(?IsRecursive(_)); ![IsRecursive(d3)|<id>]> anno2*

  combine-branch-anno :
    (anno1*, anno2*) -> (anno3*, anno4*)
    where <fetch-elem(?JoinCondition(joins1))> anno1*
    ; <fetch-elem(?JoinCondition(joins2))> anno2*
    ; joins3 := <conc; make-set> (joins1, joins2)
    ; anno3* := <remove-all(?JoinCondition(_)); ![JoinCondition(joins3)|<id>]> anno1*
    ; anno4* := <remove-all(?JoinCondition(_))> anno2*

  merge-optimization-branches :
    (branch@PrefetchNode(_, name, _, _, _, _, _), tree) -> [subtree | keep]
    with keep := <remove-all(?PrefetchNode(_, name, _, _, _, _, _))> tree
    ; subtree := <fetch-elem(?PrefetchNode(_, name, _, _, _, _, _)) < combine-optimization-branches(|branch) + !branch> tree

  combine-optimization-branches(|branch) :
    PrefetchNode(castsrt1, f{PrefetchPropAnno(decsrt,fsrt)}, neb1, templ1, cond1, elemcond1, children1){anno1*}
    -> PrefetchNode(newcastsrt, f{PrefetchPropAnno(decsrt,fsrt)}, newneb, newtempl, newcond, newelemcond, newchildren){anno3*}
    where PrefetchNode(castsrt2, f{PrefetchPropAnno(decsrt,fsrt)}, neb2, templ2, cond2, elemcond2, PrefetchChildren([subtree2])){anno2*} := branch
    with anno3* := <repeat(combine-branch-anno); Fst> (anno1*, anno2*)
    ; newneb := <combine-no-empty-batch> (neb1, neb2)
    ; newcastsrt := <combine-cast-sort(|decsrt)> (castsrt1, castsrt2)
    ; newtempl := <combine-prefetch-template-args> (templ1, templ2)
    ; newcond := <combine-prefetch-conditions> (cond1, cond2)
    ; newelemcond := <combine-prefetch-where> (elemcond1, elemcond2)
    ; subtree1 := <get-prefetch-children> children1
    ; newchildren := <merge-optimization-branches; wrap-prefetch-children> (subtree2, subtree1)

  combine-no-empty-batch : (None(), None()) -> None()
  combine-no-empty-batch : (Some(NoEmptyBatch()), None()) -> Some(NoEmptyBatch())
  combine-no-empty-batch : (None(), Some(NoEmptyBatch())) -> Some(NoEmptyBatch())
  combine-no-empty-batch : (Some(NoEmptyBatch()), Some(NoEmptyBatch())) -> Some(NoEmptyBatch())

  combine-optimization-branches(|branch) :
    PrefetchNode(castsrt1, f{PrefetchPropAnno(decsrt,fsrt)}, neb1, templ1, cond1, elemcond1, children){anno1*}
    -> PrefetchNode(newcastsrt, f{PrefetchPropAnno(decsrt,fsrt)}, newneb, newtempl, newcond, newelemcond, children){anno3*}
    where PrefetchNode(castsrt2, f{PrefetchPropAnno(decsrt,fsrt)}, neb2, templ2, cond2, elemcond2, None()){anno2*} := branch
    with anno3* := <repeat(combine-branch-anno); Fst> (anno1*, anno2*)
    ; newneb := <combine-no-empty-batch> (neb1, neb2)
    ; newcastsrt := <combine-cast-sort(|decsrt)> (castsrt1, castsrt2)
    ; newtempl := <combine-prefetch-template-args> (templ1, templ2)
    ; newcond := <combine-prefetch-conditions> (cond1, cond2)
    ; newelemcond := <combine-prefetch-where> (elemcond1, elemcond2)

  combine-prefetch-template-args : (None(), templ) -> templ
  combine-prefetch-template-args : (templ, None()) -> templ
  combine-prefetch-template-args :
    (PrefetchTemplateArgs(templ1), PrefetchTemplateArgs(templ2)) -> PrefetchTemplateArgs(templ)
    with templ := <conc; make-set> (templ1, templ2)

  combine-prefetch-conditions : (None(), cond) -> cond
  combine-prefetch-conditions : (cond, None()) -> cond
  combine-prefetch-conditions :
    (PrefetchCondition(cond1), PrefetchCondition(cond2)) -> PrefetchCondition(cond)
    with cond := <or-query-condition-helper> (cond1, cond2) // (?True() < !None() + !PrefetchCondition(<id>)

  combine-prefetch-where : (None(), cond) -> cond
  combine-prefetch-where : (cond, None()) -> cond
  combine-prefetch-where :
    (PrefetchWhere(cond1), PrefetchWhere(cond2)) -> PrefetchWhere(cond)
    with cond := <or-query-condition-helper> (cond1, cond2)

  wrap-prefetch-children : [] -> None()
  wrap-prefetch-children : lst -> PrefetchChildren(lst) where <is-list> lst; not([] := lst)

  combine-cast-sort(|decsrt) :
    (None(), _) -> None()

  combine-cast-sort(|decsrt) :
    (_, None()) -> None()

  combine-cast-sort(|decsrt) :
    (Some(srt1), Some(srt2)) -> Some(srt2)
    where <subtype-of> (srt1, srt2)

  combine-cast-sort(|decsrt) :
    (Some(srt1), Some(srt2)) -> Some(srt1)
    where <subtype-of> (srt2, srt1)

  combine-cast-sort(|decsrt) :
    (Some(srt1), Some(srt2)) -> Some(decsrt)
    where <not(subtype-of)> (srt1, srt2)
    ; <not(subtype-of)> (srt2, srt1)
/*
  merge-conditional-optimization-branches :
    ((cond, branches), tree) -> newtree
    with newtree := <foldr(!tree, merge-conditional-optimization-branch(|cond))> branches

  merge-conditional-optimization-branch(|cond) :
    (branch@PrefetchNode(_, name, _, _, _, _), tree) -> [subtree | keep]
    with keep := <remove-all(?PrefetchNode(_, name, _, _, _, _))> tree
    ; subtree := <fetch-elem(?PrefetchNode(_, name, _, _, _, _)) < combine-conditional-optimization-branches(|cond, branch) + <add-condition-to-branch(|cond)>branch> tree

  combine-conditional-optimization-branches(|templcond, branch) :
    PrefetchNode(castsrt, f{PrefetchPropAnno(decsrt,fsrt)}, templ, cond, elemcond, children1){anno1*}
    -> PrefetchNode(castsrt, f{PrefetchPropAnno(decsrt,fsrt)}, newtempl, cond, elemcond, newchildren){anno3*}
    where PrefetchNode(_, f{PrefetchPropAnno(decsrt,fsrt)}, _, _, _, PrefetchChildren([subtree2])){anno2*} := branch
    with subtree1 := <get-prefetch-children> children1
    ; newchildren := <merge-conditional-optimization-branch(|templcond); wrap-prefetch-children> (subtree2, subtree1)
    ; anno3* := <repeat(combine-branch-anno); Fst> (anno1*, anno2*)
    ; newtempl := <try(add-template-condition-to-branch-if-not-first(|templcond))> templ

  combine-conditional-optimization-branches(|templcond, branch) :
    PrefetchNode(castsrt, f{PrefetchPropAnno(decsrt,fsrt)}, templ, cond, elemcond, children){anno1*}
    -> PrefetchNode(castsrt, f{PrefetchPropAnno(decsrt,fsrt)}, newtempl, cond, elemcond, children){anno3*}
    where PrefetchNode(_, f{PrefetchPropAnno(decsrt,fsrt)}, _, _, _, None()){anno2*} := branch
    with anno3* := <repeat(combine-branch-anno); Fst> (anno1*, anno2*)
    ; newtempl := <try(add-template-condition-to-branch-if-not-first(|templcond))> templ

  add-condition-to-branch(|templcond) :
    PrefetchNode(castsrt, f{PrefetchPropAnno(decsrt,fsrt)}, templ, cond, elemcond, PrefetchChildren([subtree])){anno*}
    -> PrefetchNode(castsrt, f{PrefetchPropAnno(decsrt,fsrt)}, newtempl, cond, elemcond, PrefetchChildren([newsubtree])){anno*}
    with newsubtree := <add-condition-to-branch(|templcond)> subtree
    ; newtempl := <combine-prefetch-template-args> (templ, PrefetchIfDefault([templcond]))

  add-condition-to-branch(|templcond) :
    PrefetchNode(castsrt, f{PrefetchPropAnno(decsrt,fsrt)}, templ, cond, elemcond, None()){anno*}
    -> PrefetchNode(castsrt, f{PrefetchPropAnno(decsrt,fsrt)}, newtempl, cond, elemcond, None()){anno*}
    with newtempl := <combine-prefetch-template-args> (templ, PrefetchIfDefault([templcond]))

  add-template-condition-to-branch-if-not-first(|cond) :
    PrefetchIfDefault(oldcond) -> PrefetchIfDefault(newcond) 
    with newcond := <make-set>[cond|oldcond]
*/
	log-query-optimization-collect-basic =
	  make-set
	  ; map(info(|["Traversal: ", <id>]))

	log-query-optimization-collect-table(|col1,col2,col3) =
	  info(|["+-", <align-helper(|'-', col1)>"", "-+-", <align-helper(|'-', col2)>"", "-+-", <align-helper(|'-', col3)>"", "-+"])
	  ; info(|["| Path", <align-helper(|' ', col1)>"Path", " | Condition", <align-helper(|' ', col2)>"Condition", " | Need", <align-helper(|' ', col3)>"Need", " |"])
	  ; info(|["|-", <align-helper(|'-', col1)>"", "-+-", <align-helper(|'-', col2)>"", "-+-", <align-helper(|'-', col3)>"", "-|"])
	  ; make-set
	  ; map({col1Val, col2Val, col3Val, str1, str2, str3, align1, align2, align3:?(col1Val, _, col2Val, col3Val)
	    ; str1 := <webdsl-to-abox; box2text-string(|col1)> col1Val
	    ; str2 := <?[] < !"" + (map(webdsl-to-abox; box2text-string(|col2)); separate-by(|" && "); concat-strings)> col2Val
	    ; str3 := <?True() < !"true" + !"false"> col3Val
	    ; align1 := <align-helper(|' ', col1)> str1
	    ; align2 := <align-helper(|' ', col2)> str2
	    ; align3 := <align-helper(|' ', col3)> str3
	    ; <concat-strings>["| ", str1, align1, " | ", str2, align2, " | ", str3, align3, " |"]
	      }
	      //<concat-strings>["| ", <Fst;pp-webdsl-to-string>, <Fst;pp-webdsl-to-string;align-helper(|' ', col1)>, " | ", <Third;pp-webdsl-to-string>, <Third;pp-webdsl-to-string; align-helper(|' ', col2)>, " | ", <?(_, _, _, <id>);pp-webdsl-to-string>, <?(_, _, _, <id>);pp-webdsl-to-string;align-helper(|' ', col3)>, " |"]
	    )
	  ; make-set
	  ; string-sort
	  ; map(info(|<id>))
	  ; info(|["+-", <align-helper(|'-', col1)>"", "-+-", <align-helper(|'-', col2)>"", "-+-", <align-helper(|'-', col3)>"", "-+"])

	add-alias-anno(|expr,requiresalias) :
	  anno* -> newanno*
	  where alias := <property-to-alias> expr
	  ; <fetch-elem(?alias)> requiresalias
	  ; newanno* := [RequiresAlias()|anno*]

	sub-paths :
	  fa@FieldAccess(p, _) -> [fa | subpaths]
	  with subpaths := <sub-paths> p

	sub-paths :
	  Cast(p, _) -> subpaths
	  with subpaths := <sub-paths> p

	sub-paths :
	  Var(_) -> []

  keep-anno-in-query-optimization = ?IsRecursive(_) //fail//?MultipleDefinitionsInSubclasses()

  an-requires-joining-fa :
    (fa@FieldAccess(_, _), srt) -> cleanfa
    where <is-generic-sort <+ is-entity-type> srt
    ; cleanfa := <clean-joincandidate> fa

  an-requires-joining-fa :
    (FieldAccess(expr, _), srt) -> cleanexpr
    where(<not(is-generic-sort <+ is-entity-type)> srt)
    ; not([] := <collect(?FieldAccess(_, _))> expr) // The expression must contain at least another FieldAccess, otherwise it's just a Var with a value type fieldaccess
    ; cleanexpr := <clean-joincandidate> expr

  clean-joincandidate :
    FieldAccess(p, f){anno*} -> FieldAccess(cleanp, f{}){newanno*}
    where newanno* := <filter(keep-anno-in-query-optimization); make-set> anno*
    ; cleanp := <clean-joincandidate> p

  clean-joincandidate :
    Cast(p, srt) -> Cast(cleanp, srt{}){}
    where cleanp := <clean-joincandidate> p

  clean-joincandidate :
    v@Var(_) -> v{}

  add-lazy-anno(|ent,f, srt) :
    anno* -> [IsLazyFetch() | anno*]
    where SimpleSort(invEnt) := srt
    ; invProp := <InverseProperty; PropertyDecl> (ent, f)
    ; SimpleSort(ent) := <get-property-type> invProp
    ; <get-property-annos; fetch-elem(?InverseAnno(ent, f))> invProp // Is the inverse side the owning side?
      
  is-accessible-from-allow-calls(s) =
    replace-calls-to-return-values(s)
    //; debug(!"replace-calls-to-return-values:")
    ; filter(is-accessible-from(s))
    //; debug(!"is-accessible-from:")
    ; not(?[])

  replace-calls-to-return-values(s) :
    FieldAccess(p, f){anno*} -> results
    where subpaths := <replace-calls-to-return-values(s)> p
    ; results := <map(!FieldAccess(<id>, f){anno*})> subpaths

  replace-calls-to-return-values(s) :
    Cast(p, srt){anno*} -> results
    where subpaths := <replace-calls-to-return-values(s)> p
    ; results := <map(!Cast(<id>, srt){anno*})> subpaths

  replace-calls-to-return-values(s) :
    v@Var(_) -> [v]

  replace-calls-to-return-values(s) :
    Call(e, nm, args) -> results
    where subpaths := <replace-calls-to-return-values(s)> e
    ; results := <filter(expand-call-to-return-values(s|nm, args)); flatten-list; make-set> subpaths

  expand-call-to-return-values(s|nm, args) :
    e -> results
    where <is-accessible-from(s); ?(e2, <is-entity-type; ?SimpleSort(ent)>)> e
    ; (n, targs) := <normalize-signature> (nm, args)
    ; (fent, Function(_, defargs, _, _){defanno*}) := <try-resolve-entity-call> (ent, n, targs)
    ; returns := <fetch-elem(get-returns-from-query-analysis)> defanno*
    with argmapping := <zip> (args, defargs)
    ; varmapping := <add-this-vars-to-mapping(|returns, e, ent)> argmapping
    ; results := <foldr(!returns, rename-vars-in-analysis(RootVar))> varmapping

  // The default generic sort handler is try-strip-generic-sort, to allow fieldaccesses on collections
  // For query conditions this is not allowed, so there id should be used to deal with generic sorts
  is-accessible-from(s) = is-accessible-from(s,try-strip-generic-sort)//; try(where(collect(?Cast(Cast(_, _), _)); not(?[])); debug(!"dbl:"))

  /*is-accessible-from(s,gen): // Cast where the cast is not needed
    Cast(f, srt){anno*} -> (p, srt)
    where (p, srt2) := <is-accessible-from(s,gen)> f
    ; <subtype-of> (<gen>srt2, srt) // up-cast or cast to same type*/

  is-accessible-from(s,gen):
    Cast(Cast(f, srt), srt2){anno*} -> (p, srt3)
    where <not(eq); subtype-of> (<gen>srt2, <gen>srt) // srt2 is more specific (subtype of srt)
    ; (p, srt3) := <is-accessible-from(s,gen)> Cast(f, srt2){anno*}

  is-accessible-from(s,gen):
    Cast(Cast(f, srt){anno*}, srt2) -> (p, srt3)
    where <subtype-of> (<gen>srt, <gen>srt2) // srt is more specific (subtype of srt2 or eq)
    ; (p, srt3) := <is-accessible-from(s,gen)> Cast(f, srt){anno*}

  is-accessible-from(s,gen): // Cast where the cast is needed
    Cast(f, srt){anno*} -> (Cast(p, srt){srt2, keepanno*}, srt)
    where not(Cast(_, _) := f)
    ; (p, srt2) := <is-accessible-from(s,gen)> f
    ; not(<gen;?srt> srt2) 
    ; <subtype-of> (srt, <gen>srt2) // down-cast
    ; keepanno* := <remove-all(?GenericSort(_, _) <+ ?SimpleSort(_))> anno*

  add-mutiple-definitions-anno: // srt is a sub entity of srt2
    fa@FieldAccess(Cast(p, srt){castanno*}, f){anno*} -> fa2
    where fa2 := <add-new-anno(|MultipleDefinitionsInSubclasses())> fa
    ; <fetch-elem(?srt2@SimpleSort(superent))> castanno*
    ; not(<get-prop-type> (superent, f)) // If the property is already defined on the source/super entity then there is no property clash
    //; info(|["Finding ", f, " from ", superent, " to ", srt])
    ; all-keys-EntDecl
    ; filter({x_sub: // We find out on which sub entities property f is defined
                ?x_sub
                ; where(
                    <not(eq)>(x_sub, superent)
                    ; <subtype-of>(SimpleSort(x_sub), srt2)
                    ; <TypeOfProperty> (x_sub, f) // Deliberate use of TypeOfProperty instead of type-of-property
                )
             })
    ; not(?[_]) // If not defined on exactly one sub entity
    //; debug(!"Match:")

  update-iterator-context :
    anno* -> [IteratorContext(ic)|keep]
    with keep := <remove-all(?IteratorContext(_))> anno*
    ; ic := <bigbagof-IteratorContext>

  remove-top-level-cast:
    Cast(f, _) -> f

  is-accessible-from(s,gen):
    FieldAccess(v, f){anno*} -> (fa, srt)
    where /*debug(!"is-accessible-from-fa-begin:");*/(p, psrt) := <is-accessible-from(s,gen)> v
    ; <gen; ?SimpleSort(x_class)> psrt
    ; not(<is-derived-property> (x_class, f))
    ; srt := <get-prop-type; strip-ref-sort> (x_class, f)
    ; f2 := <try(get-real-col-prop-name(|x_class, srt))> f
    ; fa := <try(add-naturalid-anno(|x_class)); try(add-mutiple-definitions-anno)> FieldAccess(p, f2){anno*}
    //; <debug(!"is-accessible-from-fa-end:")> (fa, srt)

  is-accessible-from(s,gen):
    v@Var(_) -> (v, srt)
    where /*debug(!"is-accessible-from-v-begin:");*/srt := <s; strip-ref-sort> v//; <debug(!"is-accessible-from-v-end:")> (v, srt)

  get-real-col-prop-name(|x_class, srt) =
    where(GenericSort("List", lsrt) := srt)
    ; where(string-ends-with(|"List"))
    ; string-as-chars(take(!(<length>, 4); subt)) // Get the real property name
    ; where(<get-prop-type> (x_class, <id>); ?GenericSort(_, lsrt)) // Check if the simple sort of the collections match

  add-naturalid-anno(|x_class) :
    fa@FieldAccess(_, f){anno*} -> fa2
    where f := <natural-id-name-include-superclass> x_class
    ; fa2 := <add-new-anno(|IsNaturalId())> fa 
/*// Replaced by: or-query-condition
  join-conditions:
    (cond, []) -> cond

  join-conditions:
    (cond, True()) -> cond

  join-conditions:
    (cond, prevCond) -> Or(prevCond, cond)
    where <not(?True()); not(?[])> prevCond
*/
/*// Replaced by: and-query-condition-helper
  append-condition:
    (newCond, oldCond) -> And(newCond, oldCond)
    where <not(?True())>newCond; <not(?True())>oldCond

  append-condition:
    (newCond, True()) -> newCond

  append-condition:
    (True(), oldCond) -> oldCond
*/

  add-this-vars-to-mapping(|from, e, ent) :
    mapping -> newmapping
    with thisargs := <get-this-args(|ent)> from
    ; thismapping := <map(!(e, <id>))> thisargs
    ; newmapping := <conc> (mapping, thismapping)
    
  get-this-args(|ent) :
    from -> thisargs
    with thisvars := <collect(?Var("this")); make-set> from
    ; thisargs := <map(?Var(<id>); !Arg(<id>, SimpleSort(ent)))> thisvars

  get-prop-type: (x_class, prop) -> <type-of-property>

  get-prop-type: (x_class, prop) -> <EntityIdType> x_class
    where <EntityIdName; ?prop> x_class

  get-all-entity-properties-as-fargs =
    get-all-entity-properties-as-mapping(|None())
    ; map(Snd)

  get-all-entity-properties-as-mapping(|e) =
    all-entity-properties-tuples
    ; map(entity-property-tuple-to-mapping(|e))

  entity-property-tuple-to-mapping(|e) :
    (ent, prop) -> ( FieldAccess(e, name), Arg(name{uniquename}, srt))
    with name := <get-property-name> prop
    ; uniquename := <PropertyNameToUniqueName> (ent, name)
    ; srt := <get-property-type> prop

  get-all-entity-properties-for-rename(|prefix) =
    all-entity-properties-tuples
    ; {|OverridePropName
       : map({\ (ent, prop) -> <id> with propname := <get-property-name> prop; rules(OverridePropName : propname -> (ent, prop)) \})
       ; dr-all-keys(|"OverridePropName")
       ; map(OverridePropName; {ent,prop,name,uniquename,safename,srt:\ (ent, prop) -> (name, uniquename, safename, srt) where name := <get-property-name> prop; uniquename := <PropertyNameToUniqueName> (ent, name); safename := name{<concat-strings>[prefix, "_", name]}; srt := <get-property-type> prop \})
       |}

  // Same as resolve-entity-call, except here we allow failure
  // It also does not return functions that have an overridden version and it is unsure which version will be used
  try-resolve-entity-call = ?(ent, nm, targ*); try-resolve-entity-call-without-override-check; ?(fent, f); where(<subentities-do-no-override> (fent, nm, targ*))

  try-resolve-entity-call-without-override-check: (ent, nm, targ*) -> result
    where not("Entity" := ent)
    ; f := <resolve-function-call-to-decl> (SimpleSort(ent), nm, targ*)
      < result := (ent, f)
      + result := <try-resolve-entity-call-without-override-check> (<Extends> ent, nm, targ*)

  subentities-do-no-override =
    ?(ent, nm, targ*)
    ; all-keys-EntDecl
    ; filter({x_sub:
                ?x_sub
                ; where(
                    <not(eq)>(x_sub, ent)
                    ; <subtype-of>(SimpleSort(x_sub), SimpleSort(ent))
                    ; <resolve-function-call-to-decl>(SimpleSort(x_sub), nm, targ*)
                )
             })
    //; (?[] <+ debug(!<concat-strings>[ent, "::", nm, " already defined for: "]))
    ; ?[]
