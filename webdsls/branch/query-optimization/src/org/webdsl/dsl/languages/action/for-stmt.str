module org/webdsl/dsl/languages/action/for-stmt

imports
  libstrategolib

imports
  libwebdsl-front

rules

  normalize-action :
    ForStmtNoFilter(x, s, e, block){anno*} -> ForStmt(x, s, e, Filter(True(), OrderAscending(Null()), Limit(Int("1000"), Int("0"))), block){anno*}

  normalize-action :
    ForAllStmtNoFilter(x, s, block){anno*} -> ForAllStmt(x, s, Filter(True(), OrderAscending(Null()), Limit(Int("1000"), Int("0"))), block){anno*}

rules

  rename-action :
    fs@ForStmt(x, srt, e1, f1, b1) -> ForStmt(y, srt2, e2, f2, b2)
    with e2 := <rename-all> e1
       ; {| Rename, VarInTemplateContext
          : srt2 := <rename-all> srt
          ; y := <rename-bound-immutable(|srt2)> x
          ; rules(VarDecl : y -> fs)
          ; <declare-vars-in-entity-context> y
          ; f2 := <rename-all> f1
          ; b2 := <rename-all> b1
          |}

  rename-action :
    fs@ForStmtNoFilter(x, srt, e1, b1) -> ForStmtNoFilter(y, srt2, e2, b2)
    with e2 := <rename-all> e1
       ; {| Rename, VarInTemplateContext
          : srt2 := <rename-all> srt
          ; y := <rename-bound-immutable(|srt2)> x
          ; rules(VarDecl : y -> fs)
          ; <declare-vars-in-entity-context> y
          ; b2 := <rename-all> b1
          |}

  rename-action :
    fs@ForAllStmt(x, srt, f1, b1){anno*} -> ForAllStmt(y, srt2, f2, b2){newanno*}
    with {| Rename, VarInTemplateContext
          : srt2 := <rename-all> srt
          ; y := <rename-bound-immutable(|srt2)> x
          ; rules(VarDecl : y -> fs)
          ; <declare-vars-in-entity-context> y
          ; f2 := <rename-all> f1
          ; b2 := <rename-all> b1
          ; newanno* := <forallstmt-annotations-for-query-optimization> anno*
          |}

  rename-action :
    fs@ForAllStmtNoFilter(x, srt, b1){anno*} -> ForAllStmtNoFilter(y, srt2, b2){newanno*}
    with {| Rename, VarInTemplateContext
          : srt2 := <rename-all> srt
          ; y := <rename-bound-immutable(|srt2)> x
          ; rules(VarDecl : y -> fs)
          ; <declare-vars-in-entity-context> y
          ; b2 := <rename-all> b1
          ; newanno* := <forallstmt-annotations-for-query-optimization> anno*
          |}

  forallstmt-annotations-for-query-optimization:
    anno* -> [ qopt*, args*, ent*, plain-anno* ]
    where plain-anno* := <remove-all(?FunctionArgs(_) <+ ?QueryOptimizations(_, _, _, _))> anno*
    ; qopt* := <(fetch-elem(?QueryOptimizations(_, _, _, _)); rename-all; ![<id>]) <+ ![]> anno*
    ; args* := <(FunctionArg; ![FunctionArgs(<id>)]) <+ ![]>
    ; ent* := <fetch-elem(?FunctionEntity(_)) < ![] + ![FunctionEntity(<InEntity <+ !None()>)]> anno*

  rename-action :
    fs@ForCountStmt(x, e1, e2, b1) -> ForCountStmt(y, e3, e4, b2)
    with e3 := <rename-all> e1
       ; e4 := <rename-all> e2
       ; {| Rename, VarInTemplateContext
          : y := <rename-bound-immutable(|SimpleSort("Int"))> x
          ; rules(VarDecl : y -> fs)
          ; <declare-vars-in-entity-context> y
          ; b2 := <rename-all> b1
          |}

rules

  desugar-action :
    def@ForAllStmt(x, srt, Filter(cond, _, _), body){anno*} -> def{qoanno, anno*}
    where qoanno := <common-query-optimization-forallstmt(|x, srt, cond, anno*)> body

  desugar-action :
    def@ForAllStmtNoFilter(x, srt, body){anno*} -> def{qoanno, anno*}
    where qoanno := <common-query-optimization-forallstmt(|x, srt, True(), anno*)> body

  common-query-optimization-forallstmt(|x, srt, cond, anno*) :
    body -> QueryOptimizations(joincandidates, joincandidatesgen, querycondition2, conditionjoins)
    where not(<fetch-elem(?QueryOptimizations(_, _, _, _))> anno*)
    with args* := <fetch-elem(?FunctionArgs(<id>)) <+ ![]> anno*
    ; ent := <fetch-elem(?FunctionEntity(<id>)) <+ !None()> anno*
    ; props := <?None() < ![] + get-all-entity-properties-for-rename(|"queryoptimization_parentarg")> ent
    ; propargs* := <map({\ (name, uniquename, safename, srt) -> Arg(safename, srt) \})> props
    ; {| RenamePropInFunction, RenamePropInQueryOptimization // Here we temporarily rename the Var()s in the function body for our analysis
        : <map({\
                  (name, uniquename, safename, srt) -> <id>
                  with rules (
                                RenamePropInFunction : Var(uniquename) -> Var(safename)
                                RenamePropInQueryOptimization : Var(safename) -> Var(uniquename)
                             )
                \})> props
        ; body2 := <alltd(RenamePropInFunction)> body
        ; cond2 := <alltd(RenamePropInFunction)> cond
        ; (joincandidates, joincandidatesgen, querycondition, conditionjoins) := <get-query-optimizations>(body2, x, srt, [args*, propargs*], cond2)
        ; querycondition2 := <alltd(RenamePropInQueryOptimization)> querycondition // Joins do not have to be renamed, because they do not contain vars
      |}

/*  all-entity-properties-name-sort-tuples = all-entity-properties-name-sort-tuples(|[],[])
  
  all-entity-properties-name-sort-tuples(|alreadychecked,props*) :
    x_class -> []
    where <fetch(?x_class)> alreadychecked //prevent loop on invalid input 'entity Xyz:Xyz'
  
  all-entity-properties-name-sort-tuples(|alreadychecked,props*) :
    x_class -> result
    where not(<fetch(?x_class)> alreadychecked)
    with  newprops* := <bagof-AllProperties; !(<id>, props*); diff> x_class
        ; tuples := <map(\x -> <PropertyDecl> (x_class, x)\; create-tuple-with-entity-prop(|x_class))> newprops*
        ; if not("Entity" := x_class) //stop at Entity (but its properties are included)
           ; super := <Extends> x_class //stop if invalid entity found (for each entity Extends should succeed, but need to cope with app errors)
          then result := <concat> [<all-entity-properties-name-sort-tuples(|[x_class|alreadychecked],[props*,newprops*])> super, tuples]
               //order from least specific to most specific, that way when iterating over them and creating DR the more specific takes precedence
          else result := tuples end*/

rules

  constraint-error-action : ForCountStmt(x, e1, e2, b) -> <expression-type-constraint(|SimpleSort("Int"))> e1
  constraint-error-action : ForCountStmt(x, e1, e2, b) -> <expression-type-constraint(|SimpleSort("Int"))> e2

  expression-type-constraint(|type) :
    e -> <add-error(|["Expression should be of type ",typename])>
    with  SimpleSort(typename) := type
    where not(<type-compatible> (type, <type-of> e))

  constraint-error-action : ForStmt(_, srt, e, _, _)      -> <for-constraint-error(|srt, e)>
  constraint-error-action : ForStmtNoFilter(_, srt, e, _) -> <for-constraint-error(|srt, e)>
