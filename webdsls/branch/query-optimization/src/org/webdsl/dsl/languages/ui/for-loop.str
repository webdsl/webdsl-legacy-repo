module org/webdsl/dsl/languages/ui/for-loop

rules

  normalize-ui :
    ForNoFilter(x, s, e, te*, sep){anno*} -> For(x, s, e, Filter(True(), OrderAscending(Null()), Limit(Int("1000"), Int("0"))), te*, sep){anno*}

  normalize-ui :
    ForAllNoFilter(x, s, te*, sep){anno*} -> ForAll(x, s, Filter(True(), OrderAscending(Null()), Limit(Int("1000"), Int("0"))), te*, sep){anno*}

rules

  rename-ui :
    def@For(x, srt, e1, f1, elems1, elems3){anno*} -> For(y, srt2, e2, f2, elems2, elems4){newanno*}
    with e2 := <rename-all> e1
       ; {| Rename, VarInTemplateContext
          : srt2   := <rename-all> srt
          ; y      := <rename-bound-immutable(|srt2)> x
          ; rules(VarDecl : y -> def)
          ; <declare-vars-in-context> y
          ; f2     := <rename-all> f1
          ; elems2 := <rename-all> elems1
          |}
       ; elems4 := <rename-all> elems3 // separator cannot refer to loop index
       ; newanno* := [TemplateArgs(<TemplateArg <+ ![]>) | anno*]

  rename-ui :
    def@ForNoFilter(x, srt, e1, elems1, elems3){anno*} -> ForNoFilter(y, srt2, e2, elems2, elems4){newanno*}
    with e2 := <rename-all> e1
       ; {| Rename, VarInTemplateContext
          : srt2   := <rename-all> srt
          ; y      := <rename-bound-immutable(|srt2)> x
          ; rules(VarDecl : y -> def)
          ; <declare-vars-in-context> y
          ; elems2 := <rename-all> elems1
          |}
       ; elems4 := <rename-all> elems3 // separator cannot refer to loop index
       ; newanno* := [TemplateArgs(<TemplateArg <+ ![]>) | anno*]

  rename-ui :
    def@ForAll(x, srt, f1, elems1, elems3){anno*} -> ForAll(y, srt2, f2, elems2, elems4){newanno*}
    with {| Rename, VarInTemplateContext
          : srt2   := <rename-all> srt
          ; y      := <rename-bound-immutable(|srt2)> x
          ; rules(VarDecl : y -> def)
          ; <declare-vars-in-context> y
          ; f2     := <rename-all> f1
          ; elems2 := <rename-all> elems1
          |}
        ; elems4 := <rename-all> elems3 // separator cannot refer to loop index
        ; newanno* := [TemplateArgs(<TemplateArg>) | anno*]

  rename-ui :
    def@ForAllNoFilter(x, srt, elems1, elems3){anno*} -> ForAllNoFilter(y, srt2, elems2, elems4){newanno*}
    with {| Rename, VarInTemplateContext
          : srt2   := <rename-all> srt
          ; y      := <rename-bound-immutable(|srt2)> x
          ; rules(VarDecl : y -> def)
          ; <declare-vars-in-context> y
          ; elems2 := <rename-all> elems1
          |}
        ; elems4 := <rename-all> elems3 // separator cannot refer to loop index
        ; newanno* := [TemplateArgs(<TemplateArg>) | anno*]

  rename-ui :
    def@ForCount(x, e1, e2, elems1, elems3) -> ForCount(y, e3, e4, elems2, elems4)
    with  e3 := <rename-all> e1
        ; e4 := <rename-all> e2 
        ; {| Rename, VarInTemplateContext
          : y := <rename-bound-immutable(|SimpleSort("Int"))> x
          ; rules(VarDecl : y -> def)
          ; <declare-vars-in-context> y
          ; elems2 := <rename-all> elems1
          |}  
        ; elems4 := <rename-all> elems3 // separator cannot refer to loop index
          
rules

  desugar-ui :
    def@ForAll(x, srt, Filter(cond, _, _), body, _){anno*} -> def{QueryOptimizations(joincandidates, joincandidatesgen, querycondition, conditionjoins), anno*}
    where not(<fetch-elem(?QueryOptimizations(_, _, _, _))> anno*)
    with <fetch-elem(?TemplateArgs(args))> anno*
    ; (joincandidates, joincandidatesgen, querycondition, conditionjoins) := <get-query-optimizations>(body, x, srt, args, cond)

  desugar-ui :
    def@ForAllNoFilter(x, srt, body, _){anno*} -> def{QueryOptimizations(joincandidates, joincandidatesgen, querycondition, conditionjoins), anno*}
    where not(<fetch-elem(?QueryOptimizations(_, _, _, _))> anno*)
    with <fetch-elem(?TemplateArgs(args))> anno*
    ; (joincandidates, joincandidatesgen, querycondition, conditionjoins) := <get-query-optimizations>(body, x, srt, args, True())

  desugar-ui :
    def@For(x, srt, call{callanno*}, f1@Filter(cond, _, _), elems1, elems3){anno*} -> For(x, srt, call{queryopt, callanno*}, f1, elems1, elems3){anno*}
    where not(<fetch-elem(?QueryOptimizations(_, _, _, _, _, _))> callanno*)
    ; <is-function-call-with-query-optimization(|srt)> call
    with <fetch-elem(?TemplateArgs(args))> anno*
    ; (joincandidates, joincandidatesgen, querycondition, conditionjoins) := <get-query-optimizations>(elems1, x, srt, args, cond)
    ; queryopt := QueryOptimizations(joincandidates, joincandidatesgen, querycondition, conditionjoins, x, srt)

  desugar-ui :
    def@ForNoFilter(x, srt, call{callanno*}, elems1, elems3){anno*} -> ForNoFilter(x, srt, call{queryopt, callanno*}, elems1, elems3){anno*}
    where not(<fetch-elem(?QueryOptimizations(_, _, _, _, _, _))> callanno*)
    ; <is-function-call-with-query-optimization(|srt)> call
    with <fetch-elem(?TemplateArgs(args))> anno*
    ; (joincandidates, joincandidatesgen, querycondition, conditionjoins) := <get-query-optimizations>(elems1, x, srt, args, True())
    ; queryopt := QueryOptimizations(joincandidates, joincandidatesgen, querycondition, conditionjoins, x, srt)

  is-function-call-with-query-optimization(|srt) =
    ?ThisCall(fname, fargs)
    ; t* := <map(type-of)> fargs
    ; Function(fname2, fargs2, GenericSort(_, [srt]), _){fanno*} := <resolve-function-call-to-decl>(None(), fname, t*)
    ; t2* := <map(?Arg(_, <id>); strip-annos)> fargs2
    ; <FunctionHasQueryOptimization> (None(), fname2, t2*)

  is-function-call-with-query-optimization(|srt) =
    ?Call(e, fname, fargs)
    ; entsrt@SimpleSort(x_class) := <type-of; is-entity-type> e
    ; t* := <map(type-of)> fargs
    ; Function(fname2, fargs2, GenericSort(_, [srt]), _){fanno*} := <resolve-function-call-to-decl>(entsrt, fname, t*)
    ; t2* := <map(?Arg(_, <id>); strip-annos)> fargs2
    ; <FunctionHasQueryOptimization> (x_class, fname2, t2*)

rules // ForAll only declared entity types
  
  constraint-error-ui: ForAll(_, srt, _, _, _) -> <forall-constraint-error(|srt)>
  constraint-error-ui: ForAllNoFilter(_, srt, _, _) -> <forall-constraint-error(|srt)>

  forall-constraint-error(|srt) :
    x -> <add-error(|["'for' without 'in' can only iterate over a defined entity type, incorrect type used: ", <pp-type> srt])>
    where not(<is-entity-type> srt) <+ <?SimpleSort("Entity")> srt

rules

  constraint-error-ui : For(_, srt, e, _, _, _)            -> <for-constraint-error(|srt, e)>
  constraint-error-ui : ForNoFilter(_, srt, e, _, _)       -> <for-constraint-error(|srt, e)>
     
  for-constraint-error(|srt, e) :
    x -> <add-error(|[<pp-webdsl> e, " should be a collection of type ", <pp-type> srt])>
    where not(GenericSort(_, [srt]) := <type-of> e)  
    
rules    

  constraint-error-ui : ForCount(x, e1, e2, elems1, sep) -> <expression-type-constraint(|SimpleSort("Int"))> e1
  constraint-error-ui : ForCount(x, e1, e2, elems1, sep) -> <expression-type-constraint(|SimpleSort("Int"))> e2
