module org/webdsl/dsl/languages/ui/query-utils

imports // imports only needed for pp-aterm-box and box2text-string
  libstratego-gpp
  libstratego-aterm

rules
  
  rename-query-optimization-annos :
    anno* -> newanno*
    with toKeep* := <remove-all(?QueryOptimizations(_, _, _, _) <+ ?QueryOptimizationVars(_, _, _, _))> anno*
      ; qo* := <(fetch-elem(?QueryOptimizations(_, _, _, _)); rename-all; ![<id>]) <+ ![]> anno*
      ; qovars* := <(fetch-elem(?QueryOptimizationVars(_, _, _, _)); rename-all; ![<id>]) <+ ![]> anno*
      ; newanno* := [qo*, qovars*, toKeep*]

  get-query-optimizations : (_, _, _, _, _) -> ([], [], True(), [])
  where QueryOptimizationDisabled
  
  get-query-optimizations : (base, x, srt, args, cond) -> (joincandidatesnogen, joincandidatesgen, querycondition, conditionjoins)
    where not(QueryOptimizationDisabled)
    with {| RootVar, ParentArgs, IteratedVar, QueryConditions, IsEffectful, LocalRedefDef, LocalRedefName, LocalRedefArgs
       : rules (  IteratedVar     : Var(x) -> srt // Contains all variables we are following (is RootVar and template/function call arguments)
                  RootVar         : Var(x) -> srt // The actual variable we are interested in (the persistent root of our analysis)
                  QueryConditions := True()       // Changes over time to represent the query conditions active on the term currently being analyzed
                  IsEffectful     := False()      // True if the current statement is effectful (means: can affect non-local state), False otherwise
               )
       ; <alltd(define-local-redefine)> base
       ; <filter({vars: 
                     \ Arg(arg, srt) ->  <id>
                       with rules( ParentArgs      : Var(arg) -> srt )
                     \})> args
       //; info(|["base: ", <pp-aterm> base])
       //; info(|["Looking for property use of variable ", <pp-aterm-box ; box2text-string(|80)>x, " of type ", srt])
       ; rules( QueryConditions := <repeat(innermost-rep(desugar)); extract-query-cond> cond ) // Cannot move this up, because extract-query-cond requires previously defined rules
       //; QueryConditions; debug(!"cond:     ")
       ; fas := <collect-potential-joins> base
       //; <remove-casts;log-query-optimization-collect-table(|45,155,5)> fas
       ; querycondition := <(filter(?(_, _, _, True())); map(Third); make-set; try(?[]; ![True()]); (where(filter(?True()); ?[]) < foldr(![], join-conditions) + !True())); alltd(?FieldAccess(_, _); try(add-required-alias))> fas // Combine query conditions of the effectful field accesses
       ; conditionjoins := <collect(?FieldAccess(_, _){HasAlias()}); map(an-find-entity-property-pair; group-join-candidates-build-paths); flatten-list; make-set; string-sort-desc> querycondition // These joins should be used everytime the queryconditon is used
       ; fetchmode := <filter(collect(col-fetch-mode); ?[<id>|_]; remove-casts; an-find-entity-property-pair); make-set; map(to-fetch-mode-tuple)> fas
       ; joincandidates := <map(!(<Fst; remove-casts>, <Snd>)); filter(an-requires-joining); flatten-list; make-set; string-sort/*; foldr([], create-aliasses)*/> fas
       //; info(|["Should be inlined: ", joincandidates])
       ; queryjoins := <map(!(<Fst>, <Snd>)); filter(an-requires-joining-generic); make-set> fas // Cannot remove casts, because they are important for type-of
       ; queryroots := <map(Fst); make-set; string-sort> queryjoins
       ; joincandidatesgen := <map(group-join-candidates(|queryjoins); !(<id>, conditionjoins); diff); map(map(try(apply-fetch-mode(|fetchmode))))> queryroots
       //; info(|["Inline by queries: ", joincandidatesgen]) // Each sublist creates an extra query to fetch subcollections
       ; joincandidatesnogen := <diff; map(group-join-candidates-build-paths); flatten-list; !(<id>, conditionjoins); diff; make-set; string-sort-desc; map(try(apply-fetch-mode(|fetchmode)))> (joincandidates, <flatten-list; make-set>joincandidatesgen) 
       //; info(|["Inline by joining: ", joincandidatesnogen]) // Does not result in extra queries, but are joined on the unoptimized query itself
       //; info(|["Query condition:   ", <pp-webdsl>querycondition]) // A condition that can reduce the size of the result set
       //; info(|["Condition joins:   ", conditionjoins]) // These joins should also be present on extra queries (from inline by queries), because they are required for evaluating the query condition
      |}

  get-query-optimizations : (_, _, _, _) -> ([], [])
  where QueryOptimizationDisabled

  // Query optimization without query condition (advantage is that conditionjoins are never excluded from the joincandidate lists)
  get-query-optimizations : (base, x, srt, args) -> (joincandidatesnogen, joincandidatesgen)
    where not(QueryOptimizationDisabled)
    with {| RootVar, ParentArgs, IteratedVar, QueryConditions, IsEffectful, LocalRedefDef, LocalRedefName, LocalRedefArgs
       : rules (  IteratedVar     : Var(x) -> srt // Contains all variables we are following (is RootVar and template/function call arguments)
                  RootVar         : Var(x) -> srt // The actual variable we are interested in (the persistent root of our analysis)
                  IsEffectful     := False()      // True if the current statement is effectful (means: can affect non-local state), False otherwise
               )
       ; <alltd(define-local-redefine)> base
       ; <filter({vars: 
                     \ Arg(arg, srt) ->  <id>
                       with rules( ParentArgs      : Var(arg) -> srt )
                     \})> args
       //; info(|["base: ", <pp-aterm> base])
       ; info(|["Looking for property use of variable ", <pp-aterm-box ; box2text-string(|80)>x, " of type ", srt])
       ; fas := <collect-potential-joins> base
       ; <remove-casts;log-query-optimization-collect-table(|45,155,5)> fas
       ; joincandidates := <map(!(<Fst>, <Snd>)); filter(an-requires-joining-fa); map(sub-paths); flatten-list; make-set> fas
       ; queryroots := <filter(get-first-generic-sort); make-set; group-similar-roots> joincandidates
       ; joincandidatesgennocast := <map(map(group-join-candidates-fa(|joincandidates)))> queryroots
       ; joincandidatesgen := <map(map(try(cast-query-root)))> joincandidatesgennocast
       ; info(|["Inline by queries: ", joincandidatesgen]) // Each sublist creates an extra query to fetch subcollections
       ; joincandidatesnogen := <diff> (joincandidates, <flatten-list; make-set>joincandidatesgennocast) 
       ; info(|["Inline by joining: ", joincandidatesnogen]) // Does not result in extra queries, but are joined on the unoptimized query itself
      |}

  remove-casts = repeat(oncetd(?Cast(<id>, _)))

sub-paths :
  fa@FieldAccess(p, _) -> [fa | subpaths]
  with subpaths := <sub-paths> p

sub-paths :
  Cast(p, _) -> subpaths
  with subpaths := <sub-paths> p

sub-paths :
  Var(_) -> []

col-fetch-mode=
  ?FieldAccess(p, _){anno*}
  ; where(<fetch-elem(?UseFetchMode())> anno*; not(<oncetd(col-fetch-mode)>p))

to-fetch-mode-tuple :
  str -> (str, str)
  where [_] := <string-tokenize(|['.'])> str

to-fetch-mode-tuple :
  str -> (str, joinstr)
  where varList := <string-tokenize(|['.']); where(not(?[_]))> str
  with alias := <reverse; ?[prop|<id>]; reverse; separate-by(!"_"); !["_"|<id>]; concat-strings> varList
  ; joinstr := <concat-strings>[alias, ".", prop]

apply-fetch-mode(|fetchmode) :
  str -> newstr{UseFetchMode()}
  where [(match, replacement)] := <filter({match: ?(match, _); where(<string-starts-with(|match)> str)})> fetchmode
  ; extrastr := <split-after; Snd> (str, match)
  ; newstr := <concat-strings> [replacement, extrastr]
  

log-query-optimization-collect-basic =
  make-set
  ; map(info(|["FA: ", <id>]))

log-query-optimization-collect-table(|col1,col2,col3) =
  info(|["+-", <align-helper(|'-', col1)>"", "-+-", <align-helper(|'-', col2)>"", "-+-", <align-helper(|'-', col3)>"", "-+"])
  ; info(|["| Path", <align-helper(|' ', col1)>"Path", " | Condition", <align-helper(|' ', col2)>"Condition", " | Need", <align-helper(|' ', col3)>"Need", " |"])
  ; info(|["|-", <align-helper(|'-', col1)>"", "-+-", <align-helper(|'-', col2)>"", "-+-", <align-helper(|'-', col3)>"", "-|"])
  ; make-set
  ; map({col1Val, col2Val, col3Val, str1, str2, str3, align1, align2, align3:?(col1Val, _, col2Val, col3Val)
    ; str1 := <pp-webdsl-to-string> col1Val
    ; str2 := <?True() < !"true" + (webdsl-to-abox; box2text-string(|col2))> col2Val
    ; str3 := <?True() < !"true" + !"false"> col3Val
    ; align1 := <align-helper(|' ', col1)> str1
    ; align2 := <align-helper(|' ', col2)> str2
    ; align3 := <align-helper(|' ', col3)> str3
    ; <concat-strings>["| ", str1, align1, " | ", str2, align2, " | ", str3, align3, " |"]
      }
      //<concat-strings>["| ", <Fst;pp-webdsl-to-string>, <Fst;pp-webdsl-to-string;align-helper(|' ', col1)>, " | ", <Third;pp-webdsl-to-string>, <Third;pp-webdsl-to-string; align-helper(|' ', col2)>, " | ", <?(_, _, _, <id>);pp-webdsl-to-string>, <?(_, _, _, <id>);pp-webdsl-to-string;align-helper(|' ', col3)>, " |"]
    )
  ; make-set
  ; string-sort
  ; map(info(|<id>))
  ; info(|["+-", <align-helper(|'-', col1)>"", "-+-", <align-helper(|'-', col2)>"", "-+-", <align-helper(|'-', col3)>"", "-+"])

/*
group-joins :
	(cur, []) -> [(cur, newGroup)]
	with newGroup := <group-join-candidates-build-paths> cur

group-joins :
	(cur, prev) -> [(cur, [cur|prevGroup]) | prevTail]
	where <?[prevHead|prevTail]> prev
	; <?(prevJoin, prevGroup)> prevHead
	; <string-starts-with(|prevJoin)> cur

group-joins :
	(cur, prev) -> [(cur, newGroup) | prev]
	where <?[prevHead|prevTail]> prev
	; <?(prevJoin, prevGroup)> prevHead
	; <not(string-starts-with(|prevJoin))> cur
	; newGroup := <group-join-candidates-build-paths> cur
*/

group-join-candidates-build-paths-helper :
	(x, []) -> [x]

group-join-candidates-build-paths-helper :
	(x, y) -> [x_new|y]
	where <?[headElem|_]> y
	; x_new := <concat-strings>[headElem, ".", x]

/*create-aliasses :
	(cur, []) -> [(cur, cur, <(string-tokenize(|['.']); last; str-tail) <+ str-tail> cur)]

create-aliasses :
	(cur, prev) -> [(newCur, cur, newAlias) | prev]
	where <head; ?(prevElem, prevOriginal, prevAlias)> prev
	; <string-starts-with(|prevOriginal)> cur
	; newCur := <concat-strings>[prevAlias, <explode-string; reverse; take(|<subt>(<strlen> cur, <strlen> prevOriginal)); reverse; implode-string> cur]
	; newAlias := <concat-strings>[prevAlias, <string-tokenize(|['.']); last> cur]

create-aliasses :
	(cur, prev) -> [(cur, cur, <(string-tokenize(|['.']); last; str-tail) <+ str-tail> cur) | prev]
	where <head; ?(prevElem, prevOriginal, prevAlias)> prev
	; <not(string-starts-with(|prevOriginal))> cur

head : [x|xs] -> x
tail : [x|xs] -> xs*/

strategies

  group-join-candidates-build-paths =
    string-tokenize(|['.'])
    ; !(<id>, [])
    ; foldl(group-join-candidates-build-paths-helper)

  group-join-candidates(|queryjoins) =
  	?currentroot
  	; <filter(?(currentroot, _); conc-strings)> queryjoins
  	; map(group-join-candidates-build-paths)
  	; flatten-list
  	; make-set
  	; string-sort-desc

  group-join-candidates-fa(|joincandidates) :
    currentroot -> [currentroot|elementjoins]
    where elementjoins := <filter(where(not(?currentroot); collect(?currentroot); ?[currentroot]))> joincandidates

  cast-query-root :
    [root|elementjoins] -> [FieldAccess(Cast(p, srt), f){anno*}|elementjoins]
    where FieldAccess(p, f){anno*} := root
    ; not(Cast(_, _) := p)
    ; srt := <type-of> p

  collect-potential-joins =
    collect(an-potential-joins)
    ; flatten-list

  collect-effectful-potential-joins =
    where(IsEffectful; ?False())
    ; rules( IsEffectful := True())
    ; collect(an-potential-joins)
    ; flatten-list
    ; rules( IsEffectful := False() )

  an-potential-joins =
    ?FieldAccess(l, _)
    ; oncetd(where(IteratedVar); not(IteratedVarValue))
    ; is-accessible-from(RootVar)
    ; !(<Fst>, <Snd>, <QueryConditions <+ !True()>, <IsEffectful>)

  an-potential-joins =
    ?fa@FieldAccess(l, _)
    ; repeat(oncetd(IteratedSubListValue <+ IteratedVarValue))
    ; not(?fa)
    ; is-accessible-from(RootVar)
    ; !(<Fst>, <Snd>, <QueryConditions <+ !True()>, <IsEffectful>)

  an-potential-joins =
    ?Var(_)
    ; repeat(oncetd(IteratedSubListValue <+ IteratedVarValue))
    ; is-accessible-from(RootVar)
    ; !(<Fst>, <Snd>, <QueryConditions <+ !True()>, <IsEffectful>)

  /*an-potential-joins =
    ?TemplateCase(_, _)
    ; pp-aterm
    ; fail*/

  an-potential-joins =
    ?Call(e, nm, arg*){anno*}
    ; where(<is-accessible-from(IteratedVar <+ IteratedSubList); ?(e2, <is-entity-type; ?SimpleSort(ent)>)> e)
    ; genname := <generate-template-name-args> (<concat-strings>[ent, nm], arg*)
    ; where(not(<PassedFunction> genname)) // This prevents an infinite loop when following a recursive function
    ; (fent, Function(_, fargs, _, body)) := <try-resolve-entity-call> (ent, nm, <map(query-optimization-type-of)> arg*)
    // Here we get the properties of the entity and insert them as extra parameters for the function call
    // We also have to rename the Var("prop") to Var("prop"{Entity_myfunctionArg1Arg2}) to prevent creating a loop in IteratedVar or IteratedSubList
    ; thissafe := "this"{<concat-strings>[genname, "_this"]}
    ; {| RenamePropInFunction // Here we temporarily rename the Var()s in the function body for our analysis
        : (args, fargs2) := <get-all-entity-properties-for-rename(|genname); map({name,uniquename,safename,srt:\
                                (name, uniquename, safename, srt) -> (FieldAccess(e2, name), Arg(safename, srt))
                                where rules( RenamePropInFunction : Var(uniquename) -> Var(safename) )
                            \}); ![(e2, Arg(thissafe, SimpleSort(fent)))|<id>]; unzip> ent
        ; rules( RenamePropInFunction : Var("this") -> Var(thissafe) )
        ; body2 := <alltd(RenamePropInFunction)> body
      |}
    ; {| PassedFunction
       : rules( PassedFunction : genname )
       ; <an-potential-joins-with-args(|<conc>(args, arg*), <conc>(fargs2, fargs))> body2 // We add the properties of the entity as leading arguments of the function, this prevents them to be mistaken for local variables, which currently are ignored completely
       |}

  an-potential-joins =
    (?Call(_, _, _) <+ ?VarDeclInit(_, _, _) <+ ?VarDeclInitInferred(_, _) <+ ?Assignment(_, _) <+ ?PropertyAssignment(_, _) <+ ?PageCall(_, _) <+ ?ThisCall(_, _))
    ; collect-effectful-potential-joins

  an-potential-joins = // Skip actions (because they are only called after a postback) and local redefines (because they are already analyzed when called)
    (?Action(_, _, _, _) <+ ?LocalRedefine(_, _, _, _, _) <+ ?Define(_, _, _, _, _) <+ ?TemplateCase(_, _))
    ; ![]

  // Same as resolve-entity-call, except here we allow failure
  // It also does not return functions that have an overridden version and it is unsure which version will be used
  try-resolve-entity-call: (ent, nm, targ*) -> result
    where not("Entity" := ent)
    ; (f, targ-resolved*) := <resolve-function-call-to-current-decl> (SimpleSort(ent), nm, targ*)
      < (<subentities-do-no-override> (ent, nm, targ-resolved*); result := (ent, f))
      + result := <try-resolve-entity-call> (<Extends> ent, nm, targ*)

  subentities-do-no-override =
    ?(ent, nm, targ-resolved*)
    ; all-keys-EntDecl
    ; filter({x_sub:
                ?x_sub
                ; where(
                    <not(eq)>(x_sub, ent)
		                ; <subtype-of>(SimpleSort(x_sub), SimpleSort(ent))
		                ; <EntityFunctionDecl>(x_sub, nm, targ-resolved*)
                )
             })
    //; (?[] <+ debug(!<concat-strings>[ent, "::", nm, " already defined for: "]))
    ; ?[]

  resolve-function-call-to-current-decl: p@(SimpleSort(x_class), fname, t*) -> (f, targ-resolved*)
    where targ-resolved* := <resolve-function-call(bagof-CheckFunctionSignatureArgumentTypes | t*, fname)> p
        ; f := <CurrentEntityFunctionDecl> (x_class, fname, targ-resolved*)
          
  // If statements possibly contribute if they have only an if or else block
  an-potential-joins =
    (?IfNoElseTempl(condExp, trueBlock) <+ ?IfNoElse(condExp, trueBlock) <+ ?IfTempl(condExp, trueBlock, []) <+ ?If(condExp, trueBlock, []))
    ; newCondExp := <repeat(innermost-rep(desugar)); repeat(oncetd(IteratedVarValue)); extract-query-cond; where(not(?True()))> condExp 
    ; listC := <collect-potential-joins> condExp
    ; OldQueryCond := <QueryConditions>
    ; rules( QueryConditions := <append-condition>(newCondExp, OldQueryCond) )
    ; listT := <collect-potential-joins> trueBlock
    ; rules( QueryConditions := OldQueryCond )
    ; !<concat>[listC, listT]

  an-potential-joins =
    (?IfTempl(condExp, [], falseBlock) <+ ?If(condExp, [], falseBlock))
    ; newCondExp := Not(<repeat(innermost-rep(desugar)); repeat(oncetd(IteratedVarValue)); extract-query-cond; where(not(?True()))> condExp)
    ; listC := <collect-potential-joins> condExp
    ; OldQueryCond := <QueryConditions>
    ; rules( QueryConditions := <append-condition>(newCondExp, OldQueryCond) )
    ; listF := <collect-potential-joins> falseBlock
    ; rules( QueryConditions := OldQueryCond )
    ; !<concat>[listC, listF]

  define-local-redefine =
    ?LocalRedefine(mods, tname, fargs, tname2, extraArgs)
    ; fargsredef := <local-redefine-arg-types(|fargs,extraArgs)>
    ; LocalRedefineArgs(argsredef) := extraArgs
    ; gennameredef := <generate-template-name> (<strip-annos>tname2, fargsredef)
    ; gennamecall := <generate-template-name-fargs> (tname, fargs)
    ; rules (
        LocalRedefName: gennamecall -> gennameredef
        LocalRedefArgs: gennamecall -> argsredef
      )

  define-local-redefine =
    ?def@Define(mods, tname{tname2}, fargs, targs, elems1){anno*}
    ; where(is-local-template-def)
    ; where(<fetch(?EnclosingDefine(templatekey, encltemplatename, encltemplateargs, _))> anno*)
    ; where((argsredef,fargs2) := <get-args-fargs-from-closure-in-anno-filtered> (anno*,[elems1,<map(get-varname-from-formarg)>encltemplateargs]))
    ; fargsredef := <conc>(fargs, fargs2)
    ; gennameredef := <generate-template-name> (<strip-annos>tname2, <template-formal-arguments-to-types>fargsredef)
    ; gennamecall := <generate-template-name-fargs> (tname, fargs)
    ; rules (
        LocalRedefDef: gennameredef -> Define(mods, tname{tname2}, fargsredef, targs, elems1){anno*} // Desugar has not been called on local redefine, so CurrentTemplateDecl will fail, we define a local version here 
        LocalRedefName: gennamecall -> gennameredef
        LocalRedefArgs: gennamecall -> argsredef
      )

  // Follow a template call
  an-potential-joins =
    (?TemplateCall(_, _, [tc@TemplateCall(name,args,_,TemplateBody([]))|_], TemplateBody([])) <+ ?tc@TemplateCallNoBody(name, args) <+ ?tc@TemplateCall(name, args, _, TemplateBody([])))
    ; not([] := <filter(is-accessible-from(IteratedVar <+ IteratedSubList); ?(_, <try-strip-generic-sort; is-entity-type>))> args)
    ; (genname, args2, def, redefined) := <get-local-template-redefine(|args)> tc
    ; <?Define(_, _, fargs, _, body)> def
    ; where(not(<PassedTemplate> genname)) // Prevents an infinite loop when following a recursive template
    ; {| PassedTemplate
       : rules( PassedTemplate : genname )
       ; <an-potential-joins-with-args(|args2, fargs)> body
       |}

  an-potential-joins = // If the above rule fails to lookup the template then we try to collect effectful joins from the call
    (?TemplateCall(_, _, [tc@TemplateCall(name,args,_,TemplateBody([]))|_], TemplateBody([])) <+ ?tc@TemplateCallNoBody(name, args) <+ ?tc@TemplateCall(name, args, _, TemplateBody([])))
    ; not([] := <filter(is-accessible-from(IteratedVar <+ IteratedSubList); ?(_, <try-strip-generic-sort; is-entity-type>))> args)
    ; not(
        (genname, args2, def, redefined) := <get-local-template-redefine(|args)> tc
        ; <?Define(_, _, fargs, _, body)> def
      )
    ; <collect-effectful-potential-joins> tc

  an-potential-joins =
    (?call@TemplateCallNoBody(name, args) <+ ?call@TemplateCall(name, args, _, TemplateBody([])))
    ; [] := <filter(is-accessible-from(IteratedVar <+ IteratedSubList); ?(_, <try-strip-generic-sort; is-entity-type>))> args // Contains no arguments that are of interest to us
    ; fromlocalredefs := <collect-from-local-redefines> call // Still we need to follow the call, just to see if a local redefine is called, which may have extra arguments which are of interest to us
    ; fromcallargs := <collect-effectful-potential-joins> args
    ; <conc> (fromlocalredefs, fromcallargs)

  an-potential-joins =
    (?TemplateCallNoAssigns(_,args,TemplateBody(body)) <+ ?TemplateCallPropsNoArgs(_,p,TemplateBody(body)) <+ ?TemplateCallBody(_,TemplateBody(body)) <+ ?TemplateCall(_,args,p,TemplateBody(body)))
    ; fromargs := <collect-effectful-potential-joins <+ ![]> args
    ; fromprops := <collect-effectful-potential-joins <+ ![]> p
    ; frombody := <collect-potential-joins> body
    ; <concat>[fromargs, fromprops, frombody]

  collect-from-local-redefines =
    (?tc@TemplateCallNoBody(name, args) <+ ?tc@TemplateCall(name, args, _, TemplateBody([])))
    ; (genname, _, def, False()) := <get-local-template-redefine(|args)> tc // Not a local redefine
    ; where(not(<PassedTemplate> genname))
    ; <?Define(_, _, _, _, body)> def
    ; calls := <collect(?TemplateCallNoBody(_, _) <+ ?TemplateCall(_, _, _, TemplateBody([])))> body
    ; {| PassedTemplate, LocalRedefDef, LocalRedefName, LocalRedefArgs
       : rules( PassedTemplate : genname )
       ; <alltd(define-local-redefine)> body
       ; <filter(collect-from-local-redefines)> calls // Just follow the calls
       |}

  collect-from-local-redefines =
    (?tc@TemplateCallNoBody(name, args) <+ ?tc@TemplateCall(name, args, _, TemplateBody([])))
    ; (genname, args2, def, True()) := <get-local-template-redefine(|args)> tc // This is a call to a redefined template
    ; where(not(<PassedTemplate> genname))
    ; <?Define(_, _, fargs, _, body)> def
    ; {| PassedTemplate
       : rules( PassedTemplate : genname )
       ; <an-potential-joins-with-args(|args2, fargs)> body // Analyze the call normally
       |}

  // Redirects attention to the local redefine and augments the arguments accordingly
  get-local-template-redefine(|args) =
    is-defined-tc-get-called-tc
    ; ?genname
    ; localname := <LocalRedefName> genname
    ; !(localname, <conc>(args, <LocalRedefArgs> genname), <CurrentTemplateDecl <+ LocalRedefDef> localname, True())

  get-local-template-redefine(|args) =
    is-defined-tc-get-called-tc
    ; where(not(LocalRedefName))
    ; !(<id>, args, <CurrentTemplateDecl>, False())

  an-potential-joins =
    ?Derive(deriveType, e, props*)
    ; <map(\ DeriveDefault(f) -> FieldAccess(e, f) \); collect-effectful-potential-joins> props*

  an-potential-joins =
    (?ForNoFilter(x, srt, e, _, _) <+ ?For(x, srt, e, f, _, _) <+ ?ForStmtNoFilter(x, srt, e, _) <+ ?ForStmt(x, srt, e, f, _))
    ; ?for
    ; not([] := <filter(is-accessible-from(IteratedVar))> e) 
    ; not(<IteratedSubList> Var(x))
    ; {| IteratedSubList, IteratedSubListValue // Different from IteratedVar, because the path represents a collection and thus may not be used in query conditions, but can still be used to find additional joins
       : rules( IteratedSubListValue : Var(x) -> e
                IteratedSubList      : Var(x) -> srt
              )
       ; <collect-potential-joins> for
       |}

  //an-potential-joins = debug(!"NoMatch:  "); fail
  //an-potential-joins = where(not(should-skip)); debug(!"NoMatch:  "); fail

  // The following terms do not contain interesting info themselves, but their sub-terms possibly do, so they may be skipped
  should-skip = ?[] <+ ?[_] <+ ?[_|_]
  should-skip = ?SimpleSort(_)
  should-skip = (is-query-condition-constant <+ ?None() <+ ?Null())
  should-skip = (?Or(_, _) <+ ?And(_, _) <+ ?Eq(_, _) <+ ?NotEq(_, _) <+ ?LargerThan(_, _) <+ ?LargerThanOrEqual(_, _) <+ ?SmallerThan(_, _) <+ ?SmallerThanOrEqual(_, _) <+ ?Not(_))
  should-skip = is-string
  should-skip = (?Text(_) <+ ?XMLEmptyElement(_, _) <+ ?XMLElement(_, _, _, _) <+ ?InitAction(_) <+ ?Block(_) <+ ?Stat(_) <+ ?Page() <+ ?TemplateBody(_))
  should-skip = (?Filter(_, _, _) <+ ?OrderNonSpecific(_) <+ ?OrderAscending(_) <+ ?OrderAscending(_) <+ ?Limit(_, _) <+ ?LimitNoOffset(_) <+ ?LimitNoLimit(_) <+ ?ForSeparator(_))
  should-skip = ?IfTempl(_, trueBlock, falseBlock); where(not([] := trueBlock); not([] := falseBlock)) // If an if statement has both a true and false code block then the condition is irrelevant and thus should be skipped over

  // Following terms need more attention
  should-skip = ?AccessControlImportRules(_, _) <+ ?ResolvedRequireKey(_)

  // The following matches call collect-effectful-potential-joins, so the second time they match IsEffectful should be true, and thus collect-effectful-potential-joins will fail.
  // This will result in collecting all sub-term FieldAccesses and Vars containing some variable respresenting RootVar, with their Effectful property set to true.
  should-skip = (?TemplateCallNoBody(_, _) <+ ?TemplateCall(_, _, _, _) <+ ?Call(_, _, _) <+ ?VarDeclInit(_, _, _) <+ ?VarDeclInitInferred(_, _) <+ ?Assignment(_, _) <+ ?PropertyAssignment(_, _) <+ ?PageCall(_, _) <+ ?ThisCall(_, _)); where(IsEffectful; ?True())

  // The following line prevents FieldAccesses and Vars not related to the var we are analyzing from showing up. An extra check could be added to make sure they are indeed not related
  should-skip = (?FieldAccess(_, _) <+ ?Var(_))

  // This strategy defines rules to keep track of template / function arguments
  an-potential-joins-with-args(|args, fargs) =
    ?body
    ; {| IteratedVar, IteratedVarValue, IteratedSubList, IteratedSubListValue, LocalRedefDef, LocalRedefName, LocalRedefArgs
       : with(id
         ; <alltd(define-local-redefine)> body
         // Here we mark the arguments as interesting, because they are in some way related to the persisten root or are constants which we can use in query conditions
         // Removed the warnings, because a loop could occur when following a local redefine, because then some variables inside the redefine can belong to the caller and thus have the same name. This warning can be safely ignored.
         ; <filter({vars:
                     \ (e, Arg(x, srt)) ->  <id>
                       where [] := <collect(IteratedSubList)> e; <is-var-accessible> e; not(<is-generic-sort> srt)
                       where not(<IteratedVarValue/*; warn(|["Ignoring variable ", x, ", because it would create a loop in IteratedVarValue"])*/> Var(x))
                       with rules( IteratedVarValue : Var(x) -> e     // Helps when expressing a Var into the Var or constant passed by the caller 
                                   IteratedVar      : Var(x) -> srt
                                 )
                     \})> <zip> (args, fargs)
         ; <filter({vars: 
                     \ (e, Arg(x, srt)) ->  <id>
                       where not([] := <collect(IteratedSubList)> e) <+ (<is-generic-sort> srt; <is-var-accessible> e)
                       where not(<IteratedSubListValue/*; warn(|["Ignoring variable ", x, ", because it would create a loop in IteratedSubListValue"])*/> Var(x))
                       with rules( IteratedSubListValue  : Var(x) -> e
                                   IteratedSubList       : Var(x) -> srt
                                 )
                     \})> <zip> (args, fargs)
         )
       ; <collect-potential-joins> body
     |}


strategies // checks for potential inlining

  an-find-entity-property-pair =
    ?fa@FieldAccess(l, fld)
    ; if Var(x) := l then
        !<concat-strings> ["_", fld]
      else
        !<concat-strings> [<an-find-entity-property-pair> l, "._", fld]
      end

  // Returns a string with underscore prefixed properties, casts should be removed beforehand
  an-requires-joining =
  	?(fa@FieldAccess(_, _), srt)
  	; where(<is-generic-sort <+ is-entity-type> srt)
    ; <an-find-entity-property-pair> fa

  an-requires-joining =
    ?(FieldAccess(fa@FieldAccess(_, _), _), srt)
    ; where(<not(is-generic-sort <+ is-entity-type)> srt)
    ; <an-find-entity-property-pair> fa

  // Returns a FieldAcces instead of a string, also supports casts
  an-requires-joining-fa :
    (fa@FieldAccess(_, _), srt) -> cleanfa
    where <is-generic-sort <+ is-entity-type> srt
    ; cleanfa := <clean-joincandidate> fa

  an-requires-joining-fa :
    (FieldAccess(expr, _), srt) -> cleanexpr
    where(<not(is-generic-sort <+ is-entity-type)> srt)
    ; not([] := <collect(?FieldAccess(_, _))> expr) // The expression must contain at least another FieldAccess, otherwise it's just a Var
    ; cleanexpr := <clean-joincandidate> expr

  clean-joincandidate :
    FieldAccess(p, f){anno*} -> FieldAccess(cleanp, f{}){newanno*}
    where newanno* := <filter(?UseFetchMode()); make-set> anno*
    ; cleanp := <clean-joincandidate> p

  clean-joincandidate :
    Cast(p, srt) -> Cast(cleanp, srt{}){}
    where cleanp := <clean-joincandidate> p

  clean-joincandidate :
    v@Var(_) -> v{}

  get-first-generic-sort =
    ?FieldAccess(<get-first-generic-sort>, _)

  get-first-generic-sort =
    ?FieldAccess(p, _)
    ; where(type-of; is-generic-sort; not(<get-first-generic-sort> p))

  get-first-generic-sort = ?Cast(<get-first-generic-sort>, _)

  group-similar-roots =
    ?allroots
    ; rootnames := <map(get-query-root-name)> allroots
    ; namedroots := <zip>(rootnames, allroots)
    ; groupedroots := <make-set; map(group-roots-by-name(|namedroots)); debug(!"grouped:")> rootnames
    ; <map(sort-roots-most-specific-first)> groupedroots

  get-query-root-name :
    FieldAccess(p, f) -> name
    with name := <concat-strings>[<get-query-root-name> p, ".", f]

  get-query-root-name :
    Cast(p, _) -> name
    with name := <get-query-root-name> p

  get-query-root-name :
    Var(_) -> ""

  group-roots-by-name(|namedroots) =
    ?name
    ; <filter(?(name, <id>))> namedroots

  sort-roots-most-specific-first =
    ?roots
    ; downcasts := <map(sort-roots-most-specific-first-helper1; remove-double-casts; collect-all(?Cast(_, <id>)); reverse)>
    ; <zip/*; ?rootswithcasts; map(add-less-specific-root(|rootswithcasts))*/; sort-list(LSort(root-more-specific)); reverse> (roots, downcasts)
    ; map(Fst)

  // Adds casts
  sort-roots-most-specific-first-helper1 :
    FieldAccess(p, f) -> Cast(FieldAccess(p2, f), None())
    with p2 := <sort-roots-most-specific-first-helper1> p

  sort-roots-most-specific-first-helper1 :
    Cast(p, srt){anno*} -> Cast(p2, srt){anno*}
    with p2 := <sort-roots-most-specific-first-helper1> p

  sort-roots-most-specific-first-helper1 :
    v@Var(_) -> Cast(v, None())

  root-more-specific =
    ?((_, downcasts1), (_, downcasts2))
    ; (srt1, srt2) := <zip; fetch-elem(not(eq))> (downcasts1, downcasts2)
    ; not(None() := srt1)
    ; <?(_, None()) <+ subtype-of> (srt1, srt2)

  remove-double-casts = repeat(oncetd(\ Cast(Cast(p, _), srt){anno*} -> Cast(p, srt){anno*} \))

  /*add-less-specific-root(|rootswithcasts):
    rootcastpair@(root, cast) -> _
    where <filter(where(<root-more-specific>(rootcastpair, <id>)))> rootswithcasts*/

  an-find-entity-property-pair-generic = ?Cast(<an-find-entity-property-pair-generic>, _)

  an-find-entity-property-pair-generic =
    ?fa@FieldAccess(l, fld)
    ; where(<type-of; is-generic-sort> fa)
    ; !(<remove-casts; an-find-entity-property-pair> fa, "")

  an-find-entity-property-pair-generic =
    ?fa@FieldAccess(l, fld)
    ; where(not(<type-of; is-generic-sort> fa))
    ; <an-find-entity-property-pair-generic> l
    ; ?(genericField, associations)
    ; !(genericField, <concat-strings>[associations, "._", fld])

  an-requires-joining-generic = // The last field acces should result in a join
    ?(p, srt)
    ; where(<is-generic-sort <+ is-entity-type> srt)
    ; <an-find-entity-property-pair-generic> p

  an-requires-joining-generic = // The last field access should not result in a join
    ?(FieldAccess(p, f), srt)
    ; where(not(<is-generic-sort <+ is-entity-type> srt))
    ; <an-find-entity-property-pair-generic> p

  an-requires-joining-generic = // Removes the casts around the last field access, in order to apply the above strategy
    ?(Cast(p, _), srt)
    ; where(not(<is-generic-sort <+ is-entity-type> srt))
    ; <an-requires-joining-generic> p

  is-var-accessible = is-query-condition-constant <+ (is-accessible-from(ParentArgs <+ IteratedVar); ?(<id>, _))

  get-accessible-expr = get-accessible-dbfield

  get-accessible-expr = get-accessible-field

  get-accessible-expr = is-query-condition-constant

  get-accessible-dbfield = (?Var(_) <+ ?FieldAccess(_, _)); repeat(oncetd(IteratedSubListValue <+ IteratedVarValue)); is-accessible-from(RootVar,id); ?(<id>, srt); where([] := <collect(?_{<fetch-elem(?UseFetchMode())>})>)

  get-accessible-field = (?Var(_) <+ ?FieldAccess(_, _)); repeat(oncetd(IteratedVarValue)); ((is-accessible-from(ParentArgs,id); ?(<id>, srt)) <+ is-query-condition-constant) 

  is-query-condition-type = ?SimpleSort("Int") <+ ?SimpleSort("Long") <+ ?SimpleSort("Float") <+ ?SimpleSort("String") <+ ?SimpleSort("Bool") <+ ?SimpleSort("UUID")

  is-query-condition-constant = (?Int(_) <+ ?Long(_) <+ ?Float(_) <+ ?String(_) <+ ?True() <+ ?False() <+ ?Null()); try(normalize) 

  extract-query-cond:
    Not(expr1) -> Not(expr1new)
    where expr1new := <extract-query-cond> expr1
    ; not(True() := expr1new)
    ; not(Eq(_, _) := expr1new)

  extract-query-cond:
    Not(expr1) -> NotEq(expr1new, expr2new)
    where eq@Eq(expr1new, expr2new) := <extract-query-cond> expr1
    ; not(<negate-simple-eq-cond> eq)

  extract-query-cond:
    Not(expr1) -> Eq(expr1new, expr2new)
    where Eq(expr1new, expr2new) := <extract-query-cond; negate-simple-eq-cond> expr1

  negate-simple-eq-cond: Eq(True(), expr) -> Eq(expr, False())
  negate-simple-eq-cond: Eq(expr, True()) -> Eq(expr, False())
  negate-simple-eq-cond: Eq(False(), expr) -> Eq(expr, True())
  negate-simple-eq-cond: Eq(expr, False()) -> Eq(expr, True())

  extract-query-cond:
    Or(expr1, expr2) -> Or(expr1new, expr2new)
    where expr1new := <extract-query-cond> expr1
    ; expr2new := <extract-query-cond> expr2
    ; not(True() := expr1new)
    ; not(True() := expr2new)

  extract-query-cond:
    And(expr1, expr2) -> cond
    where expr1new := <extract-query-cond <+ !True()> expr1
    ; expr2new := <extract-query-cond <+ !True()> expr2
    ; cond := <append-condition>(expr1new, expr2new)

  extract-query-cond:    
    SmallerThanOrEqual(expr1, expr2) -> SmallerThanOrEqual(newExpr1, newExpr2)
    where newExpr1 := <get-accessible-expr> expr1
    ; newExpr2 := <get-accessible-expr> expr2
    ; <is-one-dbprop> (expr1, expr2)

  extract-query-cond:
    SmallerThan(expr1, expr2) -> SmallerThan(newExpr1, newExpr2)
    where newExpr1 := <get-accessible-expr> expr1
    ; newExpr2 := <get-accessible-expr> expr2
    ; <is-one-dbprop> (expr1, expr2)

  extract-query-cond:
    LargerThanOrEqual(expr1, expr2) -> LargerThanOrEqual(newExpr1, newExpr2)
    where newExpr1 := <get-accessible-expr> expr1
    ; newExpr2 := <get-accessible-expr> expr2
    ; <is-one-dbprop> (expr1, expr2)

  extract-query-cond:
    LargerThan(expr1, expr2) -> LargerThan(newExpr1, newExpr2)
    where newExpr1 := <get-accessible-expr> expr1
    ; newExpr2 := <get-accessible-expr> expr2
    ; <is-one-dbprop> (expr1, expr2)

  extract-query-cond:
    NotEq(expr1, expr2) -> NotEq(newExpr1, newExpr2)
    where newExpr1 := <get-accessible-expr> expr1
    ; newExpr2 := <get-accessible-expr> expr2
    ; <is-one-dbprop> (expr1, expr2)

  extract-query-cond:
    Eq(expr1, expr2) -> Eq(newExpr1, newExpr2)
    where newExpr1 := <get-accessible-expr> expr1
    ; newExpr2 := <get-accessible-expr> expr2
    ; <is-one-dbprop> (expr1, expr2)

  extract-query-cond:
  	fa1@FieldAccess(_, _) -> Eq(fa2, True())
  	where (fa2, SimpleSort("Bool")) := <repeat(oncetd(IteratedSubListValue <+ IteratedVarValue)); is-accessible-from(RootVar,id)> fa1

  extract-query-cond:
    v1@Var(_) -> Eq(v2, True())
    where (v2, SimpleSort("Bool")) := <repeat(oncetd(IteratedSubListValue <+ IteratedVarValue)); is-accessible-from(RootVar,id)> v1

  extract-query-cond=
    ?Call(e1, nm, arg*){anno*}
    ; where(<is-accessible-from(IteratedVar <+ IteratedSubList); ?(e2, <is-entity-type; ?SimpleSort(ent)>)> e1)
    ; genname := <generate-template-name-args> (<concat-strings>[ent, nm], arg*)
    ; where(not(<PassedFunction> genname)) // This prevents an infinite loop when following a recursive function
    ; (fent, Function(_, fargs, SimpleSort("Bool"), Block([Return(expr)]))) := <try-resolve-entity-call> (ent, nm, <map(query-optimization-type-of)> arg*)
    // Here we get the properties of the entity and insert them as extra parameters for the function call
    // We also have to rename the Var("prop") to Var("prop"{Entity_myfunctionArg1Arg2}) to prevent creating a loop in IteratedVar or IteratedSubList
    ; thissafe := "this"{<concat-strings>[genname, "_this"]}
    ; {| RenamePropInFunction // Here we temporarily rename the Var()s in the function body for our analysis
        : argsbinding := <get-all-entity-properties-for-rename(|genname); map({name,uniquename,safename,srt:\
                                (name, uniquename, safename, srt) -> (FieldAccess(e2, name), Arg(safename, srt))
                                where rules( RenamePropInFunction : Var(uniquename) -> Var(safename) )
                            \}); <concat>[[(e2, Arg(thissafe, SimpleSort(fent)))],<id>,<zip>(arg*, fargs)]> ent
        ; rules( RenamePropInFunction : Var("this") -> Var(thissafe) )
        ; expr2 := <alltd(RenamePropInFunction)> expr
      |}
    ; {| PassedFunction, IteratedVar, IteratedVarValue, IteratedSubList, IteratedSubListValue
       : rules( PassedFunction : genname )
         // Here we mark the arguments as interesting, because they are in some way related to the persistent root or are constants which we can use in query conditions
         // Removed the warnings, because a loop could occur when following a local redefine, because then some variables inside the redefine can belong to the caller and thus have the same name. This warning can be safely ignored.
       ; <filter({vars:
                     \ (e, Arg(x, srt)) ->  <id>
                       where [] := <collect(IteratedSubList)> e; <is-var-accessible> e; not(<is-generic-sort> srt)
                       where not(<IteratedVarValue/*; warn(|["Ignoring variable ", x, ", because it would create a loop in IteratedVarValue"])*/> Var(x))
                       with rules( IteratedVarValue : Var(x) -> e     // Helps when expressing a Var into the Var or constant passed by the caller 
                                   IteratedVar      : Var(x) -> srt
                                 )
                     \})> argsbinding
       ; <filter({vars: 
                     \ (e, Arg(x, srt)) ->  <id>
                       where not([] := <collect(IteratedSubList)> e) <+ (<is-generic-sort> srt; <is-var-accessible> e)
                       where not(<IteratedSubListValue/*; warn(|["Ignoring variable ", x, ", because it would create a loop in IteratedSubListValue"])*/> Var(x))
                       with rules( IteratedSubListValue  : Var(x) -> e
                                   IteratedSubList       : Var(x) -> srt
                                 )
                     \})> argsbinding
       ; <extract-query-cond> expr2
       ; repeat(oncetd(IteratedSubListValue <+ IteratedVarValue))
     |}

  extract-query-cond = !True()

  get-all-entity-properties-for-rename(|prefix) =
    all-entity-properties-tuples
    ; {|OverridePropName
       : map({\ (ent, prop) -> <id> with propname := <get-property-name> prop; rules(OverridePropName : propname -> (ent, prop)) \})
       ; dr-all-keys(|"OverridePropName")
       ; map(OverridePropName; {ent,prop,name,uniquename,safename,srt:\ (ent, prop) -> (name, uniquename, safename, srt) where name := <get-property-name> prop; uniquename := <PropertyNameToUniqueName> (ent, name); safename := name{<concat-strings>[prefix, "_", name]}; srt := <get-property-type> prop \})
       |}
      
rules

  generate-template-name-args :
  	(n, args) -> genname
  	with t* := <map(query-optimization-type-of; strip-annos)> args
    ; name := <strip-annos> n
    ; genname := <generate-template-name> (name,t*)

  join-conditions:
  	(cond, []) -> cond

  join-conditions:
  	(cond, True()) -> cond

  join-conditions:
    (cond, prevCond) -> Or(prevCond, cond)
    where <not(?True()); not(?[])> prevCond

  add-required-alias:
    FieldAccess(p, f){anno*} -> FieldAccess(p{HasAlias()}, f){anno*}
    where <is-accessible-from(RootVar,id); Snd; is-entity-type> p

  append-condition:
  	(newCond, oldCond) -> And(newCond, oldCond)
  	where <not(?True())>newCond; <not(?True())>oldCond

  append-condition:
  	(newCond, True()) -> newCond

  append-condition:
  	(True(), oldCond) -> oldCond

  get-prop-type: (x_class, prop) -> <type-of-property>

  get-prop-type: (x_class, prop) -> <EntityIdType> x_class
    where <EntityIdName; ?prop> x_class

  is-one-dbprop: (expr1, expr2) -> <id>
    where <get-accessible-dbfield> expr1

  is-one-dbprop: (expr1, expr2) -> <id>
    where <get-accessible-dbfield> expr2

  query-optimization-type-of = (is-accessible-from(IteratedVar <+ IteratedSubList); Snd) <+ type-of

  // The default generic sort handler is try-strip-generic-sort, to allow fieldaccesses on collections
  // For query conditions this is not allowed, so there id should be used to deal with generic sorts
  is-accessible-from(s) = is-accessible-from(s,try-strip-generic-sort)

  is-accessible-from(s,gen): // Case where the cast is not needed
    Cast(f, srt){anno*} -> (p, srt)
    where (p, srt2) := <repeat(remove-top-level-cast); is-accessible-from(s,gen)> f
    //; (<subtype-of> (srt, srt2) <+ <subtype-of> (srt2, srt))
    ; <subtype-of> (srt2, srt) // up-cast or cast to same type

  is-accessible-from(s,gen): // Case where the cast is needed
    Cast(f, srt){anno*} -> (Cast(p, srt){srt2, anno*}, srt)
    where (p, srt2) := <repeat(remove-top-level-cast); is-accessible-from(s,gen)> f
    ; not(<?srt> srt2) 
    ; <subtype-of> (srt, srt2) // down-cast

  add-fetch-mode-anno: // srt is a sub entity of srt2
    fa@FieldAccess(Cast(p, srt){castanno*}, f){anno*} -> fa{UseFetchMode(),anno*}  
    where <fetch-elem(?srt2@SimpleSort(superent))> castanno*
    ; not(<get-prop-type> (superent, f)) // If the property is already defined on the source/super entity then there is no property clash
    //; info(|["Finding ", f, " from ", superent, " to ", srt])
    ; all-keys-EntDecl
    ; filter({x_sub: // We find out on which sub entities property f is defined
                ?x_sub
                ; where(
                    <not(eq)>(x_sub, superent)
                    ; <subtype-of>(SimpleSort(x_sub), srt2)
                    ; <TypeOfProperty> (x_sub, f) // Deliberate use of TypeOfProperty instead of type-of-property
                )
             })
    ; not(?[_]) // If not defined on exactly one sub entity
    //; debug(!"Match:")

  remove-top-level-cast:
    Cast(f, _) -> f

  is-accessible-from(s,gen):
    FieldAccess(v, f){anno*} -> (fa, srt)
    where (p, psrt) := <is-accessible-from(s,gen)> v
    ; <gen; ?SimpleSort(x_class)> psrt
    ; not(<is-derived-property> (x_class, f))
    ; srt := <get-prop-type; strip-ref-sort> (x_class, f)
    ; f2 := <try(get-real-col-prop-name(|x_class, srt))> f
    ; fa := <try(add-naturalid-anno(|x_class)); try(add-fetch-mode-anno)> FieldAccess(p, f2){anno*}

  is-accessible-from(s,gen):
    v@Var(_) -> (v, srt)
    where srt := <s; strip-ref-sort> v

  get-real-col-prop-name(|x_class, srt) =
    where(GenericSort("List", lsrt) := srt)
    ; where(string-ends-with(|"List"))
    ; string-as-chars(take(!(<length>, 4); subt)) // Get the real property name
    ; where(<get-prop-type> (x_class, <id>); ?GenericSort(_, lsrt)) // Check if the simple sort of the collections match

  add-naturalid-anno(|x_class) :
    fa@FieldAccess(_, f){anno*} -> fa{IsNaturalId(), anno*}
    where f := <natural-id-name-include-superclass> x_class
