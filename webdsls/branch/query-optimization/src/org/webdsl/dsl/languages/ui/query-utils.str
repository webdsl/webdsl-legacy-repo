module org/webdsl/dsl/languages/ui/query-utils

imports // imports only needed for pp-aterm-box and box2text-string
  libstratego-gpp
  libstratego-aterm


rules

  get-query-optimizations : (base, x, srt, args, cond) -> (joincandidatesnogen, joincandidatesgen, querycondition, conditionjoins)
    with {| RootVar, ParentArgs, IteratedVar, QueryConditions, IsEffectful, LocalRedefDef, LocalRedefName, LocalRedefArgs
       : rules (  IteratedVar     : Var(x) -> srt // Contains all variables we are following (is RootVar and template/function call arguments)
                  RootVar         : Var(x) -> srt // The actual variable we are interested in (the persistent root of our analysis)
                  QueryConditions := True()       // Changes over time to represent the query conditions active on the term currently being analyzed
                  IsEffectful     := False()      // True if the current statement is effectful (means: can affect non-local state), False otherwise
               )
       ; <alltd(define-local-redefine)> base
       ; <filter({vars: 
                     \ Arg(arg, srt) ->  <id>
                       with rules( ParentArgs      : Var(arg) -> srt )
                     \})> args
       //; info(|["base: ", <pp-aterm> base])
       ; info(|["Looking for property use of variable ", <pp-aterm-box ; box2text-string(|80)>x, " of type ", srt])
       ; rules( QueryConditions := <repeat(innermost-rep(desugar)); extract-query-cond> cond ) // Cannot move this up, because extract-query-cond requires previously defined rules
       //; QueryConditions; debug(!"cond:     ")
       ; fas := <collect-potential-joins> base
       //; <make-set; map(info(|["FA from ", x, ": ", <id>]))> fas
       ; querycondition := <(filter(?(_, _, True())); map(?(_, <id>, _)); make-set; try(?[]; ![True()]); foldr([], join-conditions) <+ !True()); alltd(?FieldAccess(_, _); where(type-of; is-entity-type); !<id>{HasAlias()})> fas // Combine query conditions of the effectful field accesses
       ; conditionjoins := <collect(?FieldAccess(_, _){HasAlias()}); map(an-find-entity-property-pair; group-join-candidates-build-paths); flatten-list; make-set; string-sort-desc> querycondition // These joins should be used everytime the queryconditon is used
       ; joincandidates := <map(?(<id>, _, _)); filter(an-requires-joining); flatten-list; make-set/*; string-sort-desc; foldr([], create-aliasses)*/> fas
       ; info(|["Should be inlined: ", joincandidates])
       ; queryjoins := <map(?(<id>, _, _)); filter(an-requires-joining-generic); make-set> fas
       ; queryroots := <map(?(<id>, _)); make-set; string-sort> queryjoins
       ; joincandidatesgen := <map(group-join-candidates(|queryjoins); !(<id>, conditionjoins); diff)> queryroots
       ; info(|["Inline by queries: ", joincandidatesgen]) // Each sublist creates an extra query to fetch subcollections
       ; joincandidatesnogen := <diff; map(group-join-candidates-build-paths); flatten-list; !(<id>, conditionjoins); diff; make-set; string-sort-desc> (joincandidates, <flatten-list; make-set>joincandidatesgen) 
       ; info(|["Inline by joining: ", joincandidatesnogen]) // Does not result in extra queries, but are joined on the unoptimized query itself
       ; info(|["Query condition:   ", <pp-webdsl>querycondition]) // A condition that can reduce the size of the result set
       ; info(|["Condition joins:   ", conditionjoins]) // These joins should also be present on extra queries (from inline by queries), because they are required for evaluating the query condition
      |}

/*
group-joins :
	(cur, []) -> [(cur, newGroup)]
	with newGroup := <group-join-candidates-build-paths> cur

group-joins :
	(cur, prev) -> [(cur, [cur|prevGroup]) | prevTail]
	where <?[prevHead|prevTail]> prev
	; <?(prevJoin, prevGroup)> prevHead
	; <string-starts-with(|prevJoin)> cur

group-joins :
	(cur, prev) -> [(cur, newGroup) | prev]
	where <?[prevHead|prevTail]> prev
	; <?(prevJoin, prevGroup)> prevHead
	; <not(string-starts-with(|prevJoin))> cur
	; newGroup := <group-join-candidates-build-paths> cur
*/

group-join-candidates-build-paths-helper :
	(x, []) -> [x]

group-join-candidates-build-paths-helper :
	(x, y) -> [x_new|y]
	where <?[headElem|_]> y
	; x_new := <concat-strings>[headElem, ".", x]

/*create-aliasses :
	(cur, []) -> [(cur, cur, <(string-tokenize(|['.']); last; str-tail) <+ str-tail> cur)]

create-aliasses :
	(cur, prev) -> [(newCur, cur, newAlias) | prev]
	where <head; ?(prevElem, prevOriginal, prevAlias)> prev
	; <string-starts-with(|prevOriginal)> cur
	; newCur := <concat-strings>[prevAlias, <explode-string; reverse; take(|<subt>(<strlen> cur, <strlen> prevOriginal)); reverse; implode-string> cur]
	; newAlias := <concat-strings>[prevAlias, <string-tokenize(|['.']); last> cur]

create-aliasses :
	(cur, prev) -> [(cur, cur, <(string-tokenize(|['.']); last; str-tail) <+ str-tail> cur) | prev]
	where <head; ?(prevElem, prevOriginal, prevAlias)> prev
	; <not(string-starts-with(|prevOriginal))> cur

head : [x|xs] -> x
tail : [x|xs] -> xs*/

strategies

  group-join-candidates-build-paths =
    string-tokenize(|['.'])
    ; !(<id>, [])
    ; foldl(group-join-candidates-build-paths-helper)

  group-join-candidates(|queryjoins) =
  	?currentroot
  	; <filter(?(currentroot, _); conc-strings)> queryjoins
  	; map(group-join-candidates-build-paths)
  	; flatten-list
  	; make-set
  	; string-sort-desc

  collect-potential-joins =
    collect(an-potential-joins)
    ; flatten-list

  collect-effectful-potential-joins =
    where(not(IsEffectful; ?True()))
    ; rules( IsEffectful := True())
    ; collect(an-potential-joins)
    ; flatten-list
    ; rules( IsEffectful := False() )

  an-potential-joins =
  	?Var(_)
  	; repeat(oncetd(IteratedVarValue))
  	; where(collect(?Var(_)); ?[<id>]; RootVar)
  	; !(<id>, <QueryConditions>, <IsEffectful>)

  an-potential-joins =
    ?FieldAccess(l, _)
    ; oncetd(where(IteratedVar); not(IteratedVarValue))
    ; where(get-accessible-var)
    ; !(<id>, <QueryConditions>, <IsEffectful>)

  an-potential-joins =
    ?fa@FieldAccess(l, _)
    ; repeat(oncetd(IteratedSubListValue <+ IteratedVarValue))
    ; not(?fa)
    ; where(get-accessible-var)
    ; !(<id>, <QueryConditions>, <IsEffectful>)

  /*an-potential-joins =
    ?fa@FieldAccess(l, _)
    ; repeat(oncetd(IteratedVarValue))
    ; not(?fa)
    ; where(get-accessible-var)
    ; !(<id>, <QueryConditions>, <IsEffectful>)

  an-potential-joins =
    ?fa@FieldAccess(l, _)
    ; repeat(oncetd(IteratedSubListValue))
    ; not(?fa)
    ; where(get-accessible-var)
    ; !(<id>, <QueryConditions>, <IsEffectful>)*/

  an-potential-joins =
    ?Var(_)
    ; repeat(oncetd(IteratedSubListValue <+ IteratedVarValue))
    ; not(?Var(_))
    ; where(get-accessible-var)
    ; !(<id>, <QueryConditions>, <IsEffectful>)

  an-potential-joins =
    ?Call(e, nm, arg*){anno*}
    ; where(evar := <get-accessible-var> e; esrt := <(IteratedVar <+ IteratedSubList)> evar)
    ; {| TypeOf
      	: rules( TypeOf: evar -> esrt )
    	; where(SimpleSort(ent) := <type-of; is-entity-type> e) // Only follow calls to entity functions
      |}
    ; genname := <generate-template-name-args> (<concat-strings>[ent, nm], arg*)
    ; where(not(<PassedFunction> genname)) // This prevents an infinite loop when following a recursive function
    ; decl := <try-resolve-entity-call> (ent, nm, <map(type-of)> arg*)
    ; ?Function(_, fargs, _, body)
    // Here we get the properties of the entity and insert them as extra parameters for the function call
    // We also have to rename the Var("prop") to Var("prop"{Entity_myfunctionArg1Arg2}) to prevent creating a loop in IteratedVar or IteratedSubList
    ; {| RenamePropInFunction // Here we temporarily rename the Var()s in the function body for our analysis
        : (args, fargs2) := <get-all-entity-properties-for-rename(|genname); map({name,uniquename,safename,srt:\
                                (name, uniquename, safename, srt) -> (FieldAccess(e, name), Arg(safename, srt))
                                where rules( RenamePropInFunction : Var(name) -> Var(safename) )
                            \}); unzip> ent
        ; body2 := <alltd(RenamePropInFunction)> body
      |}
    ; {| PassedFunction
       : rules( PassedFunction : genname -> genname )
       ; <an-potential-joins-with-args(|<conc>(args, arg*), <conc>(fargs2, fargs))> body2 // We add the properties of the entity as leading arguments of the function, this prevents them to be mistaken for local variables, which currently are ignored completely
       |}

  an-potential-joins =
    (?Call(_, _, _) <+ ?VarDeclInit(_, _, _) <+ ?VarDeclInitInferred(_, _) <+ ?Assignment(_, _) <+ ?PropertyAssignment(_, _) <+ ?PageCall(_, _) <+ ?ThisCall(_, _))
    ; collect-effectful-potential-joins

  try-resolve-entity-call: (ent, nm, targ*) -> f // Same as resolve-entity-call, except here we allow failure
    where not("Entity" := ent)
    ; f := <resolve-function-call-to-decl> (SimpleSort(ent), nm, targ*)
      <+ f := <try-resolve-entity-call> (<Extends> ent, nm, targ*)

  // If statements possibly contribute if they have only an if or else block
  an-potential-joins =
    (?IfNoElseTempl(condExp, trueBlock) <+ ?IfNoElse(condExp, trueBlock) <+ ?IfTempl(condExp, trueBlock, []) <+ ?If(condExp, trueBlock, []))
    ; newCondExp := <repeat(innermost-rep(desugar)); repeat(oncetd(IteratedVarValue)); extract-query-cond> condExp 
    ; listC := <collect-potential-joins> condExp
    ; OldQueryCond := <QueryConditions>
    ; rules( QueryConditions := <append-condition>(newCondExp, OldQueryCond) )
    ; listT := <collect-potential-joins> trueBlock
    ; rules( QueryConditions := OldQueryCond )
    ; !<concat>[listC, listT]

  an-potential-joins =
    (?IfTempl(condExp, [], falseBlock) <+ ?If(condExp, [], falseBlock))
    ; newCondExp := <try(?Not(True()); !True())>Not(<repeat(innermost-rep(desugar)); repeat(oncetd(IteratedVarValue)); extract-query-cond> condExp)
    ; listC := <collect-potential-joins> condExp
    ; OldQueryCond := <QueryConditions>
    ; rules( QueryConditions := <append-condition>(newCondExp, OldQueryCond) )
    ; listF := <collect-potential-joins> falseBlock
    ; rules( QueryConditions := OldQueryCond )
    ; !<concat>[listC, listF]

  define-local-redefine =
    ?LocalRedefine(mods, tname, fargs, tname2, extraArgs)
    ; fargsredef := <local-redefine-arg-types(|fargs,extraArgs)>
    ; LocalRedefineArgs(argsredef) := extraArgs
    ; gennameredef := <generate-template-name> (<strip-annos>tname2, fargsredef)
    ; gennamecall := <generate-template-name-fargs> (tname, fargs)
    ; rules (
        LocalRedefName: gennamecall -> gennameredef
        LocalRedefArgs: gennamecall -> argsredef
      )

  define-local-redefine =
    ?def@Define(mods, tname{tname2}, fargs, _, elems1){anno*}
    ; where(is-local-template-def)
    ; where(<fetch(?EnclosingDefine(templatekey, encltemplatename, encltemplateargs, _))> anno*)
    ; where((argsredef,fargs2) := <get-args-fargs-from-closure-in-anno-filtered> (anno*,[elems1,<map(get-varname-from-formarg)>encltemplateargs]))
    ; fargsredef := <local-redefine-arg-types(|fargs,LocalRedefineArgs(argsredef))>
    ; gennameredef := <generate-template-name> (<strip-annos>tname2, fargsredef)
    ; gennamecall := <generate-template-name-fargs> (tname, fargs)
    ; rules (
        LocalRedefDef: gennameredef -> def // Desugar has not been called on local redefine, so CurrentTemplateDecl will fail, we define a local version here 
        LocalRedefName: gennamecall -> gennameredef
        LocalRedefArgs: gennamecall -> argsredef
      )

  // Follow a template call
  an-potential-joins =
    (?TemplateCallNoBody(name, args) <+ ?TemplateCall(name, args, _, TemplateBody([])))
    ; not([] := <filter(where(type-of; is-entity-type); get-accessible-var; (IteratedVar <+ IteratedSubList))> args)
    ; (genname, args2, def) := <generate-template-name-args; get-local-template-redefine(|args)> (name, args)
    ; where(not(<PassedTemplate> genname)) // Prevents an infinite loop when following a recursive template
    ; <?Define(_, _, fargs, _, body)> def
    ; {| PassedTemplate
       : rules( PassedTemplate : genname -> genname )
       ; <an-potential-joins-with-args(|args2, fargs)> body
       |}

  an-potential-joins =
    (?call@TemplateCallNoBody(name, args) <+ ?call@TemplateCall(name, args, _, TemplateBody([])))
    ; [] := <filter(where(type-of; is-entity-type); get-accessible-var; (IteratedVar <+ IteratedSubList))> args // Contains no arguments that are of interest to us
    ; fromlocalredefs := <collect-from-local-redefines> call // Still we need to follow the call, just to see if a local redefine is called, which may have extra arguments which are of interest to us
    ; fromcallargs := <collect-effectful-potential-joins> args
    ; <conc> (fromlocalredefs, fromcallargs)

  collect-from-local-redefines =
    (?TemplateCallNoBody(name, args) <+ ?TemplateCall(name, args, _, TemplateBody([])))
    ; (genname, _, def) := <generate-template-name-args; where(not(LocalRedefName)); get-local-template-redefine(|args)> (name, args) // Not a local redefine
    ; where(not(<PassedTemplate> genname))
    ; <?Define(_, _, _, _, body)> def
    ; calls := <collect(?TemplateCallNoBody(_, _) <+ ?TemplateCall(_, _, _, TemplateBody([])))> body
    ; {| PassedTemplate, LocalRedefDef, LocalRedefName, LocalRedefArgs
       : rules( PassedTemplate : genname -> genname )
       ; <alltd(define-local-redefine)> body
       ; <filter(collect-from-local-redefines)> calls // Just follow the calls
       |}

  collect-from-local-redefines =
    (?TemplateCallNoBody(name, args) <+ ?TemplateCall(name, args, _, TemplateBody([])))
    ; (genname, args2, def) := <generate-template-name-args; where(LocalRedefName); get-local-template-redefine(|args)> (name, args) // This is a call to a redefined template
    ; where(not(<PassedTemplate> genname))
    ; <?Define(_, _, fargs, _, body)> def
    ; {| PassedTemplate
       : rules( PassedTemplate : genname -> genname )
       ; <an-potential-joins-with-args(|args2, fargs)> body // Analyze the call normally
       |}

  // Redirects attention to the local redefine and augments the arguments accordingly
  get-local-template-redefine(|args) =
    ?genname
    ; localname := <LocalRedefName> genname
    ; !(localname, <conc>(args, <LocalRedefArgs> genname), <CurrentTemplateDecl <+ LocalRedefDef> localname)

  get-local-template-redefine(|args) =
    where(not(LocalRedefName))
    ; !(<id>, args, <CurrentTemplateDecl>)

  an-potential-joins =
    ?TemplateCall(_, args*, passign*, TemplateBody([]))
    ; where(<fetch(?tc@TemplateCall(_,_,_,_))> passign*)
    ; effectful := <conc; remove-all(?tc); collect-effectful-potential-joins> (args*, passign*)
    ; called := <collect-potential-joins> tc
    ; <conc> (effectful, called)

  an-potential-joins =
    (?TemplateCallNoBody(_, _) <+ ?TemplateCall(_, _, _, _))
    ; collect-effectful-potential-joins

  an-potential-joins =
    ?Derive(deriveType, e, props*)
    ; <map(\ DeriveDefault(f) -> FieldAccess(e, f) \); collect-effectful-potential-joins> props*

  an-potential-joins =
    (?ForNoFilter(x, srt, e, _, _) <+ ?For(x, srt, e, _, _, _) <+ ?ForStmtNoFilter(x, srt, e, _) <+ ?ForStmt(x, srt, e, _, _))
    ; ?for
    ; not([] := <filter(get-accessible-var; IteratedVar)> e) 
    ; not(<IteratedSubList> Var(x))
    ; {| IteratedSubList, IteratedSubListValue // Different from IteratedVar, because the path represents a collection and thus may not be used in query conditions, but can still be used to find additional joins
       : rules( IteratedSubListValue : Var(x) -> e
                IteratedSubList      : Var(x) -> srt
              )
       ; <collect-potential-joins> for
       |}

  //an-potential-joins = debug(!"NoMatch:  "); fail
  //an-potential-joins = where(not(should-skip)); debug(!"NoMatch:  "); fail

  // The following terms do not contain interesting info themselves, but their sub-terms possibly do, so they may be skipped
  should-skip = ?[] <+ ?[_] <+ ?[_|_]
  should-skip = ?SimpleSort(_)
  should-skip = (is-query-condition-constant <+ ?None() <+ ?Null())
  should-skip = (?Or(_, _) <+ ?And(_, _) <+ ?Eq(_, _) <+ ?NotEq(_, _) <+ ?LargerThan(_, _) <+ ?LargerThanOrEqual(_, _) <+ ?SmallerThan(_, _) <+ ?SmallerThanOrEqual(_, _) <+ ?Not(_))
  should-skip = is-string
  should-skip = (?Text(_) <+ ?XMLEmptyElement(_, _) <+ ?XMLElement(_, _, _, _) <+ ?InitAction(_) <+ ?Block(_) <+ ?Stat(_) <+ ?Page() <+ ?TemplateBody(_))
  should-skip = (?Filter(_, _, _) <+ ?OrderNonSpecific(_) <+ ?OrderAscending(_) <+ ?OrderAscending(_) <+ ?Limit(_, _) <+ ?LimitNoOffset(_) <+ ?LimitNoLimit(_) <+ ?ForSeparator(_))
  should-skip = ?IfTempl(_, trueBlock, falseBlock); where(not([] := trueBlock); not([] := falseBlock)) // If an if statement has both a true and false code block then the condition is irrelevant and thus should be skipped over

  // Following terms need more attention
  should-skip = ?AccessControlImportRules(_, _) <+ ?ResolvedRequireKey(_)

  // The following matches call collect-effectful-potential-joins, so the second time they match IsEffectful should be true, and thus collect-effectful-potential-joins will fail.
  // This will result in collecting all sub-term FieldAccesses and Vars containing some variable respresenting RootVar, with their Effectful property set to true.
  should-skip = (?TemplateCallNoBody(_, _) <+ ?TemplateCall(_, _, _, _) <+ ?Call(_, _, _) <+ ?VarDeclInit(_, _, _) <+ ?VarDeclInitInferred(_, _) <+ ?Assignment(_, _) <+ ?PropertyAssignment(_, _) <+ ?PageCall(_, _) <+ ?ThisCall(_, _)); where(IsEffectful; ?True())

  // The following line prevents FieldAccesses and Vars not related to the var we are analyzing from showing up. An extra check could be added to make sure they are indeed not related
  should-skip = (?FieldAccess(_, _) <+ ?Var(_))

  // This strategy defines rules to keep track of template / function arguments
  an-potential-joins-with-args(|args, fargs) =
    ?body
    ; {| IteratedVar, IteratedVarValue, IteratedSubList, IteratedSubListValue, LocalRedefDef, LocalRedefName, LocalRedefArgs
       : with(id
         ; <alltd(define-local-redefine)> body
         // Here we mark the arguments as interesting, because they are in some way related to the persisten root or are constants which we can use in query conditions
         ; <filter({vars:
                     \ (e, Arg(x, srt)) ->  <id>
                       where [] := <collect(IteratedSubList)> e; <is-var-accessible> e
                       where not(<IteratedVarValue; warn(|["Ignoring variable ", x, ", because it would create a loop in IteratedVarValue"])> Var(x))
                       with rules( IteratedVarValue : Var(x) -> e     // Helps when expressing a Var into the Var or constant passed by the caller 
                                   IteratedVar      : Var(x) -> srt
                                 )
                     \})> <zip> (args, fargs)
         ; <filter({vars: 
                     \ (e, Arg(x, srt)) ->  <id>
                       where not([] := <collect(IteratedSubList)> e)
                       where not(<IteratedSubListValue; warn(|["Ignoring variable ", x, ", because it would create a loop in IteratedSubListValue"])> Var(x))
                       with rules( IteratedSubListValue  : Var(x) -> e
                                   IteratedSubList       : Var(x) -> srt
                                 )
                     \})> <zip> (args, fargs)
         ) 
       ; <collect-potential-joins> body
     |}


strategies // checks for potential inlining

  an-find-entity-property-pair =
    ?fa@FieldAccess(l, fld)
    ; if Var(x) := l then
        !<concat-strings> ["_", fld]
      else
        !<concat-strings> [<an-find-entity-property-pair> l, "._", fld]
      end

  an-requires-joining =
  	?fa@FieldAccess(_, _)
  	; where(<type-of; (is-generic-sort <+ is-entity-type)> fa)
    ; <an-find-entity-property-pair> fa

  an-requires-joining =
    ?FieldAccess(fa@FieldAccess(_, _), _)
    ; <an-find-entity-property-pair> fa

  an-find-entity-property-pair-generic =
    ?fa@FieldAccess(l, fld)
    ; where(<type-of; is-generic-sort> fa)
    ; !(<an-find-entity-property-pair> fa, "")

  an-find-entity-property-pair-generic =
    ?fa@FieldAccess(l, fld)
    ; where(not(<type-of; is-generic-sort> fa))
    ; <an-find-entity-property-pair-generic> l
    ; ?(genericField, associations)
    ; !(genericField, <concat-strings>[associations, "._", fld])

  an-requires-joining-generic =
    ?fa@FieldAccess(_, _)
    ; where(<type-of; is-generic-sort> fa)
    ; !(<an-find-entity-property-pair> fa, "")

  an-requires-joining-generic =
    ?fa1@FieldAccess(fa2@FieldAccess(_, _), _)
    ; where(not(<type-of; is-generic-sort> fa1))
    ; <an-find-entity-property-pair-generic> fa2

  is-var-accessible = where(is-query-condition-constant <+ (get-accessible-var; (ParentArgs <+ IteratedVar)))

  get-accessible-expr = where(
  	(ParentArgs <+ IteratedVar)
  	; ?SimpleSort(x_class)
  	; srt := <EntityIdType> x_class
  	; <is-query-condition-type> srt
  	; fieldName := <EntityIdName> x_class)
  	; !FieldAccess(<id>, fieldName){srt} // I am still adding an annotation to store the type when that type could be a UUID, I used this to generate different code for those field, because this type caused a typecast exception  

  get-accessible-expr = get-accessible-dbfield

  get-accessible-expr = get-accessible-field

  get-accessible-expr = where(is-query-condition-constant)

  get-accessible-expr = where((ParentArgs <+ IteratedVar); is-query-condition-type)

  get-accessible-dbfield = where(?FieldAccess(v, _); <?Var(_)> v; <RootVar> v)

  get-accessible-dbfield = where(?FieldAccess(v, _); <get-accessible-dbfield> v)

  get-accessible-field =
  	where(
  	  ?fa@FieldAccess(v, f)
  	  ; x_class := <get-accessible-field-type> v
      ; srt := <get-prop-type>(x_class, f)
      ; <is-query-condition-type> srt
    )
    ; !fa{srt}

  get-accessible-field =
  	where(
  	  ?fa@FieldAccess(v, f)
  	  ; v_class := <get-accessible-field-type> v
      ; x_class := <get-prop-type>(v_class, f)
      ; srt := <EntityIdType> x_class
      ; <is-query-condition-type> srt
      ; fieldName := <EntityIdName> x_class
    )
    ; !FieldAccess(fa, fieldName){srt}

  get-accessible-field-type = where(?v@Var(_); not(<RootVar> v))
    ; <(ParentArgs <+ IteratedVar); ?SimpleSort(<id>)> v

  get-accessible-field-type = where(?FieldAccess(v, f); not(<RootVar> v))
    ; x_class := <(ParentArgs <+ IteratedVar); ?SimpleSort(<id>)> v
    ; <get-prop-type>(x_class, f)

  get-accessible-field-type = where(?FieldAccess(v, f); x_class := <get-accessible-field-type> v)
    ; <get-prop-type>(x_class, f)

  is-query-condition-type = ?SimpleSort("Int") <+ ?SimpleSort("Long") <+ ?SimpleSort("Float") <+ ?SimpleSort("String") <+ ?SimpleSort("Bool") <+ ?SimpleSort("UUID")

  is-query-condition-constant = ?Int(_) <+ ?Long(_) <+ ?Float(_) <+ ?String(_) <+ True() <+ False()

  extract-query-cond =
    ?Not(expr1)
    ; expr1new := <extract-query-cond> expr1
    ; where(<not(?True())>expr1new)
    ; !Not(expr1new)

  extract-query-cond =
    ?cond@Or(expr1, expr2)
    ; expr1new := <extract-query-cond> expr1
    ; expr2new := <extract-query-cond> expr2
    ; where(<not(?True())>expr1new; <not(?True())>expr2new)
    ; !Or(expr1new, expr2new)

  extract-query-cond =
    ?And(expr1, expr2)
    ; expr1new := <extract-query-cond <+ !True()> expr1
    ; expr2new := <extract-query-cond <+ !True()> expr2
    ; !<append-condition>(expr1new, expr2new)

  extract-query-cond =    
    ?SmallerThanOrEqual(expr1, expr2)
    ; where(newExpr1 := <get-accessible-expr> expr1; newExpr2 := <get-accessible-expr> expr2; <is-one-dbprop> (expr1, expr2))
    ; !SmallerThanOrEqual(newExpr1, newExpr2)

  extract-query-cond =
    ?SmallerThan(expr1, expr2)
    ; where(newExpr1 := <get-accessible-expr> expr1; newExpr2 := <get-accessible-expr> expr2; <is-one-dbprop> (expr1, expr2))
    ; !SmallerThan(newExpr1, newExpr2)

  extract-query-cond =
    ?LargerThanOrEqual(expr1, expr2)
    ; where(newExpr1 := <get-accessible-expr> expr1; newExpr2 := <get-accessible-expr> expr2; <is-one-dbprop> (expr1, expr2))
    ; !LargerThanOrEqual(newExpr1, newExpr2)

  extract-query-cond =
    ?LargerThan(expr1, expr2)
    ; where(newExpr1 := <get-accessible-expr> expr1; newExpr2 := <get-accessible-expr> expr2; <is-one-dbprop> (expr1, expr2))
    ; !LargerThan(newExpr1, newExpr2)

  extract-query-cond =
    ?NotEq(expr1, expr2)
    ; where(newExpr1 := <get-accessible-expr> expr1; newExpr2 := <get-accessible-expr> expr2; <is-one-dbprop> (expr1, expr2))
    ; !NotEq(newExpr1, newExpr2)

  extract-query-cond =
    ?Eq(expr1, expr2)
    ; where(newExpr1 := <get-accessible-expr> expr1; newExpr2 := <get-accessible-expr> expr2; <is-one-dbprop> (expr1, expr2))
    ; !Eq(newExpr1, newExpr2)

  extract-query-cond = !True()

  get-all-entity-properties-for-rename(|prefix) =
    all-entity-properties-tuples
    ; {|OverridePropName
       : map({\ (ent, prop) -> <id> with propname := <get-property-name> prop; rules(OverridePropName : propname -> (ent, prop)) \})
       ; dr-all-keys(|"OverridePropName")
       ; map(OverridePropName; {ent,prop,name,uniquename,safename,srt:\ (ent, prop) -> (name, uniquename, safename, srt) where name := <get-property-name> prop; uniquename := <PropertyNameToUniqueName> (ent, name); safename := name{<concat-strings>[prefix, "_", name]}; srt := <get-property-type> prop \})
       |}
      
rules

  generate-template-name-args :
  	(n, args) -> genname
  	with t* := <map(type-of; strip-annos)> args
    ; name := <strip-annos> n
    ; genname := <generate-template-name> (name,t*)

  join-conditions:
  	(cond, []) -> cond

  join-conditions:
  	(cond, True()) -> cond

  join-conditions:
  	(cond, prevCond) -> Or(prevCond, cond)
	where <not(?True()); not(?[])> prevCond

  append-condition:
  	(newCond, oldCond) -> And(newCond, oldCond)
  	where <not(?True())>newCond; <not(?True())>oldCond

  append-condition:
  	(newCond, True()) -> newCond

  append-condition:
  	(True(), oldCond) -> oldCond

  anno-query-expr:
  	(t, expr) -> expr
  	where <where(is-query-condition-type);not(?SimpleSort("UUID"))> t 

  anno-query-expr:
  	(SimpleSort("UUID"), expr) -> expr{SimpleSort("UUID")}

  get-prop-type: (x_class, prop) -> <TypeOfProperty>

  get-prop-type: (x_class, prop) -> <EntityIdType> x_class
    where <EntityIdName; ?prop> x_class

  is-one-dbprop: (expr1, expr2) -> <id>
    where <get-accessible-dbfield <+ RootVar> expr1

  is-one-dbprop: (expr1, expr2) -> <id>
    where <get-accessible-dbfield <+ RootVar> expr2

  get-accessible-var :
  	FieldAccess(fa, _) -> var
  	where var := <get-accessible-var> fa

  get-accessible-var :
	Var(_) -> <id>
