module org/webdsl/dsl/languages/action/rename

signature
  constructors
    EntityFunctionAnno : Term    

rules

  rename-action :
    v@VarDecl(x, srt){anno*} -> VarDecl(y, srt2){anno*}
    where InDef
    with  srt2 := <rename-all> srt 
        ; y := <rename-bound(|srt2)> x
        ; <declare-vars-in-context> y
        ; rules(VarDecl : y -> v)

  rename-action :
    v@VarDeclInit(x, srt, e){anno*} -> VarDeclInit(y, srt2, e'){anno*}
    where InDef
    with  srt2 := <rename-all> srt
        ; e' := <rename-all> e
        ; y := <rename-bound(|srt2)> x
        ; <declare-vars-in-context> y
        ; rules(VarDecl : y -> v)
        
  rename-action :
    v@VarDeclInitInferred(x, e){anno*} -> VarDeclInitInferred(y, e'){anno*}
    where InDef
    with  e' := <rename-all> e
        ; srt := <type-of;strip-immutable-anno <+ !"unknown"> e'
          // type-of can fail if the expression cannot be typed, in that case the var will not be declared and constraint error triggers
          // strip ImmutableReference annotation, because x will be assignable even if e wasn't
        ; y := <rename-bound(|srt)> x 
        ; <declare-vars-in-context> y
        ; rules(VarDecl : y -> v)

  rename-action :
    v@VarDeclInit(x, srt, e{anno*}){anno_v*} -> VarDeclInit(x, srt, e'{ObjectCreationSecretTypesNeedDigests(),anno*}){anno_v*}
    where not(InDef)//needed for inital rename
        ; not(IsGlobal)//needed for rename from model-to-model innermost without context
    with  e' := <rename-all> e
        
  rename-action :
    v@VarDeclInitInferred(x, e{anno*}){anno_v*} -> VarDeclInitInferred(x, e'{ObjectCreationSecretTypesNeedDigests(),anno*}){anno_v*}
    where not(InDef)//needed for inital rename
        ; not(IsGlobal)//needed for rename from model-to-model innermost without context
    with  e' := <rename-all> e
        
   rename-action :
     s@SimpleSort(_) -> s2
     with  s3 := <rename-type> s
         ; s2 := <rename-sort-for-generic> s3
         
   rename-action :
     GenericSort(g, types){anno*} -> GenericSort(g, types2){anno*} 
     where not( g := "SDFInput")
     with  types2 := <rename-all> types

   /**
    *  Important, takes care of scoping if-then-else blocks in action code and in templates
    */ 
   rename-action :
    Block(stat1*){anno*} -> Block(stat2*){anno*}
    with {| Rename, VarInTemplateContext
          : stat2* := <rename-all> stat1*
          |}
          
  rename-action :
    f@Function(x, farg1*, srt, b1){anno*} -> Function(x, farg2*, srt, b2){newanno*}
    where not(InEntity)
    with {| Rename, InDef, FunctionArg, VarInTemplateContext
          : rules ( InDef := True() )
          ; farg2* := <map(rename)> farg1*
          ; rules ( FunctionArg := farg2* )
          ; <declare-args-in-context> farg2*
          ; b2 := <rename-all> b1
          ; newanno* := <try-add-query-optimized-function> f
          |}

  rename-action :
    FunctionNoReturn(x, farg1*, b1){anno*} -> FunctionNoReturn(x, farg2*, b2){anno*}
    where not(InEntity)
    with {| Rename, InDef, FunctionArg, VarInTemplateContext
          : rules ( InDef := True() )
          ; farg2* := <map(rename)> farg1*
          ; rules ( FunctionArg := farg2* )
          ; <declare-args-in-context> farg2*
          ; b2 := <rename-all> b1
          |}

  rename-action :
    Function(x, farg1*, srt, b1){anno*} -> <add-new-anno(|EntityFunctionAnno())> Function(x, farg2*, srt, b2){anno*}
    where InEntity
    with {| Rename, InDef, FunctionArg, VarInTemplateContext
          : rules ( InDef := True() )
          ; farg2* := <map(rename)> farg1*
          ; rules ( FunctionArg := farg2* )
          ; <declare-args-in-context> farg2*
          ; b2 := <rename-all> b1
          |}

  rename-action :
    FunctionNoReturn(x, farg1*, b1){anno*} -> <add-new-anno(|EntityFunctionAnno())> FunctionNoReturn(x, farg2*, b2){anno*}
    where InEntity
    with {| Rename, InDef, FunctionArg, VarInTemplateContext
          : rules ( InDef := True() )
          ; farg2* := <map(rename)> farg1*
          ; rules ( FunctionArg := farg2* )
          ; <declare-args-in-context> farg2*
          ; b2 := <rename-all> b1
          |}

  /**
   *  Used for rename of many argument types, including templates, functions
   */
  rename-action :
    a@Arg(x, srt){anno*} -> Arg(y, srt2){anno*} 
    where <not(fetch-elem(?QueryOptimizations(_, _, _, _)))> anno*
    with srt2 := <rename-type> srt
       ; y := <rename-bound-immutable(|srt2)> x
       ; rules(VarDecl : y -> a)

  // we need to keep query optimizations
  rename-action :
    a@Arg(x, srt){anno*} -> Arg(y, srt2){QueryOptimizations(jp, jpgen, newcond, condjoin), newanno*}
    where <fetch-elem(?QueryOptimizations(jp, jpgen, cond, condjoin))> anno*
    with newanno* := <remove-all(?QueryOptimizations(jp, jpgen, cond, condjoin))> anno*
       ; srt2 := <rename-type> srt
       ; y := <rename-bound-immutable(|srt2)> x
       ; newcond := <alltd(\ Var(x) -> Var(y) \)> cond
       ; rules(VarDecl : y -> a)

  try-add-query-optimized-function :
  	Function(x, fargs, srt, b1){anno*} -> newanno*
  	where not(<fetch-elem(?HasQueryOptimizedVersion())> anno*)
  	; not(<fetch-elem(?QueryOptimizationVars(_, _))> anno*)
  	; GenericSort(_, [simplesrt]) := srt
  	; <is-entity-type> simplesrt
  	with joinvar := "joins"{<concat-strings; newname-webdsl>[x, "_joins"]}
    ; condvar := "condition"{<concat-strings; newname-webdsl>[x, "_condition"]}
    ; newargs := <concat>[ fargs, [Arg(joinvar, SimpleSort("Object")), Arg(condvar, SimpleSort("Object"))] ]
    ; <emit-webdsl-code;rename> Function(x,newargs,srt,b1){anno*,QueryOptimizationVars(Var(joinvar), Var(condvar))}
    ; newanno* := [HasQueryOptimizedVersion()|anno*]

  try-add-query-optimized-function : // This is the optimized version, but we need to rename the vars in the annotation again
    Function(x, farg1*, srt, b1){anno*} -> newanno*
    where <fetch-elem(?QueryOptimizationVars(joinvar, condvar))> anno*
    with newanno* := <remove-all(?QueryOptimizationVars(_, _)); ![QueryOptimizationVars(<rename>joinvar, <rename>condvar)|<id>]> anno*

  try-add-query-optimized-function : // We already added an optimized version
    Function(x, farg1*, srt, b1){anno*} -> anno*
    where <fetch-elem(?HasQueryOptimizedVersion())> anno*

  try-add-query-optimized-function : // No optimized version needed
    Function(x, farg1*, srt, b1){anno*} -> anno*
    where not(GenericSort(_, [simplesrt]) := srt)

  try-add-query-optimized-function : // No optimized version needed
    Function(x, farg1*, srt, b1){anno*} -> anno*
    where GenericSort(_, [simplesrt]) := srt; not(<is-entity-type> simplesrt)
