module org/webdsl/dsl/languages/query-analysis

rules // Entry points

  perform-query-analysis(|name,args,cond) :
    (body, anno*) -> (body, [qa | anno*])
    where QueryOptimizationDisabled
    ; not(<fetch-elem(is-query-analysis)> anno*)
    ; qa := <get-empty-query-analysis>
    //; info(|"QueryOptimization disabled")

  perform-waiting-check-only(|args) :
    (body, anno*) -> wait
    where not(QueryOptimizationDisabled)
    ; not(<fetch-elem(is-query-analysis)> anno*)
    ; {| RootVar, QueryConditions, IsEffectful, DetectedTraveral, DetectedReturn, DetectedRequiredCall, DetectedUnresolvedCall
       : <filter(\ Arg(arg, srt) -> <id> with rules( RootVar : Var(arg) -> srt ) \)> args
       ; wait := <collect(perform-waiting-check-only-loops <+ query-optimization-waiting-for-calls); flatten-list> body
      |}

  perform-waiting-check-only-loops = // Required for calls on persistent iterators, otherwise these calls are not detected as recursive
    ((?For(x, srt, e, f, b, _){anno*} <+ ?ForStmt(x, srt, e, f, b){anno*}); <is-entity-type> srt)
    ; {| RootVar
       : rules( RootVar : Var(x) -> srt )
       ; wait := <collect(perform-waiting-check-only-loops <+ query-optimization-waiting-for-calls); flatten-list> b
       |}
    ; !wait

  perform-query-analysis(|name,args,cond) :
    (body, anno*) -> (body3, [QueryAnalysis(ts, returns, requiredcalls, unresolvedcalls, recursivecalls) | anno*])
    where not(QueryOptimizationDisabled)
    ; not(<fetch-elem(is-query-analysis)> anno*)
    ; {| RootVar, BindableVar
       : <filter(\ Arg(v, srt) -> <id> with rules( RootVar : Var(v) -> srt ) \)> args
       ; <filter(\ arg@Arg(v, srt) -> <id> where <query-optimization-bindable-argument> arg; rules( BindableVar : Var(v) -> srt ) \)> args
       //; <debug(!"Perform: ")> name
       //; [] := <collect(query-optimization-waiting-for-calls); flatten-list> body
       //; <debug(!"Ready: ")> name
       //; body2 := <alltd(perform-analysis-for-loops);debug(!"body2:")> body
       //; (body := body2 < info(|"Same") + info(|"Diff"))
       //; <debug(!"LoopOk: ")> name
       //; dr-all-keys(|"RootVar"); debug(!"RootVars:")
       ; [] := <collect(query-optimization-waiting-for); flatten-list/*; try(where(not(?[]); <debug(!"Wait:")> (name, <id>)))*//*;debug(!"Wait:")*/> (body, cond)
       ; {| QueryConditions, IsEffectful, DetectedTraveral, DetectedReturn, DetectedRequiredCall, DetectedUnresolvedCall, DetectedRecursiveCall
         : with(
		       rules (  QueryConditions := <extract-query-cond-as-list(get-accessible-expr(try-strip-generic-sort,id))> cond  // Changes over time to represent the query conditions active on the term currently being analyzed
		                IsEffectful     := False()                            // True if the current statement is effectful (means: can affect non-local state), False otherwise
		             )
		       //; <debug(!"Analyzing: ")> name
		       ; body3 := <analyze-for-query-optimization-continue> body
		       ; ts := <bagof-DetectedTraveral>
		       ; returns := <bagof-DetectedReturn>
		       ; requiredcalls := <bagof-DetectedRequiredCall>
		       ; unresolvedcalls := <bagof-DetectedUnresolvedCall/*;debug(!"gotunres:")*/>
		       ; recursivecalls := <bagof-DetectedRecursiveCall>
		       //; <debug(!"TS of ")> name
		       //; <remove-casts;log-query-optimization-collect-table(|45,135,5)> ts
	        )
	      //;<debug(!"qa:")>(name, QueryAnalysis(ts, returns, requiredcalls, unresolvedcalls, recursivecalls))
	      |}
      |}

  query-analysis-to-query-optimizition(|qa,x,xsrt,bindableargs) :
    b1 -> (QueryCondition(querycondition), b2)
    with {|RootVar, BindableVar
    : rules( RootVar : Var(x) -> xsrt )
    ; oldprefetch := <get-prefetch-for(|x); (?PrefetchFor(Var(x), PrefetchChildren(<id>)) <+ ![])> b1
    ; QueryAnalysis(analysis, _, _, unresolved, recursive) := qa
    //; <debug(!"x:")> Var(x)
    //; <debug(!"qa:")> qa
    ; <filter(\ Arg(arg, srt) -> <id> where not(<RootVar>Var(arg)) with /*debug(!"Bindable:");*/rules( BindableVar : Var(arg) -> srt ) \)> bindableargs
    ; ts := <filter-traversal-summary> analysis
    ; querycondition := <traversal-summary-to-query-condition> ts // Combine query conditions of the effectful field accesses
    ; requiresalias := <collect(condition-to-alias-string(|x))> querycondition
    //; alljoins := <map(traversal-to-join(|x,xsrt,requiresalias))> joincandidates
    //; alljoins := <traversals-to-tree(|x,xsrt,requiresalias)> joincandidates
    //; alljoins := <doall(|x,xsrt,requiresalias)> joincandidates
    ; prefetch := <traversal-summary-to-branches(|x,xsrt,requiresalias); foldr(!oldprefetch, merge-optimization-branches)> ts
    ; prefetch2 := <filter(get-branches-from-recursive(|x,xsrt,requiresalias)); flatten-list; foldr(!prefetch, merge-optimization-branches)> recursive
    ; prefetch3 := <filter(get-conditional-branches-from-unresolved(|x,xsrt,requiresalias)); foldr(!prefetch2, merge-conditional-optimization-branches)> unresolved
    ; prefetch4 := <map(revalidate-join-conditions(|[]); alltd(revalidate-query-condition-filters))> prefetch3
      |}
    //; try(not([] := prefetch4); <debug(!"opt:")>Var(x); <debug(!"prefetch4:")> prefetch4; <pp-webdsl-to-string; debug(!"")> PrefetchFor(Var(x), PrefetchChildren(prefetch4)))
    ; b2 := <try(not(?[]); replace-prefetch-for(|x, prefetch4))> b1
    //; debug(!"qo:")

  get-query-condition(|x,xsrt,bindableargs) :
    anno* -> QueryCondition(querycondition)
    with {|RootVar, BindableVar
			    : rules( RootVar : Var(x) -> xsrt )
			    ; <fetch-elem(?QueryAnalysis(analysis, _, _, _, _))> anno*
			    ; <filter(\ Arg(arg, srt) -> <id> where not(<RootVar>Var(arg)) with rules( BindableVar : Var(arg) -> srt ) \)> bindableargs
			    ; ts := <filter-traversal-summary> analysis
			    ; querycondition := <traversal-summary-to-query-condition> ts // Combine query conditions of the effectful field accesses
          |}

  extract-body-wrapper = ?Block(<id>)
  extract-body-wrapper = ?Block(<id>)

  get-branches-from-recursive(|x,xsrt,requiresalias) :
    (callee, e, args) -> branches2
    where passed := <(PassedCallee <+ !0); where(<lt>(<id>, 3))> callee
    ; (fent, Function(_, deffargs, _, defb){defanno*}) := <try-resolve-entity-call> callee
    ; qa := <fetch-elem(is-query-analysis)> defanno*
    ; analysis := <get-ts-from-query-analysis> qa
    ; argmapping := <zip> (args, deffargs)
    ; varmapping := <add-this-vars-to-mapping(|analysis, e, fent)> argmapping
    ; {| PassedCallee
      : times := <int-inc> passed
      ; rules( PassedCallee : callee -> times )
      ; recursivebranches := <get-recursive-from-query-analysis; filter(translate-recursive(|varmapping); get-branches-from-recursive(|x,xsrt,requiresalias))> qa
      |}
    ; branches := <common-branches-from-recursive(|x,xsrt,requiresalias,varmapping)> analysis
    ; branches2 := <conc; flatten-list> (branches, recursivebranches)

  get-branches-from-recursive(|x,xsrt,requiresalias) :
    (callee@(None(), n, targs), args) -> branches2
    where passed := <(PassedCallee <+ !0); where(<lt>(<id>, 3))> callee
    ; Function(_, deffargs, _, defb){defanno*} := <resolve-function-call-to-decl> callee
    ; qa := <fetch-elem(is-query-analysis)> defanno*
    ; analysis := <get-ts-from-query-analysis> qa
    ; argmapping := <zip> (args, deffargs)
    ; {| PassedCallee
      : times := <int-inc> passed
      ; rules( PassedCallee : callee -> times )
      ; recursivebranches := <get-recursive-from-query-analysis; filter(translate-recursive(|argmapping); get-branches-from-recursive(|x,xsrt,requiresalias))> qa
      |}
    ; branches := <common-branches-from-recursive(|x,xsrt,requiresalias,argmapping)> analysis
    ; branches2 := <conc; flatten-list> (branches, recursivebranches)

  get-branches-from-recursive(|x,xsrt,requiresalias) :
    (callee, args) -> branches2
    where not((None(), _, _) := callee)
    ; passed := <(PassedCallee <+ !0); where(<lt>(<id>, 3))> callee
    ; Define(defmod, defname, deffargs, deftargs, defbody){defanno*} := <CurrentTemplateDecl> callee
    ; qa := <fetch-elem(is-query-analysis)> defanno*
    ; analysis := <get-ts-from-query-analysis> qa
    ; varmapping := <zip> (args, deffargs)
    ; {| PassedCallee
      : times := <int-inc> passed
      ; rules( PassedCallee : callee -> times )
      ; recursivebranches := <get-recursive-from-query-analysis; filter(translate-recursive(|varmapping); get-branches-from-recursive(|x,xsrt,requiresalias))> qa
      |}
    ; branches := <common-branches-from-recursive(|x,xsrt,requiresalias,varmapping)> analysis
    ; branches2 := <conc; flatten-list> (branches, recursivebranches)

  common-branches-from-recursive(|x,xsrt,requiresalias,varmapping) :
    analysis -> branches
    where newanalysis := <foldr(!analysis, rename-vars-in-analysis(RootVar))> varmapping
    ; ts := <filter-traversal-summary> newanalysis
    //; joincandidates := <map(!(<Fst; is-accessible-from(RootVar); Fst>, <Snd>)); filter(an-requires-joining-fa); flatten-list; map(try(?Cast(<id>, _))); make-set> ts
    ; branches := <traversal-summary-to-branches(|x,xsrt,requiresalias)> ts
    ; foldr(![], merge-optimization-branches)
    ; not([] := branches)

  get-conditional-branches-from-unresolved(|x,xsrt,requiresalias) :
    (genname, args, cond, eff) -> (templ, branches)
    where Define(defmod, defname, deffargs, deftargs, defbody){defanno*} := <CurrentTemplateDecl> genname
    ; templ := <normalize-signature; !TemplateArg(<Fst>,<Snd>)> (defname, deffargs)
    ; analysis := <fetch-elem(get-ts-from-query-analysis)> defanno*
    ; newmap := <zip> (args, deffargs)
    ; newanalysis := <foldr(!analysis, rename-vars-in-analysis(RootVar))> newmap
    ; ts := <filter-traversal-summary> newanalysis
    //; joincandidates := <map(!(<Fst>, <Snd>)); filter(an-requires-joining-fa); /*map(sub-paths); */flatten-list; map(try(?Cast(<id>, _))); make-set/*; keep-least-specific-casts*/> ts
    ; branches := <traversal-summary-to-branches(|x,xsrt,requiresalias)> ts
    ; not([] := branches)

strategies

  register-detected-traversal =
    ?(traversal, srt)
    ; condition := <QueryConditions <+ !True()>
    ; effectful := <IsEffectful>
    ; <register-detected-traversal> (traversal, srt, condition, effectful)

  register-detected-traversal =
    ?(traversal, srt, condition, effectful)
    ; rules( DetectedTraveral :+= (traversal, srt, condition, effectful) )

  register-detected-return-traversal =
    ?(traversal, srt)
    ; rules( DetectedReturn :+= traversal )

  register-detected-required-call =
    ?tc
    ; condition := <QueryConditions <+ !True()>
    ; effectful := <IsEffectful>
    ; rules( DetectedRequiredCall :+= (tc, condition, effectful) )

  register-detected-unresolved-call =
    ?(genname, args)
    ; args2 := <filter(filter(where(is-accessible-from(RootVar))))> args
    ; condition := <QueryConditions <+ !True()>
    ; effectful := <IsEffectful>
    ; rules( DetectedUnresolvedCall :+= (genname, args2, condition, effectful) )

  register-detected-recursive-call = 
    ?(callee, args)
    ; args2 := <map(filter(where(is-accessible-from(RootVar))))> args
    ; rules( DetectedRecursiveCall :+= (callee, args2) )

  register-detected-recursive-call = 
    ?(callee, e, args)
    ; <is-accessible-from(RootVar)> e
    ; args2 := <map(filter(where(is-accessible-from(RootVar))))> args
    ; rules( DetectedRecursiveCall :+= (callee, e, args2) )

  register-all-effectful = 
    condition := <QueryConditions <+ !True()>
    ; dr-all-keys(|"RootVar")
    ; map({key,value
          : ?key
          ; value := <RootVar> key
          ; <register-detected-traversal> (key, value, condition, True())
          })

  // Succeeds if the argument can be used in the query condition
  query-optimization-bindable-argument =
    ?Arg(_, srt)
    ; where(<is-simple-sort; not(is-entity-type)> srt)

  // Skip
  analyze-for-query-optimization = query-optimization-skip

  query-optimization-skip =
    ?Action(_, _, _, _) <+ ?LocalRedefine(_, _, _, _, _)

rules // Traversals

  analyze-for-query-optimization :
    fa@FieldAccess(_, _){anno*} -> fa{anno*}
    where is-accessible-from-allow-calls(RootVar)
    //; where(try(log-calls(|fa)))
    ; map(register-detected-traversal)

  //log-calls(|fa) = where(<debug(!"from expr ")> fa); map(debug(!"found:"))

  analyze-for-query-optimization :
    v@Var(_){anno*} -> v{anno*}
    where is-accessible-from-allow-calls(RootVar)
    ; map(register-detected-traversal)

  analyze-for-query-optimization :
    Return(e1){anno*} -> Return(e2){anno*}
    where <is-accessible-from-allow-calls(RootVar)> e1
    ; map(register-detected-return-traversal)
    ; e2 := <analyze-for-query-optimization> e1

  analyze-for-query-optimization :
    Return(e1){anno*} -> Return(e2){anno*}
    where <is-accessible-from-allow-calls(RootVar)> e1
    ; map(register-detected-return-traversal)
    ; e2 := <analyze-for-query-optimization> e1

  analyze-for-query-optimization : // For functions returning SimpleSort("Bool")
    Return(e1){anno*} -> Return(e2){anno*}
    where traversal := <extract-query-cond(get-accessible-expr(id,id)); not(?True())> e1
    ; rules( DetectedReturn :+= traversal )
    ; e2 := <analyze-for-query-optimization> e1

/*  analyze-for-query-optimization :
    Derive(deriveType, e, props*) -> Derive(deriveType, e, props*)
    where <map(\ DeriveDefault(f) -> FieldAccess(e, f) \); analyze-for-query-optimization-effectful> props*
*/
strategies // Resolve

  /*
  analyze-for-query-optimization-calls : // Collect effectful traversals for builtin calls
    c@Call(e, nm, args1){anno*} -> Call(e2, nm, args2){anno*}
    where <is-accessible-from(RootVar); ?(e2, <is-entity-type; ?SimpleSort(ent)>)> e
    ; targs := <map(type-of); prepare-type-list-for-compare> args1
    ; n := <strip-annos> nm  
    ; <not(not-allowed-ent-fun-name)> n
    ; not("Entity" := ent)
    ; (fent, Function(_, defargs, _, _){defanno*}) := <try-resolve-entity-call> (ent, n, targs)
    ; <check-builtin-signature> (fent, n, targs)
    ; e2 := <analyze-for-query-optimization-effectful> e
    ; args2 := <map(analyze-for-query-optimization-effectful)> args1
  */

  analyze-for-query-optimization-calls :
    c@Call(e, nm, args1){anno*} -> Call(e, nm, args2){anno*}
    where <is-accessible-from(RootVar); ?(e2, <is-entity-type; ?SimpleSort(ent)>)> e
    ; targs := <map(type-of); prepare-type-list-for-compare> args1
    ; n := <strip-annos> nm  
    ; <not(not-allowed-ent-fun-name)> n
    ; not("Entity" := ent)
    ; (fent, Function(defname, defargs, _, _){defanno*}) := <try-resolve-entity-call> (ent, n, targs)
    ; <not(check-builtin-signature)> (fent, n, targs)
    with /*<debug(!"Combining call:")> (ent, nm, <map(type-of)> args1); */argmapping := <zip; handle-escaped-ref-arg-in-mapping> (args1, defargs)
      ; (defn, deftargs) := <normalize-signature> (defname, defargs)
      ; if <Recursive> (fent, defn, deftargs) then
          recargs := <map((is-accessible-from-allow-calls(RootVar); map(Fst)) <+ ![])> args1
          ; <register-detected-recursive-call> ((fent, defn, deftargs), e, recargs)
          ; args2 := <map(analyze-for-query-optimization-effectful)> args1
		    else
          args2 := <map(where(is-accessible-from-allow-calls(RootVar)) < analyze-for-query-optimization-continue + analyze-for-query-optimization-effectful)> args1
          ; analysis := <fetch-elem(get-ts-from-query-analysis)> defanno*
          ; recursivecalls := <fetch-elem(get-recursive-from-query-analysis)> defanno*
          ; varmapping := <add-this-vars-to-mapping(|analysis, e, ent)> argmapping
          ; <filter(translate-recursive(|varmapping); register-detected-recursive-call)> recursivecalls
          //; <debug(!"Following entity function ")> (ent, nm)
          ; newanalysis := <foldr(!analysis, rename-vars-in-analysis(RootVar))> varmapping
          ; <filter(combine-analysis)> newanalysis
          ; try(<is-accessible-from-allow-calls(RootVar); map(register-detected-traversal)> c)
		    end

  analyze-for-query-optimization =
    (?Call(_, _, args) <+ ?ThisCall(_, args))
    ; (analyze-for-query-optimization-calls <+ with(register-all-effectful; <map(analyze-for-query-optimization-effectful)> args))

  analyze-for-query-optimization-calls :
    c@ThisCall(nm, args1){anno*} -> ThisCall(nm, args2){anno*}
    where <not(IsNativeFunction)> nm
    ; not([] := <filter(is-accessible-from-allow-calls(RootVar))> args1)
    ; argtypes := <map(type-of)> args1
    ; targs := <prepare-type-list-for-compare> argtypes
    ; n := <strip-annos> nm
    ; <not(bagof-StaticSignatures; filter(signature-to-static-anno(|argtypes)); Hd; ?StaticFunctionCallAnno(_, _))> nm // Not a static function
    ; n := <strip-annos> nm  
    ; <not(check-builtin-signature)> (None(), n, targs)
    //; <not(is-reserved-function)> (n, targs)
    ; <not(IsReservedFunction)> (nm, <length> targs)
    ; Function(defname, defargs, _, _){defanno*} := <resolve-function-call-to-decl> (None(), n, targs)
    with argmapping := <zip; handle-escaped-ref-arg-in-mapping> (args1, defargs)
      ; (defn, deftargs) := <normalize-signature> (defname, defargs)
      ; if <Recursive> (None(), defn, deftargs) then
          recargs := <map((is-accessible-from-allow-calls(RootVar); map(Fst)) <+ ![])> args1
          ; <register-detected-recursive-call> ((None(), defn, deftargs), recargs)
          ; args2 := <map(analyze-for-query-optimization-effectful)> args1
        else
          args2 := <map(where(is-accessible-from-allow-calls(RootVar)) < analyze-for-query-optimization-continue + analyze-for-query-optimization-effectful)> args1
          ; analysis := <fetch-elem(get-ts-from-query-analysis)> defanno*
          ; recursivecalls := <fetch-elem(get-recursive-from-query-analysis)> defanno*
          ; <filter(translate-recursive(|argmapping); register-detected-recursive-call)> recursivecalls
          //; <debug(!"Following global function ")> (nm)
          ; newanalysis := <foldr(!analysis, rename-vars-in-analysis(RootVar))> argmapping
          ; <filter(combine-analysis)> newanalysis
          ; try(<is-accessible-from-allow-calls(RootVar); map(register-detected-traversal)> c)
        end

  handle-escaped-ref-arg-in-mapping =
    with(try(filter(is-escaped-ref-arg); not(?[]); register-all-effectful))

  is-escaped-ref-arg : // Means that we do not track the ref arg, which is a problem, because changes made to the ref arg may be effectful
    (e, Arg(x, srt)) -> e
    where <is-ref-type> srt
    ; <not(is-accessible-from-allow-calls(RootVar))> e

  analyze-for-query-optimization :
    Assignment(v, e){anno*} -> Assignment(v, e2){anno*}
    with register-all-effectful
    ; e2 := <analyze-for-query-optimization-effectful> e

  analyze-for-query-optimization :
    PropertyAssignment(v, e){anno*} -> PropertyAssignment(v, e2){anno*}
    with register-all-effectful
    ; e2 := <analyze-for-query-optimization-effectful> e

  analyze-for-query-optimization :
    VarDeclInit(v, srt, e){anno*} -> VarDeclInit(v, srt, e2){anno*}
    with e2 := <analyze-for-query-optimization-effectful> e
    
  analyze-for-query-optimization :
    VarDeclInitInferred(v, e){anno*} -> VarDeclInitInferred(v, e2){anno*}
    with e2 := <analyze-for-query-optimization-effectful> e

  combine-analysis =
    ?(e, srt, cond, effectful)
    ; where (
      (traversal, esrt) := <is-accessible-from(RootVar)> e
      ; tmpcond := <revalidate-query-condition(get-accessible-expr(try-strip-generic-sort,id))> cond
      ; fltrs := <filter(?PrefetchWhere(_)); (map(where(revalidate-prefetch-where)) <+ !PrefetchWhere(True()))> cond
      ; newcond := <concat; make-set>[<QueryConditions>, tmpcond, fltrs]
      ; iseffectful := <IsEffectful; (?True() <+ !effectful)>
      ; rules( DetectedTraveral :+= (traversal, esrt, newcond, iseffectful) )
    )

  revalidate-prefetch-where =
    ?PrefetchWhere(cond)
    ; collect(?Var(_))
    ; map(is-accessible-from(BindableVar))

  revalidate-query-condition(check-expr) = filter(not(?PrefetchWhere(_));extract-query-cond(check-expr); not(?True()))

  rename-vars-in-analysis(s) :
    ((e, Arg(x, srt)), analysis) -> newanalysis
    where <is-list> e
    ; values := <filter((is-accessible-from-allow-calls(s); map(Fst)) <+ is-query-condition-constant); flatten-list> e
    ; newanalysis := <(?[] < !analysis + (map(replace-var-with-value(|analysis, x)); flatten-list; make-set))> values

  rename-vars-in-analysis(s) :
    ((e, Arg(x, srt)), analysis) -> newanalysis
    where values := <is-accessible-from-allow-calls(s); map(Fst)> e
    ; newanalysis := <map(replace-var-with-value(|analysis, x)); flatten-list; make-set> values

  rename-vars-in-analysis(s) :
    ((e, Arg(x, srt)), analysis) -> newanalysis
    where <is-query-condition-constant> e
    ; newanalysis := <replace-var-with-value(|analysis, x)> e

  rename-vars-in-analysis(s) :
    ((e, Arg(x, srt)), analysis) -> analysis
    where <not(is-list <+ is-accessible-from-allow-calls(s) <+ is-query-condition-constant)> e

  replace-var-with-value(|analysis, x) :
    value -> newanalysis
    with newanalysis := <alltd(?Var(x); !value)> analysis

  analyze-for-query-optimization =
    where(match-template-with-name(|"elements")
	    ; register-detected-required-call
    )

  analyze-for-query-optimization :
    c@TemplateCall(name, args1, passign1, body){anno*} -> c{anno*}
    where <CallToRequiredTemplate> name
    ; <register-detected-required-call> c

  analyze-for-query-optimization :
    c@TemplateCall(name, args1, passign1, body){anno*} -> c
    where genname := <is-defined-tc-get-called-tc; where(is-unresolved-local-redefine)> c
    ; args := <map((is-accessible-from-allow-calls(RootVar); map(Fst)) <+ ![])> args1
    ; <register-detected-unresolved-call> (genname, args)

  analyze-for-query-optimization :
    c@TemplateCall(name, args1, passign1, body){anno*} -> TemplateCall(name, args2, passign2, body){anno*}
    where genname := <is-defined-tc-get-called-tc> c
    ; [] := <filter(?ResolvedRequireKey(_))> passign1 // Required calls are resolved on the call that requires them
    with Define(defmod, defname, deffargs, deftargs, defbody){defanno*} := <get-local-redefined-decl <+ CurrentTemplateDecl> genname // get-local-redefined-decl resolves a template call if it is redefined in the current template/page. That way it is handled as a regular resolvable template call.
        ; passign2 := <map(?TemplateCall(_, _, _, _) <+ analyze-for-query-optimization-effectful)> passign1
        ; if recname := <get-follow-genname; Recursive> genname then
            extraArgs := <LocalRedefineArgs <+ ![]> recname
            ; recargs := <conc; map((is-accessible-from-allow-calls(RootVar); map(Fst)) <+ ![])> (args1, extraArgs)
            ; <register-detected-recursive-call> (recname, recargs)
            ; args2 := <map(analyze-for-query-optimization-effectful)> args1
		      else
            args2 := <map(where(is-accessible-from-allow-calls(RootVar)) < analyze-for-query-optimization-continue + analyze-for-query-optimization-effectful)> args1
            ; <fetch-elem(?QueryAnalysis(analysis, _, reqCalls, redefCalls, recursivecalls))> defanno*
            ; reqcallana := <filter(resolve-required-call-for-analysis(|genname,passign1,deffargs));flatten-list/*;debug(!"reqcallres:")*/> reqCalls
            //; <try(not(?[]); debug(!"redefs:"))> redefCalls
            ; argmapping := <zip; handle-escaped-ref-arg-in-mapping> (args1, deffargs)
            ; <filter(translate-recursive(|argmapping); register-detected-recursive-call)> recursivecalls
            ; resolvedcalls := <resolve-unresolved-calls/*;try(not(?[]);debug(!"tempres:"))*/> (argmapping, redefCalls)
            //; <debug(!"Following template ")> genname
            //; <debug(!"analysis:")>analysis
            ; newanalysis := <foldr(!<concat>[analysis,reqcallana,resolvedcalls], rename-vars-in-analysis(RootVar))> argmapping
            //; <debug(!"newanalysis:")>newanalysis
            //; <debug(!"combine:")> (name, newanalysis)
            ; <filter(combine-analysis)> newanalysis
		      end

  is-unresolved-local-redefine =
    ?genname
    /*; debug(!"genname:")*/
    ; where(
        tname := <CurrentTemplateName/*;debug(!"is-tname:")*/> // This DR is set if we are analyzing a page/template
        ; redefines := <bagof-TemplateRedefinitions/*;debug(!"is-bag:")*/> genname
        ; not([] := redefines) // There are local redefinitions of genname somewhere
        ; <not(fetch-elem(?tname))/*;debug(!"is-empty:")*/> redefines // The template is not redefined within the current template and remains unresolved.
      )

  // Will fail if the template is not redefined locally, extra arguments are already resolved
  /*get-local-redefined-decl :
    genname -> decl
    where (decl, _) := <get-local-redefined-decl-with-extra-args> genname*/

  get-follow-genname :
    genname -> genname
    where not(CurrentTemplateName)

  get-follow-genname :
    genname -> followgenname
    where tname := <CurrentTemplateName>
    with followgenname := <LocalRedefineGenname <+ !genname> (tname, genname)

  get-local-redefined-decl = get-local-redefined-decl-with-mapping; Fst

  get-local-redefined-decl-with-mapping:
    genname -> (Define(defmod, defname, newfargs, newdeftargs, newdefbody){newdefanno*}, extraArgsMapping)
    where tname := <CurrentTemplateName/*;debug(!"tname:")*/>
    //; t* := <TemplateArguments; formal-arguments-to-types> genname
    //; name := <bagof-TemplateRedefinitions/*;debug(!"bag:")*/; fetch-elem(?tname)/*;debug(!"gotit:")*//*; ?[(_, _{<id>}, t*)]*//*;debug(!"name:")*/> genname
    //; localname := <concat-strings;debug(!"localname:")> [name,"$l$"]
    ; localgenname := <LocalRedefineGenname/*;debug(!"redefgen:")*/> (tname, genname)//localname
    ; extraArgs := <LocalRedefineArgs/*;debug(!"redefargs:")*/> localgenname
    //; targs := <CurrentTemplateArgs>
    //; tgenname := <generate-template-name-fargs; debug(!"tgenname:")> (tname, targs)
    //; <debug(!"extraargs:")> extraargs
    //; <CurrentTemplateDecl;debug(!"tdecl:");collect(?LocalRedefine(_,_,_,localname, LocalRedefineArgs(extraArgs)));debug(!"redefs:")> tgenname
    //; t2* := <map(type-of)> extraArgs
    //; localgenname := <generate-template-name;debug(!"localgenname:")>(localname,<conc>(t*,t2*))
    ; def@Define(defmod, defname, deffargs, deftargs, defbody){defanno*} := <CurrentTemplateDecl/*;debug(!"localdecl:")*/> localgenname
    //; <debug(!"resolved:")> (tname, genname, localgenname)
    // Now we replace the extra arguments and remove them from the fargs
    ; (newfargs, extrafargs) := <split-at(|<subti>(<length>deffargs, <length>extraArgs))>deffargs
    ; extraArgsMapping := <zip> (extraArgs, extrafargs)
    ; newdefanno* := <foldr(!defanno*, replace-vars)> extraArgsMapping
    ; newdeftargs := <foldr(!deftargs, replace-vars)> extraArgsMapping
    ; newdefbody := <foldr(!defbody, replace-vars)> extraArgsMapping

  check-resolvable-calls-ready = check-resolvable-calls-ready(check-resolvable-calls-ready(id))

  check-resolvable-calls-ready(s) :
    QueryAnalysis(_, _, _, redefCalls, _) -> unready
    where tocheck := <filter(Fst; not(is-unresolved-local-redefine))> redefCalls
    ; unready := <filter(where(not(get-local-redefined-decl; get-anno(is-query-analysis); s)))> tocheck

  /*check-resolvable-calls-ready-helper :
    QueryAnalysis(_, _, _, redefCalls, _) -> unready
    where tocheck := <filter(Fst;debug(!"is-unresolved-local-redefine2:");not(is-unresolved-local-redefine));debug(!"tocheck2:")> redefCalls
    ; unready := <filter(where(not(debug(!"genname2:");get-local-redefined-decl;debug(!"chkdecl2:");get-anno(is-query-analysis);debug(!"anno2:");debug(!"ready2:"))));debug(!"unready2:")> tocheck
  */

  replace-vars :
    ((v, Arg(x, srt)), term) -> newterm
    with newterm := <alltd(?Var(x); !v)> term

  resolve-unresolved-calls :
    (argmapping, redefCalls) -> resolvedcalls
    with <filter(translate-unresolved(|argmapping))> redefCalls // Calls that we cannot resolve are registered as such
    ; (qas, unresolvedcalls1) := <filter(resolve-unresolved-call(|argmapping)); unzip> redefCalls // We resolve calls, which may result in more unresolved calls
    ; <flatten-list/*; debug(!"todo:")*/;filter(translate-unresolved(|argmapping))/*;debug(!"unsolvable:")*/> unresolvedcalls1 // We register new unsolvable calls
    ; (qas2, unresolvedcalls2) := <flatten-list; filter(resolve-unresolved-call(|argmapping))/*;debug(!"out:")*/; unzip> unresolvedcalls1 // We solve the new resolvable calls
    ; unresolved3 := <flatten-list; make-set; filter(translate-unresolved(|argmapping) <+ (analyze-for-query-optimization-effectful; fail))/*;debug(!"unsolvable3:")*/> unresolvedcalls2 // We do not try to solve new unresolved calls
    ; resolvedcalls := <conc; flatten-list; make-set/*;debug(!"qas:")*/> (qas, qas2)

  translate-unresolved(|argmapping) :
    (genname, args, cond, eff) -> (genname, newargs, cond, eff) // TODO: cond and eff
    where <is-unresolved-local-redefine> genname
    ; newargs := <map(fix-argument(|argmapping))> args
    ; <register-detected-unresolved-call> (genname, newargs) // We ignore cond and eff for now

  resolve-unresolved-call(|argmapping) :
    (genname, args, cond, eff) -> (newanalysis, newRedefCalls)
    where (Define(defmod, defname, deffargs, deftargs, defbody){defanno*}, extraMapping) := <get-local-redefined-decl-with-mapping> genname
    ; <fetch-elem(?QueryAnalysis(analysis, _, _, redefCalls, _))> defanno*
    ; newargs := <map(fix-argument(|argmapping))> args
    ; <handle-escaped-ref-arg-in-mapping> extraMapping 
    ; newmap := <zip; handle-escaped-ref-arg-in-mapping> (newargs, deffargs)
    ; tmpana := <map(add-condition-to-traversal(|cond))>analysis
    ; newanalysis := <foldr(!tmpana, rename-vars-in-analysis(RootVar))> newmap
    ; newRedefCalls := <foldr(!redefCalls, rename-vars-in-analysis(RootVar))> newmap

  translate-recursive(|argmapping) :
    (callee, args) -> (callee, newargs)
    where newargs := <map(fix-argument(|argmapping))> args
    //; <register-detected-recursive-call> (callee, newargs)

  translate-recursive(|argmapping) :
    (callee, e, args) -> (callee, newe, newargs)
    where newargs := <map(fix-argument(|argmapping))> args
    ; newe := <fix-expression(|argmapping)> e
    //; <register-detected-recursive-call> (callee, newe, newargs)

  fix-expression(|argmapping) :
    arg -> newarg
    where newarg := <foldr(!arg, \ ((e, Arg(x, srt)), analysis) -> <try(alltd(?Var(x); !e))> analysis \); where(is-accessible-from(RootVar))> argmapping

  fix-argument(|argmapping) :
    arg -> newarg
    where newarg := <foldr(!arg, rename-vars-in-analysis(RootVar)); try(?[<id>])> argmapping

  resolve-required-call-for-analysis(|elemname,passign1,callerargs) :
    (req@TemplateCall(reqname, reqargs, reqpassign, TemplateBody([])), cond, eff) -> newanalysis
    where if <match-template-with-name(|"elements")> req then // elements call is not resolvable when no elements are present
      reqkey := <concat-strings>["elements#",elemname]
    else
      reqkey := <strip-annos> reqname
    end
    //; reqkey := <where(try(generate-elements-tcallsmap-name; debug(!"test:")); try(CallToDefinedTemplate; debug(!"test2:")));strip-annos;debug(!"reqkey:")> reqname
    ; TemplateCall(resname, resargs, respassign, TemplateBody([])) := <fetch-elem(where(?TemplateCall(_, _, <fetch-elem(?ResolvedRequireKey(reqkey))>, _))/*;debug(!"restempl:")*/)> passign1
    ; newargs := <conc>(reqargs, resargs)
    ; newpassign := <conc>(reqpassign,respassign)
    ; genname := </*debug(!"newtempl:");*/is-defined-tc-get-called-tc> TemplateCall(resname, newargs, newpassign, TemplateBody([]))
    ; Define(defmod, defname, deffargs, deftargs, defbody){defanno*} := </*debug(!"Combining req call:");*/CurrentTemplateDecl/*;debug(!"decl:")*/> genname
    ; analysis := <fetch-elem(get-ts-from-query-analysis)> defanno*
    ; argmapping := <zip; handle-escaped-ref-arg-in-mapping> (newargs, deffargs)
    ; tmpana := <map(add-condition-to-traversal(|cond))/*;debug(!"oldana:")*/>analysis
    ; {| TempVar
       : <map(\Arg(x, srt) -> <id> with rules(TempVar : Var(x) -> srt)\)> callerargs
       ; newanalysis := <foldr(!tmpana, rename-vars-in-analysis(TempVar <+ RootVar))/*;debug(!"newana:")*/> argmapping
       |}

  add-condition-to-traversal(|cond) :
    (e, srt, oldcond, eff) -> (e, srt, newcond, eff)
    with newcond := <conc; make-set> (oldcond, cond)

  analyze-for-query-optimization =
    //(?ForAll(x, srt, f, b, _){anno*} <+ ?For(x, srt, e, f, b, _){anno*} <+ ?ForAllStmt(x, srt, f, b){anno*} <+ ?ForStmt(x, srt, e, f, b){anno*})
    where((?For(x, srt, e, f, b, _){anno*} <+ ?ForStmt(x, srt, e, f, b){anno*}); <is-entity-type> srt)
    ; with(<analyze-for-query-optimization-continue> e
    ; <analyze-for-query-optimization-continue> f
    ; <fetch-elem(?QueryAnalysis(analysis, _, _, unresolvedcalls, recursivecalls))> anno*
    ; mapping := [(e, Arg(x, srt))] // We only need to rename the iterator to the collection, all other variables are the same
    //; <debug(!"usefor:")> (x, anno*)
    ; newanalysis := <foldr(<try(add-filter-to-analysis(|x,anno*))> analysis, rename-vars-in-analysis(RootVar))> mapping
    ; <map(translate-unresolved(|mapping))> unresolvedcalls
    ; <filter(translate-recursive(|mapping); register-detected-recursive-call)> recursivecalls
    ; <filter(combine-analysis)> newanalysis
      )

strategies // Effectful

  analyze-for-query-optimization-continue = alltd(analyze-for-query-optimization)

  analyze-for-query-optimization =
    (
	       ?Call(_, _, _)
	    <+ ?VarDeclInit(_, _, _)
	    <+ ?VarDeclInitInferred(_, _)
	    <+ ?Assignment(_, _)
	    <+ ?PropertyAssignment(_, _)
	    <+ ?PageCall(_, _)
	    <+ ?ThisCall(_, _)
	    <+ (?TemplateCall(name, args, passign, body); where(not(is-defined-tc-get-called-tc))) // A template call we cannot follow
    )
    ; where(False() := <IsEffectful>)
    ; rules( IsEffectful := True() )
    ; analyze-for-query-optimization-continue
    ; rules( IsEffectful := False() )

  analyze-for-query-optimization-effectful =
    where(True() := <IsEffectful>)
    ; analyze-for-query-optimization-continue

  analyze-for-query-optimization-effectful =
    where(False() := <IsEffectful>)
    ; rules( IsEffectful := True() )
    ; analyze-for-query-optimization-continue
    ; rules( IsEffectful := False() )

strategies // Resolve

  query-optimization-waiting-for = query-optimization-waiting-for-calls <+ query-optimization-waiting-for-loops

  query-optimization-waiting-for-calls = query-optimization-waiting-for-skip <+ query-optimization-waiting-for-template-calls <+ query-optimization-waiting-for-function-calls 

  // We return an empty list, which should later be removed by flatten-list
  query-optimization-waiting-for-skip = where(query-optimization-skip); ![]

  query-optimization-waiting-for-loops =
    ?ForStmt(x, srt, e, filter, body){anno*}
    ; where(
        <is-entity-type> srt // Important, because we do not analyze for loops of primitive types
        //; (expr, exprsrt) := <debug(!"e:");is-accessible-from(RootVar);debug(!"acc:")> e
        ; not(<fetch-elem(is-query-analysis)> anno*)
      )

  query-optimization-waiting-for-loops =
    ?For(x, srt, e, filter, body, sep){anno*}
    ; where(
        <is-entity-type> srt // Important, because we do not analyze for loops of primitive types
        //; (expr, exprsrt) := <is-accessible-from(RootVar)> e
        ; not(<fetch-elem(is-query-analysis)> anno*)
      )

  // Entity function
  query-optimization-waiting-for-function-calls =
    ?call@Call(e, nm, args)
    ; <is-accessible-from(RootVar); ?(e2, <is-entity-type; ?SimpleSort(ent)>)> e
    ; targs* := <map(type-of); prepare-type-list-for-compare> args
    ; n := <strip-annos> nm
    ; <not(IsReservedFunction)> (nm, <length> targs*)
    ; query-optimization-waiting-for-entity-function-calls(|ent, n, targs*)

  // Entity function
  /*query-optimization-waiting-for-function-calls =
    ?ThisCall(nm, args)
    ; argtypes := <map(type-of)> args
    ; targs* := <prepare-type-list-for-compare> argtypes
    ; n := <strip-annos> nm
    ; <not(IsReservedFunction)> (nm, <length> targs*)
    ; ent := <ThisEntity>
    ; <not(bagof-StaticSignatures; filter(signature-to-static-anno(|argtypes)); Hd; ?StaticFunctionCallAnno(_, _))> nm // Not a static function
    ; <not(check-builtin-signature)> (None(), n, targs*) // Not a global function
    ; <not(resolve-function-call-to-decl; ?Function(_, _, _, _))> (None(), n, targs*) // Not a global function
    ; query-optimization-waiting-for-entity-function-calls(|ent, n, targs*)*/

  query-optimization-waiting-for-entity-function-calls(|ent, n, targs*) =
    <not(not-allowed-ent-fun-name)> n
    ; not("Entity" := ent)
    ; (
       (fent, Function(defnm, defargs, _, _){anno*}) := <try-resolve-entity-call-without-override-check> (ent, n, targs*) // We should wait if this fails, because the function may still be a predicate function
       <
       (
         <subentities-do-no-override> (fent, n, targs*) // Only wait if subentities-do-no-override
         ; <not(fetch-elem(is-query-analysis))> anno*
         ; <not(check-builtin-signature)> (fent, n, targs*)
         ; <not(Recursive)> (fent, n, targs*)
         ; !(fent, n, targs*)
       )
       + (<not(check-builtin-signature)> (ent, n, targs*); !(ent, n, targs*))
      )

  // Global function
  query-optimization-waiting-for-function-calls =
    ?ThisCall(nm, args)
    ; <not(IsNativeFunction)> nm
    ; not([] := <filter(is-accessible-from-allow-calls(RootVar))> args)
    ; argtypes := <map(type-of)> args
    ; targs* := <prepare-type-list-for-compare> argtypes
    ; n := <strip-annos> nm
    ; <not(bagof-StaticSignatures; filter(signature-to-static-anno(|argtypes)); Hd; ?StaticFunctionCallAnno(_, _))> nm // Not a static function
    ; <not(check-builtin-signature)> (None(), n, targs*)
    //; <not(is-reserved-function)> (n, targs*)
    ; <not(IsReservedFunction)> (nm, <length> targs*)
    ; <not(where(Recursive))> (None(), n, targs*)
    ; Function(defname, defargs, _, _){anno*} := <resolve-function-call-to-decl> (None(), n, targs*)
    ; <not(fetch-elem(?StaticFunctionAnno()))> anno*
    ; <not(fetch-elem(is-query-analysis))> anno*
    ; !(None(), n, targs*)

  /* // No static function support yet
  // Static function
  query-optimization-waiting-for-function-calls =
    ?call@Call(e, nm, args)
    ; EntitySort(x_class) := <type-of> e
    ; targs* := <map(type-of); prepare-type-list-for-compare> args
    ; n := <strip-annos> nm
    ; query-optimization-waiting-for-static-function-calls(|x_class, n, targs*)

  // Static function
  query-optimization-waiting-for-function-calls =
    ?ThisCall(nm, args)
    ; not([] := <filter(is-accessible-from-allow-calls(RootVar))> args)
    ; argtypes := <map(type-of)> args
    ; targs* := <prepare-type-list-for-compare> argtypes
    ; StaticFunctionCallAnno(x_class, x_funcname) := <bagof-StaticSignatures; filter(signature-to-static-anno(|argtypes)); Hd> nm
    ; n := <strip-annos> x_funcname
    ; query-optimization-waiting-for-static-function-calls(|x_class, n, targs*)

  query-optimization-waiting-for-static-function-calls(|x_class, n, targs*) =
    <not(check-builtin-signature)> (EntitySort(x_class), n, targs*)
    //; <not(is-reserved-function)> (n, targs*)
    ; <not(IsReservedFunction)> (nm, <length> targs*)
    ; <not(where(Recursive))> (EntitySort(x_class), n, targs*)
    ; Function(defname, defargs, _, _){anno*} := <resolve-function-call-to-decl> (EntitySort(x_class), n, targs*)
    ; <not(fetch-elem(is-query-analysis))> anno*
    ; !(EntitySort(x_class), n, targs*)
  */

  query-optimization-waiting-for-template-calls =
    ?TemplateCall(name, args, passign, body)
    ; where(
        genname := <is-defined-tc-get-called-tc>
        ; followgenname := <get-follow-genname> genname
        ; <not(Recursive)> followgenname
        ; not(
            Define(defmod, defname, deffargs, deftargs, defbody){anno*} := <(get-local-redefined-decl <+ CurrentTemplateDecl)> genname
            ; <fetch-elem(is-query-analysis)> anno*
            ; [] := <check-resolvable-calls-ready>
          )
      )
      ; !followgenname

rules // Query conditions

  // Extracts the query condition as a list where elements should be combined with the and operator
  extract-query-cond-as-list(check-expr) :
    And(expr1, expr2) -> cond 
    where lst1 := <extract-query-cond-as-list(check-expr)> expr1
    ; lst2 := <extract-query-cond-as-list(check-expr)> expr2
    ; cond := <conc> (lst1, lst2)

  extract-query-cond-as-list(check-expr) :
    expr -> cond
    where not(And(_, _) := expr)
    ; cond := <extract-query-cond(check-expr); (?True() < ![] + ![<id>])> expr

strategies

  negate-query-cond-lst = // De Morgan's law, from conjuction list to disjunction with negated elements
    map(negate-query-cond <+ !Not(<id>))
    ; or-query-condition
    ; ![<id>]

  negate-query-cond :
    SmallerThanOrEqual(expr1, expr2) -> LargerThan(expr1, expr2)

  negate-query-cond :
    LargerThan(expr1, expr2) -> SmallerThanOrEqual(expr1, expr2)

  negate-query-cond :
    SmallerThan(expr1, expr2) -> LargerThanOrEqual(expr1, expr2)

  negate-query-cond :
    LargerThanOrEqual(expr1, expr2) -> SmallerThan(expr1, expr2)

  negate-query-cond :
    NotEq(expr1, expr2) -> Eq(expr1, expr2)

  negate-query-cond =
    ?Eq(expr1, expr2)
    ; (negate-simple-eq-cond <+ !NotEq(expr1, expr2)) // We first try to keep this an equals comparison

rules // Special cases

  analyze-for-query-optimization :
    IfTempl(cond1, true1, false1){anno*} -> IfTempl(cond2, true2, false2){anno*}
    where (cond2, true2, false2) := <analyze-for-query-optimization-if> (cond1, true1, false1)

  analyze-for-query-optimization :
    If(cond1, true1, false1){anno*} -> If(cond2, true2, false2){anno*}
    where (cond2, true2, false2) := <analyze-for-query-optimization-if> (cond1, true1, false1)

  analyze-for-query-optimization-if :
    (cond1, true1, false1) -> (cond2, true2, false2)
    where condlst := <extract-query-cond-as-list(get-accessible-expr(try-strip-generic-sort,id))> cond1
    ; not([] := condlst)
    with cond2 := <analyze-for-query-optimization-continue> cond1
    ; oldcond := <QueryConditions> 
    ; rules( QueryConditions := <conc; make-set>(oldcond, condlst) )
    ; true2 := <analyze-for-query-optimization-continue> true1
    ; rules( QueryConditions := <conc; make-set>(oldcond, <negate-query-cond-lst>condlst) )
    ; false2 := <analyze-for-query-optimization-continue> false1
    ; rules( QueryConditions := oldcond )

rules // Query conditions

  is-accessible-field(s,gen) =
    (?Var(_) <+ ?FieldAccess(_, _))
    ; is-accessible-from(s,gen)
    ; Fst
    ; where([] := <collect(?_{<fetch-elem(?MultipleDefinitionsInSubclasses())>})>)

  is-accessible-field(s,gen,srtcheck) =
    (?Var(_) <+ ?FieldAccess(_, _))
    ; is-accessible-from(s,gen)
    ; where(Snd; srtcheck)
    ; Fst
    ; where([] := <collect(?_{<fetch-elem(?MultipleDefinitionsInSubclasses())>})>)

  get-accessible-expr(gen,check) = get-accessible-expr(gen,check,is-query-condition-type)

  get-accessible-expr(gen,check,srtcheck) :
    (expr1, expr2) -> (newexpr1, newexpr2)
    where newexpr1 := <is-accessible-field(RootVar,gen,srtcheck); check> expr1 // This expression is accessible from the query root entity
    ; newexpr2 := <where(is-bindable-expr(gen) <+ is-accessible-field(RootVar,gen)); check> expr2// This expression does not need to be accessible from the query root entity, but may be a query argument

  get-accessible-expr(gen,check,srtcheck) :
    (expr1, expr2) -> (newexpr1, newexpr2)
    where newexpr2 := <is-accessible-field(RootVar,gen,srtcheck); check> expr2 // This expression is accessible from the query root entity
    ; newexpr1 := <where(is-bindable-expr(gen) <+ is-accessible-field(RootVar,gen)); check> expr1// This expression does not need to be accessible from the query root entity, but may be a query argument

  is-bindable-expr(gen) = is-query-condition-constant
  is-bindable-expr(gen) = is-accessible-field(BindableVar,gen,is-query-condition-type)
  is-bindable-expr(gen) = 
    (?Mul(expr1, expr2) <+ ?Div(expr1, expr2) <+ ?Mod(expr1, expr2) <+ ?Add(expr1, expr2) <+ ?Sub(expr1, expr2))
    ; <is-bindable-expr(gen)> expr1
    ; <is-bindable-expr(gen)> expr2

  is-query-condition-type = ?SimpleSort("Int") <+ ?SimpleSort("Long") <+ ?SimpleSort("Float") <+ ?SimpleSort("String") <+ ?SimpleSort("Bool") <+ ?SimpleSort("UUID")

  is-query-condition-constant = (?Int(_) <+ ?Long(_) <+ ?Float(_) <+ ?String(_) <+ ?True() <+ ?False() <+ ?Null()); try(normalize) 

  extract-query-cond(check-expr):
    Not(expr1) -> Not(expr1new)
    where expr1new := <extract-query-cond(check-expr)> expr1
    ; not(True() := expr1new)
    ; not(Eq(_, _) := expr1new)

  extract-query-cond(check-expr):
    Not(expr1) -> NotEq(expr1new, expr2new)
    where eq@Eq(expr1new, expr2new) := <extract-query-cond(check-expr)> expr1
    ; not(<negate-simple-eq-cond> eq)

  extract-query-cond(check-expr):
    Not(expr1) -> Eq(expr1new, expr2new)
    where Eq(expr1new, expr2new) := <extract-query-cond(check-expr); negate-simple-eq-cond> expr1

  negate-simple-eq-cond: Eq(True(), expr) -> Eq(expr, False())
  negate-simple-eq-cond: Eq(expr, True()) -> Eq(expr, False())
  negate-simple-eq-cond: Eq(False(), expr) -> Eq(expr, True())
  negate-simple-eq-cond: Eq(expr, False()) -> Eq(expr, True())

  extract-query-cond(check-expr):
    Or(expr1, expr2) -> Or(expr1new, expr2new)
    where expr1new := <extract-query-cond(check-expr)> expr1
    ; expr2new := <extract-query-cond(check-expr)> expr2
    ; not(True() := expr1new)
    ; not(True() := expr2new)

  extract-query-cond(check-expr):
    And(expr1, expr2) -> cond
    where expr1new := <extract-query-cond(check-expr) <+ !True()> expr1
    ; expr2new := <extract-query-cond(check-expr) <+ !True()> expr2
    ; cond := <and-query-condition-helper>(expr1new, expr2new)

  extract-query-cond(check-expr):    
    SmallerThanOrEqual(expr1, expr2) -> SmallerThanOrEqual(newExpr1, newExpr2)
    where (newExpr1, newExpr2) := <check-expr> (expr1, expr2)

  extract-query-cond(check-expr):
    SmallerThan(expr1, expr2) -> SmallerThan(newExpr1, newExpr2)
    where (newExpr1, newExpr2) := <check-expr> (expr1, expr2)

  extract-query-cond(check-expr):
    LargerThanOrEqual(expr1, expr2) -> LargerThanOrEqual(newExpr1, newExpr2)
    where (newExpr1, newExpr2) := <check-expr> (expr1, expr2)

  extract-query-cond(check-expr):
    LargerThan(expr1, expr2) -> LargerThan(newExpr1, newExpr2)
    where (newExpr1, newExpr2) := <check-expr> (expr1, expr2)

  extract-query-cond(check-expr):
    NotEq(expr1, expr2) -> NotEq(newExpr1, newExpr2)
    where (newExpr1, newExpr2) := <check-expr> (expr1, expr2)

  extract-query-cond(check-expr):
    Eq(expr1, expr2) -> Eq(newExpr1, newExpr2)
    where (newExpr1, newExpr2) := <check-expr> (expr1, expr2)

  extract-query-cond(check-expr):
    fa1@FieldAccess(_, _) -> Eq(fa2, True())
    where (fa2, _) := <check-expr> (fa1, True())
    ; <is-accessible-field(RootVar,try-strip-generic-sort,?SimpleSort("Bool"))> fa1 // An extra check to make sure that this property can be placed inside the query by itself and is a boolean, other checks are left to check-expr (like allowing FAs on generic-sorts)

  extract-query-cond(check-expr):
    v1@Var(_) -> Eq(v2, True())
    where (v2, _) := <check-expr> (v1, True())
    ; <is-accessible-field(RootVar,try-strip-generic-sort,?SimpleSort("Bool"))> v1 // An extra check to make sure that this var can be placed inside the query by itself and is a boolean, other checks are left to check-expr (like allowing FAs on generic-sorts or not)

  extract-query-cond(check-expr) :
    c@Call(e, nm, args1){anno*} -> cond
    where <is-accessible-from(RootVar); ?(e2, <is-entity-type; ?SimpleSort(ent)>)> e
    ; <not(not-allowed-ent-fun-name)> nm
    ; not("Entity" := ent)
    ; targs := <map(type-of); prepare-type-list-for-compare> args1
    ; n := <strip-annos> nm  
    ; (fent, Function(_, defargs, retsrt, _){defanno*}) := <try-resolve-entity-call> (ent, n, targs)
    ; retsrt := SimpleSort("Bool")
    ; returns := <fetch-elem(get-returns-from-query-analysis)> defanno*
    with argmapping := <zip> (args1, defargs)
    ; varmapping := <add-this-vars-to-mapping(|returns, e2, ent)> argmapping
    ; newreturns := <foldr(!returns, rename-vars-in-analysis(RootVar))> varmapping
    ; cond := <or-query-condition; extract-query-cond(check-expr)> newreturns
    where not(True() := cond)

  /*extract-query-cond=
    ?Call(e1, nm, arg*){anno*}
    ; where(<is-accessible-from(IteratedVar <+ IteratedSubList); ?(e2, <is-entity-type; ?SimpleSort(ent)>)> e1)
    ; genname := <generate-template-name-args> (<concat-strings>[ent, nm], arg*)
    ; where(not(<PassedFunction> genname)) // This prevents an infinite loop when following a recursive function
    ; (fent, Function(_, fargs, SimpleSort("Bool"), Block([Return(expr)]))) := <try-resolve-entity-call> (ent, nm, <map(query-optimization-type-of)> arg*)
    // Here we get the properties of the entity and insert them as extra parameters for the function call
    // We also have to rename the Var("prop") to Var("prop"{Entity_myfunctionArg1Arg2}) to prevent creating a loop in IteratedVar or IteratedSubList
    ; thissafe := "this"{<concat-strings>[genname, "_this"]}
    ; {| RenamePropInFunction // Here we temporarily rename the Var()s in the function body for our analysis
        : argsbinding := <get-all-entity-properties-for-rename(|genname); map({name,uniquename,safename,srt:\
                                (name, uniquename, safename, srt) -> (FieldAccess(e2, name), Arg(safename, srt))
                                where rules( RenamePropInFunction : Var(uniquename) -> Var(safename) )
                            \}); <concat>[[(e2, Arg(thissafe, SimpleSort(fent)))],<id>,<zip>(arg*, fargs)]> ent
        ; rules( RenamePropInFunction : Var("this") -> Var(thissafe) )
        ; expr2 := <alltd(RenamePropInFunction)> expr
      |}
    ; {| PassedFunction, IteratedVar, IteratedVarValue, IteratedSubList, IteratedSubListValue
       : rules( PassedFunction : genname )
         // Here we mark the arguments as interesting, because they are in some way related to the persistent root or are constants which we can use in query conditions
         // Removed the warnings, because a loop could occur when following a local redefine, because then some variables inside the redefine can belong to the caller and thus have the same name. This warning can be safely ignored.
       ; <filter({vars:
                     \ (e, Arg(x, srt)) ->  <id>
                       where [] := <collect(IteratedSubList)> e; <is-var-accessible> e; not(<is-generic-sort> srt)
*///                       where not(<IteratedVarValue/*; warn(|["Ignoring variable ", x, ", because it would create a loop in IteratedVarValue"])*/> Var(x))
/*                       with rules( IteratedVarValue : Var(x) -> e     // Helps when expressing a Var into the Var or constant passed by the caller 
                                   IteratedVar      : Var(x) -> srt
                                 )
                     \})> argsbinding
       ; <filter({vars: 
                     \ (e, Arg(x, srt)) ->  <id>
                       where not([] := <collect(IteratedSubList)> e) <+ (<is-generic-sort> srt; <is-var-accessible> e)
*///                       where not(<IteratedSubListValue/*; warn(|["Ignoring variable ", x, ", because it would create a loop in IteratedSubListValue"])*/> Var(x))
/*                       with rules( IteratedSubListValue  : Var(x) -> e
                                   IteratedSubList       : Var(x) -> srt
                                 )
                     \})> argsbinding
       ; <extract-query-cond> expr2
       ; repeat(oncetd(IteratedSubListValue <+ IteratedVarValue))
     |}*/

  extract-query-cond(check-expr) = !True()
