module org/webdsl/dsl/languages/query-analysis

rules // Entry points

  perform-query-analysis(|name,args,cond) :
    (body, anno*) -> (body, [QueryAnalysis([], [], [], []) | anno*])
    where QueryOptimizationDisabled
    ; not(<fetch-elem(is-query-analysis)> anno*)
    //; info(|"QueryOptimization disabled")

  // x is the root
  // args contains variables that may appear in the query condition. They do not have to be bindable yet, because they may be bindable in the caller. 
/*  perform-query-analysis(|x,srt,args,cond) :
    (body, anno*) -> (body2, [QueryAnalysis(ts) | anno*])
    where not(QueryOptimizationDisabled)
    ; <not(fetch-elem(?QueryAnalysis(_)))> anno*
    ; {| RootVar
     : rules( RootVar : Var(x) -> srt)
     ; <debug(!"x:")> Var(x)
     ; [] := <collect(query-optimization-waiting-for);debug(!"wait:")> body
    |}
    with {| RootVar, QueryArg, IteratedVar, QueryConditions, IsEffectful, DetectedTraveral
       : rules (  IteratedVar     : Var(x) -> srt // Contains all variables we are following (is RootVar and template/function call arguments)
                  RootVar         : Var(x) -> srt // The actual variable we are interested in (the persistent root of our analysis)
                  QueryConditions := []           // Changes over time to represent the query conditions active on the term currently being analyzed
                  IsEffectful     := False()      // True if the current statement is effectful (means: can affect non-local state), False otherwise
               )
       ; <filter({vars: 
                     \ Arg(arg, srt) ->  <id>
                       with rules( QueryArg      : Var(arg) -> srt )
                     \})> args
       ; rules( QueryConditions := <extract-query-cond-as-list> cond)
       ; body2 := <analyze-for-query-optimization-continue> body
       ; ts := <bagof-DetectedTraveral>
       ; <remove-casts;log-query-optimization-collect-table(|45,155,5)> ts
       ; av := []
       ; calls := []//<bagof-DetectedCall>
      |}
*/

  perform-query-analysis(|name,args,cond) :
    (body, anno*) -> (body2, [QueryAnalysis(ts, returns, requiredcalls, unresolvedcalls) | anno*])
    where not(QueryOptimizationDisabled)
    //; <debug(!"anno*:");not(debug(!"fetching:");fetch-elem(debug(!"isqa:");?QueryAnalysis(_, _);debug(!"Opted:"));debug(!"fetched:"));> anno*
    ; not(<fetch-elem(is-query-analysis)> anno*)
    ; {| RootVar, QueryConditions, IsEffectful, DetectedTraveral, DetectedReturn, DetectedRequiredCall, DetectedUnresolvedCall
       : <filter(\ Arg(arg, srt) -> <id> with rules( RootVar : Var(arg) -> srt ) \)> args
       ; [] := <collect(query-optimization-waiting-for); flatten-list/*; try(where(not(?[]); <debug(!"Waiting: ")> (name, <id>)))/*;debug(!"wait:")*/> body
       ; with(
	       rules (  QueryConditions := <extract-query-cond-as-list> cond  // Changes over time to represent the query conditions active on the term currently being analyzed
	                IsEffectful     := False()                            // True if the current statement is effectful (means: can affect non-local state), False otherwise
	             )
	       ; body2 := <analyze-for-query-optimization-continue> body
	       ; ts := <bagof-DetectedTraveral>
	       ; returns := <bagof-DetectedReturn>
	       ; requiredcalls := <bagof-DetectedRequiredCall>
	       ; unresolvedcalls := <bagof-DetectedUnresolvedCall>
	       //; <debug(!"TS of ")> name
	       //; <remove-casts;log-query-optimization-collect-table(|45,135,5)> ts
	       ; calls := []//<bagof-DetectedCall>
	      )
	      /*;<debug(!"qa:")>QueryAnalysis(ts, returns)*/
      |}

  query-analysis-to-query-optimizition(|x,xsrt,bindableargs) :
    anno* -> newanno*
    where {|RootVar, BindableVar
    : rules( RootVar : Var(x) -> xsrt )
    //; <debug(!"Root:")> Var(x)
    ; <filter(\ Arg(arg, srt) -> <id> where not(<RootVar>Var(arg)) with /*debug(!"Bindable:");*/rules( BindableVar : Var(arg) -> srt ) \)> bindableargs
    ; ts := </*debug(!"aanno:");*/fetch-elem(?QueryAnalysis(<id>, _, _, _));/*debug(!"analysis:");*/filter(where(Fst; is-accessible-from(RootVar)))/*;debug(!"ts:")*/> anno*
    ; tokeep := <remove-all(is-query-analysis)> anno*
    ; joincandidates := <map(!(<Fst>, <Snd>)); filter(an-requires-joining-fa); map(sub-paths); flatten-list; make-set; keep-least-specific-casts/*;debug(!"joins:")*/> ts
    ; querycondition := <filter(?(_, _, <revalidate-query-condition;and-query-condition>, True())); make-set/*;debug(!"conds:")*/; try(?[]; ![True()]); (where(filter(?True()); ?[]) < foldr(![], join-conditions) + !True())/*;debug(!"final:")*/> ts // Combine query conditions of the effectful field accesses
    ; requiresalias := <collect(condition-to-alias-string(|x))/*;debug(!"req:")*/> querycondition
    ; alljoins := <map(traversal-to-join(|x,xsrt,requiresalias))/*;debug(!"all:")*/> joincandidates
    ; joincandidatesnogen := <filter(?(<id>, False()))> alljoins
    ; joincandidatesgen := <filter(?(<id>, True()))> alljoins
    ; newanno* := [/*<debug(!"qo:")>*/QueryOptimizations(joincandidatesnogen, joincandidatesgen, querycondition) | tokeep]
      |}

strategies

  register-detected-traversal =
    ?(traversal, srt)
    ; condition := <QueryConditions <+ !True()>
    ; effectful := <IsEffectful>
    ; rules( DetectedTraveral :+= (traversal, srt, condition, effectful) )

  register-detected-return-traversal =
    ?(traversal, srt)
    ; rules( DetectedReturn :+= traversal )

  register-detected-required-call =
    ?tc
    ; condition := <QueryConditions <+ !True()>
    ; effectful := <IsEffectful>
    ; rules( DetectedRequiredCall :+= (tc, condition, effectful) )

  register-detected-unresolved-call =
    ?tc
    ; condition := <QueryConditions <+ !True()>
    ; effectful := <IsEffectful>
    ; rules( DetectedUnresolvedCall :+= (tc, condition, effectful) )

  // Succeeds if the argument can be used in the query condition
  query-optimization-bindable-argument =
    ?Arg(_, srt)
    ; where(<is-simple-sort; not(is-entity-type)> srt)

  // Skip
  analyze-for-query-optimization = query-optimization-skip

  query-optimization-skip =
    ?Action(_, _, _, _) <+ ?LocalRedefine(_, _, _, _, _)

rules // Traversals

  analyze-for-query-optimization :
    fa@FieldAccess(_, _){anno*} -> fa{anno*}
    where is-accessible-from-allow-calls(RootVar)
    //; where(try(log-calls(|fa)))
    ; map(register-detected-traversal)

  //log-calls(|fa) = where(<debug(!"from expr ")> fa); map(debug(!"found:"))

  analyze-for-query-optimization :
    v@Var(_){anno*} -> v{anno*}
    where is-accessible-from-allow-calls(RootVar)
    ; map(register-detected-traversal)

  analyze-for-query-optimization :
    Return(e1){anno*} -> Return(e2){anno*}
    where <is-accessible-from-allow-calls(RootVar)> e1
    ; map(register-detected-return-traversal)
    ; e2 := <analyze-for-query-optimization> e1

  analyze-for-query-optimization :
    Derive(deriveType, e, props*) -> Derive(deriveType, e, props*)
    where <map(\ DeriveDefault(f) -> FieldAccess(e, f) \); analyze-for-query-optimization-effectful> props*

strategies // Resolve

  analyze-for-query-optimization :
    c@Call(e, nm, args1){anno*} -> Call(e, nm, args2){anno*}
    where <is-accessible-from(RootVar); ?(e2, <is-entity-type; ?SimpleSort(ent)>)> e
    ; (fent, Function(_, defargs, _, _){defanno*}) := <try-resolve-entity-call> (ent, nm, <map(type-of)> args1)
    with argmapping := <zip> (args1, defargs)
      ; args2 := <map(where(is-accessible-from-allow-calls(RootVar)) < analyze-for-query-optimization-continue + analyze-for-query-optimization-effectful)> args1
      ; <fetch-elem(?QueryAnalysis(analysis, _, _, _))> defanno*
      ; if [Var(xthis)] := <map(Fst); collect(?Var("this")); make-set> analysis then
          varmapping := [ (e, Arg(xthis, SimpleSort(ent))) | argmapping]
        else
          varmapping := argmapping
        end
      //; <debug(!"Following entity function ")> (ent, nm)
      ; newanalysis := <foldr(!analysis, rename-vars-in-analysis(RootVar))> varmapping
      ; <filter(combine-analysis)> newanalysis
      ; try(<is-accessible-from-allow-calls(RootVar); map(register-detected-traversal)> c)

  combine-analysis =
    ?(e, srt, cond, effectful)
    ; where (
      (traversal, esrt) := <is-accessible-from(RootVar)> e
      ; tmpcond := <revalidate-query-condition> cond
      ; newcond := <conc; make-set>(<QueryConditions>, tmpcond)
      ; iseffectful := <IsEffectful; (?True() <+ !effectful)>
      ; rules( DetectedTraveral :+= (traversal, esrt, newcond, iseffectful) )
    )

  revalidate-query-condition = filter(extract-query-cond; not(?True()))

  rename-vars-in-analysis(s) :
    ((e, Arg(x, srt)), analysis) -> newanalysis
    where values := <is-accessible-from-allow-calls(s); map(Fst)/*;debug(!"RenameTo:")*/> e
    //; <debug(!"RenameFrom:")> e
    //; <debug(!"analysis1:")> analysis
    ; newanalysis := <map(replace-var-with-value(|analysis, x)); flatten-list; make-set> values
    //; <debug(!"analysis2:")> newanalysis

  rename-vars-in-analysis(s) :
    ((e, Arg(x, srt)), analysis) -> newanalysis
    where <is-query-condition-constant/*;debug(!"Const:")*/> e
    ; newanalysis := <replace-var-with-value(|analysis, x)> e
    //; <debug(!"analysis4:")> newanalysis

  rename-vars-in-analysis(s) :
    ((e, Arg(x, srt)), analysis) -> analysis
    where <not(is-accessible-from-allow-calls(s) <+ is-query-condition-constant)/*;debug(!"Skip:")*/> e
    //; <debug(!"analysis3:")> analysis
    //with newanalysis := <map(replace-var-with-values(|x,values)); flatten-list> analysis
    //with <debug(!"renaming:")> (e, Arg(x, srt)); newanalysis := <alltd(\Var(x) -> e\)> analysis

  replace-var-with-value(|analysis, x) :
    value -> newanalysis
    with newanalysis := <alltd(?Var(x); !value)> analysis

  analyze-for-query-optimization :
    c@TemplateCall(name, args1, passign1, body){anno*} -> c
	where <CallToRequiredTemplate> name
    ; <register-detected-required-call> c

  analyze-for-query-optimization :
    c@TemplateCall(name, args1, passign1, body){anno*} -> TemplateCall(name, args2, passign2, body){anno*}
    where /*<debug(!"is-defined:")>Var(name); */genname := <is-defined-tc-get-called-tc/*;debug(!"yes-defined:")*/> c
    ; [] := <filter(?ResolvedRequireKey(_))> passign1 // Required calls are resolved on the call that requires them
    //; <debug(!"Call:")> c
    with Define(defmod, defname, deffargs, deftargs, defbody){defanno*} := <CurrentTemplateDecl/*;debug(!"resolved:")*/> genname
        ; <fetch-elem(?QueryAnalysis(_, _, reqCalls, _))> defanno*
        ; reqcallana := </*debug(!"reqCalls:");*/map(/*debug(!"call:");*/resolve-required-call-for-analysis(|passign1,deffargs));flatten-list/*;debug(!"reqcallres:")*/> reqCalls
        ; argmapping := </*debug(!"zipping:");*/zip> (args1, deffargs)
        ; passign2 := <map(?TemplateCall(_, _, _, _) <+ analyze-for-query-optimization-effectful)> passign1
        ; args2 := <map(where(is-accessible-from-allow-calls(RootVar)) < analyze-for-query-optimization-continue + analyze-for-query-optimization-effectful)> args1
	      ; <fetch-elem(?QueryAnalysis(analysis, _, _, _))> defanno*
	      //; <debug(!"Following template ")> name
	      //; <debug(!"analysis:")>analysis
	      ; newanalysis := </*debug(!"mapping:");*/foldr(!<conc>(analysis,reqcallana), rename-vars-in-analysis(RootVar))> argmapping
	      //; <debug(!"newanalysis:")>newanalysis
	      ; <filter(combine-analysis)> newanalysis

  resolve-required-call-for-analysis(|passign1,callerargs) :
    (req@TemplateCall(reqname, reqargs, reqpassign, TemplateBody([])), cond, eff) -> newanalysis
    with reqkey := <strip-annos> reqname
    ; TemplateCall(resname, resargs, respassign, TemplateBody([])) := <fetch-elem(where(?TemplateCall(_, _, <fetch-elem(?ResolvedRequireKey(reqkey))>, _))/*;debug(!"restempl:")*/)> passign1
    ; newargs := <conc>(reqargs, resargs)
    ; newpassign := <conc>(reqpassign,respassign)
    ; genname := </*debug(!"newtempl:");*/is-defined-tc-get-called-tc> TemplateCall(resname, newargs, newpassign, TemplateBody([]))
    ; Define(defmod, defname, deffargs, deftargs, defbody){defanno*} := <CurrentTemplateDecl/*;debug(!"decl:")*/> genname
    ; <fetch-elem(?QueryAnalysis(analysis, _, _, _))> defanno*
    ; argmapping := <zip> (newargs, deffargs)
    ; tmpana := <map(add-condition-to-traversal(|cond))/*;debug(!"oldana:")*/>analysis
    ; {| TempVar
       : <map(\Arg(x, srt) -> <id> with rules(TempVar : Var(x) -> srt)\)> callerargs
       ; newanalysis := <foldr(!tmpana, rename-vars-in-analysis(TempVar <+ RootVar))/*;debug(!"newana:")*/> argmapping
       |}

  add-condition-to-traversal(|cond) :
    (e, srt, oldcond, eff) -> (e, srt, newcond, eff)
    with newcond := <conc; make-set> (oldcond, cond)

  analyze-for-query-optimization =
    //(?ForAll(x, srt, f, b, _){anno*} <+ ?For(x, srt, e, f, b, _){anno*} <+ ?ForAllStmt(x, srt, f, b){anno*} <+ ?ForStmt(x, srt, e, f, b){anno*})
    where((?For(x, srt, e, f, b, _){anno*} <+ ?ForStmt(x, srt, e, f, b){anno*})
    //; <debug(!"forloop:")> Var(x)
    ; <fetch-elem(?QueryAnalysis(analysis, _, _, _))> anno*
    //; <debug(!"analysis:")>analysis
    ; newanalysis := </*debug(!"mapping:");*/foldr(!analysis, rename-vars-in-analysis(RootVar))> [(e, Arg(x, srt))]
    //; <debug(!"newanalysis:")>newanalysis
    ; <filter(combine-analysis)> newanalysis
      )
/*
  analyze-for-query-optimization :
    Call(e, nm, args1){anno*} -> Call(e, nm, args2){anno*}
    where <is-accessible-from(RootVar); ?(e2, <is-entity-type; ?SimpleSort(ent)>)> e
    ; (fent, Function(_, defargs, _, _){defanno*}) := <try-resolve-entity-call> (ent, nm, <map(type-of)> args1)
      with argmapping := <zip> (args1, defargs)
      ; <fetch-elem(?QueryAnalysis(thisanalysis))> defanno*
      //; entmapping := <get-all-entity-properties-as-mapping(|e2)> ent
      ; boundarguments := <filter(where(Snd; query-optimization-argument))> argmapping // These arguments can appear in the query condition
       ; try(
       [Var(xthis)] := <map(Fst); collect(?Var("this")); make-set>thisanalysis
      ; <combine-argument-query-optimization(|boundarguments)> (e2, Arg(xthis, SimpleSort(ent)){defanno*})
        )
      ; args2 := <map(
          combine-argument-query-optimization(|boundarguments) // We could follow this argument
          <+ analyze-effectful-argument // We could not follow this argument, so consider all traversals as effectful
         )> argmapping

  analyze-for-query-optimization :
    TemplateCall(name, args1, passign1, body){anno*} -> TemplateCall(name, args2, passign2, body){anno*}
    where genname := <is-defined-tc-get-called-tc>
    with Define(defmod, defname, deffargs, deftargs, defbody){defanno*} := <CurrentTemplateDecl> genname
        ; argmapping := <zip> (args1, deffargs)
        ; boundarguments := <filter(where(Snd; query-optimization-argument))> argmapping // These arguments can appear in the query condition
        ; passign2 := <analyze-for-query-optimization-effectful> passign1
        ; args2 := <map(
            combine-argument-query-optimization(|boundarguments) // We could follow this argument
            <+ analyze-effectful-argument // We could not follow this argument, so consider all traversals as effectful
           )> argmapping

  analyze-effectful-argument :
    (e, _) -> result
    with result := <analyze-for-query-optimization-effectful> e

  combine-argument-query-optimization(|boundarguments) :
    (e, arg@Arg(_, _){anno*}) -> e
    where <is-accessible-from(RootVar)> e // We can follow the expression from a variable that we are analyzing
    ; ?(_, <try-strip-generic-sort; is-entity-type>)
    ; <combine-query-analysis(|boundarguments)> (e, arg, <fetch-elem(?QueryAnalysis(_))> anno*)

  combine-query-analysis(|boundarguments) =
    ?(e, arg, QueryAnalysis(opt))
    ; opt2 := <foldr(!opt, alltd(bind-query-analysis-argument))> [(e, arg)|boundarguments]
    ; cond := <QueryConditions>
    ; forceEffectful := <IsEffectful>
    ; <map(register-combined-traversal(|cond,forceEffectful))> opt2

  bind-query-analysis-argument =
    ?((e, Arg(x, srt)), opt)
    ; <alltd(?Var(x); !e)> opt

  register-combined-traversal(|cond,forceEffectful) =
    ?(e, esrt, oldcond, oldEffectful)
    ; (traversal, srt) := <is-accessible-from(RootVar)> e
    ; newcond := <conc; make-set>(oldcond, cond)
    ; effectful := <?(True(), _) < !True() + Snd>(forceEffectful, oldEffectful)
    ; rules( DetectedTraveral :+= (traversal, srt, newcond, effectful) )
*/
strategies // Effectful

  analyze-for-query-optimization-continue = alltd(analyze-for-query-optimization)

  analyze-for-query-optimization =
    (
	       ?Call(_, _, _)
	    <+ ?VarDeclInit(_, _, _)
	    <+ ?VarDeclInitInferred(_, _)
	    <+ ?Assignment(_, _)
	    <+ ?PropertyAssignment(_, _)
	    <+ ?PageCall(_, _)
	    <+ ?ThisCall(_, _)
	    <+ (?TemplateCall(name, args, passign, body); where(not(is-defined-tc-get-called-tc))) // A template call we cannot follow
    )
    ; where(False() := <IsEffectful>)
    ; rules( IsEffectful := True() )
    ; analyze-for-query-optimization-continue
    ; rules( IsEffectful := False() )

  analyze-for-query-optimization-effectful =
    where(True() := <IsEffectful>)
    ; analyze-for-query-optimization-continue

  analyze-for-query-optimization-effectful =
    where(False() := <IsEffectful>)
    ; rules( IsEffectful := True() )
    ; analyze-for-query-optimization-continue
    ; rules( IsEffectful := False() )

strategies // Resolve

  // We return an empty list, which should later be removed by flatten-list
  query-optimization-waiting-for = where(query-optimization-skip); ![]

  query-optimization-waiting-for =
    ?ForStmt(x, srt, e, filter, body){anno*}
    ; where(
        <is-entity-type> srt // Important, because we do not analyze for loops of primitive types
        ; (expr, exprsrt) := <is-accessible-from(RootVar)> e
        ; not(<fetch-elem(is-query-analysis)> anno*)
      )

  query-optimization-waiting-for =
    ?For(x, srt, e, filter, body, sep){anno*}
    ; where(
        <is-entity-type> srt // Important, because we do not analyze for loops of primitive types
        ; (expr, exprsrt) := <is-accessible-from(RootVar)> e
        ; not(<fetch-elem(is-query-analysis)> anno*)
      )

  query-optimization-waiting-for =
    ?Call(e, nm, args)
    ; where(
		    <is-accessible-from(RootVar); ?(e2, <is-entity-type; ?SimpleSort(ent)>)> e
		    ; (fent, Function(_, defargs, _, _){anno*}) := <try-resolve-entity-call> (ent, nm, <map(type-of)> args)
		    ; not(<fetch-elem(is-query-analysis)> anno*)
        //; waitingonargs := <zip; filter(query-optimization-waiting-for-argument)>(args, defargs)
        //; (not([] := waitingonargs) <+ not(<fetch-elem(?QueryAnalysis(_))> anno*)) // not waiting for analysis of arguments or this keyword
      )

  query-optimization-waiting-for =
    ?TemplateCall(name, args, passign, body)
    ; where(
        genname := <is-defined-tc-get-called-tc>
        //; _{anno*} := <CurrentTemplateDecl> genname
        //; not(<fetch-elem(?QueryAnalysis(_))> anno*)
        ; Define(defmod, defname, deffargs, deftargs, defbody){anno*} := </*debug(!"tc:");*/CurrentTemplateDecl> genname
        //; <zip; filter(query-optimization-waiting-for-argument); not(?[])>(args, deffargs)
        ; not(<fetch-elem(is-query-analysis)> anno*)
      )

  //query-optimization-waiting-for =
    //(?ForAll(_, _, _, _, _){anno*} <+ ?For(_, _, _, _, _, _){anno*} <+ ?ForAllStmt(_, _, _, _){anno*} <+ ?ForStmt(_, _, _, _, _){anno*})
    //(?For(_, _, _, _, _, _){anno*} <+ ?ForStmt(_, _, _, _, _){anno*})
    //; where(not(<fetch-elem(?QueryAnalysis(_, _))> anno*))

/*  query-optimization-waiting-for-argument =
    ?(arg, Arg(_, _){anno*})
    ; <is-accessible-from(RootVar)> arg // We can follow the expression from a variable that we are analyzing
    ; ?(_, <try-strip-generic-sort; is-entity-type>) // The expression is of an entity type, which could result in more field accesses
    ; <not(fetch-elem(?QueryAnalysis(_)))> anno* // We should follow this argument, so we check if the target analysis is complete
*/
/*
  query-optimization-waiting-for =
    ?Call(e, nm, arg*){anno*}
    ; where(<is-accessible-from(IteratedVar); ?(e2, <is-entity-type; ?SimpleSort(ent)>)> e)
    ; genname := <generate-template-name-args> (<concat-strings>[ent, nm], arg*)
*/

rules // Query conditions

  // Extracts the query condition as a list where elements should be combined with the and operator
  extract-query-cond-as-list :
    And(expr1, expr2) -> cond 
    where lst1 := <extract-query-cond-as-list> expr1
    ; lst2 := <extract-query-cond-as-list> expr2
    ; cond := <conc> (lst1, lst2)

  extract-query-cond-as-list :
    expr -> cond
    where not(And(_, _) := expr)
    ; cond := <extract-query-cond; (?True() < ![] + ![<id>])> expr

strategies

  negate-query-cond-lst =
    map(negate-query-cond <+ !Not(<id>))
    ; flatten-list

  negate-query-cond :
    SmallerThanOrEqual(expr1, expr2) -> LargerThan(expr1, expr2)

  negate-query-cond :
    LargerThan(expr1, expr2) -> SmallerThanOrEqual(expr1, expr2)

  negate-query-cond :
    SmallerThan(expr1, expr2) -> LargerThanOrEqual(expr1, expr2)

  negate-query-cond :
    LargerThanOrEqual(expr1, expr2) -> SmallerThan(expr1, expr2)

  negate-query-cond :
    NotEq(expr1, expr2) -> Eq(expr1, expr2)

  negate-query-cond =
    ?Eq(expr1, expr2)
    ; (negate-simple-eq-cond <+ !NotEq(expr1, expr2)) // We first try to keep this an equals comparison

rules // Special cases

  analyze-for-query-optimization :
    IfTempl(cond1, true1, false1){anno*} -> IfTempl(cond2, true2, false2){anno*}
    where (cond2, true2, false2) := <analyze-for-query-optimization-if> (cond1, true1, false1)

  analyze-for-query-optimization :
    If(cond1, true1, false1){anno*} -> If(cond2, true2, false2){anno*}
    where (cond2, true2, false2) := <analyze-for-query-optimization-if> (cond1, true1, false1)

  analyze-for-query-optimization-if :
    (cond1, true1, false1) -> (cond2, true2, false2)
    where condlst := <extract-query-cond-as-list> cond1
    ; not([] := condlst)
    with cond2 := <analyze-for-query-optimization-continue> cond1
    ; oldcond := <QueryConditions> 
    ; rules( QueryConditions := <conc; make-set>(oldcond, condlst) )
    ; true2 := <analyze-for-query-optimization-continue> true1
    ; rules( QueryConditions := <conc; make-set>(oldcond, <negate-query-cond-lst>condlst) )
    ; false2 := <analyze-for-query-optimization-continue> false1
    ; rules( QueryConditions := oldcond )

rules // Query conditions

  //is-var-accessible = is-query-condition-constant <+ (is-accessible-from(QueryArg <+ RootVar); ?(<id>, _))
  is-var-accessible = is-query-condition-constant <+ (is-accessible-from(BindableVar <+ RootVar); ?(<id>, _))

  get-accessible-expr = get-accessible-dbfield

  get-accessible-expr = get-accessible-field

  get-accessible-expr = is-query-condition-constant

  //get-accessible-dbfield = (?Var(_) <+ ?FieldAccess(_, _)); is-accessible-from(QueryArg,id); ?(<id>, srt); where([] := <collect(?_{<fetch-elem(?MultipleDefinitionsInSubclasses())>})>)
  get-accessible-dbfield = (?Var(_) <+ ?FieldAccess(_, _)); is-accessible-from(RootVar,id); ?(<id>, srt); where([] := <collect(?_{<fetch-elem(?MultipleDefinitionsInSubclasses())>})>)

  get-accessible-field = (?Var(_) <+ ?FieldAccess(_, _)); is-accessible-from(BindableVar,id); ?(<id>, srt); where([] := <collect(?_{<fetch-elem(?MultipleDefinitionsInSubclasses())>})>)
  //get-accessible-field = (?Var(_) <+ ?FieldAccess(_, _)); ((is-accessible-from(ParentArgs,id); ?(<id>, srt)) <+ is-query-condition-constant) 

  is-query-condition-type = ?SimpleSort("Int") <+ ?SimpleSort("Long") <+ ?SimpleSort("Float") <+ ?SimpleSort("String") <+ ?SimpleSort("Bool") <+ ?SimpleSort("UUID")

  is-query-condition-constant = (?Int(_) <+ ?Long(_) <+ ?Float(_) <+ ?String(_) <+ ?True() <+ ?False() <+ ?Null()); try(normalize) 

  extract-query-cond:
    Not(expr1) -> Not(expr1new)
    where expr1new := <extract-query-cond> expr1
    ; not(True() := expr1new)
    ; not(Eq(_, _) := expr1new)

  extract-query-cond:
    Not(expr1) -> NotEq(expr1new, expr2new)
    where eq@Eq(expr1new, expr2new) := <extract-query-cond> expr1
    ; not(<negate-simple-eq-cond> eq)

  extract-query-cond:
    Not(expr1) -> Eq(expr1new, expr2new)
    where Eq(expr1new, expr2new) := <extract-query-cond; negate-simple-eq-cond> expr1

  negate-simple-eq-cond: Eq(True(), expr) -> Eq(expr, False())
  negate-simple-eq-cond: Eq(expr, True()) -> Eq(expr, False())
  negate-simple-eq-cond: Eq(False(), expr) -> Eq(expr, True())
  negate-simple-eq-cond: Eq(expr, False()) -> Eq(expr, True())

  extract-query-cond:
    Or(expr1, expr2) -> Or(expr1new, expr2new)
    where expr1new := <extract-query-cond> expr1
    ; expr2new := <extract-query-cond> expr2
    ; not(True() := expr1new)
    ; not(True() := expr2new)

  extract-query-cond:
    And(expr1, expr2) -> cond
    where expr1new := <extract-query-cond <+ !True()> expr1
    ; expr2new := <extract-query-cond <+ !True()> expr2
    ; cond := <append-condition>(expr1new, expr2new)

  extract-query-cond:    
    SmallerThanOrEqual(expr1, expr2) -> SmallerThanOrEqual(newExpr1, newExpr2)
    where newExpr1 := <get-accessible-expr> expr1
    ; newExpr2 := <get-accessible-expr> expr2
    ; <is-one-dbprop> (expr1, expr2)

  extract-query-cond:
    SmallerThan(expr1, expr2) -> SmallerThan(newExpr1, newExpr2)
    where newExpr1 := <get-accessible-expr> expr1
    ; newExpr2 := <get-accessible-expr> expr2
    ; <is-one-dbprop> (expr1, expr2)

  extract-query-cond:
    LargerThanOrEqual(expr1, expr2) -> LargerThanOrEqual(newExpr1, newExpr2)
    where newExpr1 := <get-accessible-expr> expr1
    ; newExpr2 := <get-accessible-expr> expr2
    ; <is-one-dbprop> (expr1, expr2)

  extract-query-cond:
    LargerThan(expr1, expr2) -> LargerThan(newExpr1, newExpr2)
    where newExpr1 := <get-accessible-expr> expr1
    ; newExpr2 := <get-accessible-expr> expr2
    ; <is-one-dbprop> (expr1, expr2)

  extract-query-cond:
    NotEq(expr1, expr2) -> NotEq(newExpr1, newExpr2)
    where newExpr1 := <get-accessible-expr> expr1
    ; newExpr2 := <get-accessible-expr> expr2
    ; <is-one-dbprop> (expr1, expr2)

  extract-query-cond:
    Eq(expr1, expr2) -> Eq(newExpr1, newExpr2)
    where newExpr1 := <get-accessible-expr> expr1
    ; newExpr2 := <get-accessible-expr> expr2
    ; <is-one-dbprop> (expr1, expr2)

  extract-query-cond:
    fa1@FieldAccess(_, _) -> Eq(fa2, True())
    where (fa2, SimpleSort("Bool")) := <is-accessible-from(RootVar,id)> fa1

  extract-query-cond:
    v1@Var(_) -> Eq(v2, True())
    where (v2, SimpleSort("Bool")) := <is-accessible-from(RootVar,id)> v1

  /*extract-query-cond=
    ?Call(e1, nm, arg*){anno*}
    ; where(<is-accessible-from(IteratedVar <+ IteratedSubList); ?(e2, <is-entity-type; ?SimpleSort(ent)>)> e1)
    ; genname := <generate-template-name-args> (<concat-strings>[ent, nm], arg*)
    ; where(not(<PassedFunction> genname)) // This prevents an infinite loop when following a recursive function
    ; (fent, Function(_, fargs, SimpleSort("Bool"), Block([Return(expr)]))) := <try-resolve-entity-call> (ent, nm, <map(query-optimization-type-of)> arg*)
    // Here we get the properties of the entity and insert them as extra parameters for the function call
    // We also have to rename the Var("prop") to Var("prop"{Entity_myfunctionArg1Arg2}) to prevent creating a loop in IteratedVar or IteratedSubList
    ; thissafe := "this"{<concat-strings>[genname, "_this"]}
    ; {| RenamePropInFunction // Here we temporarily rename the Var()s in the function body for our analysis
        : argsbinding := <get-all-entity-properties-for-rename(|genname); map({name,uniquename,safename,srt:\
                                (name, uniquename, safename, srt) -> (FieldAccess(e2, name), Arg(safename, srt))
                                where rules( RenamePropInFunction : Var(uniquename) -> Var(safename) )
                            \}); <concat>[[(e2, Arg(thissafe, SimpleSort(fent)))],<id>,<zip>(arg*, fargs)]> ent
        ; rules( RenamePropInFunction : Var("this") -> Var(thissafe) )
        ; expr2 := <alltd(RenamePropInFunction)> expr
      |}
    ; {| PassedFunction, IteratedVar, IteratedVarValue, IteratedSubList, IteratedSubListValue
       : rules( PassedFunction : genname )
         // Here we mark the arguments as interesting, because they are in some way related to the persistent root or are constants which we can use in query conditions
         // Removed the warnings, because a loop could occur when following a local redefine, because then some variables inside the redefine can belong to the caller and thus have the same name. This warning can be safely ignored.
       ; <filter({vars:
                     \ (e, Arg(x, srt)) ->  <id>
                       where [] := <collect(IteratedSubList)> e; <is-var-accessible> e; not(<is-generic-sort> srt)
*///                       where not(<IteratedVarValue/*; warn(|["Ignoring variable ", x, ", because it would create a loop in IteratedVarValue"])*/> Var(x))
/*                       with rules( IteratedVarValue : Var(x) -> e     // Helps when expressing a Var into the Var or constant passed by the caller 
                                   IteratedVar      : Var(x) -> srt
                                 )
                     \})> argsbinding
       ; <filter({vars: 
                     \ (e, Arg(x, srt)) ->  <id>
                       where not([] := <collect(IteratedSubList)> e) <+ (<is-generic-sort> srt; <is-var-accessible> e)
*///                       where not(<IteratedSubListValue/*; warn(|["Ignoring variable ", x, ", because it would create a loop in IteratedSubListValue"])*/> Var(x))
/*                       with rules( IteratedSubListValue  : Var(x) -> e
                                   IteratedSubList       : Var(x) -> srt
                                 )
                     \})> argsbinding
       ; <extract-query-cond> expr2
       ; repeat(oncetd(IteratedSubListValue <+ IteratedVarValue))
     |}*/

  extract-query-cond = !True()
