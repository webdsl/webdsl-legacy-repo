module org/webdsl/dsl/languages/query-analysis

rules // Entry points

  perform-query-analysis(|name,args,cond) :
    (body, anno*) -> (body, [QueryAnalysis([], [], [], []) | anno*])
    where QueryOptimizationDisabled
    ; not(<fetch-elem(is-query-analysis)> anno*)
    //; info(|"QueryOptimization disabled")

  // x is the root
  // args contains variables that may appear in the query condition. They do not have to be bindable yet, because they may be bindable in the caller. 
/*  perform-query-analysis(|x,srt,args,cond) :
    (body, anno*) -> (body2, [QueryAnalysis(ts) | anno*])
    where not(QueryOptimizationDisabled)
    ; <not(fetch-elem(?QueryAnalysis(_)))> anno*
    ; {| RootVar
     : rules( RootVar : Var(x) -> srt)
     ; <debug(!"x:")> Var(x)
     ; [] := <collect(query-optimization-waiting-for);debug(!"wait:")> body
    |}
    with {| RootVar, QueryArg, IteratedVar, QueryConditions, IsEffectful, DetectedTraveral
       : rules (  IteratedVar     : Var(x) -> srt // Contains all variables we are following (is RootVar and template/function call arguments)
                  RootVar         : Var(x) -> srt // The actual variable we are interested in (the persistent root of our analysis)
                  QueryConditions := []           // Changes over time to represent the query conditions active on the term currently being analyzed
                  IsEffectful     := False()      // True if the current statement is effectful (means: can affect non-local state), False otherwise
               )
       ; <filter({vars: 
                     \ Arg(arg, srt) ->  <id>
                       with rules( QueryArg      : Var(arg) -> srt )
                     \})> args
       ; rules( QueryConditions := <extract-query-cond-as-list> cond)
       ; body2 := <analyze-for-query-optimization-continue> body
       ; ts := <bagof-DetectedTraveral>
       ; <remove-casts;log-query-optimization-collect-table(|45,155,5)> ts
       ; av := []
       ; calls := []//<bagof-DetectedCall>
      |}
*/

  perform-waiting-check-only(|args) :
    (body, anno*) -> wait
    where not(QueryOptimizationDisabled)
    ; not(<fetch-elem(is-query-analysis)> anno*)
    ; {| RootVar, QueryConditions, IsEffectful, DetectedTraveral, DetectedReturn, DetectedRequiredCall, DetectedUnresolvedCall
       : <filter(\ Arg(arg, srt) -> <id> with rules( RootVar : Var(arg) -> srt ) \)> args
       ; wait := <collect(query-optimization-waiting-for); flatten-list> body
      |}

  perform-query-analysis(|name,args,cond) :
    (body, anno*) -> (body2, [QueryAnalysis(ts, returns, requiredcalls, unresolvedcalls) | anno*])
    where not(QueryOptimizationDisabled)
    ; not(<fetch-elem(is-query-analysis)> anno*)
    ; {| RootVar, QueryConditions, IsEffectful, DetectedTraveral, DetectedReturn, DetectedRequiredCall, DetectedUnresolvedCall
       : <filter(\ Arg(arg, srt) -> <id> with rules( RootVar : Var(arg) -> srt ) \)> args
       //; <debug(!"Checking: ")> name
       ; [] := <collect(query-optimization-waiting-for); flatten-list/*;debug(!"wait:")*/> (body, cond)
       ; with(
		       rules (  QueryConditions := <extract-query-cond-as-list> cond  // Changes over time to represent the query conditions active on the term currently being analyzed
		                IsEffectful     := False()                            // True if the current statement is effectful (means: can affect non-local state), False otherwise
		             )
		       //; <debug(!"Analyzing: ")> name
		       ; body2 := <analyze-for-query-optimization-continue> body
		       ; ts := <bagof-DetectedTraveral>
		       ; returns := <bagof-DetectedReturn>
		       ; requiredcalls := <bagof-DetectedRequiredCall>
		       ; unresolvedcalls := <bagof-DetectedUnresolvedCall/*;debug(!"gotunres:")*/>
		       //; <debug(!"TS of ")> name
		       //; <remove-casts;log-query-optimization-collect-table(|45,135,5)> ts
		       ; calls := []//<bagof-DetectedCall>
	      )
	      //;<debug(!"qa:")>QueryAnalysis(ts, returns, requiredcalls, unresolvedcalls)
      |}

  query-analysis-to-query-optimizition(|x,xsrt,bindableargs) :
    qa -> qo
    with {|RootVar, BindableVar
    : rules( RootVar : Var(x) -> xsrt )
    ; <filter(\ Arg(arg, srt) -> <id> where not(<RootVar>Var(arg)) with /*debug(!"Bindable:");*/rules( BindableVar : Var(arg) -> srt ) \)> bindableargs
    ; ts := <?QueryAnalysis(<id>, _, _, _); filter(where(Fst; is-accessible-from(RootVar)))> qa
    ; joincandidates := <map(!(<Fst>, <Snd>)); filter(an-requires-joining-fa); map(sub-paths); flatten-list; make-set; keep-least-specific-casts/*;debug(!"joins:")*/> ts
    ; querycondition := <filter(?(_, _, <revalidate-query-condition;and-query-condition>, True())); make-set; try(?[]; ![True()]); (where(filter(?True()); ?[]) < foldr(![], join-conditions) + !True())> ts // Combine query conditions of the effectful field accesses
    ; requiresalias := <collect(condition-to-alias-string(|x))> querycondition
    ; alljoins := <map(traversal-to-join(|x,xsrt,requiresalias))> joincandidates
    ; joincandidatesnogen := <filter(?(<id>, False()))> alljoins
    ; joincandidatesgen := <filter(?(<id>, True()))> alljoins
    ; qo := QueryOptimizations(joincandidatesnogen, joincandidatesgen, querycondition)
      |}

strategies

  register-detected-traversal =
    ?(traversal, srt)
    ; condition := <QueryConditions <+ !True()>
    ; effectful := <IsEffectful>
    ; rules( DetectedTraveral :+= (traversal, srt, condition, effectful) )

  register-detected-return-traversal =
    ?(traversal, srt)
    ; rules( DetectedReturn :+= traversal )

  register-detected-required-call =
    ?tc
    ; condition := <QueryConditions <+ !True()>
    ; effectful := <IsEffectful>
    ; rules( DetectedRequiredCall :+= (tc, condition, effectful) )

  register-detected-unresolved-call =
    ?(genname, args)
    ; condition := <QueryConditions <+ !True()>
    ; effectful := <IsEffectful>
    ; rules( DetectedUnresolvedCall :+= (genname, args, condition, effectful) )

  // Succeeds if the argument can be used in the query condition
  query-optimization-bindable-argument =
    ?Arg(_, srt)
    ; where(<is-simple-sort; not(is-entity-type)> srt)

  // Skip
  analyze-for-query-optimization = query-optimization-skip

  query-optimization-skip =
    ?Action(_, _, _, _) <+ ?LocalRedefine(_, _, _, _, _)

rules // Traversals

  analyze-for-query-optimization :
    fa@FieldAccess(_, _){anno*} -> fa{anno*}
    where is-accessible-from-allow-calls(RootVar)
    //; where(try(log-calls(|fa)))
    ; map(register-detected-traversal)

  //log-calls(|fa) = where(<debug(!"from expr ")> fa); map(debug(!"found:"))

  analyze-for-query-optimization :
    v@Var(_){anno*} -> v{anno*}
    where is-accessible-from-allow-calls(RootVar)
    ; map(register-detected-traversal)

  analyze-for-query-optimization :
    Return(e1){anno*} -> Return(e2){anno*}
    where <is-accessible-from-allow-calls(RootVar)> e1
    ; map(register-detected-return-traversal)
    ; e2 := <analyze-for-query-optimization> e1

  analyze-for-query-optimization :
    Return(e1){anno*} -> Return(e2){anno*}
    where <is-accessible-from-allow-calls(RootVar)> e1
    ; map(register-detected-return-traversal)
    ; e2 := <analyze-for-query-optimization> e1

  analyze-for-query-optimization : // For functions returning SimpleSort("Bool")
    Return(e1){anno*} -> Return(e2){anno*}
    where traversal := <extract-query-cond; not(?True())> e1
    ; rules( DetectedReturn :+= traversal )
    ; e2 := <analyze-for-query-optimization> e1

  analyze-for-query-optimization :
    Derive(deriveType, e, props*) -> Derive(deriveType, e, props*)
    where <map(\ DeriveDefault(f) -> FieldAccess(e, f) \); analyze-for-query-optimization-effectful> props*

strategies // Resolve

  analyze-for-query-optimization :
    c@Call(e, nm, args1){anno*} -> Call(e, nm, args2){anno*}
    where <is-accessible-from(RootVar); ?(e2, <is-entity-type; ?SimpleSort(ent)>)> e
    ; <not(not-allowed-ent-fun-name)> nm
    ; not("Entity" := ent)
    ; (fent, Function(_, defargs, _, _){defanno*}) := <try-resolve-entity-call> (ent, nm, <map(type-of)> args1)
    with /*<debug(!"Combining call:")> (ent, nm, <map(type-of)> args1); */argmapping := <zip> (args1, defargs)
      ; args2 := <map(where(is-accessible-from-allow-calls(RootVar)) < analyze-for-query-optimization-continue + analyze-for-query-optimization-effectful)> args1
      ; <fetch-elem(?QueryAnalysis(analysis, _, _, _))> defanno*
      ; if [Var(xthis)] := <map(Fst); collect(?Var("this")); make-set> analysis then
          varmapping := [ (e, Arg(xthis, SimpleSort(ent))) | argmapping]
        else
          varmapping := argmapping
        end
      //; <debug(!"Following entity function ")> (ent, nm)
      ; newanalysis := <foldr(!analysis, rename-vars-in-analysis(RootVar))> varmapping
      ; <filter(combine-analysis)> newanalysis
      ; try(<is-accessible-from-allow-calls(RootVar); map(register-detected-traversal)> c)

  combine-analysis =
    ?(e, srt, cond, effectful)
    ; where (
      (traversal, esrt) := <is-accessible-from(RootVar)> e
      ; tmpcond := <revalidate-query-condition> cond
      ; newcond := <conc; make-set>(<QueryConditions>, tmpcond)
      ; iseffectful := <IsEffectful; (?True() <+ !effectful)>
      ; rules( DetectedTraveral :+= (traversal, esrt, newcond, iseffectful) )
    )

  revalidate-query-condition = filter(extract-query-cond; not(?True()))

  rename-vars-in-analysis(s) :
    ((e, Arg(x, srt)), analysis) -> newanalysis
    where <is-list> e
    ; values := <filter((is-accessible-from-allow-calls(s); map(Fst)) <+ is-query-condition-constant); flatten-list> e
    ; newanalysis := <?[] < !analysis + (map(replace-var-with-value(|analysis, x)); flatten-list; make-set)> values

  rename-vars-in-analysis(s) :
    ((e, Arg(x, srt)), analysis) -> newanalysis
    where values := <is-accessible-from-allow-calls(s); map(Fst)/*;debug(!"RenameTo:")*/> e
    ; newanalysis := <map(replace-var-with-value(|analysis, x)); flatten-list; make-set> values

  rename-vars-in-analysis(s) :
    ((e, Arg(x, srt)), analysis) -> newanalysis
    where <is-query-condition-constant> e
    ; newanalysis := <replace-var-with-value(|analysis, x)> e

  rename-vars-in-analysis(s) :
    ((e, Arg(x, srt)), analysis) -> analysis
    where <not(is-list <+ is-accessible-from-allow-calls(s) <+ is-query-condition-constant)> e

  replace-var-with-value(|analysis, x) :
    value -> newanalysis
    with newanalysis := <alltd(?Var(x); !value)> analysis

  analyze-for-query-optimization =
    where(match-template-with-name(|"elements")
	    ; register-detected-required-call
    )

  analyze-for-query-optimization :
    c@TemplateCall(name, args1, passign1, body){anno*} -> c{anno*}
    where <CallToRequiredTemplate> name
    ; <register-detected-required-call> c

  analyze-for-query-optimization :
    c@TemplateCall(name, args1, passign1, body){anno*} -> c
    where genname := <is-defined-tc-get-called-tc; where(is-unresolved-local-redefine)> c
    ; args := <map((is-accessible-from-allow-calls(RootVar); map(Fst)) <+ ![])> args1
    ; <register-detected-unresolved-call> (genname, args)

  analyze-for-query-optimization :
    c@TemplateCall(name, args1, passign1, body){anno*} -> TemplateCall(name, args2, passign2, body){anno*}
    where /*<debug(!"is-defined:")>Var(name); */genname := <is-defined-tc-get-called-tc/*;debug(!"yes-defined:")*/> c
    ; [] := <filter(?ResolvedRequireKey(_))> passign1 // Required calls are resolved on the call that requires them
    //; <debug(!"Call:")> c
    with Define(defmod, defname, deffargs, deftargs, defbody){defanno*} := </*debug(!"Combining template:");*/get-local-redefined-decl <+ CurrentTemplateDecl> genname // get-local-redefined-decl resolves a template call if it is redefined in the current template/page. That way it is handled as a regular resolvable template call.
        ; <fetch-elem(?QueryAnalysis(analysis, _, reqCalls, redefCalls))> defanno*
        ; reqcallana := <filter(resolve-required-call-for-analysis(|genname,passign1,deffargs));flatten-list/*;debug(!"reqcallres:")*/> reqCalls
        //; <try(not(?[]); debug(!"redefs:"))> redefCalls
        ; argmapping := </*debug(!"zipping:");*/zip> (args1, deffargs)
        ; resolvedcalls := <resolve-unresolved-calls/*;try(not(?[]);debug(!"tempres:"))*/> (argmapping, redefCalls)
        ; passign2 := <map(?TemplateCall(_, _, _, _) <+ analyze-for-query-optimization-effectful)> passign1
        ; args2 := <map(where(is-accessible-from-allow-calls(RootVar)) < analyze-for-query-optimization-continue + analyze-for-query-optimization-effectful)> args1
	      //; <debug(!"Following template ")> name
	      //; <debug(!"analysis:")>analysis
	      ; newanalysis := </*debug(!"mapping:");*/foldr(!<concat>[analysis,reqcallana,resolvedcalls], rename-vars-in-analysis(RootVar))> argmapping
	      //; <debug(!"newanalysis:")>newanalysis
	      ; <filter(combine-analysis)> newanalysis

  is-unresolved-local-redefine =
    ?genname
    /*; debug(!"genname:")*/
    ; where(
        tname := <CurrentTemplateName/*;debug(!"is-tname:")*/> // This DR is set if we are analyzing a page/template
        ; redefines := <bagof-TemplateRedefinitions/*;debug(!"is-bag:")*/> genname
        ; not([] := redefines) // There are local redefinitions of genname somewhere
        ; <not(fetch-elem(?tname))/*;debug(!"is-empty:")*/> redefines // The template is not redefined within the current template and remains unresolved.
      )

  // Will fail if the template is not redefined locally, extra arguments are already resolved
  /*get-local-redefined-decl :
    genname -> decl
    where (decl, _) := <get-local-redefined-decl-with-extra-args> genname*/

  get-local-redefined-decl : /*-with-extra-args*/
    genname -> Define(defmod, defname, newfargs, newdeftargs, newdefbody){newdefanno*}
    where tname := <CurrentTemplateName/*;debug(!"tname:")*/>
    //; t* := <TemplateArguments; formal-arguments-to-types> genname
    //; name := <bagof-TemplateRedefinitions/*;debug(!"bag:")*/; fetch-elem(?tname)/*;debug(!"gotit:")*//*; ?[(_, _{<id>}, t*)]*//*;debug(!"name:")*/> genname
    //; localname := <concat-strings;debug(!"localname:")> [name,"$l$"]
    ; localgenname := <LocalRedefineGenname/*;debug(!"redefgen:")*/> (tname, genname)//localname
    ; extraArgs := <LocalRedefineArgs/*;debug(!"redefargs:")*/> localgenname
    //; targs := <CurrentTemplateArgs>
    //; tgenname := <generate-template-name-fargs; debug(!"tgenname:")> (tname, targs)
    //; <debug(!"extraargs:")> extraargs
    //; <CurrentTemplateDecl;debug(!"tdecl:");collect(?LocalRedefine(_,_,_,localname, LocalRedefineArgs(extraArgs)));debug(!"redefs:")> tgenname
    //; t2* := <map(type-of)> extraArgs
    //; localgenname := <generate-template-name;debug(!"localgenname:")>(localname,<conc>(t*,t2*))
    ; def@Define(defmod, defname, deffargs, deftargs, defbody){defanno*} := <CurrentTemplateDecl/*;debug(!"localdecl:")*/> localgenname
    //; <debug(!"resolved:")> (tname, genname, localgenname)
    // Now we replace the extra arguments and remove them from the fargs
    ; (newfargs, extrafargs) := <split-at(|<subti>(<length>deffargs, <length>extraArgs))>deffargs
    ; extraArgsMapping := <zip> (extraArgs, extrafargs)
    ; newdefanno* := <foldr(!defanno*, replace-vars)> extraArgsMapping
    ; newdeftargs := <foldr(!deftargs, replace-vars)> extraArgsMapping
    ; newdefbody := <foldr(!defbody, replace-vars)> extraArgsMapping

  check-resolvable-calls-ready = check-resolvable-calls-ready(check-resolvable-calls-ready(id))

  check-resolvable-calls-ready(s) :
    QueryAnalysis(_, _, _, redefCalls) -> unready
    where tocheck := <filter(Fst; not(is-unresolved-local-redefine))> redefCalls
    ; unready := <filter(where(not(get-local-redefined-decl; get-anno(is-query-analysis); s)))> tocheck

  /*check-resolvable-calls-ready-helper :
    QueryAnalysis(_, _, _, redefCalls) -> unready
    where tocheck := <filter(Fst;debug(!"is-unresolved-local-redefine2:");not(is-unresolved-local-redefine));debug(!"tocheck2:")> redefCalls
    ; unready := <filter(where(not(debug(!"genname2:");get-local-redefined-decl;debug(!"chkdecl2:");get-anno(is-query-analysis);debug(!"anno2:");debug(!"ready2:"))));debug(!"unready2:")> tocheck
  */

  replace-vars :
    ((v, Arg(x, srt)), term) -> newterm
    with newterm := <alltd(?Var(x); !v)> term

  resolve-unresolved-calls :
    (argmapping, redefCalls) -> resolvedcalls
    with <filter(translate-unresolved(|argmapping))> redefCalls // Calls that we cannot resolve are registered as such
    ; (qas, unresolvedcalls1) := <filter(resolve-unresolved-call(|argmapping)); unzip> redefCalls // We resolve calls, which may result in more unresolved calls
    ; <flatten-list/*; debug(!"todo:")*/;filter(translate-unresolved(|argmapping))/*;debug(!"unsolvable:")*/> unresolvedcalls1 // We register new unsolvable calls
    ; (qas2, unresolvedcalls2) := <flatten-list; filter(resolve-unresolved-call(|argmapping))/*;debug(!"out:")*/; unzip> unresolvedcalls1 // We solve the new resolvable calls
    ; unresolved3 := <flatten-list; make-set; filter(translate-unresolved(|argmapping) <+ (analyze-for-query-optimization-effectful; fail))/*;debug(!"unsolvable3:")*/> unresolvedcalls2 // We do not try to solve new unresolved calls
    ; resolvedcalls := <conc; flatten-list; make-set/*;debug(!"qas:")*/> (qas, qas2)

  translate-unresolved(|argmapping) :
    (genname, args, cond, eff) -> (genname, newargs, cond, eff) // TODO: cond and eff
    where <is-unresolved-local-redefine> genname
    ; newargs := <map(fix-argument(|argmapping))> args
    ; <register-detected-unresolved-call> (genname, newargs) // We ignore cond and eff for now

  resolve-unresolved-call(|argmapping) :
    (genname, args, cond, eff) -> (newanalysis, newRedefCalls)
    where Define(defmod, defname, deffargs, deftargs, defbody){defanno*} := <get-local-redefined-decl/*;debug(!"renameddecl:")*/> genname
    ; <fetch-elem(?QueryAnalysis(analysis, _, _, redefCalls))/*;debug(!"ana:")*/> defanno*
    /*; <debug(!"args:      ")> args
    ; <debug(!"argmapping:")> argmapping
    ; <debug(!"deffargs:  ")> deffargs*/
    ; newargs := <map(fix-argument(|argmapping))> args
    ; newmap := <zip/*;debug(!"newmap:    ")*/> (newargs, deffargs)
    ; tmpana := <map(add-condition-to-traversal(|cond))/*;debug(!"oldana:")*/>analysis
    ; newanalysis := <foldr(!tmpana, rename-vars-in-analysis(RootVar))/*;debug(!"newana:")*/> newmap
    ; newRedefCalls := <foldr(!/*<debug(!"oldRedefCalls:")>*/redefCalls, rename-vars-in-analysis(RootVar))/*;debug(!"newRedefCalls:")*/> newmap

  /*resolve-unresolved-call(|argmapping) :
    (genname, args, cond, eff) -> (genname, [], cond, eff)
    where
    (Define(defmod, defname, deffargs, deftargs, defbody){defanno*}, extraArgs) := <get-local-redefined-decl-with-extra-args> genname
    //; extraArgMapping := <zip; filter(?(Var(_), _))>(<conc>(args, extraArgs), deffargs)
    ; <debug(!"defanno*:");fetch-elem(?QueryAnalysis(analysis, _, _, redefCalls));debug(!"ana:")> defanno*
    ; <debug(!"args:      ")> args
    ; <debug(!"argmapping:")> argmapping
    ; <debug(!"deffargs:  ")> deffargs
    ; <debug(!"extraArgs: ")> extraArgs
    ; newargs := <map(fix-argument(|argmapping))> args
    ; <debug(!"newargs:   ")> newargs
    ; newargs2 := <conc;debug(!"newargs2:  ")> (newargs, extraArgs)
    ; newmap := <zip;debug(!"newmap:    ")> (newargs2, deffargs)*/
    //; argmapping := <zip> (newargs, deffargs)
    //; tmpana := <map(add-condition-to-traversal(|cond))/*;debug(!"oldana:")*/>analysis
    //; {| TempVar
    //   : <map(\Arg(x, srt) -> <id> with rules(TempVar : Var(x) -> srt)\)> callerargs
    //   ; newanalysis := <foldr(!tmpana, rename-vars-in-analysis(TempVar <+ RootVar))/*;debug(!"newana:")*/> argmapping
    //   |}

  fix-argument(|argmapping) :
    arg -> newarg
    where newarg := <foldr(!arg, rename-vars-in-analysis(RootVar)); try(?[<id>])> argmapping

  resolve-required-call-for-analysis(|elemname,passign1,callerargs) :
    (req@TemplateCall(reqname, reqargs, reqpassign, TemplateBody([])), cond, eff) -> newanalysis
    where if <match-template-with-name(|"elements")> req then // elements call is not resolvable when no elements are present
      reqkey := <concat-strings>["elements#",elemname]
    else
      reqkey := <strip-annos> reqname
    end
    //; reqkey := <where(try(generate-elements-tcallsmap-name; debug(!"test:")); try(CallToDefinedTemplate; debug(!"test2:")));strip-annos;debug(!"reqkey:")> reqname
    ; TemplateCall(resname, resargs, respassign, TemplateBody([])) := <fetch-elem(where(?TemplateCall(_, _, <fetch-elem(?ResolvedRequireKey(reqkey))>, _))/*;debug(!"restempl:")*/)> passign1
    ; newargs := <conc>(reqargs, resargs)
    ; newpassign := <conc>(reqpassign,respassign)
    ; genname := </*debug(!"newtempl:");*/is-defined-tc-get-called-tc> TemplateCall(resname, newargs, newpassign, TemplateBody([]))
    ; Define(defmod, defname, deffargs, deftargs, defbody){defanno*} := </*debug(!"Combining req call:");*/CurrentTemplateDecl/*;debug(!"decl:")*/> genname
    ; <fetch-elem(?QueryAnalysis(analysis, _, _, _))> defanno*
    ; argmapping := <zip> (newargs, deffargs)
    ; tmpana := <map(add-condition-to-traversal(|cond))/*;debug(!"oldana:")*/>analysis
    ; {| TempVar
       : <map(\Arg(x, srt) -> <id> with rules(TempVar : Var(x) -> srt)\)> callerargs
       ; newanalysis := <foldr(!tmpana, rename-vars-in-analysis(TempVar <+ RootVar))/*;debug(!"newana:")*/> argmapping
       |}

  add-condition-to-traversal(|cond) :
    (e, srt, oldcond, eff) -> (e, srt, newcond, eff)
    with newcond := <conc; make-set> (oldcond, cond)

  analyze-for-query-optimization =
    //(?ForAll(x, srt, f, b, _){anno*} <+ ?For(x, srt, e, f, b, _){anno*} <+ ?ForAllStmt(x, srt, f, b){anno*} <+ ?ForStmt(x, srt, e, f, b){anno*})
    where((?For(x, srt, e, f, b, _){anno*} <+ ?ForStmt(x, srt, e, f, b){anno*})
    //; <debug(!"forloop:")> Var(x)
    ; <fetch-elem(?QueryAnalysis(analysis, _, _, _))> anno*
    //; <debug(!"analysis:")>analysis
    ; newanalysis := </*debug(!"mapping:");*/foldr(!analysis, rename-vars-in-analysis(RootVar))> [(e, Arg(x, srt))]
    //; <debug(!"newanalysis:")>newanalysis
    ; <filter(combine-analysis)> newanalysis
      )
/*
  analyze-for-query-optimization :
    Call(e, nm, args1){anno*} -> Call(e, nm, args2){anno*}
    where <is-accessible-from(RootVar); ?(e2, <is-entity-type; ?SimpleSort(ent)>)> e
    ; (fent, Function(_, defargs, _, _){defanno*}) := <try-resolve-entity-call> (ent, nm, <map(type-of)> args1)
      with argmapping := <zip> (args1, defargs)
      ; <fetch-elem(?QueryAnalysis(thisanalysis))> defanno*
      //; entmapping := <get-all-entity-properties-as-mapping(|e2)> ent
      ; boundarguments := <filter(where(Snd; query-optimization-argument))> argmapping // These arguments can appear in the query condition
       ; try(
       [Var(xthis)] := <map(Fst); collect(?Var("this")); make-set>thisanalysis
      ; <combine-argument-query-optimization(|boundarguments)> (e2, Arg(xthis, SimpleSort(ent)){defanno*})
        )
      ; args2 := <map(
          combine-argument-query-optimization(|boundarguments) // We could follow this argument
          <+ analyze-effectful-argument // We could not follow this argument, so consider all traversals as effectful
         )> argmapping

  analyze-for-query-optimization :
    TemplateCall(name, args1, passign1, body){anno*} -> TemplateCall(name, args2, passign2, body){anno*}
    where genname := <is-defined-tc-get-called-tc>
    with Define(defmod, defname, deffargs, deftargs, defbody){defanno*} := <CurrentTemplateDecl> genname
        ; argmapping := <zip> (args1, deffargs)
        ; boundarguments := <filter(where(Snd; query-optimization-argument))> argmapping // These arguments can appear in the query condition
        ; passign2 := <analyze-for-query-optimization-effectful> passign1
        ; args2 := <map(
            combine-argument-query-optimization(|boundarguments) // We could follow this argument
            <+ analyze-effectful-argument // We could not follow this argument, so consider all traversals as effectful
           )> argmapping

  analyze-effectful-argument :
    (e, _) -> result
    with result := <analyze-for-query-optimization-effectful> e

  combine-argument-query-optimization(|boundarguments) :
    (e, arg@Arg(_, _){anno*}) -> e
    where <is-accessible-from(RootVar)> e // We can follow the expression from a variable that we are analyzing
    ; ?(_, <try-strip-generic-sort; is-entity-type>)
    ; <combine-query-analysis(|boundarguments)> (e, arg, <fetch-elem(?QueryAnalysis(_))> anno*)

  combine-query-analysis(|boundarguments) =
    ?(e, arg, QueryAnalysis(opt))
    ; opt2 := <foldr(!opt, alltd(bind-query-analysis-argument))> [(e, arg)|boundarguments]
    ; cond := <QueryConditions>
    ; forceEffectful := <IsEffectful>
    ; <map(register-combined-traversal(|cond,forceEffectful))> opt2

  bind-query-analysis-argument =
    ?((e, Arg(x, srt)), opt)
    ; <alltd(?Var(x); !e)> opt

  register-combined-traversal(|cond,forceEffectful) =
    ?(e, esrt, oldcond, oldEffectful)
    ; (traversal, srt) := <is-accessible-from(RootVar)> e
    ; newcond := <conc; make-set>(oldcond, cond)
    ; effectful := <?(True(), _) < !True() + Snd>(forceEffectful, oldEffectful)
    ; rules( DetectedTraveral :+= (traversal, srt, newcond, effectful) )
*/
strategies // Effectful

  analyze-for-query-optimization-continue = alltd(analyze-for-query-optimization)

  analyze-for-query-optimization =
    (
	       ?Call(_, _, _)
	    <+ ?VarDeclInit(_, _, _)
	    <+ ?VarDeclInitInferred(_, _)
	    <+ ?Assignment(_, _)
	    <+ ?PropertyAssignment(_, _)
	    <+ ?PageCall(_, _)
	    <+ ?ThisCall(_, _)
	    <+ (?TemplateCall(name, args, passign, body); where(not(is-defined-tc-get-called-tc))) // A template call we cannot follow
    )
    ; where(False() := <IsEffectful>)
    ; rules( IsEffectful := True() )
    ; analyze-for-query-optimization-continue
    ; rules( IsEffectful := False() )

  analyze-for-query-optimization-effectful =
    where(True() := <IsEffectful>)
    ; analyze-for-query-optimization-continue

  analyze-for-query-optimization-effectful =
    where(False() := <IsEffectful>)
    ; rules( IsEffectful := True() )
    ; analyze-for-query-optimization-continue
    ; rules( IsEffectful := False() )

strategies // Resolve

  // We return an empty list, which should later be removed by flatten-list
  query-optimization-waiting-for = where(query-optimization-skip); ![]

  query-optimization-waiting-for =
    ?ForStmt(x, srt, e, filter, body){anno*}
    ; where(
        <is-entity-type> srt // Important, because we do not analyze for loops of primitive types
        ; (expr, exprsrt) := <is-accessible-from(RootVar)> e
        ; not(<fetch-elem(is-query-analysis)> anno*)
      )

  query-optimization-waiting-for =
    ?For(x, srt, e, filter, body, sep){anno*}
    ; where(
        <is-entity-type> srt // Important, because we do not analyze for loops of primitive types
        ; (expr, exprsrt) := <is-accessible-from(RootVar)> e
        ; not(<fetch-elem(is-query-analysis)> anno*)
      )

  query-optimization-waiting-for =
    ?Call(e, nm, args)
    ; where(
		    <is-accessible-from(RootVar); ?(e2, <is-entity-type; ?SimpleSort(ent)>)> e
		    ; <not(not-allowed-ent-fun-name)> nm
		    ; not("Entity" := ent)
		    ; targs* := <map(type-of)> args
        ; (
           (fent, Function(_, defargs, _, _){anno*}) := <try-resolve-entity-call-without-override-check> (ent, nm, targs*) // We should wait if this fails, because the function may still be a predicate function
           <
           (
             <subentities-do-no-override> (fent, nm, targs*) // Only wait if subentities-do-no-override
             ; <not(fetch-elem(is-query-analysis))> anno*
           )
           + id
          )
		    /*; not(
		      (fent, Function(_, defargs, _, _){anno*}) := <try-resolve-entity-call-without-override-check> (ent, nm, targs*) // We should wait if this fails, because the function may still be a predicate function
          ; info(|"Match")
          ; <subentities-do-no-override> (fent, nm, targs*) // Only wait if subentities-do-no-override
          ; info(|"no-override")
		      ; <fetch-elem(is-query-analysis)> anno*
		      ; info(|"Anno")
		    )*/
        //; waitingonargs := <zip; filter(query-optimization-waiting-for-argument)>(args, defargs)
        //; (not([] := waitingonargs) <+ not(<fetch-elem(?QueryAnalysis(_))> anno*)) // not waiting for analysis of arguments or this keyword
      )

  query-optimization-waiting-for =
    ?TemplateCall(name, args, passign, body)
    //;debug(!"check:")
    ; where(
        //where(<debug(!"checking:")> ("templatecall",name))
        /*;*/ genname := <is-defined-tc-get-called-tc>
        //; _{anno*} := <CurrentTemplateDecl> genname
        //; not(<fetch-elem(?QueryAnalysis(_))> anno*)
        //; Define(defmod, defname, deffargs, deftargs, defbody){anno*} := <get-local-redefined-decl <+ CurrentTemplateDecl> genname
        //; <zip; filter(query-optimization-waiting-for-argument); not(?[])>(args, deffargs)
        //; (<fetch-elem(is-query-analysis)> anno* < (check-resolvable-calls-ready/*; debug(!"notready::")*/; not(?[])/*;debug(!"wait1:")*/) + id/*debug(!"wait2:")*/)
        ; not(
            Define(defmod, defname, deffargs, deftargs, defbody){anno*} := <get-local-redefined-decl <+ CurrentTemplateDecl> genname
            ; <fetch-elem(is-query-analysis)> anno*
            ; [] := <check-resolvable-calls-ready/*; debug(!"notready:")*/>
          )
      )

  //query-optimization-waiting-for =
    //(?ForAll(_, _, _, _, _){anno*} <+ ?For(_, _, _, _, _, _){anno*} <+ ?ForAllStmt(_, _, _, _){anno*} <+ ?ForStmt(_, _, _, _, _){anno*})
    //(?For(_, _, _, _, _, _){anno*} <+ ?ForStmt(_, _, _, _, _){anno*})
    //; where(not(<fetch-elem(?QueryAnalysis(_, _))> anno*))

/*  query-optimization-waiting-for-argument =
    ?(arg, Arg(_, _){anno*})
    ; <is-accessible-from(RootVar)> arg // We can follow the expression from a variable that we are analyzing
    ; ?(_, <try-strip-generic-sort; is-entity-type>) // The expression is of an entity type, which could result in more field accesses
    ; <not(fetch-elem(?QueryAnalysis(_)))> anno* // We should follow this argument, so we check if the target analysis is complete
*/
/*
  query-optimization-waiting-for =
    ?Call(e, nm, arg*){anno*}
    ; where(<is-accessible-from(IteratedVar); ?(e2, <is-entity-type; ?SimpleSort(ent)>)> e)
    ; genname := <generate-template-name-args> (<concat-strings>[ent, nm], arg*)
*/

rules // Query conditions

  // Extracts the query condition as a list where elements should be combined with the and operator
  extract-query-cond-as-list :
    And(expr1, expr2) -> cond 
    where lst1 := <extract-query-cond-as-list> expr1
    ; lst2 := <extract-query-cond-as-list> expr2
    ; cond := <conc> (lst1, lst2)

  extract-query-cond-as-list :
    expr -> cond
    where not(And(_, _) := expr)
    ; cond := <extract-query-cond; (?True() < ![] + ![<id>])> expr

strategies

  negate-query-cond-lst =
    map(negate-query-cond <+ !Not(<id>))
    ; flatten-list

  negate-query-cond :
    SmallerThanOrEqual(expr1, expr2) -> LargerThan(expr1, expr2)

  negate-query-cond :
    LargerThan(expr1, expr2) -> SmallerThanOrEqual(expr1, expr2)

  negate-query-cond :
    SmallerThan(expr1, expr2) -> LargerThanOrEqual(expr1, expr2)

  negate-query-cond :
    LargerThanOrEqual(expr1, expr2) -> SmallerThan(expr1, expr2)

  negate-query-cond :
    NotEq(expr1, expr2) -> Eq(expr1, expr2)

  negate-query-cond =
    ?Eq(expr1, expr2)
    ; (negate-simple-eq-cond <+ !NotEq(expr1, expr2)) // We first try to keep this an equals comparison

rules // Special cases

  analyze-for-query-optimization :
    IfTempl(cond1, true1, false1){anno*} -> IfTempl(cond2, true2, false2){anno*}
    where (cond2, true2, false2) := <analyze-for-query-optimization-if> (cond1, true1, false1)

  analyze-for-query-optimization :
    If(cond1, true1, false1){anno*} -> If(cond2, true2, false2){anno*}
    where (cond2, true2, false2) := <analyze-for-query-optimization-if> (cond1, true1, false1)

  analyze-for-query-optimization-if :
    (cond1, true1, false1) -> (cond2, true2, false2)
    where condlst := <extract-query-cond-as-list> cond1
    ; not([] := condlst)
    with cond2 := <analyze-for-query-optimization-continue> cond1
    ; oldcond := <QueryConditions> 
    ; rules( QueryConditions := <conc; make-set>(oldcond, condlst) )
    ; true2 := <analyze-for-query-optimization-continue> true1
    ; rules( QueryConditions := <conc; make-set>(oldcond, <negate-query-cond-lst>condlst) )
    ; false2 := <analyze-for-query-optimization-continue> false1
    ; rules( QueryConditions := oldcond )

rules // Query conditions

  //is-var-accessible = is-query-condition-constant <+ (is-accessible-from(QueryArg <+ RootVar); ?(<id>, _))
  is-var-accessible = is-query-condition-constant <+ (is-accessible-from(BindableVar <+ RootVar); ?(<id>, _))

  get-accessible-expr = get-accessible-dbfield

  get-accessible-expr = get-accessible-field

  get-accessible-expr = is-query-condition-constant

  //get-accessible-dbfield = (?Var(_) <+ ?FieldAccess(_, _)); is-accessible-from(QueryArg,id); ?(<id>, srt); where([] := <collect(?_{<fetch-elem(?MultipleDefinitionsInSubclasses())>})>)
  get-accessible-dbfield = (?Var(_) <+ ?FieldAccess(_, _)); is-accessible-from(RootVar,id); ?(<id>, srt); where([] := <collect(?_{<fetch-elem(?MultipleDefinitionsInSubclasses())>})>)

  get-accessible-field = (?Var(_) <+ ?FieldAccess(_, _)); is-accessible-from(BindableVar,id); ?(<id>, srt); where([] := <collect(?_{<fetch-elem(?MultipleDefinitionsInSubclasses())>})>)
  //get-accessible-field = (?Var(_) <+ ?FieldAccess(_, _)); ((is-accessible-from(ParentArgs,id); ?(<id>, srt)) <+ is-query-condition-constant) 

  is-query-condition-type = ?SimpleSort("Int") <+ ?SimpleSort("Long") <+ ?SimpleSort("Float") <+ ?SimpleSort("String") <+ ?SimpleSort("Bool") <+ ?SimpleSort("UUID")

  is-query-condition-constant = (?Int(_) <+ ?Long(_) <+ ?Float(_) <+ ?String(_) <+ ?True() <+ ?False() <+ ?Null()); try(normalize) 

  extract-query-cond:
    Not(expr1) -> Not(expr1new)
    where expr1new := <extract-query-cond> expr1
    ; not(True() := expr1new)
    ; not(Eq(_, _) := expr1new)

  extract-query-cond:
    Not(expr1) -> NotEq(expr1new, expr2new)
    where eq@Eq(expr1new, expr2new) := <extract-query-cond> expr1
    ; not(<negate-simple-eq-cond> eq)

  extract-query-cond:
    Not(expr1) -> Eq(expr1new, expr2new)
    where Eq(expr1new, expr2new) := <extract-query-cond; negate-simple-eq-cond> expr1

  negate-simple-eq-cond: Eq(True(), expr) -> Eq(expr, False())
  negate-simple-eq-cond: Eq(expr, True()) -> Eq(expr, False())
  negate-simple-eq-cond: Eq(False(), expr) -> Eq(expr, True())
  negate-simple-eq-cond: Eq(expr, False()) -> Eq(expr, True())

  extract-query-cond:
    Or(expr1, expr2) -> Or(expr1new, expr2new)
    where expr1new := <extract-query-cond> expr1
    ; expr2new := <extract-query-cond> expr2
    ; not(True() := expr1new)
    ; not(True() := expr2new)

  extract-query-cond:
    And(expr1, expr2) -> cond
    where expr1new := <extract-query-cond <+ !True()> expr1
    ; expr2new := <extract-query-cond <+ !True()> expr2
    ; cond := <append-condition>(expr1new, expr2new)

  extract-query-cond:    
    SmallerThanOrEqual(expr1, expr2) -> SmallerThanOrEqual(newExpr1, newExpr2)
    where newExpr1 := <get-accessible-expr> expr1
    ; newExpr2 := <get-accessible-expr> expr2
    ; <is-one-dbprop> (expr1, expr2)

  extract-query-cond:
    SmallerThan(expr1, expr2) -> SmallerThan(newExpr1, newExpr2)
    where newExpr1 := <get-accessible-expr> expr1
    ; newExpr2 := <get-accessible-expr> expr2
    ; <is-one-dbprop> (expr1, expr2)

  extract-query-cond:
    LargerThanOrEqual(expr1, expr2) -> LargerThanOrEqual(newExpr1, newExpr2)
    where newExpr1 := <get-accessible-expr> expr1
    ; newExpr2 := <get-accessible-expr> expr2
    ; <is-one-dbprop> (expr1, expr2)

  extract-query-cond:
    LargerThan(expr1, expr2) -> LargerThan(newExpr1, newExpr2)
    where newExpr1 := <get-accessible-expr> expr1
    ; newExpr2 := <get-accessible-expr> expr2
    ; <is-one-dbprop> (expr1, expr2)

  extract-query-cond:
    NotEq(expr1, expr2) -> NotEq(newExpr1, newExpr2)
    where newExpr1 := <get-accessible-expr> expr1
    ; newExpr2 := <get-accessible-expr> expr2
    ; <is-one-dbprop> (expr1, expr2)

  extract-query-cond:
    Eq(expr1, expr2) -> Eq(newExpr1, newExpr2)
    where newExpr1 := <get-accessible-expr> expr1
    ; newExpr2 := <get-accessible-expr> expr2
    ; <is-one-dbprop> (expr1, expr2)

  extract-query-cond:
    fa1@FieldAccess(_, _) -> Eq(fa2, True())
    where (fa2, SimpleSort("Bool")) := <is-accessible-from(RootVar,id)> fa1

  extract-query-cond:
    v1@Var(_) -> Eq(v2, True())
    where (v2, SimpleSort("Bool")) := <is-accessible-from(RootVar,id)> v1

  extract-query-cond :
    c@Call(e, nm, args1){anno*} -> cond
    where <is-accessible-from(RootVar); ?(e2, <is-entity-type; ?SimpleSort(ent)>)> e
    ; <not(not-allowed-ent-fun-name)> nm
    ; not("Entity" := ent)
    ; (fent, Function(_, defargs, retsrt, _){defanno*}) := <try-resolve-entity-call> (ent, nm, <map(type-of)> args1)
    ; retsrt := SimpleSort("Bool")
    with <fetch-elem(?QueryAnalysis(_, returns, _, _))> defanno*
      ; argmapping := <zip> (args1, defargs)
      ; if [Var(xthis)] := <collect(?Var("this")); make-set> returns then
          varmapping := [ (e, Arg(xthis, SimpleSort(ent))) | argmapping]
        else
          varmapping := argmapping
        end
    ; newreturns := <foldr(!returns, rename-vars-in-analysis(RootVar))> varmapping
    ; cond := <or-query-condition; extract-query-cond> newreturns
    where not(True() := cond)

  /*extract-query-cond=
    ?Call(e1, nm, arg*){anno*}
    ; where(<is-accessible-from(IteratedVar <+ IteratedSubList); ?(e2, <is-entity-type; ?SimpleSort(ent)>)> e1)
    ; genname := <generate-template-name-args> (<concat-strings>[ent, nm], arg*)
    ; where(not(<PassedFunction> genname)) // This prevents an infinite loop when following a recursive function
    ; (fent, Function(_, fargs, SimpleSort("Bool"), Block([Return(expr)]))) := <try-resolve-entity-call> (ent, nm, <map(query-optimization-type-of)> arg*)
    // Here we get the properties of the entity and insert them as extra parameters for the function call
    // We also have to rename the Var("prop") to Var("prop"{Entity_myfunctionArg1Arg2}) to prevent creating a loop in IteratedVar or IteratedSubList
    ; thissafe := "this"{<concat-strings>[genname, "_this"]}
    ; {| RenamePropInFunction // Here we temporarily rename the Var()s in the function body for our analysis
        : argsbinding := <get-all-entity-properties-for-rename(|genname); map({name,uniquename,safename,srt:\
                                (name, uniquename, safename, srt) -> (FieldAccess(e2, name), Arg(safename, srt))
                                where rules( RenamePropInFunction : Var(uniquename) -> Var(safename) )
                            \}); <concat>[[(e2, Arg(thissafe, SimpleSort(fent)))],<id>,<zip>(arg*, fargs)]> ent
        ; rules( RenamePropInFunction : Var("this") -> Var(thissafe) )
        ; expr2 := <alltd(RenamePropInFunction)> expr
      |}
    ; {| PassedFunction, IteratedVar, IteratedVarValue, IteratedSubList, IteratedSubListValue
       : rules( PassedFunction : genname )
         // Here we mark the arguments as interesting, because they are in some way related to the persistent root or are constants which we can use in query conditions
         // Removed the warnings, because a loop could occur when following a local redefine, because then some variables inside the redefine can belong to the caller and thus have the same name. This warning can be safely ignored.
       ; <filter({vars:
                     \ (e, Arg(x, srt)) ->  <id>
                       where [] := <collect(IteratedSubList)> e; <is-var-accessible> e; not(<is-generic-sort> srt)
*///                       where not(<IteratedVarValue/*; warn(|["Ignoring variable ", x, ", because it would create a loop in IteratedVarValue"])*/> Var(x))
/*                       with rules( IteratedVarValue : Var(x) -> e     // Helps when expressing a Var into the Var or constant passed by the caller 
                                   IteratedVar      : Var(x) -> srt
                                 )
                     \})> argsbinding
       ; <filter({vars: 
                     \ (e, Arg(x, srt)) ->  <id>
                       where not([] := <collect(IteratedSubList)> e) <+ (<is-generic-sort> srt; <is-var-accessible> e)
*///                       where not(<IteratedSubListValue/*; warn(|["Ignoring variable ", x, ", because it would create a loop in IteratedSubListValue"])*/> Var(x))
/*                       with rules( IteratedSubListValue  : Var(x) -> e
                                   IteratedSubList       : Var(x) -> srt
                                 )
                     \})> argsbinding
       ; <extract-query-cond> expr2
       ; repeat(oncetd(IteratedSubListValue <+ IteratedVarValue))
     |}*/

  extract-query-cond = !True()
