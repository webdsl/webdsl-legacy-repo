module separation/dependencies

imports
  check read
  separation/-

strategies  
  
  typecheck-dependencies-file = !$[[<ProjectDir>]/.cache/dependencies.nwl]
  
  // TODO: when are module keys deleted from the dep file ?
  
  update-typecheck-dependencies =
    typecheck-dependencies-file;
    update-dependency-graph(
      RulesUsedBy | <all-keys-RulesUsedBy>
    )
      
  update-dependency-graph(used-data | used-keys): filename -> deps
    with
    {| PreviouslyUsedRules:
      old-data := <file-exists; ReadFromFile <+ ![]> filename
    ; filter({
        ?(fullpath, usedrules);
        rules(PreviouslyUsedRules : fullpath -> usedrules)
      })
    ; if dependencies-unchanged(used-data | used-keys) then
          <debug> "No dependencies changed."
          // TODO: touch dep file (no stratego strategy for touching files?)
      else
          // store changed data
		      x1* := <map(\fullpath -> (fullpath, <used-data> fullpath)\)> used-keys;
		      // store unchanged data
          x2* := <all-keys-PreviouslyUsedRules; filter(\fullpath -> (fullpath, <PreviouslyUsedRules>) where not(<used-data> fullpath)\)>;
          x* := [x1*,x2*];
		      <WriteToBinaryFile> (filename, x*)
		  end
		; deps := <find-dependent-modules(used-data)>
  |}
		  
  dependencies-unchanged(used-data|used-keys) = <map(<eq> (<PreviouslyUsedRules>, <used-data>))> used-keys
  
  /*
  read-old-dependencies(used-data): (fullpath, usedrules) -> (fullpath, usedrules)
    where not(<used-data> fullpath)   // not updated in this analyze run
        ; rules(UnchangedData : fullpath -> usedrules)
  */
  
	find-dependent-modules(used-rules) =
      FullPath => current
    ; changed := <create-change-set> (<RulesCreated>, <RulesCreatedPrev>)
    ; bagof-ModulesIncluded
    ; map(ModuleFullpath)
    ; filter(not(?current); has-rule-use(used-rules | changed))
  
  // If we have no caching information, check the file
  has-rule-use(rules-used | ruleset): mod -> mod
    where not(rules-used <+ PreviouslyUsedRules)
    
  has-rule-use(rules-used | ruleset): mod -> mod
    with  uses := <rules-used <+ PreviouslyUsedRules> mod
          // find common rule usage
        ; common1* := <isect> (ruleset, uses)
          // find all-keys- usage
        ; common2* := <isect> (<map(Fst);uniq> ruleset, <filter(?(_,DR_DUMMY()); Fst);uniq> uses)
        ; common* := [common1*,common2*]
    where not([] := common*)
        ; !mod; debug(!".. have to re-analyze mod: ")
        ; !common*; debug(!".. common rules: ")
  
  remove-dr-dummies = map(remove-dr-dummy)
  
  create-change-set: (new, old) -> all-changes
    with   {| NewRule, OldRule: 
              <rules-as-key-val-pairs(\(key,val) -> <rules(NewRule :+ key -> val)>\)> new
            ; <rules-as-key-val-pairs(\(key,val) -> <rules(OldRule :+ key -> val)>\)> old
              // changed rules
            ; all-keys-NewRule; remove-dr-dummies
            ; filter(where(<not(eq)> (<bagof-NewRule>, <bagof-OldRule>)))
            ; ?changed
            //; try(?[]; debug(!"Rules changed: "))
              // new rules
            ; all-keys-NewRule; remove-dr-dummies
            ; filter(where(not(OldRule)))
            ; ?added
            //; try(not(?[]); debug(!"Rules added: "))
              // removed rules
            ; all-keys-OldRule; remove-dr-dummies
            ; filter(where(not(NewRule)))
            ; ?removed
            //; try(not(?[]); debug(!"Rules removed: "))
           |}
        ; all-changes := <concat;uniq> [changed, added, removed]
        //; debug(!"All changes: ")
