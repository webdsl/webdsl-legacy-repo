module separation/typecheck

imports 
  separation/-

rules
  
  dependency-file = <path-to-cache-path> "$deps-typecheck.aterm"
  
  find-dependent-modules =
      all-definitions => defs
    ; filter(is-module-loaded)
    ; length => 0
    ; <verbose-msg> ["Clean compile detected: skipping change detection"]
    ; !defs
      
  find-dependent-modules =
    // filter(get-module-signature), some files may have no cached version
    prev-created := <all-modules; filter(is-module-loaded); filter(get-module-signature <+ debug(!"No cache for: "); fail); concat>;
    // load PreviouslyUsedRules
    dependency-file; load-dependency-data;
    if 0 := <all-modules; filter(is-module-loaded); length> then
      <verbose-msg> ["No modified files: skipping change detection"];
      all-definitions;
      filter(not(PreviouslyUsedRules))  // re-check files for which we have no dependency info
    else
	    // created rules
	    all-definitions;
	    filter(is-definition-loaded);
	    //debug(!"Loaded defs: ");
	    //where(all-keys-CreatedRules; debug(!"Keys: "));
	    mapconcat(bagof-CreatedRules;concat);
	    //debug(!"Newly created: ");
	    ?new-created;
	    // find dependent
	    find-dependent-modules(
	      |new-created, prev-created, <all-definitions; remove-all(is-definition-loaded)>
	    )
	  end;
    try(not(?[]); debug(!"Dependent definitions: "))      
  
  update-typecheck-dependencies =
    {| RulesUsedBy:
      log-time(store-used-rules | "store used rules");
	    dependency-file;
	    log-time(update-dependency-graph(
	      RulesUsedBy | <all-keys-RulesUsedBy>
	    ) | "update-dependency-graph")
	  |}
  
  store-used-rules =
    all-definitions; filter(is-definition-loaded) => defs;
    {| UsedRulesTable:
	    // Create tables
	    log-time(
	      !defs;
   	    map({table: \key -> <new-hashtable; ?table; rules(UsedRulesTable : key -> table)> \})
		      | "store-used>create-tables");
	    // Store rules
	    log-time(
	      all-used-rules;
	      map(\(mod, rulekey) -> <UsedRulesTable; hashtable-put(|rulekey,1)> mod\)
	        | "store-used>fill-tables");
	    // Read out
	    log-time(
	      !defs;
	      map({ruleset: \key -> <UsedRulesTable; hashtable-keys; ?ruleset; rules(RulesUsedBy : key -> ruleset)> key \})
	        | "store-used>store-rules")
		|}
    
    /* This is very slow, but memory efficient
    all-keys-TopLevelDefinitions;
    filter( {key, ruleset:
        ?key;
        all-used-rules;
        filter(?(key, <id>));
        ?ruleset;
        rules(RulesUsedBy : key -> ruleset)
      }
    )
    */
    // cleanup
    ; dr-end-scope(|"CreatedRules")
    ; dr-begin-scope(|"CreatedRules")
    ; dr-end-scope(|"DesugarRulesUsed")
    ; dr-begin-scope(|"DesugarRulesUsed")
    
  is-used-dr = id     // TODO: fix
  