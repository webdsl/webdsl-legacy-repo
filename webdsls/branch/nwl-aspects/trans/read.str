module read

imports libstratego-aterm libstratego-gpp
imports include/nwl
imports type-analysis rename pretty-print primitives
imports nwl check emit
imports lib/dr
imports lib/editor-common.generated

rules 

  get-toplevel-defs = transform-defs(id)
  
  debug-toplevel-defs = where(get-toplevel-defs; pp-aterm; debug)
          
  transform-defs(s) =
    map-defs(
      {s; ?newdef; where(CurrentDefinitionKey => key; rules(Definition : key -> newdef)) }
    ) 
     
  map-defs(s) =
    all-keys-Definition;
    filter(where(Definition)); // skip deleted
    map(//{| CurrentDefinitionKey: 
      {def:
        \key -> <rules(CurrentDefinitionKey := key); Definition; s> key \}
      /*|}*/)
  
  remove-defs(s) =
    all-keys-Definition;
    filter(where(Definition));
    filter(\key -> <rules(CurrentDefinitionKey := key); Definition; s; rules(Definition :- key)> key\)
  
  collect-in-defs(s) = {| Collected:
    transform-defs(
      { res:
        where(
          try(
            s => res;
            rules(Collected :+= res)
          )
        )
      }
    );
    bagof-Collected;
    concat
  |}

rules
  
  module-to-toplevel-defs: mod@Module(name, body) -> defs
    with  FullPath => fullpath;
          name' := <strip-annos> name;
          rules(
            ModuleName := name'
            ModuleFullpath : name' -> fullpath
            Imported : name'
          );
          <load-imports; store-module> mod;
          get-toplevel-defs => defs
          
  store-module: mod@Module(name, body) -> mod
    with  body2 := <body-to-toplevel-defs> body;
          name' := <strip-annos> name;
          rules(ModuleToDefs : name' -> body2);
          <map(where({def:
              ?def;
              store-def(|name')
          }))> body2

  body-to-toplevel-defs =
    lift-access-control-defs
    
  lift-access-control-defs : 
    defs -> new-defs
    with  defs1* := <remove-all(?AccessControlDefinition(_))> defs;
          defs2* := <filter(?AccessControlDefinition(<id>)); concat> defs;
          new-defs := [defs1*, defs2*]

  store-def(|modname): def -> key
    with  key := <def-to-key> (modname, def);
          rules(
            Definition : key -> def
            DefinitionLoaded : key
            DefToModule : key -> modname
            // Note: ModuleToDef is undefined for empty modules!
            ModuleToDef :+ modname -> key 
          )
  
 // def-to-key: (modname, constructor#(_)) -> x
 //   with x := (modname, <concat-strings> (<origin-line;int-to-string> z)
  
  key-to-string: (modname, key) -> $[[modname]_[key]]
  
  def-to-key: (modname, cons#(_)) -> (modname, cons)
    where <is-emit-mod> modname
 
  defkey-to-mod: (modname, _) -> modname
    
  load-imports: mod@Module(name, body) -> Module(name, body2)
    with  imports := <filter(?Import(_); strip-annos)> body;
          <map(parse-import)> imports;
          name' := <strip-annos> name;
          rules(ModuleImports : name' -> imports);
          body2 := <remove-all(?Import(_))> body

  parse-import: Import(modname) -> []
    where <Imported> modname
          
  parse-import: Import(modname) -> []
    with  rules(Imported : modname);
          filename := <modname-to-filename> modname;
          <parse-file-with-cache> filename;
          rules(
            ModulesIncluded :+= modname
            ModuleFullpath : modname -> filename
          );
          if not(?"cached") then
            load-imports;
            store-module
          end
  
  modname-to-filename: modname -> filename
    with  (
              !$[[<ProjectDir>]/[modname].nwl]; file-exists
            <+ !$[[<AlternativeProjectDir>]/[modname].nwl]
          );
          trim-initial-dotslash => filename
  
  trim-initial-dotslash =
    try(<split-after> (<id>, "./"); Snd)
  
  parse-file-with-cache: filename -> content
    with  cache := <path-to-cache-path> filename;  
      if <file-exists> cache; <is-newer> (cache, filename); (imports, defrules) := <ReadFromFile> cache then
        // Read rule signature
        <debug(!"using cache for: ")> filename;
        <load-dynamic-rule-closure> defrules;
        <map(parse-import)> imports;
        rules(CachedFiles :+= filename);
        content := "cached"
      else
        <debug(!"Parsing: ")> filename; 
        content := <my-parse-file> filename;
        ?Module(modname, _)
      end
      
  read-signature: fullpath -> sig
    with  cachepath := <path-to-cache-path> fullpath
    where (imports, sig) := <file-exists; ReadFromFile> cachepath
     
  load-cached-files =
    bagof-CachedFiles;
    debug(!"Loading: ");
    map(load-cached-file)
    
  load-cached-file =
    ?filename;
    parse-file;
    \Module(name,defs) -> Module(name, <remove-all(?Import(_))> defs)\;
    store-module;
    rules(CachedFiles :- filename)
  
  load-cached-def: defkey -> defkey
    with  defkey-to-mod => modname;
          modname-to-filename => filename;
          content := <ParsedFile <+ debug(!"Parsing: "); my-parse-file> filename;
          rules(ParsedFile : filename -> content);
          ?Module(_,<id>);
          body-to-toplevel-defs;
          filter(where(<def-to-key> (modname,<id>); ?defkey));
          try(not(1 := <length>); !(defkey,<id>); debug(!"Multiple defs match key: "));
          ?[thedef];
          <store-def(|modname)> thedef    
    
    