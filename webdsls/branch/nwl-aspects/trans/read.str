module read

imports libstratego-aterm libstratego-gpp
imports include/nwl
imports type-analysis rename pretty-print primitives
imports lib/editor-common.generated
imports nwl check
imports separation/dr

rules 

  get-toplevel-defs = transform-defs(id)
  
  debug-toplevel-defs = where(get-toplevel-defs; pp-aterm; debug)
          
  transform-defs(s) = 
    all-keys-Definition;
    filter(where(Definition)); // skip deleted
    map(//{| CurrentDefinitionKey: 
      {def:
        \key -> <rules(CurrentDefinitionKey := key); Definition; s; ?def; rules(Definition : key -> def)> key \}
      /*|}*/)
  
  remove-defs(s) =
    all-keys-Definition;
    filter(where(Definition));
    filter(\key -> <rules(CurrentDefinitionKey := key); Definition; s; rules(Definition :- key)> key\)
  
  collect-in-defs(s) = {| Collected:
    transform-defs(
      { res:
        where(
          try(
            s => res;
            rules(Collected :+= res)
          )
        )
      }
    );
    bagof-Collected;
    concat
  |}

rules
  
  module-to-toplevel-defs: mod@Module(name, body) -> defs
    with  FullPath => fullpath;
          rules(
            ModuleName := name
            ModuleFullpath : name -> fullpath
            Imported : name
          );
          <load-imports; store-module> mod;
          get-toplevel-defs => defs
          
  store-module: mod@Module(name, body) -> mod
    with  rules(ModuleToDefs : name -> body);
          <map(where({key,def:
              ?def;
              store-def => key;
              rules(
                DefToModule : key -> name
                ModuleToDef :+ name -> key
              )
          }))> body

  store-def: def -> key
    with  key := <def-to-key> def;
          rules(Definition : key -> def)
  
  def-to-key: constructor#(_) -> x
    with x := <newname> constructor
    
  load-imports: mod@Module(name, body) -> Module(name, body2)
    with  imports := <filter(?Import(_))> body;
          <map(parse-import)> imports;
          rules(ModuleImports : name -> imports);
          body2 := <remove-all(?Import(_))> body

  parse-import: Import(modname) -> []
    where <Imported> modname
          
  parse-import: Import(modname) -> []
    with  rules(Imported : modname);
          (
              !$[[<ProjectDir>]/[modname].nwl]; file-exists
            <+ !$[[<AlternativeProjectDir>]/[modname].nwl]
          ) => filename;
          <parse-file-with-cache> filename;
          if not(?"cached") then
            load-imports;
            store-module
          end
  
  parse-file-with-cache: filename -> content
    with  cache := <import-cache-path> filename;  
      if <file-exists> cache; <is-newer> (cache, filename); (imports, defrules) := <ReadFromFile> cache then
        // Read rule signature
        <debug(!"using cache for: ")> filename;
        <load-dynamic-rule-closure> defrules;
        <map(parse-import)> imports;
        rules(CachedFiles :+= filename);
        content := "cached"
      else
        <debug(!"Parsing: ")> filename; 
        content := <parse-file> filename;
        ?Module(modname, _);
        rules(ModuleFullpath : modname -> filename)
      end
      
  read-signature: fullpath -> sig
    with  cachepath := <import-cache-path> fullpath
    where (imports, sig) := <file-exists; ReadFromFile> cachepath
     
  load-cached-files =
    bagof-CachedFiles;
    debug(!"Loading: ");
    map(
      parse-file;
      \Module(name,defs) -> Module(name, <remove-all(?Import(_))> defs)\;
      store-module
    );
    rules(CachedFiles :- _)
    