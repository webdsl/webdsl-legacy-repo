module read

imports libstratego-aterm libstratego-gpp
imports include/nwl
imports type-analysis rename pretty-print primitives
imports lib/editor-common.generated
imports nwl check emit
imports separation/dr

rules 

  get-toplevel-defs = transform-defs(id)
  
  debug-toplevel-defs = where(get-toplevel-defs; pp-aterm; debug)
          
  transform-defs(s) = 
    all-keys-Definition;
    filter(where(Definition)); // skip deleted
    map(//{| CurrentDefinitionKey: 
      {def:
        \key -> <rules(CurrentDefinitionKey := key); Definition; s; ?def; rules(Definition : key -> def)> key \}
      /*|}*/)
  
  remove-defs(s) =
    all-keys-Definition;
    filter(where(Definition));
    filter(\key -> <rules(CurrentDefinitionKey := key); Definition; s; rules(Definition :- key)> key\)
  
  collect-in-defs(s) = {| Collected:
    transform-defs(
      { res:
        where(
          try(
            s => res;
            rules(Collected :+= res)
          )
        )
      }
    );
    bagof-Collected;
    concat
  |}

rules
  
  module-to-toplevel-defs: mod@Module(name, body) -> defs
    with  FullPath => fullpath;
          rules(
            ModuleName := name
            ModuleFullpath : name -> fullpath
            Imported : name
          );
          <load-imports; store-module> mod;
          get-toplevel-defs => defs
          
  store-module: mod@Module(name, body) -> mod
    with  rules(ModuleToDefs : name -> body);
          <map(where({def:
              ?def;
              store-def(|name)
          }))> body

  store-def(|modname): def -> key
    with  key := <def-to-key> (modname, def);
          rules(
            Definition : key -> def
            DefinitionLoaded : key
            DefToModule : key -> modname
            ModuleToDef :+ modname -> key 
          )
  
 // def-to-key: (modname, constructor#(_)) -> x
 //   with x := (modname, <concat-strings> (<origin-line;int-to-string> z)
  
  key-to-string: (modname, key) -> $[[modname]_[key]]
  
  def-to-key: (modname, cons#(_)) -> (modname, cons)
    where <is-emit-mod> modname
 
  def-to-key: (modname, x) -> key
    with  <?constructor#(_)> x; 
          posy := <(origin-line);int-to-string> x;
          posx := <(origin-column);int-to-string> x;
          key := (modname, <concat-strings> [constructor, "_", posx, "_", posy])
     
  defkey-to-mod: (modname, _) -> modname
    
  load-imports: mod@Module(name, body) -> Module(name, body2)
    with  imports := <filter(?Import(_))> body;
          <map(parse-import)> imports;
          rules(ModuleImports : name -> imports);
          body2 := <remove-all(?Import(_))> body

  parse-import: Import(modname) -> []
    where <Imported> modname
          
  parse-import: Import(modname) -> []
    with  rules(Imported : modname);
          filename := <modname-to-filename> modname;
          <parse-file-with-cache> filename;
          rules(
            ModulesIncluded :+= modname
            ModuleFullpath : modname -> filename
          );
          if not(?"cached") then
            load-imports;
            store-module
          end
  
  modname-to-filename: modname -> filename
    with  (
              !$[[<ProjectDir>]/[modname].nwl]; file-exists
            <+ !$[[<AlternativeProjectDir>]/[modname].nwl]
          ) => filename  
  
  parse-file-with-cache: filename -> content
    with  cache := <import-cache-path> filename;  
      if <file-exists> cache; <is-newer> (cache, filename); (imports, defrules) := <ReadFromFile> cache then
        // Read rule signature
        <debug(!"using cache for: ")> filename;
        <load-dynamic-rule-closure> defrules;
        <map(parse-import)> imports;
        rules(CachedFiles :+= filename);
        content := "cached"
      else
        <debug(!"Parsing: ")> filename; 
        content := <parse-file> filename;
        ?Module(modname, _)
      end
      
  read-signature: fullpath -> sig
    with  cachepath := <import-cache-path> fullpath
    where (imports, sig) := <file-exists; ReadFromFile> cachepath
     
  load-cached-files =
    bagof-CachedFiles;
    debug(!"Loading: ");
    map(load-cached-file)
    
  load-cached-file =
    ?filename;
    parse-file;
    \Module(name,defs) -> Module(name, <remove-all(?Import(_))> defs)\;
    store-module;
    rules(CachedFiles :- filename)
  
  load-cached-def: defkey -> defkey
    with  defkey-to-mod => modname;
          modname-to-filename => filename;
          content := <ParsedFile <+ debug(!"Parsing: "); parse-file> filename;
          rules(ParsedFile : filename -> content);
          ?Module(_,<id>);
          filter(where(<def-to-key> (modname,<id>); ?defkey));
          try(not(1 := <length>); !(defkey,<id>); debug(!"Multiple defs match key: "));
          ?[thedef];
          <store-def(|modname)> thedef    
    
    