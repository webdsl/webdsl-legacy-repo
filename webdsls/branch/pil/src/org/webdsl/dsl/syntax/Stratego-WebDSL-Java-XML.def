definition
module languages/java/eblock/Main
imports
  languages/java-15/Main
   
exports
  context-free syntax
    "{|" BlockStm* "|" Expr "|}" -> Expr {cons("PreEBlock")}
    "{|" Expr "|" BlockStm* "|}" -> Expr {cons("PostEBlock")}
    "{|" BlockStm* "|}"          -> BlockStm {cons("InnerBlock")}

    "{|" BlockStm* "|" Expr "|" BlockStm* "|}" -> Expr {cons("PrePostEBlock")}

module languages/java/eblock/JavaEBlockMix[Ctx0]
imports languages/java/eblock/Main
          [ CompilationUnit       => CompilationUnit[[Ctx0]]
            TypeDec               => TypeDec[[Ctx0]]
            ImportDec             => ImportDec[[Ctx0]]
            PackageDec            => PackageDec[[Ctx0]]
            ElemVal               => ElemVal[[Ctx0]]
            ElemValPair           => ElemValPair[[Ctx0]]
            Anno                  => Anno[[Ctx0]]
            LHS                   => LHS[[Ctx0]]
            CondMid               => CondMid[[Ctx0]]
            ArraySubscript        => ArraySubscript[[Ctx0]]
            DimExpr               => DimExpr[[Ctx0]]
            ArrayBaseType         => ArrayBaseType[[Ctx0]]
            ArrayCreationExpr     => ArrayCreationExpr[[Ctx0]]
            ClassMemberDec        => ClassMemberDec[[Ctx0]]
            ClassBodyDec          => ClassBodyDec[[Ctx0]]
            Interfaces            => Interfaces[[Ctx0]]
            Super                 => Super[[Ctx0]]
            ClassMod              => ClassMod[[Ctx0]]
            ClassDecHead          => ClassDecHead[[Ctx0]]
            ClassBody             => ClassBody[[Ctx0]]
            ClassDec              => ClassDec[[Ctx0]]
            InterfaceMod          => InterfaceMod[[Ctx0]]
            InterfaceMemberDec    => InterfaceMemberDec[[Ctx0]]
            ExtendsInterfaces     => ExtendsInterfaces[[Ctx0]]
            InterfaceDecHead      => InterfaceDecHead[[Ctx0]]
            InterfaceDec          => InterfaceDec[[Ctx0]]
            DefaultVal            => DefaultVal[[Ctx0]]
            AnnoElemDec           => AnnoElemDec[[Ctx0]]
            AnnoDecHead           => AnnoDecHead[[Ctx0]]
            AnnoDec               => AnnoDec[[Ctx0]]
            AbstractMethodMod     => AbstractMethodMod[[Ctx0]]
            AbstractMethodDec     => AbstractMethodDec[[Ctx0]]
            ConstantMod           => ConstantMod[[Ctx0]]
            ConstantDec           => ConstantDec[[Ctx0]]
            EnumBodyDecs          => EnumBodyDecs[[Ctx0]]
            EnumConstArgs         => EnumConstArgs[[Ctx0]]
            EnumConst             => EnumConst[[Ctx0]]
            EnumBody              => EnumBody[[Ctx0]]
            EnumDecHead           => EnumDecHead[[Ctx0]]
            EnumDec               => EnumDec[[Ctx0]]
            ConstrMod             => ConstrMod[[Ctx0]]
            ConstrInv             => ConstrInv[[Ctx0]]
            ConstrBody            => ConstrBody[[Ctx0]]
            ConstrHead            => ConstrHead[[Ctx0]]
            ConstrDec             => ConstrDec[[Ctx0]]
            StaticInit            => StaticInit[[Ctx0]]
            InstanceInit          => InstanceInit[[Ctx0]]
            MethodBody            => MethodBody[[Ctx0]]
            ExceptionType         => ExceptionType[[Ctx0]]
            Throws                => Throws[[Ctx0]]
            MethodMod             => MethodMod[[Ctx0]]
            VarMod                => VarMod[[Ctx0]]
            FormalParam           => FormalParam[[Ctx0]]
            ResultType            => ResultType[[Ctx0]]
            MethodDecHead         => MethodDecHead[[Ctx0]]
            MethodDec             => MethodDec[[Ctx0]]
            BlockStm              => BlockStm[[Ctx0]]
            Block                 => Block[[Ctx0]]
            CatchClause           => CatchClause[[Ctx0]]
            SwitchLabel           => SwitchLabel[[Ctx0]]
            SwitchGroup           => SwitchGroup[[Ctx0]]
            SwitchBlock           => SwitchBlock[[Ctx0]]
            Stm                   => Stm[[Ctx0]]
            LocalVarDec           => LocalVarDec[[Ctx0]]
            LocalVarDecStm        => LocalVarDecStm[[Ctx0]]
            FieldMod              => FieldMod[[Ctx0]]
            VarInit               => VarInit[[Ctx0]]
            Dim                   => Dim[[Ctx0]]
            VarDecId              => VarDecId[[Ctx0]]
            VarDec                => VarDec[[Ctx0]]
            FieldDec              => FieldDec[[Ctx0]]
            ArrayInit             => ArrayInit[[Ctx0]]
            ClassLiteral          => ClassLiteral[[Ctx0]]
            Literal               => Literal[[Ctx0]]
            Type                  => Type[[Ctx0]]
            ArrayType             => ArrayType[[Ctx0]]
            TypeVar               => TypeVar[[Ctx0]]
            TypeDecSpec           => TypeDecSpec[[Ctx0]]
            InterfaceType         => InterfaceType[[Ctx0]]
            ClassType             => ClassType[[Ctx0]]
            ClassOrInterfaceType  => ClassOrInterfaceType[[Ctx0]]
            RefType               => RefType[[Ctx0]]
            TypeVarId             => TypeVarId[[Ctx0]]
            TypeParams            => TypeParams[[Ctx0]]
            TypeBound             => TypeBound[[Ctx0]]
            TypeParam             => TypeParam[[Ctx0]]
            WildcardBound         => WildcardBound[[Ctx0]]
            ActualTypeArg         => ActualTypeArg[[Ctx0]]
            TypeArgs              => TypeArgs[[Ctx0]]
            PackageOrTypeName     => PackageOrTypeName[[Ctx0]]
            MethodName            => MethodName[[Ctx0]]
            ExprName              => ExprName[[Ctx0]]
            TypeName              => TypeName[[Ctx0]]
            AmbName               => AmbName[[Ctx0]]
            PackageName           => PackageName[[Ctx0]]
            FloatType             => FloatType[[Ctx0]]
            IntType               => IntType[[Ctx0]]
            NumType               => NumType[[Ctx0]]
            PrimType              => PrimType[[Ctx0]]
            NullLiteral           => NullLiteral[[Ctx0]]
            FooStringChars        => FooStringChars[[Ctx0]]
            StringChars           => StringChars[[Ctx0]]
            StringPart            => StringPart[[Ctx0]]
            StringLiteral         => StringLiteral[[Ctx0]]
            SingleChar            => SingleChar[[Ctx0]]
            CharContent           => CharContent[[Ctx0]]
            CharLiteral           => CharLiteral[[Ctx0]]
            LastOcta              => LastOcta[[Ctx0]]
            OctaEscape            => OctaEscape[[Ctx0]]
            NamedEscape           => NamedEscape[[Ctx0]]
            EscapeSeq             => EscapeSeq[[Ctx0]]
            Bool                  => Bool[[Ctx0]]
            BoolLiteral           => BoolLiteral[[Ctx0]]
            BinaryExponent        => BinaryExponent[[Ctx0]]
            HexaSignificand       => HexaSignificand[[Ctx0]]
            HexaFloatNumeral      => HexaFloatNumeral[[Ctx0]]
            SignedInteger         => SignedInteger[[Ctx0]]
            DeciFloatExponentPart => DeciFloatExponentPart[[Ctx0]]
            DeciFloatDigits       => DeciFloatDigits[[Ctx0]]
            DeciFloatNumeral      => DeciFloatNumeral[[Ctx0]]
            FloatLiteral          => FloatLiteral[[Ctx0]]
            HexaFloatLiteral      => HexaFloatLiteral[[Ctx0]]
            DeciFloatLiteral      => DeciFloatLiteral[[Ctx0]]
            IntLiteral            => IntLiteral[[Ctx0]]
            OctaNumeral           => OctaNumeral[[Ctx0]]
            HexaNumeral           => HexaNumeral[[Ctx0]]
            DeciNumeral           => DeciNumeral[[Ctx0]]
            OctaLiteral           => OctaLiteral[[Ctx0]]
            HexaLiteral           => HexaLiteral[[Ctx0]]
            DeciLiteral           => DeciLiteral[[Ctx0]]
            Modifier              => Modifier[[Ctx0]]
            StrictFP              => StrictFP[[Ctx0]]
            Synchronized          => Synchronized[[Ctx0]]
            Volatile              => Volatile[[Ctx0]]
            Transient             => Transient[[Ctx0]]
            Native                => Native[[Ctx0]]
            Static                => Static[[Ctx0]]
            Final                 => Final[[Ctx0]]
            Abstract              => Abstract[[Ctx0]]
            Protected             => Protected[[Ctx0]]
            Private               => Private[[Ctx0]]
            Public                => Public[[Ctx0]]
            Id                    => Id[[Ctx0]]
            ID                    => ID[[Ctx0]]
            Keyword               => Keyword[[Ctx0]]
            ArrayAccess           => ArrayAccess[[Ctx0]]
            FieldAccess           => FieldAccess[[Ctx0]]
            MethodSpec            => MethodSpec[[Ctx0]]
            Expr                  => Expr[[Ctx0]] ]


module languages/java-15/expressions/Priorities
imports
  languages/java-15/lexical/Identifiers
  languages/java-15/expressions/Main

exports
  context-free priorities
      Expr "." "new" TypeArgs? Id TypeArgs? "(" {Expr ","}* ")" ClassBody? -> Expr
    > {right:
        Expr "++" -> Expr
        Expr "--" -> Expr
      } 

  context-free priorities
      {right:
        Expr "++" -> Expr
        Expr "--" -> Expr
      }
    > { "(" PrimType ")" Expr -> Expr    
        "(" RefType  ")" Expr -> Expr
      }

  context-free priorities
      "(" PrimType ")" Expr -> Expr
    > {left:
        Expr "*" Expr -> Expr
        Expr "/" Expr -> Expr
        Expr "%" Expr -> Expr
      } 

  context-free priorities
      "(" RefType ")" Expr -> Expr 
    > {
        "++" Expr -> Expr
        "--" Expr -> Expr
        "+"  Expr -> Expr
        "-"  Expr -> Expr
      }

  context-free priorities
    {
      Expr ArraySubscript -> ArrayAccess
      Expr "." Id -> FieldAccess
      Expr "." TypeArgs? Id -> MethodSpec
    }
  > {right:
      Expr "++" -> Expr
      Expr "--" -> Expr
    }
  > {
      "++" Expr -> Expr
      "--" Expr -> Expr
      "+"  Expr -> Expr
      "-"  Expr -> Expr
      "~"  Expr -> Expr
      "!"  Expr -> Expr
    }
  > {left:
      Expr "*" Expr -> Expr
      Expr "/" Expr -> Expr
      Expr "%" Expr -> Expr
    } 
  > {left:
      Expr "+" Expr -> Expr
      Expr "-" Expr -> Expr
    }
  > {left:
      Expr "<<"  Expr -> Expr
      Expr ">>"  Expr -> Expr
      Expr ">>>" Expr -> Expr
    }
  > {left:
      Expr "instanceof" RefType -> Expr
      Expr "<"   Expr -> Expr
      Expr ">"   Expr -> Expr
      Expr "<="  Expr -> Expr
      Expr ">="  Expr -> Expr
    }
  > {left:
      Expr "=="  Expr -> Expr
      Expr "!="  Expr -> Expr
    }
  >   Expr "&"   Expr -> Expr
  >   Expr "^"   Expr -> Expr
  >   Expr "|"   Expr -> Expr
  >   Expr "&&"  Expr -> Expr
  >   Expr "||"  Expr -> Expr
  >   Expr CondMid Expr -> Expr
  > {right:
      LHS "="    Expr -> Expr
      LHS "*="   Expr -> Expr
      LHS "/="   Expr -> Expr
      LHS "%="   Expr -> Expr
      LHS "+="   Expr -> Expr
      LHS "-="   Expr -> Expr
      LHS "<<="  Expr -> Expr
      LHS ">>="  Expr -> Expr
      LHS ">>>=" Expr -> Expr
      LHS "&="   Expr -> Expr
      LHS "^="   Expr -> Expr
      LHS "|="   Expr -> Expr
    }

module languages/java-15/expressions/Restrictions
exports
  lexical restrictions
    "+" -/- [\+]
    "-" -/- [\-]
    "/" -/- [\/]

module languages/java-15/expressions/AssignmentOperators
imports
  languages/java-15/expressions/Main

exports
  sorts LHS
  context-free syntax
    LHS "="    Expr -> Expr {cons("Assign")}
    LHS "*="   Expr -> Expr {cons("AssignMul")}
    LHS "/="   Expr -> Expr {cons("AssignDiv")}
    LHS "%="   Expr -> Expr {cons("AssignRemain")}
    LHS "+="   Expr -> Expr {cons("AssignPlus")}
    LHS "-="   Expr -> Expr {cons("AssignMinus")}
    LHS "<<="  Expr -> Expr {cons("AssignLeftShift")}
    LHS ">>="  Expr -> Expr {cons("AssignRightShift")}
    LHS ">>>=" Expr -> Expr {cons("AssignURightShift")}
    LHS "&="   Expr -> Expr {cons("AssignAnd")}
    LHS "^="   Expr -> Expr {cons("AssignExcOr")}
    LHS "|="   Expr -> Expr {cons("AssignOr")}

    ExprName    -> LHS
    FieldAccess -> LHS
    ArrayAccess -> LHS


module languages/java-15/expressions/BinaryOperators
imports
  languages/java-15/expressions/Main
  languages/java-15/types/Main

exports
  sorts CondMid
  context-free syntax
    Expr "instanceof" RefType -> Expr {cons("InstanceOf")}

    Expr "*"   Expr -> Expr  {left, cons("Mul")}
    Expr "/"   Expr -> Expr  {left, cons("Div")}
    Expr "%"   Expr -> Expr  {left, cons("Remain")}

    Expr "+"   Expr -> Expr  {left, cons("Plus")}
    Expr "-"   Expr -> Expr  {left, cons("Minus")}

    Expr "<<"  Expr -> Expr  {left, cons("LeftShift")}
    Expr ">>"  Expr -> Expr  {left, cons("RightShift")}
    Expr ">>>" Expr -> Expr  {left, cons("URightShift")}

    Expr "<"   Expr -> Expr  {left, cons("Lt")}
    Expr ">"   Expr -> Expr  {left, cons("Gt")}
    Expr "<="  Expr -> Expr  {left, cons("LtEq")}
    Expr ">="  Expr -> Expr  {left, cons("GtEq")}
    Expr "=="  Expr -> Expr  {left, cons("Eq")}
    Expr "!="  Expr -> Expr  {left, cons("NotEq")}

    Expr "&&"  Expr -> Expr  {left, cons("LazyAnd")}
    Expr "||"  Expr -> Expr  {left, cons("LazyOr")}

    Expr "&" Expr -> Expr {left, cons("And")}
    Expr "^" Expr -> Expr {left, cons("ExcOr")}
    Expr "|" Expr -> Expr {left, cons("Or")}

    %% todo JFR-30
    Expr CondMid Expr -> Expr {right, cons("Cond")}
    "?" Expr ":" -> CondMid {bracket}

module languages/java-15/expressions/UnaryOperators
imports 
  languages/java-15/expressions/Main
exports
  context-free syntax
    "+" Expr -> Expr {cons("Plus")}
    "-" Expr -> Expr {cons("Minus")}

    "++" Expr -> Expr {cons("PreIncr")}
    "--" Expr -> Expr {cons("PreDecr")}

    "~" Expr -> Expr {cons("Complement")}
    "!" Expr -> Expr {cons("Not")}

    "(" PrimType ")" Expr -> Expr {cons("CastPrim")}
    "(" RefType  ")" Expr -> Expr {cons("CastRef")}

module languages/java-15/expressions/Postfix
imports 
  languages/java-15/expressions/Main

exports
  context-free syntax
    ExprName  -> Expr
    Expr "++" -> Expr {cons("PostIncr")}
    Expr "--" -> Expr {cons("PostDecr")}

module languages/java-15/expressions/MethodInvocation
imports
  languages/java-15/expressions/Main

exports
  sorts MethodSpec
  context-free syntax
    MethodSpec "(" {Expr ","}* ")" -> Expr {cons("Invoke")}

                               MethodName -> MethodSpec {cons("Method")}
                    Expr "." TypeArgs? Id -> MethodSpec {cons("Method")}
                 "super" "." TypeArgs? Id -> MethodSpec {cons("SuperMethod")}
    TypeName "." "super" "." TypeArgs? Id -> MethodSpec {cons("QSuperMethod")}
                 AmbName "." TypeArgs  Id -> MethodSpec {cons("GenericMethod")}

  %% This priority forbids a Expr "." MethodSpec if the expression is a plain ExprName.
  %% This solves an ambiguity with the MethodName and AmbName . TypeArgs MethodSpecs.
  %% foo.bar.fred() results in a MethodName MethodSpec.
  %% (foo.bar).fred() results in the Expr. MethodSpec
  %% foo.bar.<T>fred() results in a GenericMethod
  context-free priorities
      Expr "." TypeArgs? Id -> MethodSpec
    > ExprName  -> Expr


module languages/java-15/expressions/ArrayAccess
imports
  languages/java-15/expressions/Main
exports
  sorts
    ArrayAccess
    ArraySubscript

  context-free syntax
    ArrayAccess -> Expr

    %% todo: JFR-29
    Expr ArraySubscript -> ArrayAccess {cons("ArrayAccess")}
    "[" Expr "]" -> ArraySubscript {bracket}

    ArrayCreationExpr ArraySubscript -> ArrayAccess {reject}

module languages/java-15/expressions/FieldAccess
imports
  languages/java-15/expressions/Main

exports
  sorts FieldAccess
  context-free syntax
    FieldAccess -> Expr

  context-free syntax

                    Expr "." Id -> FieldAccess {cons("Field")}
                ExprName "." Id -> FieldAccess {reject}
                 "super" "." Id -> FieldAccess {cons("SuperField")}
    TypeName "." "super" "." Id -> FieldAccess {cons("QSuperField")}

module languages/java-15/expressions/ArrayCreation
imports
  languages/java-15/expressions/Main

exports
  sorts
    ArrayCreationExpr
    ArrayBaseType
    Dim
    DimExpr

  context-free syntax
    ArrayCreationExpr     -> Expr

    "new" ArrayBaseType DimExpr+ Dim*  -> ArrayCreationExpr {cons("NewArray")}
    "new" ArrayBaseType Dim+ ArrayInit -> ArrayCreationExpr {cons("NewArray")}

    PrimType -> ArrayBaseType
    TypeName -> ArrayBaseType
    TypeName "<" "?" ">" -> ArrayBaseType {cons("UnboundWld")}

    "[" Expr "]" -> DimExpr {cons("Dim")}
    "[" "]"      -> Dim     {cons("Dim")}

module languages/java-15/expressions/ClassInstanceCreation
imports
  languages/java-15/expressions/Main
  languages/java-15/classes/ClassDeclarations

exports
  context-free syntax

             "new" TypeArgs? ClassOrInterfaceType "(" {Expr ","}* ")" ClassBody? -> Expr {cons("NewInstance")}
    Expr "." "new" TypeArgs? Id         TypeArgs? "(" {Expr ","}* ")" ClassBody? -> Expr {cons("QNewInstance")}

module languages/java-15/expressions/Primary
imports
  languages/java-15/lexical/literals/Main
  languages/java-15/names/Main
  languages/java-15/expressions/Main

exports
  %%%
   %% Section 15.8.1: Lexical Literals
   %%%
  sorts Literal
  context-free syntax
    Literal -> Expr {cons("Lit")}

    IntLiteral    -> Literal
    FloatLiteral  -> Literal
    BoolLiteral   -> Literal 
    CharLiteral   -> Literal
    StringLiteral -> Literal
    NullLiteral   -> Literal

  %%%
   %% Section 15.8.2: Class Literals
   %%%
  sorts ClassLiteral
  context-free syntax
    ClassLiteral -> Literal
    Type   "." "class" -> ClassLiteral {cons("Class")}
    "void" "." "class" -> ClassLiteral {cons("VoidClass")}

  %%%
   %% Section 15.8.3/4: (Qualified this)
   %%%
  context-free syntax
                 "this" -> Expr {cons("This")}
    TypeName "." "this" -> Expr {cons("QThis")}

  %%%
   %% Section 15.8.5: Parenthesized Expression
   %%%
  context-free syntax
    "(" Expr ")"          -> Expr {bracket}

module languages/java-15/expressions/Main
imports
  languages/java-15/expressions/Primary
  languages/java-15/expressions/ClassInstanceCreation
  languages/java-15/expressions/ArrayCreation
  languages/java-15/expressions/FieldAccess
  languages/java-15/expressions/ArrayAccess
  languages/java-15/expressions/MethodInvocation
  languages/java-15/expressions/Postfix
  languages/java-15/expressions/UnaryOperators
  languages/java-15/expressions/BinaryOperators
  languages/java-15/expressions/AssignmentOperators
  languages/java-15/expressions/Restrictions
  languages/java-15/expressions/Priorities

exports
  sorts
    Expr

module languages/java-15/statements/Main
imports
  languages/java-15/statements/Blocks
  languages/java-15/statements/LocalVariableDeclarations
  languages/java-15/statements/Statements


module languages/java-15/arrays/Main
imports
  languages/java-15/arrays/ArrayInitializers


module languages/java-15/interfaces/Main
imports
  languages/java-15/interfaces/InterfaceDeclarations
  languages/java-15/interfaces/AbstractMethodDeclarations
  languages/java-15/interfaces/AnnotationTypes
  languages/java-15/interfaces/Annotations


module languages/java-15/classes/Main
imports
  languages/java-15/classes/ClassDeclarations
  languages/java-15/classes/EnumDeclarations


module languages/java-15/packages/PackageDeclarations
imports
  languages/java-15/names/Main
  languages/java-15/interfaces/Annotations

exports
  sorts
    PackageDec

  context-free syntax
    Anno* "package" PackageName ";" -> PackageDec {cons("PackageDec")}

module languages/java-15/packages/ImportDeclarations
imports
  languages/java-15/lexical/Identifiers
  languages/java-15/names/Main

exports
  sorts
    ImportDec

  context-free syntax
    "import" TypeName                  ";"  -> ImportDec {cons("TypeImportDec")}
    "import" PackageName       "." "*" ";"  -> ImportDec {cons("TypeImportOnDemandDec")}
    "import" "static" TypeName "." Id  ";"  -> ImportDec {cons("StaticImportDec")}
    "import" "static" TypeName "." "*" ";"  -> ImportDec {cons("StaticImportOnDemandDec")}

module languages/java-15/interfaces/AnnotationTypes
imports
  languages/java-15/lexical/Identifiers
  languages/java-15/classes/ClassDeclarations
  languages/java-15/classes/EnumDeclarations
  languages/java-15/interfaces/InterfaceDeclarations
  languages/java-15/interfaces/AbstractMethodDeclarations
  languages/java-15/interfaces/ConstantDeclarations
  languages/java-15/interfaces/Annotations

exports
  sorts
    AnnoDec
    AnnoDecHead

  context-free syntax
    AnnoDecHead "{" AnnoElemDec* "}" -> AnnoDec {cons("AnnoDec")}
    (Anno | InterfaceMod)* "@" "interface" Id -> AnnoDecHead {cons("AnnoDecHead")}

  sorts
    AnnoElemDec
    DefaultVal

  context-free syntax
    AbstractMethodMod* Type Id "(" ")" DefaultVal? ";" -> AnnoElemDec {cons("AnnoMethodDec")}

    ConstantDec  -> AnnoElemDec
    ClassDec     -> AnnoElemDec
    InterfaceDec -> AnnoElemDec
    EnumDec      -> AnnoElemDec
    AnnoDec      -> AnnoElemDec
    ";"          -> AnnoElemDec {cons("Semicolon")}

    "default" ElemVal -> DefaultVal {cons("DefaultVal")}

module languages/java-15/interfaces/AbstractMethodDeclarations
imports
  languages/java-15/lexical/Modifiers
  languages/java-15/names/Main
  languages/java-15/types/Main
  languages/java-15/classes/MethodDeclarations

exports
  sorts
    AbstractMethodDec
    AbstractMethodMod

  context-free syntax
    (Anno | AbstractMethodMod)* TypeParams? ResultType
      Id "(" {FormalParam ","}* ")" Throws? ";" -> AbstractMethodDec {cons("AbstractMethodDec")}

    (Anno | AbstractMethodMod)* TypeParams? ResultType
      Id "(" {FormalParam ","}* ")" Dim+ Throws? ";" -> AbstractMethodDec {cons("DeprAbstractMethodDec")}

    Public   -> AbstractMethodMod
    Abstract -> AbstractMethodMod



module languages/java-15/interfaces/ConstantDeclarations
imports
  languages/java-15/lexical/Modifiers
  languages/java-15/types/Main
  languages/java-15/classes/MethodDeclarations
  languages/java-15/interfaces/Annotations

exports
  sorts
    ConstantDec
    ConstantMod

  context-free syntax
    (Anno | ConstantMod)* Type {VarDec ","}+ ";" -> ConstantDec {cons("ConstantDec")}

    Public -> ConstantMod
    Static -> ConstantMod
    Final  -> ConstantMod


module languages/java-15/interfaces/InterfaceDeclarations
imports
  languages/java-15/lexical/Identifiers
  languages/java-15/lexical/Modifiers
  languages/java-15/names/Main
  languages/java-15/types/Main
  languages/java-15/classes/ClassDeclarations
  languages/java-15/classes/MethodDeclarations
  languages/java-15/interfaces/ConstantDeclarations
  languages/java-15/interfaces/AbstractMethodDeclarations
  languages/java-15/interfaces/AnnotationTypes
  languages/java-15/interfaces/Annotations

exports
  sorts
    InterfaceDec
    InterfaceDecHead
    ExtendsInterfaces
    InterfaceMemberDec
    InterfaceMod

  context-free syntax
    AnnoDec -> InterfaceDec

    InterfaceDecHead "{" InterfaceMemberDec* "}" -> InterfaceDec {cons("InterfaceDec")}

    (Anno | InterfaceMod)* "interface" Id TypeParams? ExtendsInterfaces? -> InterfaceDecHead {cons("InterfaceDecHead")}
    "extends" {InterfaceType ","}+ -> ExtendsInterfaces {cons("ExtendsInterfaces")}

  context-free syntax
    ConstantDec       -> InterfaceMemberDec
    AbstractMethodDec -> InterfaceMemberDec
    ClassDec          -> InterfaceMemberDec
    InterfaceDec      -> InterfaceMemberDec
    ";"               -> InterfaceMemberDec {cons("Semicolon")}

  context-free syntax
    Public         -> InterfaceMod
    Protected      -> InterfaceMod
    Private        -> InterfaceMod
    Abstract       -> InterfaceMod
    Static         -> InterfaceMod
    StrictFP       -> InterfaceMod


module languages/java-15/classes/EnumDeclarations
imports
  languages/java-15/lexical/Identifiers
  languages/java-15/classes/ClassDeclarations

exports
  sorts
    EnumDec
    EnumDecHead
    EnumBody
    EnumConst
    EnumConstArgs
    EnumBodyDecs

  context-free syntax
    EnumDecHead EnumBody -> EnumDec {cons("EnumDec")}

    (Anno | ClassMod)* "enum" Id Interfaces? -> EnumDecHead {cons("EnumDecHead")}

    "{" {EnumConst ","}*     EnumBodyDecs? "}" -> EnumBody {cons("EnumBody")}
    "{" {EnumConst ","}* "," EnumBodyDecs? "}" -> EnumBody {cons("EnumBody")}

    Id EnumConstArgs? ClassBody?  -> EnumConst {cons("EnumConst")}
    "(" {Expr ","}* ")"  -> EnumConstArgs {bracket}

    ";" ClassBodyDec* -> EnumBodyDecs {cons("EnumBodyDecs")}

module languages/java-15/classes/ConstructorDeclarations
imports
  languages/java-15/lexical/Identifiers
  languages/java-15/lexical/Modifiers
  languages/java-15/interfaces/Annotations
  languages/java-15/statements/Main
  languages/java-15/expressions/Main

exports
  sorts
    ConstrDec
    ConstrBody
    ConstrHead
    ConstrInv

  context-free syntax
    ConstrHead ConstrBody ->  ConstrDec {cons("ConstrDec")}
    (Anno | ConstrMod)* TypeParams? Id "(" {FormalParam ","}* ")" Throws? -> ConstrHead {cons("ConstrDecHead")}


    "{" ConstrInv? BlockStm* "}" -> ConstrBody {cons("ConstrBody")}

             TypeArgs? "this"  "(" {Expr ","}* ")" ";" -> ConstrInv {cons("AltConstrInv")}
             TypeArgs? "super" "(" {Expr ","}* ")" ";" -> ConstrInv {cons("SuperConstrInv")}
    Expr "." TypeArgs? "super" "(" {Expr ","}* ")" ";" -> ConstrInv {cons("QSuperConstrInv")}

  sorts ConstrMod
  context-free syntax  
    Public    -> ConstrMod
    Protected -> ConstrMod
    Private   -> ConstrMod


module languages/java-15/classes/StaticInitializers
imports
  languages/java-15/statements/Blocks

exports
  sorts
    StaticInit

  context-free syntax
    "static" Block -> StaticInit   {cons("StaticInit")}

module languages/java-15/classes/InstanceInitializers
imports
  languages/java-15/statements/Blocks

exports
  sorts
    InstanceInit

  context-free syntax
    Block -> InstanceInit {cons("InstanceInit")}

module languages/java-15/statements/Statements
imports
  languages/java-15/statements/LocalVariableDeclarations
  languages/java-15/statements/Blocks
  languages/java-15/expressions/Main

exports
  sorts
    Stm

  context-free syntax
    Block      -> Stm

  %%%
   %% Section 14.6: The Empty Statement
   %%%
  context-free syntax
    ";"        -> Stm {cons("Empty")}

  %%%
   %% Section 14.7: Labeled Statements
   %%%
  context-free syntax
    Id ":" Stm -> Stm {cons("Labeled")}

  %%%
   %% Section 14.8: Expressions Statements
   %%%
  context-free syntax
    Expr ";"   -> Stm {cons("ExprStm")}

  %%%
   %% Section 14.9: The If Statement
   %%%
  context-free syntax
    "if" "(" Expr ")" Stm             -> Stm {prefer, cons("If")}
    "if" "(" Expr ")" Stm  "else" Stm -> Stm {cons("If")}

  %%%
   %% Section 14.10: The Assert Statement
   %%%
  context-free syntax
    "assert" Expr          ";" -> Stm  {cons("AssertStm")}
    "assert" Expr ":" Expr ";" -> Stm  {cons("AssertStm")}


  %%%
   %% Section 14.11: The Switch Statement
   %%%
  sorts SwitchBlock SwitchGroup SwitchLabel
  context-free syntax
    "switch" "(" Expr ")" SwitchBlock -> Stm {cons("Switch")}
    "{" SwitchGroup* SwitchLabel* "}" -> SwitchBlock {cons("SwitchBlock")}
    SwitchLabel+ BlockStm+ -> SwitchGroup  {cons("SwitchGroup")}

    "case" Expr ":" -> SwitchLabel {cons("Case")}
    "default"   ":" -> SwitchLabel {cons("Default")}

  %%%
   %% Section 14.12: The While Statement
   %%%
  context-free syntax
    "while" "(" Expr ")" Stm -> Stm {cons("While")}

  %%%
   %% Section 14.13: The Do Statement
   %%%
  context-free syntax
  "do" Stm "while" "(" Expr ")" ";" -> Stm {cons("DoWhile")}


  %%%
   %% Section 14.14: The For Statement
   %%%
  context-free syntax
    "for" "(" LocalVarDec ";" Expr? ";" {Expr ","}* ")" Stm -> Stm {cons("For")}
    "for" "(" {Expr ","}* ";" Expr? ";" {Expr ","}* ")" Stm -> Stm {cons("For")}

    "for" "(" FormalParam ":" Expr ")" Stm -> Stm {cons("ForEach")}

  %%%
   %% Section 14.15: The Break Statement
   %%%
  context-free syntax
    "break"    Id? ";"   -> Stm {cons("Break")}

  %%%
   %% Section 14.16: The Continue Statement
   %%%
  context-free syntax
    "continue" Id? ";"   -> Stm {cons("Continue")}

  %%%
   %% Section 14.17: The Return Statement
   %%%
  context-free syntax
    "return"   Expr? ";" -> Stm {cons("Return")}

  %%%
   %% Section 14.18: The Throw Statement
   %%%
  context-free syntax
    "throw"    Expr  ";" -> Stm {cons("Throw")}

  %%%
   %% Section 14.19: The Synchronized Statement
   %%%
  context-free syntax
    "synchronized" "(" Expr ")" Block -> Stm {cons("Synchronized")}

  %%%
   %% Section 14.20: The Try Statement
   %%%
  sorts CatchClause
  context-free syntax
    "try" Block CatchClause+ -> Stm {cons("Try")}
    "try" Block CatchClause* "finally" Block -> Stm {cons("Try")}
    "catch" "(" FormalParam ")" Block -> CatchClause {cons("Catch")}

module languages/java-15/statements/LocalVariableDeclarations
imports
  languages/java-15/classes/MethodDeclarations
  languages/java-15/classes/FieldDeclarations

exports
  sorts
    LocalVarDecStm
    LocalVarDec

  context-free syntax
    LocalVarDec ";" -> LocalVarDecStm {prefer, cons("LocalVarDecStm")}
    (Anno | VarMod)* Type {VarDec ","}+ -> LocalVarDec {prefer, cons("LocalVarDec")}

module languages/java-15/statements/Blocks
imports
  languages/java-15/classes/ClassDeclarations
  languages/java-15/statements/LocalVariableDeclarations
  languages/java-15/statements/Statements

exports
  sorts
    BlockStm
    Block

  context-free syntax
    "{" BlockStm* "}" -> Block {cons("Block")}

    LocalVarDecStm  -> BlockStm 
    ClassDec        -> BlockStm {cons("ClassDecStm")}
    Stm             -> BlockStm


module languages/java-15/classes/MethodDeclarations
imports
  languages/java-15/lexical/Identifiers
  languages/java-15/lexical/Modifiers
  languages/java-15/types/Main
  languages/java-15/classes/FieldDeclarations
  languages/java-15/interfaces/Annotations
  languages/java-15/statements/Blocks

exports
  sorts
    MethodDec
    MethodDecHead
    ResultType

  context-free syntax
    MethodDecHead MethodBody -> MethodDec {cons("MethodDec")}

    (Anno | MethodMod)* TypeParams? ResultType Id "(" {FormalParam ","}* ")" Throws?      -> MethodDecHead {cons("MethodDecHead")}
    (Anno | MethodMod)* TypeParams? ResultType Id "(" {FormalParam ","}* ")" Dim+ Throws? -> MethodDecHead {cons("DeprMethodDecHead")}

    Type   -> ResultType
    "void" -> ResultType {cons("Void")}

  sorts FormalParam
  context-free syntax
    (Anno | VarMod)* Type       VarDecId -> FormalParam {cons("Param")}
    (Anno | VarMod)* Type "..." VarDecId -> FormalParam {cons("VarArityParam")}

  sorts VarMod
  context-free syntax
    Final -> VarMod

  sorts MethodMod
  context-free syntax
    Public         -> MethodMod
    Protected      -> MethodMod
    Private        -> MethodMod

    Abstract       -> MethodMod
    Static         -> MethodMod
    Final          -> MethodMod
    Synchronized   -> MethodMod
    Native         -> MethodMod
    StrictFP       -> MethodMod

  %%%
   %% Section 8.4.6: Method Throws
   %%%
  sorts
    Throws
    ExceptionType

  context-free syntax
    "throws" {ExceptionType ","}+ -> Throws {cons("ThrowsDec")}
    ClassType -> ExceptionType
    %% TypeVar -> ExceptionType

  %%%
   %% Section 8.4.7: Method Body
   %%% 
  sorts MethodBody
  context-free syntax
    Block -> MethodBody
    ";"   -> MethodBody {cons("NoMethodBody")}

module languages/java-15/arrays/ArrayInitializers
imports
  languages/java-15/classes/FieldDeclarations

exports
  sorts ArrayInit
  context-free syntax
    "{" {VarInit ","}*     "}" -> ArrayInit {cons("ArrayInit")}
    "{" {VarInit ","}* "," "}" -> ArrayInit {cons("ArrayInit")}

module languages/java-15/interfaces/Annotations
imports
  languages/java-15/lexical/Identifiers
  languages/java-15/names/Main
  languages/java-15/expressions/Main

exports
  sorts
    Anno
    ElemVal
    ElemValPair

  context-free syntax
    "@" TypeName "(" {ElemValPair ","}* ")" -> Anno {cons("Anno")}
    "@" TypeName "(" ElemVal ")"            -> Anno {cons("SingleElemAnno")}
    "@" TypeName                            -> Anno {cons("MarkerAnno")}

  context-free syntax  
    Id "=" ElemVal -> ElemValPair {cons("ElemValPair")}

    Expr -> ElemVal
    Anno -> ElemVal

    "{" {ElemVal ","}*     "}" -> ElemVal {cons("ElemValArrayInit")}
    "{" {ElemVal ","}* "," "}" -> ElemVal {cons("ElemValArrayInit")}

    %% Assignments are not allowed as element values.
    LHS "=" Expr -> ElemVal {reject}

module languages/java-15/classes/FieldDeclarations
imports
  languages/java-15/lexical/Identifiers
  languages/java-15/lexical/Modifiers
  languages/java-15/types/Main
  languages/java-15/interfaces/Annotations
  languages/java-15/arrays/ArrayInitializers
  languages/java-15/expressions/Main

exports
  sorts
    FieldDec
    VarDec
    VarDecId
    Dim
    VarInit

  context-free syntax
    (Anno | FieldMod)* Type { VarDec ","}+ ";" -> FieldDec {cons("FieldDec")}

    VarDecId             -> VarDec {cons("VarDec")}
    VarDecId "=" VarInit -> VarDec {cons("VarDec")}

    Id      -> VarDecId
    Id Dim+ -> VarDecId {cons("ArrayVarDecId")}

    "[" "]" -> Dim {cons("Dim")}

    Expr      -> VarInit
    ArrayInit -> VarInit

  sorts FieldMod
  context-free syntax
    Public    -> FieldMod
    Protected -> FieldMod
    Private   -> FieldMod

    Static    -> FieldMod
    Final     -> FieldMod
    Transient -> FieldMod
    Volatile  -> FieldMod


module languages/java-15/classes/ClassDeclarations
imports
  languages/java-15/lexical/Identifiers
  languages/java-15/lexical/Modifiers
  languages/java-15/types/ReferenceTypes
  languages/java-15/types/TypeVariables
  languages/java-15/classes/FieldDeclarations
  languages/java-15/classes/MethodDeclarations
  languages/java-15/classes/InstanceInitializers
  languages/java-15/classes/StaticInitializers
  languages/java-15/classes/ConstructorDeclarations
  languages/java-15/classes/EnumDeclarations
  languages/java-15/interfaces/InterfaceDeclarations

exports
  sorts
    ClassDec
    ClassBody
    ClassDecHead

  context-free syntax
    EnumDec -> ClassDec

    ClassDecHead ClassBody -> ClassDec {cons("ClassDec")}
    "{" ClassBodyDec* "}" -> ClassBody {cons("ClassBody")}

    (Anno | ClassMod)* "class" Id  TypeParams? Super? Interfaces? -> ClassDecHead {cons("ClassDecHead")}

  %% 8.1.1: Class Modifiers
  sorts ClassMod
  context-free syntax
    Abstract  -> ClassMod
    Public    -> ClassMod
    Protected -> ClassMod
    Private   -> ClassMod
    Static    -> ClassMod
    Final     -> ClassMod
    StrictFP  -> ClassMod

  %% 8.1.4: Superclasses and Subclasses
  sorts Super
  context-free syntax

    "extends" ClassType -> Super {cons("SuperDec")}

  %% 8.1.5: Superinterfaces
  sorts Interfaces
  context-free syntax
    "implements" {InterfaceType ","}+ -> Interfaces {cons("ImplementsDec")}


  %% 8.1.6: Class Body and Member Declarations
  sorts
    ClassBodyDec
    ClassMemberDec

  context-free syntax
    ClassMemberDec -> ClassBodyDec
    InstanceInit   -> ClassBodyDec
    StaticInit     -> ClassBodyDec
    ConstrDec      -> ClassBodyDec

  context-free syntax
    FieldDec     -> ClassMemberDec
    MethodDec    -> ClassMemberDec
    ClassDec     -> ClassMemberDec
    InterfaceDec -> ClassMemberDec
    ";"          -> ClassMemberDec {cons("Semicolon")}

module languages/java-15/packages/TypeDeclarations
imports
  languages/java-15/classes/ClassDeclarations
  languages/java-15/interfaces/InterfaceDeclarations

exports
  sorts
    TypeDec

  context-free syntax
    ClassDec      -> TypeDec
    InterfaceDec  -> TypeDec
    ";"           -> TypeDec {cons("Semicolon")}

module languages/java-15/packages/CompilationUnits
imports
  languages/java-15/packages/PackageDeclarations
  languages/java-15/packages/ImportDeclarations
  languages/java-15/packages/TypeDeclarations

exports
  sorts
    CompilationUnit

  context-free syntax
    PackageDec? ImportDec* TypeDec+ -> CompilationUnit   {cons("CompilationUnit")}

module languages/java-15/packages/Main
imports
  languages/java-15/packages/CompilationUnits
  languages/java-15/packages/ImportDeclarations
  languages/java-15/packages/PackageDeclarations


module languages/java-15/names/Main
imports
  languages/java-15/lexical/Identifiers
exports
  sorts PackageName
  context-free syntax
    {Id "."}+ -> PackageName {cons("PackageName")}

  sorts
    TypeName
    ExprName
    MethodName
    PackageOrTypeName
    AmbName

  context-free syntax
    Id             -> AmbName {cons("AmbName")}
    AmbName "." Id -> AmbName {cons("AmbName")}

    Id                       -> TypeName {cons("TypeName")}
    PackageOrTypeName "." Id -> TypeName {cons("TypeName")}

    Id             -> ExprName {cons("ExprName")}
    AmbName "." Id -> ExprName {cons("ExprName")}

    Id             -> MethodName  {cons("MethodName")}
    AmbName "." Id -> MethodName  {cons("MethodName")}

    Id                       -> PackageOrTypeName {cons("PackageOrTypeName")}
    PackageOrTypeName "." Id -> PackageOrTypeName {cons("PackageOrTypeName")}

module languages/java-15/types/ParameterizedTypes
imports
  languages/java-15/types/ReferenceTypes

exports
  sorts
    TypeArgs
    ActualTypeArg
    WildcardBound
    
  context-free syntax
    "<" {ActualTypeArg ","}+ ">" -> TypeArgs {cons("TypeArgs")}

    Type               -> ActualTypeArg
    "?" WildcardBound? -> ActualTypeArg {cons("Wildcard")}

    "extends" RefType -> WildcardBound {cons("WildcardUpperBound")}
    "super"   RefType -> WildcardBound {cons("WildcardLowerBound")}

module languages/java-15/types/TypeVariables
imports
  languages/java-15/lexical/Identifiers
  languages/java-15/types/ReferenceTypes

exports
  sorts
    TypeParams
    TypeParam
    TypeBound
    TypeVarId
  
  context-free syntax
    TypeVarId TypeBound? -> TypeParam {cons("TypeParam")}
    
    "extends" {ClassOrInterfaceType "&"}+ -> TypeBound {cons("TypeBound")}
    "<" {TypeParam ","}+ ">" -> TypeParams {cons("TypeParams")}

    Id -> TypeVarId
    

module languages/java-15/types/ReferenceTypes
imports
  languages/java-15/lexical/Identifiers
  languages/java-15/names/Main
  languages/java-15/types/Main  
  languages/java-15/types/ParameterizedTypes
  languages/java-15/types/TypeVariables


exports
  sorts
    RefType
    ClassOrInterfaceType
    ClassType
    InterfaceType
    TypeDecSpec
    ArrayType
    TypeVar

  context-free syntax
    ClassOrInterfaceType -> RefType
    ArrayType            -> RefType
    
    %% This production rule is highly ambiguous, since every
    %% TypeVar can be a ClassOrInterfaceType. A later disambiguation
    %% phase has to find out if a ClassOrInterfaceType is in fact
    %% a TypeVar.
    
    %% TypeVar -> RefType {avoid}

  context-free syntax
  
    %% ClassType and InterfaceType are ambiguous. We modify the
    %% production of ClassOrInterfaceType to make this ambiguity explicit.
    
    TypeDecSpec TypeArgs? -> ClassOrInterfaceType {cons("ClassOrInterfaceType")}
    TypeDecSpec TypeArgs? -> ClassType {cons("ClassType")}
    TypeDecSpec TypeArgs? -> InterfaceType {cons("InterfaceType")}

    TypeName -> TypeDecSpec
    TypeDecSpec TypeArgs "." Id -> TypeDecSpec {cons("Member")}
    
  context-free syntax    
    TypeVarId -> TypeVar {cons("TypeVar")}

  context-free syntax
    Type "[" "]" -> ArrayType  {cons("ArrayType")}

module languages/java-15/types/PrimitiveTypes
exports
  sorts
    PrimType
    NumType
    IntType  
    FloatType

  context-free syntax
    NumType   -> PrimType
    "boolean" -> PrimType {cons("Boolean")}

    IntType   -> NumType
    FloatType -> NumType

    "byte"   -> IntType   {cons("Byte")}
    "short"  -> IntType   {cons("Short")}
    "int"    -> IntType   {cons("Int")}
    "long"   -> IntType   {cons("Long")}
    "char"   -> IntType   {cons("Char")}
    "float"  -> FloatType {cons("Float")}
    "double" -> FloatType {cons("Double")}

module languages/java-15/types/Main
imports
  languages/java-15/types/PrimitiveTypes
  languages/java-15/types/ReferenceTypes
  languages/java-15/types/TypeVariables
  languages/java-15/types/ParameterizedTypes

exports
  sorts
    Type

  context-free syntax
    PrimType -> Type
    RefType  -> Type


module languages/java-15/lexical/literals/NullLiteral
exports
  sorts NullLiteral
  context-free syntax
    "null"  -> NullLiteral {cons("Null")}

module languages/java-15/lexical/literals/StringLiterals
imports
  languages/java-15/lexical/literals/EscapeSequences
  languages/java-15/lexical/UnicodeEscapes

exports
  sorts
    StringLiteral
    StringPart
    StringChars
    FooStringChars

  syntax
    StringLiteral -> <StringLiteral-CF>
    
    "\"" StringPart* "\"" -> StringLiteral {cons("String")}
    StringChars    -> StringPart {cons("Chars")}
    UnicodeEscape  -> StringPart
    EscapeSeq      -> StringPart

    <FooStringChars-LEX> -> StringChars
    ~[\"\\\n\13]+  -> <FooStringChars-LEX>

  restrictions
    StringChars -/- ~[\"\\\n\13]

module languages/java-15/lexical/literals/EscapeSequences
imports

exports
  sorts
    EscapeSeq
    NamedEscape
    OctaEscape
    LastOcta

  syntax
    OctaEscape  -> EscapeSeq
    NamedEscape -> EscapeSeq

    "\\" [btnfr\"\'\\]     -> NamedEscape {cons("NamedEscape")}
    "\\" LastOcta          -> OctaEscape  {cons("OctaEscape1")}
    "\\" [0-3] LastOcta    -> OctaEscape  {cons("OctaEscape2")}
    "\\" [4-7] [0-7]       -> OctaEscape  {cons("OctaEscape2")}
    "\\" [0-3] [0-7] [0-7] -> OctaEscape  {cons("OctaEscape3")}

    [0-7] -> LastOcta

  restrictions
    LastOcta -/- [0-7]

module languages/java-15/lexical/literals/CharacterLiterals
imports
  languages/java-15/lexical/literals/EscapeSequences
  languages/java-15/lexical/UnicodeEscapes

exports
  sorts
    CharLiteral
    CharContent
    SingleChar

  syntax
    CharLiteral   -> <CharLiteral-CF>

    "'" CharContent "'" -> CharLiteral {cons("Char")}
    SingleChar    -> CharContent {cons("Single")}
    UnicodeEscape -> CharContent
    EscapeSeq     -> CharContent

    ~[\r\n\'\\] -> SingleChar


module languages/java-15/lexical/literals/BooleanLiterals
exports
  sorts
    Bool
    BoolLiteral

  context-free syntax
    Bool -> BoolLiteral {cons("Bool")}
    "true"  -> Bool {cons("True")}
    "false" -> Bool {cons("False")}

module languages/java-15/lexical/literals/FloatingPointLiterals
exports
  sorts
    FloatLiteral
    DeciFloatLiteral
    HexaFloatLiteral      
  
  context-free syntax
    DeciFloatLiteral -> FloatLiteral {cons("Float")}
    HexaFloatLiteral -> FloatLiteral {cons("Float")}

  lexical syntax
    DeciFloatNumeral [fFdD]? -> DeciFloatLiteral
    HexaFloatNumeral [fFdD]? -> HexaFloatLiteral
    
    %% Reject plain integer literals as decimal float literals.
    %% A similar rejection for hexadecimal float literals is not
    %% required, since these always contain an exponent part.
    [0-9]+ -> DeciFloatLiteral {reject}

  lexical restrictions
    DeciFloatLiteral -/- [fFdD]
    HexaFloatLiteral -/- [fFdD]

  %%%
   %% Decimal Floating Point Numerals
   %%%
  sorts
    DeciFloatNumeral
    DeciFloatDigits
    DeciFloatExponentPart

  lexical syntax
    DeciFloatDigits DeciFloatExponentPart? -> DeciFloatNumeral

    [0-9]* "." [0-9]* -> DeciFloatDigits
           "."        -> DeciFloatDigits {reject}
    [0-9]+            -> DeciFloatDigits

    [eE] SignedInteger -> DeciFloatExponentPart
    
    [\+\-]? [0-9]+ -> SignedInteger    

  lexical restrictions
    DeciFloatDigits  -/- [0-9]
    DeciFloatExponentPart -/- [0-9]

  %%%
   %% Hexadecimal Floating Point Literals
   %%%
  sorts
    HexaFloatNumeral
    HexaSignificand
    BinaryExponent
    SignedInteger
    
  lexical syntax
    HexaSignificand BinaryExponent -> HexaFloatNumeral

    [0][xX] [0-9a-fA-F]+                  -> HexaSignificand
    [0][xX] [0-9a-fA-F]* "." [0-9a-fA-F]* -> HexaSignificand
    [0][xX]              "."              -> HexaSignificand {reject}

    [pP] SignedInteger -> BinaryExponent
  lexical restrictions
    HexaSignificand -/- [0-9a-fA-F]
    SignedInteger   -/- [0-9]

module languages/java-15/lexical/literals/IntegerLiterals
exports
  sorts
    IntLiteral
    DeciLiteral
    HexaLiteral
    OctaLiteral
    DeciNumeral
    HexaNumeral
    OctaNumeral

  context-free syntax
    DeciLiteral -> IntLiteral {cons("Deci")}
    HexaLiteral -> IntLiteral {cons("Hexa")}
    OctaLiteral -> IntLiteral {cons("Octa")}

  lexical syntax
    DeciNumeral [lL]? -> DeciLiteral
    HexaNumeral [lL]? -> HexaLiteral
    OctaNumeral [lL]? -> OctaLiteral

    "0" -> DeciNumeral
    [1-9][0-9]*  -> DeciNumeral
    [0][xX] [0-9a-fA-F]+ -> HexaNumeral
    [0]     [0-7]+       -> OctaNumeral

  lexical restrictions
    DeciNumeral -/- [0-9\.fFdD]
    HexaNumeral -/- [0-9a-fA-F]
    OctaNumeral -/- [0-7]

    DeciLiteral -/- [lL]
    HexaLiteral -/- [lL]
    OctaLiteral -/- [lL]

module languages/java-15/lexical/literals/Main
imports
  languages/java-15/lexical/literals/IntegerLiterals
  languages/java-15/lexical/literals/FloatingPointLiterals
  languages/java-15/lexical/literals/BooleanLiterals  
  languages/java-15/lexical/literals/CharacterLiterals  
  languages/java-15/lexical/literals/StringLiterals
  languages/java-15/lexical/literals/NullLiteral


module languages/java-15/lexical/Modifiers
exports
  sorts
    Public
    Private
    Protected
    Abstract
    Final
    Static
    Native
    Transient
    Volatile
    Synchronized
    StrictFP
    Modifier

  context-free syntax
    "public"       -> Public       {cons("Public")}
    "private"      -> Private      {cons("Private")}
    "protected"    -> Protected    {cons("Protected")}

    "abstract"     -> Abstract     {cons("Abstract")}
    "final"        -> Final        {cons("Final")}
    "static"       -> Static       {cons("Static")}
    "native"       -> Native       {cons("Native")}
    "transient"    -> Transient    {cons("Transient")}
    "volatile"     -> Volatile     {cons("Volatile")}
    "synchronized" -> Synchronized {cons("Synchronized")}
    "strictfp"     -> StrictFP     {cons("StrictFP")}

    Public       -> Modifier
    Private      -> Modifier
    Protected    -> Modifier
    Abstract     -> Modifier
    Final        -> Modifier
    Static       -> Modifier
    Native       -> Modifier
    Transient    -> Modifier
    Volatile     -> Modifier
    Synchronized -> Modifier
    StrictFP     -> Modifier


module languages/java-15/lexical/Keywords
exports
  sorts Keyword
  lexical syntax
    "abstract"      -> Keyword
    "assert"        -> Keyword
    "boolean"       -> Keyword
    "break"         -> Keyword
    "byte"          -> Keyword
    "case"          -> Keyword
    "catch"         -> Keyword
    "char"          -> Keyword
    "class"         -> Keyword
    "const"         -> Keyword
    "continue"      -> Keyword
    "default"       -> Keyword
    "do"            -> Keyword
    "double"        -> Keyword
    "else"          -> Keyword
    "enum"          -> Keyword
    "extends"       -> Keyword
    "final"         -> Keyword
    "finally"       -> Keyword
    "float"         -> Keyword
    "for"           -> Keyword
    "goto"          -> Keyword
    "if"            -> Keyword
    "implements"    -> Keyword
    "import"        -> Keyword
    "instanceof"    -> Keyword
    "int"           -> Keyword
    "interface"     -> Keyword
    "long"          -> Keyword
    "native"        -> Keyword
    "new"           -> Keyword
    "package"       -> Keyword
    "private"       -> Keyword
    "protected"     -> Keyword
    "public"        -> Keyword
    "return"        -> Keyword
    "short"         -> Keyword
    "static"        -> Keyword
    "strictfp"      -> Keyword
    "super"         -> Keyword
    "switch"        -> Keyword
    "synchronized"  -> Keyword
    "this"          -> Keyword
    "throw"         -> Keyword
    "throws"        -> Keyword
    "transient"     -> Keyword
    "try"           -> Keyword
    "void"          -> Keyword
    "volatile"      -> Keyword
    "while"         -> Keyword

  lexical restrictions

    "abstract"
    "assert"
    "boolean" 
    "break"   
    "byte"    
    "case"    
    "catch"   
    "char"     
    "class"
    "const"    
    "continue" 
    "default"  
    "do"       
    "double"   
    "else"     
    "enum"
    "extends"  
    "final"     
    "finally"   
    "float"     
    "for"       
    "goto"       
    "if"         
    "implements" 
    "import"     
    "instanceof" 
    "int"        
    "interface"  
    "long"       
    "native"     
    "new"        
    "package"    
    "private"    
    "protected"   
    "public"       
    "return"       
    "short"        
    "static"     
    "strictfp"
    "super"        
    "switch"       
    "synchronized" 
    "this"         
    "throw"        
    "throws"       
    "transient"    
    "try"          
    "void"         
    "volatile"     
    "while"       -/- [A-Za-z0-9\_\$]

module languages/java-15/lexical/Identifiers
imports
  languages/java-15/lexical/Keywords
exports
  sorts
    Id
    ID

  context-free syntax
    ID -> Id {cons("Id")}

  lexical syntax
    [A-Za-z\_\$][A-Za-z0-9\_\$]* -> ID
    
    Keyword -> ID {reject}
    "true"  -> ID {reject}
    "false" -> ID {reject}
    "null"  -> ID {reject}

  lexical restrictions
    ID -/- [a-zA-Z0-9\_\$]

module languages/java-15/lexical/Comments
imports
  languages/java-15/lexical/LineTerminators
exports
  sorts
    Comment
    EOLCommentChars
    CommentPart
    UnicodeEscape
    BlockCommentChars
    Asterisk
    EscEscChar
    EscChar

  lexical syntax
    Comment -> LAYOUT

    "//" EOLCommentChars LineTerminator -> Comment
    ~[\n\r]* -> EOLCommentChars

    "/*"  CommentPart* "*/" -> Comment
    "/**" CommentPart* "*/" -> Comment
    "/**/"                  -> Comment %% Strange javadoc comment

    BlockCommentChars -> CommentPart
    EscChar           -> CommentPart
    EscEscChar        -> CommentPart
    Asterisk          -> CommentPart
    UnicodeEscape     -> CommentPart

    ~[\*\\]+ -> BlockCommentChars

    "*"    -> Asterisk
    "\\\\" -> EscEscChar
    "\\"   -> EscChar

    "\\" [u]+ [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] -> UnicodeEscape

  lexical restrictions
    "/**"    -/- [\/]
    "/*"     -/- [\*]
    Asterisk -/- [\/]
    EscChar  -/- [\\u]

    BlockCommentChars -/- ~[\*\\]
    EOLCommentChars   -/- ~[\n\13]

  context-free restrictions
    LAYOUT?  -/- [\/].[\*]
    LAYOUT?  -/- [\/].[\/]

module languages/java-15/lexical/WhiteSpace
exports
  lexical syntax
    [\ \t\12\r\n] -> LAYOUT

  context-free restrictions
    LAYOUT? -/- [\ \t\12\n\r]

module languages/java-15/lexical/LineTerminators
exports
  sorts
    LineTerminator CarriageReturn EndOfFile

  lexical syntax
    [\n]           -> LineTerminator
    [\r][\n]       -> LineTerminator
    CarriageReturn -> LineTerminator
    EndOfFile      -> LineTerminator

    [\r] -> CarriageReturn

  lexical restrictions
    CarriageReturn -/- [\n]

  %% End of file is empty.
  lexical syntax    
    -> EndOfFile

  lexical restrictions
    EndOfFile -/- ~[]

module languages/java-15/lexical/UnicodeEscapes
exports
  sorts
    UnicodeEscape

  syntax
    "\\" [u]+ [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] -> UnicodeEscape {cons("UnicodeEscape")}

module languages/java-15/lexical/Main
imports
  languages/java-15/lexical/UnicodeEscapes
  languages/java-15/lexical/LineTerminators
  languages/java-15/lexical/WhiteSpace
  languages/java-15/lexical/Comments
  languages/java-15/lexical/Identifiers
  languages/java-15/lexical/Keywords
  languages/java-15/lexical/Modifiers
  languages/java-15/lexical/literals/Main

module languages/java-15/Main
imports
  languages/java-15/lexical/Main
  languages/java-15/types/Main
  languages/java-15/names/Main
  languages/java-15/packages/Main
  languages/java-15/classes/Main
  languages/java-15/interfaces/Main
  languages/java-15/arrays/Main
  languages/java-15/statements/Main
  languages/java-15/expressions/Main


module languages/java/EmbeddedJava[E]
imports
  languages/java-15/Main

exports
  variables
    [ij]  [0-9\']*            -> DeciLiteral {prefer}
    [ij]  [\_] [a-zA-Z0-9\']* -> DeciLiteral {prefer}
    [xyz] [0-9\']*            -> ID          {prefer}
    [xyz] [\_] [a-zA-Z0-9\']* -> ID          {prefer}

  context-free restrictions
    ID -/- [\_a-zA-Z0-9\']

%%%
 %% Expressions
 %%%
exports

  %%%
   %% Variables for Expressions
   %%%
  variables
    "e"    [0-9\']*         -> Expr           {prefer}
    "e_" [a-zA-Z0-9\']*     -> Expr           {prefer}
    "e"    [0-9\']* "*"     -> {VarInit ","}* {prefer}
    "e_" [a-zA-Z0-9\']* "*" -> {VarInit ","}* {prefer}
    "e"    [0-9\']* "*"     -> {Expr ","}*    {prefer}
    "e_" [a-zA-Z0-9\']* "*" -> {Expr ","}*    {prefer}

  lexical syntax
    "e" [0-9\']*            -> ID {reject}
    "e_" [a-zA-Z0-9\']*     -> ID {reject}

  %%%
   %% Quotations for Expressions
   %%%
  context-free syntax
            "e" "|[" Expr "]|"   -> E {cons("ToMetaExpr")}
    "java:expr" "|[" Expr "]|"   -> E {cons("ToMetaExpr")}
         "expr" "|[" Expr "]|"   -> E {cons("ToMetaExpr")}
    "java"      "|[" Expr "]|"   -> E {cons("ToMetaExpr")}
                "|[" Expr "]|"   -> E {cons("ToMetaExpr")}

    "var-init" "|[" VarInit "]|" -> E {cons("ToMetaExpr")}

%%%
 %% Statements
 %%%
exports

  %%%
   %% Variables for Statements
   %%%
  variables
    "stm"  [0-9\']*             -> Stm         {prefer}
    "stm_" [a-zA-Z0-9\']*       -> Stm         {prefer}
    "bstm" [0-9\']*             -> BlockStm    {prefer}
    "bstm_" [a-zA-Z0-9\']*      -> BlockStm    {prefer}
    "bstm" [0-9\']* "*"         -> BlockStm*   {prefer}    
    "bstm_" [a-zA-Z0-9\']* "*"  -> BlockStm*   {prefer}

  %%%
   %% Quotations for Statements
   %%%
  context-free syntax
    "java:bstm"  "|[" BlockStm "]|" -> E {cons("ToMetaExpr")}
         "bstm"  "|[" BlockStm "]|" -> E {cons("ToMetaExpr")}
    "java"       "|[" BlockStm "]|" -> E {cons("ToMetaExpr")}
                 "|[" BlockStm "]|" -> E {cons("ToMetaExpr")}

    "java:bstm*" "|[" BlockStm* "]|" -> E {cons("ToMetaListExpr")}
         "bstm*" "|[" BlockStm* "]|" -> E {cons("ToMetaListExpr")}

    "java:block-stm"  "|[" BlockStm "]|" -> E {cons("ToMetaExpr")}
         "block-stm"  "|[" BlockStm "]|" -> E {cons("ToMetaExpr")}
    "java"            "|[" BlockStm "]|" -> E {cons("ToMetaExpr")}
                      "|[" BlockStm "]|" -> E {cons("ToMetaExpr")}

    "java:block-stm*" "|[" BlockStm* "]|" -> E {cons("ToMetaListExpr")}
         "block-stm*" "|[" BlockStm* "]|" -> E {cons("ToMetaListExpr")}


    "java:stm"  "|[" Stm "]|" -> E {cons("ToMetaExpr")}
         "stm"  "|[" Stm "]|" -> E {cons("ToMetaExpr")}
         
         "switch-group" "|[" SwitchGroup "]|" -> E {cons("ToMetaListExpr")}         
    "java:switch-group" "|[" SwitchGroup "]|" -> E {cons("ToMetaListExpr")}
    
  %%%
   %% Anti Quotations for Statements
   %%%
  context-free syntax
    "~"       E  -> BlockStm  {cons("FromMetaExpr")}
    "~bstm:"  E  -> BlockStm  {cons("FromMetaExpr")}
    "~*"      E  -> BlockStm* {cons("FromMetaExpr")}
    "~bstm*:" E  -> BlockStm* {cons("FromMetaExpr")}

    "~stm:"   E  -> Stm {cons("FromMetaExpr"), prefer}
    "~"       E  -> Stm {cons("FromMetaExpr")}

    "~*"              E -> SwitchGroup* {cons("FromMetaExpr")}    
    "~switch-group*:" E -> SwitchGroup* {cons("FromMetaExpr")}    

    "~"               E -> SwitchGroup {cons("FromMetaExpr")}
    "~switch-group:"  E -> SwitchGroup {cons("FromMetaExpr")}

%%%
 %% Variable Declarations
 %%%

  %%%
   %% Variables for Variable Declarations
   %%%
  variables
    "lvdec" [0-9]*            -> LocalVarDec    {prefer}
    "lvdec_" [a-zA-Z0-9]*     -> LocalVarDec    {prefer}
     "vdec" [0-9]*            -> VarDec         {prefer}
     "vdec_" [a-zA-Z0-9]*     -> VarDec         {prefer}
     "vdec"  [0-9]* "*"       -> {VarDec ","}+  {prefer}
     "vdec_" [a-zA-Z0-9]* "*" -> {VarDec ","}+  {prefer}

  lexical syntax
    "lvdec"               -> ID {reject}
    "lvdec_" [a-zA-Z0-9]* -> ID {reject}
     "vdec"               -> ID {reject}
     "vdec_" [a-zA-Z0-9]* -> ID {reject}

  %%%
   %% Quotations for Local Variable Declarations
   %%%
  context-free syntax
    "java:lvdec"  "|[" LocalVarDec "]|" -> E {cons("ToMetaExpr")}
         "lvdec"  "|[" LocalVarDec "]|" -> E {cons("ToMetaExpr")}

    "java:vdec" "|[" VarDec "]|" -> E {cons("ToMetaExpr")}
         "vdec" "|[" VarDec "]|" -> E {cons("ToMetaExpr")}

  %%%
   %% Anti Quotations for Local Variable Declarations
   %%%
  context-free syntax

%%%
 %% LeftHandSide of Assignment
 %%%
exports

  %%%
   %% Variables for LeftHandSide of Assignment
   %%%
  variables
    "lhs" [0-9\']* -> LHS {prefer}
    "e"   [0-9\']* -> LHS {prefer}

  lexical syntax
    "lhs" [0-9\']* -> ID {reject}

%%%
 %% Types
 %%%
exports

  %%%
   %% Variables for Types
   %%%
  variables
    MetaTypeVar     -> Type     {prefer}
    MetaPrimTypeVar -> PrimType {prefer}
    MetaRefTypeVar  -> RefType  {prefer}

  lexical syntax
    "t"  [0-9\']*        -> MetaTypeVar
    "t_" [a-zA-Z0-9\']*  -> MetaTypeVar
    "ty" [0-9]*          -> MetaTypeVar
    "ty_" [a-zA-Z0-9\']* -> MetaTypeVar

    "primt"  [0-9]*        -> MetaPrimTypeVar
    "primt_" [a-zA-Z0-9]*  -> MetaPrimTypeVar
    "primty" [0-9]*        -> MetaPrimTypeVar
    "primty_" [a-zA-Z0-9]* -> MetaPrimTypeVar
    "reft"   [0-9]*        -> MetaRefTypeVar
    "reft_" [a-zA-Z0-9]*   -> MetaRefTypeVar
    "refty"  [0-9]*        -> MetaRefTypeVar
    "refty_" [a-zA-Z0-9]*  -> MetaRefTypeVar

    "t"  [0-9\']*          -> ID {reject}
    "t_" [a-zA-Z0-9]*      -> ID {reject}
    "ty" [0-9]*            -> ID {reject}
    "ty_" [a-zA-Z0-9]*     -> ID {reject}
    "primt"  [0-9]*        -> ID {reject}
    "primt_" [a-zA-Z0-9]*  -> ID  {reject}
    "primty" [0-9]*        -> ID {reject}
    "primty_" [a-zA-Z0-9]* -> ID {reject}
    "reft"   [0-9]*        -> ID {reject}
    "reft_" [a-zA-Z0-9]*   -> ID {reject}    
    "refty"  [0-9]*        -> ID {reject}
    "refty_" [a-zA-Z0-9]*  -> ID {reject}

  lexical restrictions
    MetaTypeVar -/- [a-zA-Z0-9\_\$\']

  %%%
   %% Quotation for Types
   %%%
  context-free syntax
            "t" "|[" Type "]|"   -> E {cons("ToMetaExpr")}
           "ty" "|[" Type "]|"   -> E {cons("ToMetaExpr")}

    "java:type" "|[" Type "]|"   -> E {cons("ToMetaExpr")}
         "type" "|[" Type "]|"   -> E {cons("ToMetaExpr")}
    "java"      "|[" Type "]|"   -> E {cons("ToMetaExpr")}
                "|[" Type "]|"   -> E {cons("ToMetaExpr")}

  %%%
   %% Anti-Quotation for Types
   %%%
  context-free syntax
    "~"       E -> Type {cons("FromMetaExpr")}
    "~type:"  E -> Type {cons("FromMetaExpr")}

%%%
 %% Names
 %%%
exports

  %%%
   %% Variables for Names
   %%%
  variables
    "ambname"  [0-9]*        -> AmbName    {prefer}
    "ambname_" [a-zA-Z0-9]*  -> AmbName    {prefer}
    "ename"    [0-9]*        -> ExprName   {prefer}
    "ename_" [a-zA-Z0-9]*    -> ExprName   {prefer}
    "fname"    [0-9]*        -> MethodName {prefer}
    "fname_" [a-zA-Z0-9]*    -> MethodName {prefer}
    "tname"    [0-9]*        -> TypeName   {prefer}
    "tname_" [a-zA-Z0-9]*    -> TypeName   {prefer}
    "pkgtname" [0-9]*        -> PackageOrTypeName  {prefer}
    "pkgtname_" [a-zA-Z0-9]* -> PackageOrTypeName  {prefer}
    "pkgname" [0-9]*         -> PackageName  {prefer}
    "pkgname_" [a-zA-Z0-9]*  -> PackageName  {prefer}

  %%%
   %% Quotations for Names
   %%%
  context-free syntax
    "ambname"  "|[" AmbName    "]|" -> E {cons("ToMetaExpr")}
    "ename"    "|[" ExprName   "]|" -> E {cons("ToMetaExpr")}
    "fname"    "|[" MethodName "]|" -> E {cons("ToMetaExpr")}
    "tname"    "|[" TypeName   "]|" -> E {cons("ToMetaExpr")}
    "pkgtname" "|[" PackageOrTypeName "]|" -> E {cons("ToMetaExpr")}

%%%
 %% Modifiers
 %%%
exports

  %%%
   %% Variables for Modifiers
   %%%
  variables
     "mod" [0-9]*            -> MethodMod  {prefer}
     "mod_" [a-zA-Z0-9]*     -> MethodMod  {prefer}
     "mod" [0-9]* "*"        -> (Anno | MethodMod)* {prefer}
     "mod_" [a-zA-Z0-9]* "*" -> (Anno | MethodMod)* {prefer}
     
     "mod" [0-9]*            -> ClassMod  {prefer}
     "mod_" [a-zA-Z0-9]*     -> ClassMod  {prefer}
     "mod" [0-9]* "*"        -> (Anno | ClassMod)* {prefer}
     "mod_" [a-zA-Z0-9]* "*" -> (Anno | ClassMod)* {prefer}
     
     "mod" [0-9]*            -> ConstrMod  {prefer}
     "mod_" [a-zA-Z0-9]*     -> ConstrMod  {prefer}
     "mod" [0-9]* "*"        -> (Anno | ConstrMod)* {prefer}
     "mod_" [a-zA-Z0-9]* "*" -> (Anno | ConstrMod)* {prefer}
     
     "mod" [0-9]*            -> VarMod  {prefer}
     "mod_" [a-zA-Z0-9]*     -> VarMod  {prefer}
     "mod" [0-9]* "*"        -> (Anno | VarMod)* {prefer}
     "mod_" [a-zA-Z0-9]* "*" -> (Anno | VarMod)* {prefer}

     "mod" [0-9]*            -> FieldMod  {prefer}
     "mod_" [a-zA-Z0-9]*     -> FieldMod  {prefer}
     "mod" [0-9]* "*"        -> (Anno | FieldMod)* {prefer}
     "mod_" [a-zA-Z0-9]* "*" -> (Anno | FieldMod)* {prefer}

  %%%
   %% Quotations for Modifiers
   %%%
  context-free syntax
           "|[" Modifier "]|" -> E {cons("ToMetaExpr")}
    "mod"  "|[" Modifier "]|" -> E {cons("ToMetaExpr")}

    "anno" "|[" Anno "]|" -> E {cons("ToMetaExpr")}


%%%
 %% Formal Parameters
 %%%
exports

  %%%
   %% Variables for Formal Parameters
   %%%
  variables
     "param" [0-9]*            -> FormalParam  {prefer}
     "param_" [a-zA-Z0-9]*     -> FormalParam  {prefer}
     "param" [0-9]* "*"        -> {FormalParam ","}*  {prefer}
     "param_" [a-zA-Z0-9]* "*" -> {FormalParam ","}* {prefer}

  %%%
   %% Quotations for Formal Parameters
   %%%
  context-free syntax

         "param"  "|[" FormalParam "]|" -> E {cons("ToMetaExpr")}
    "java:param"  "|[" FormalParam "]|" -> E {cons("ToMetaExpr")}

         "param*" "|[" {FormalParam ","}* "]|" -> E {cons("ToMetaExpr")}
    "java:param*" "|[" {FormalParam ","}* "]|" -> E {cons("ToMetaExpr")}

    "java:formal-param" "|[" FormalParam "]|" -> E {cons("ToMetaExpr")}
         "formal-param" "|[" FormalParam "]|" -> E {cons("ToMetaExpr")}
    "java"              "|[" FormalParam "]|" -> E {cons("ToMetaExpr")}
                        "|[" FormalParam "]|" -> E {cons("ToMetaExpr")}

    "java:formal-param*" "|[" {FormalParam ","}* "]|" -> E {cons("ToMetaExpr")}
         "formal-param*" "|[" {FormalParam ","}* "]|" -> E {cons("ToMetaExpr")}
    "java"               "|[" {FormalParam ","}* "]|" -> E {cons("ToMetaExpr")}
                         "|[" {FormalParam ","}* "]|" -> E {cons("ToMetaExpr")}

  %%%
   %% Anti Quotations for Formal Parameters
   %%%
  context-free syntax
    "~"  E  ->  FormalParam       {cons("FromMetaExpr")}
    "~*" E  -> {FormalParam ","}* {cons("FromMetaExpr")}

%%%
 %% Package Declarations
 %%%
exports

  %%%
   %% Quotations
   %%%
  context-free syntax
    "java:package-dec" "|[" PackageDec  "]|" -> E {cons("ToMetaExpr")}
         "package-dec" "|[" PackageDec  "]|" -> E {cons("ToMetaExpr")}
                       "|[" PackageDec  "]|" -> E {cons("ToMetaExpr")}

    "java:package-dec?" "|[" PackageDec? "]|" -> E {cons("ToMetaExpr")}
         "package-dec?" "|[" PackageDec? "]|" -> E {cons("ToMetaExpr")}

  %%%
   %% Anti Quotations
   %%%
  context-free syntax
    "~package-dec:"  E -> PackageDec {cons("FromMetaExpr")}
    "~package-dec?:" E -> PackageDec? {cons("FromMetaExpr")}

%%%
 %% Import Declarations
 %%%
exports

  %%%
   %% Quotations for Import Declarations
   %%%
  context-free syntax

    "java:import-dec"  "|[" ImportDec  "]|" -> E {cons("ToMetaExpr")}
         "import-dec"  "|[" ImportDec  "]|" -> E {cons("ToMetaExpr")}
                       "|[" ImportDec  "]|" -> E {cons("ToMetaExpr")}

    "java:import-dec*" "|[" ImportDec* "]|" -> E {cons("ToMetaListExpr")}
         "import-dec*" "|[" ImportDec* "]|" -> E {cons("ToMetaListExpr")}

  %%%
   %% Anti Quotations for Import Declarations
   %%%
  context-free syntax

    "~import-dec:"  E  -> ImportDec  {cons("FromMetaExpr")}
    "~import-dec*:" E  -> ImportDec* {cons("FromMetaExpr")}

%%%
 %% Must be cleaned up
 %%%
exports
  context-free syntax
            "e" "|[" Expr "]|"   -> E {cons("ToMetaExpr")}
    "java:expr" "|[" Expr "]|"   -> E {cons("ToMetaExpr")}
         "expr" "|[" Expr "]|"   -> E {cons("ToMetaExpr")}
    "java"      "|[" Expr "]|"   -> E {cons("ToMetaExpr")}
                "|[" Expr "]|"   -> E {cons("ToMetaExpr")}

    "java:compilation-unit" "|[" CompilationUnit "]|"  -> E {cons("ToMetaExpr")}
         "compilation-unit" "|[" CompilationUnit "]|"  -> E {cons("ToMetaExpr")}
    "java"                  "|[" CompilationUnit "]|"  -> E {cons("ToMetaExpr")}
                            "|[" CompilationUnit "]|"  -> E {cons("ToMetaExpr")}

    "java:importdecl" "|[" ImportDec "]|"  -> E {cons("ToMetaExpr")}
         "importdecl" "|[" ImportDec "]|"  -> E {cons("ToMetaExpr")}
    "java"            "|[" ImportDec "]|"  -> E {cons("ToMetaExpr")}

    "java:type-dec" "|[" TypeDec "]|" -> E {cons("ToMetaExpr")}
         "type-dec" "|[" TypeDec "]|" -> E {cons("ToMetaExpr")}
    "java"          "|[" TypeDec "]|" -> E {cons("ToMetaExpr")}
                    "|[" TypeDec "]|" -> E {cons("ToMetaExpr")}

    "java:class-body-dec" "|["  ClassBodyDec  "]|" -> E {cons("ToMetaExpr")}
         "class-body-dec" "|["  ClassBodyDec  "]|" -> E {cons("ToMetaExpr")}
    "java"                "|["  ClassBodyDec  "]|" -> E {cons("ToMetaExpr")}
                          "|["  ClassBodyDec  "]|" -> E {cons("ToMetaExpr")}

    "java:interface-member-dec" "|[" InterfaceMemberDec  "]|" -> E {cons("ToMetaExpr")}
         "interface-member-dec" "|[" InterfaceMemberDec  "]|" -> E {cons("ToMetaExpr")}

    "java:constant-dec" "|[" ConstantDec  "]|" -> E {cons("ToMetaExpr")}
         "constant-dec" "|[" ConstantDec  "]|" -> E {cons("ToMetaExpr")}

    "java:class-body-dec*" "|[" ClassBodyDec* "]|" -> E {cons("ToMetaExpr")}
         "class-body-dec*" "|[" ClassBodyDec* "]|" -> E {cons("ToMetaExpr")}
    "java"                 "|[" ClassBodyDec* "]|" -> E {cons("ToMetaExpr")}
                           "|[" ClassBodyDec* "]|" -> E {cons("ToMetaListExpr")}

    "java:stm" "|["  Stm "]|" -> E {cons("ToMetaExpr")}
         "stm" "|["  Stm "]|" -> E {cons("ToMetaExpr")}

    "java:imember-dec" "|["  AbstractMethodDec  "]|" -> E {cons("ToMetaExpr")}
         "imember-dec" "|["  AbstractMethodDec  "]|" -> E {cons("ToMetaExpr")}
    "java"             "|["  AbstractMethodDec  "]|" -> E {cons("ToMetaExpr")}
                       "|["  AbstractMethodDec  "]|" -> E {cons("ToMetaExpr")}

    "java:imember-dec*" "|["  AbstractMethodDec*  "]|" -> E {cons("ToMetaExpr")}
         "imember-dec*" "|["  AbstractMethodDec*  "]|" -> E {cons("ToMetaExpr")}
    "java"              "|["  AbstractMethodDec*  "]|" -> E {cons("ToMetaExpr")}
                        "|["  AbstractMethodDec*  "]|" -> E {cons("ToMetaExpr")}

  %% Anti-quotation
  context-free syntax

    "~"      E -> Name {cons("FromMetaExpr")}
    "~name:" E -> Name {cons("FromMetaExpr")}
    "~*:"    E -> Name {cons("FromMetaExpr")}

    "~"     E     -> Id   {cons("FromMetaExpr")}
    "~id:"  E     -> Id   {cons("FromMetaExpr")}
    "~idd:" E ":" -> Id   {cons("FromMetaExpr")}

    "~x:" E -> ID {cons("FromMetaExpr")}

    "~"  E -> TypeParam        {cons("FromMetaExpr")}
    "~*" E -> {TypeParam ","}+ {cons("FromMetaExpr")}

    "~*" E -> {ExceptionType ","}* {cons("FromMetaExpr")}

    "~"      E  ->  Expr {cons("FromMetaExpr")}
    "~e:"    E  ->  Expr {prefer, cons("FromMetaExpr")}
    "~expr:" E  ->  Expr {prefer, cons("FromMetaExpr")}

    "~*" E      -> {Expr ","}*    {cons("FromMetaExpr")}
    "~*" E      -> {VarInit ","}* {cons("FromMetaExpr")}

    "~"  E  -> TypeDec  {cons("FromMetaExpr")}
    "~*" E  -> TypeDec* {cons("FromMetaExpr")}

    "~"  E  -> ClassBodyDec  {cons("FromMetaExpr")}
    "~*" E  -> ClassBodyDec* {cons("FromMetaExpr")}

    "~"  E  -> InterfaceMemberDec  {cons("FromMetaExpr")}
    "~*" E  -> InterfaceMemberDec* {cons("FromMetaExpr")}

    "~i:"      E -> DeciLiteral   {cons("FromMetaExpr")}
    "~deci:"   E -> DeciLiteral   {cons("FromMetaExpr")}
    "~hexa:"   E -> HexaLiteral   {cons("FromMetaExpr")}
    "~octa:"   E -> OctaLiteral   {cons("FromMetaExpr")}
    "~float:"  E -> FloatLiteral  {cons("FromMetaExpr")}
    "~string:" E -> StringLiteral {cons("FromMetaExpr")}
    "~char:"   E -> CharLiteral   {cons("FromMetaExpr")}

  syntax
    "~" <E-CF> -> StringChars {cons("FromMetaExpr"), prefer}
    "~" <E-CF> <LAYOUT?-CF> -> SingleChar  {cons("FromMetaExpr"), prefer}

module languages/java/EmbeddedJavaMix[Ctx0 E]
imports languages/java/EmbeddedJava[E]
          [ Name                  => Name[[Ctx0]]
            MetaRefTypeVar        => MetaRefTypeVar[[Ctx0]]
            MetaPrimTypeVar       => MetaPrimTypeVar[[Ctx0]]
            MetaTypeVar           => MetaTypeVar[[Ctx0]]
            CompilationUnit       => CompilationUnit[[Ctx0]]
            TypeDec               => TypeDec[[Ctx0]]
            ImportDec             => ImportDec[[Ctx0]]
            PackageDec            => PackageDec[[Ctx0]]
            ElemVal               => ElemVal[[Ctx0]]
            ElemValPair           => ElemValPair[[Ctx0]]
            Anno                  => Anno[[Ctx0]]
            LHS                   => LHS[[Ctx0]]
            CondMid               => CondMid[[Ctx0]]
            ArraySubscript        => ArraySubscript[[Ctx0]]
            DimExpr               => DimExpr[[Ctx0]]
            ArrayBaseType         => ArrayBaseType[[Ctx0]]
            ArrayCreationExpr     => ArrayCreationExpr[[Ctx0]]
            ClassMemberDec        => ClassMemberDec[[Ctx0]]
            ClassBodyDec          => ClassBodyDec[[Ctx0]]
            Interfaces            => Interfaces[[Ctx0]]
            Super                 => Super[[Ctx0]]
            ClassMod              => ClassMod[[Ctx0]]
            ClassDecHead          => ClassDecHead[[Ctx0]]
            ClassBody             => ClassBody[[Ctx0]]
            ClassDec              => ClassDec[[Ctx0]]
            InterfaceMod          => InterfaceMod[[Ctx0]]
            InterfaceMemberDec    => InterfaceMemberDec[[Ctx0]]
            ExtendsInterfaces     => ExtendsInterfaces[[Ctx0]]
            InterfaceDecHead      => InterfaceDecHead[[Ctx0]]
            InterfaceDec          => InterfaceDec[[Ctx0]]
            DefaultVal            => DefaultVal[[Ctx0]]
            AnnoElemDec           => AnnoElemDec[[Ctx0]]
            AnnoDecHead           => AnnoDecHead[[Ctx0]]
            AnnoDec               => AnnoDec[[Ctx0]]
            AbstractMethodMod     => AbstractMethodMod[[Ctx0]]
            AbstractMethodDec     => AbstractMethodDec[[Ctx0]]
            ConstantMod           => ConstantMod[[Ctx0]]
            ConstantDec           => ConstantDec[[Ctx0]]
            EnumBodyDecs          => EnumBodyDecs[[Ctx0]]
            EnumConstArgs         => EnumConstArgs[[Ctx0]]
            EnumConst             => EnumConst[[Ctx0]]
            EnumBody              => EnumBody[[Ctx0]]
            EnumDecHead           => EnumDecHead[[Ctx0]]
            EnumDec               => EnumDec[[Ctx0]]
            ConstrMod             => ConstrMod[[Ctx0]]
            ConstrInv             => ConstrInv[[Ctx0]]
            ConstrBody            => ConstrBody[[Ctx0]]
            ConstrHead            => ConstrHead[[Ctx0]]
            ConstrDec             => ConstrDec[[Ctx0]]
            StaticInit            => StaticInit[[Ctx0]]
            InstanceInit          => InstanceInit[[Ctx0]]
            MethodBody            => MethodBody[[Ctx0]]
            ExceptionType         => ExceptionType[[Ctx0]]
            Throws                => Throws[[Ctx0]]
            MethodMod             => MethodMod[[Ctx0]]
            VarMod                => VarMod[[Ctx0]]
            FormalParam           => FormalParam[[Ctx0]]
            ResultType            => ResultType[[Ctx0]]
            MethodDecHead         => MethodDecHead[[Ctx0]]
            MethodDec             => MethodDec[[Ctx0]]
            BlockStm              => BlockStm[[Ctx0]]
            Block                 => Block[[Ctx0]]
            CatchClause           => CatchClause[[Ctx0]]
            SwitchLabel           => SwitchLabel[[Ctx0]]
            SwitchGroup           => SwitchGroup[[Ctx0]]
            SwitchBlock           => SwitchBlock[[Ctx0]]
            Stm                   => Stm[[Ctx0]]
            LocalVarDec           => LocalVarDec[[Ctx0]]
            LocalVarDecStm        => LocalVarDecStm[[Ctx0]]
            FieldMod              => FieldMod[[Ctx0]]
            VarInit               => VarInit[[Ctx0]]
            Dim                   => Dim[[Ctx0]]
            VarDecId              => VarDecId[[Ctx0]]
            VarDec                => VarDec[[Ctx0]]
            FieldDec              => FieldDec[[Ctx0]]
            ArrayInit             => ArrayInit[[Ctx0]]
            ClassLiteral          => ClassLiteral[[Ctx0]]
            Literal               => Literal[[Ctx0]]
            Type                  => Type[[Ctx0]]
            ArrayType             => ArrayType[[Ctx0]]
            TypeVar               => TypeVar[[Ctx0]]
            TypeDecSpec           => TypeDecSpec[[Ctx0]]
            InterfaceType         => InterfaceType[[Ctx0]]
            ClassType             => ClassType[[Ctx0]]
            ClassOrInterfaceType  => ClassOrInterfaceType[[Ctx0]]
            RefType               => RefType[[Ctx0]]
            TypeVarId             => TypeVarId[[Ctx0]]
            TypeParams            => TypeParams[[Ctx0]]
            TypeBound             => TypeBound[[Ctx0]]
            TypeParam             => TypeParam[[Ctx0]]
            WildcardBound         => WildcardBound[[Ctx0]]
            ActualTypeArg         => ActualTypeArg[[Ctx0]]
            TypeArgs              => TypeArgs[[Ctx0]]
            PackageOrTypeName     => PackageOrTypeName[[Ctx0]]
            MethodName            => MethodName[[Ctx0]]
            ExprName              => ExprName[[Ctx0]]
            TypeName              => TypeName[[Ctx0]]
            AmbName               => AmbName[[Ctx0]]
            PackageName           => PackageName[[Ctx0]]
            FloatType             => FloatType[[Ctx0]]
            IntType               => IntType[[Ctx0]]
            NumType               => NumType[[Ctx0]]
            PrimType              => PrimType[[Ctx0]]
            NullLiteral           => NullLiteral[[Ctx0]]
            FooStringChars        => FooStringChars[[Ctx0]]
            StringChars           => StringChars[[Ctx0]]
            StringPart            => StringPart[[Ctx0]]
            StringLiteral         => StringLiteral[[Ctx0]]
            SingleChar            => SingleChar[[Ctx0]]
            CharContent           => CharContent[[Ctx0]]
            CharLiteral           => CharLiteral[[Ctx0]]
            LastOcta              => LastOcta[[Ctx0]]
            OctaEscape            => OctaEscape[[Ctx0]]
            NamedEscape           => NamedEscape[[Ctx0]]
            EscapeSeq             => EscapeSeq[[Ctx0]]
            Bool                  => Bool[[Ctx0]]
            BoolLiteral           => BoolLiteral[[Ctx0]]
            BinaryExponent        => BinaryExponent[[Ctx0]]
            HexaSignificand       => HexaSignificand[[Ctx0]]
            HexaFloatNumeral      => HexaFloatNumeral[[Ctx0]]
            SignedInteger         => SignedInteger[[Ctx0]]
            DeciFloatExponentPart => DeciFloatExponentPart[[Ctx0]]
            DeciFloatDigits       => DeciFloatDigits[[Ctx0]]
            DeciFloatNumeral      => DeciFloatNumeral[[Ctx0]]
            FloatLiteral          => FloatLiteral[[Ctx0]]
            HexaFloatLiteral      => HexaFloatLiteral[[Ctx0]]
            DeciFloatLiteral      => DeciFloatLiteral[[Ctx0]]
            IntLiteral            => IntLiteral[[Ctx0]]
            OctaNumeral           => OctaNumeral[[Ctx0]]
            HexaNumeral           => HexaNumeral[[Ctx0]]
            DeciNumeral           => DeciNumeral[[Ctx0]]
            OctaLiteral           => OctaLiteral[[Ctx0]]
            HexaLiteral           => HexaLiteral[[Ctx0]]
            DeciLiteral           => DeciLiteral[[Ctx0]]
            Modifier              => Modifier[[Ctx0]]
            StrictFP              => StrictFP[[Ctx0]]
            Synchronized          => Synchronized[[Ctx0]]
            Volatile              => Volatile[[Ctx0]]
            Transient             => Transient[[Ctx0]]
            Native                => Native[[Ctx0]]
            Static                => Static[[Ctx0]]
            Final                 => Final[[Ctx0]]
            Abstract              => Abstract[[Ctx0]]
            Protected             => Protected[[Ctx0]]
            Private               => Private[[Ctx0]]
            Public                => Public[[Ctx0]]
            Id                    => Id[[Ctx0]]
            ID                    => ID[[Ctx0]]
            Keyword               => Keyword[[Ctx0]]
            ArrayAccess           => ArrayAccess[[Ctx0]]
            FieldAccess           => FieldAccess[[Ctx0]]
            MethodSpec            => MethodSpec[[Ctx0]]
            Expr                  => Expr[[Ctx0]] ]


module xml-attribute
imports xml-names xml-text

exports

  context-free syntax

    QName "=" AttValue -> Attribute {cons("Attribute")}

  syntax

    "\"" DoubleQuotedPart* "\"" -> <AttValue-CF> {cons("DoubleQuoted")}
    "'"  SingleQuotedPart* "'" -> <AttValue-CF> {cons("SingleQuoted")}

    FooDoubleQuotedText -> DoubleQuotedPart {cons("Literal")}
    FooSingleQuotedText -> SingleQuotedPart {cons("Literal")}

    <DoubleQuotedText-LEX> -> FooDoubleQuotedText
    <SingleQuotedText-LEX> -> FooSingleQuotedText

    <Ref-CF> -> DoubleQuotedPart
    <Ref-CF> -> SingleQuotedPart

  lexical syntax

    ~[\&\<\"]+ -> DoubleQuotedText
    ~[\&\<\']+ -> SingleQuotedText

  lexical restrictions

    DoubleQuotedText -/- ~[\&\<\"]
    SingleQuotedText -/- ~[\&\<\']

module xml-text
exports

  lexical syntax
    [\ \t\n\13] -> WhiteSpaceChar

  syntax

    CharDataPart+ -> CharData {cons("Text")}

    FooCharDataText -> CharDataPart {cons("Literal")}
    <Ref-CF> -> CharDataPart
    "<![CDATA[" <CData-LEX> "]]>" -> CharDataPart {cons("CDATASection")}

    <CharDataText-LEX> -> FooCharDataText

  lexical syntax

    ~[\<\&]+ -> CharDataText

  lexical restrictions

    CharDataText -/- ~[\<\&]

  syntax

    "&#"  <NatConst-LEX> ";" -> <DecCharRef-CF> {cons("DecCharRef")}
    "&#x" <HexConst-LEX> ";" -> <HexCharRef-CF> {cons("HexCharRef")}
    "&"   <NCName-LEX>   ";" -> <EntityRef-CF>  {cons("EntityRef")}

  context-free syntax

    DecCharRef -> CharRef
    HexCharRef -> CharRef
    CharRef    -> Ref
    EntityRef  -> Ref

  lexical syntax

    [0-9]+       -> NatConst
    [0-9a-fA-F]+ -> HexConst

  lexical syntax

    (~[\]] | CloseBracket | TwoCloseBrackets )* -> CData

    "]"  -> CloseBracket
    "]]" -> TwoCloseBrackets

  lexical restrictions

    CloseBracket     -/- [\]]
    TwoCloseBrackets -/- [\>]
    CharDataToken    -/- ~[\<\&\]\ \t\n\13]

module xml-external

exports
  context-free syntax
    "SYSTEM" SystemLit           -> ExternalID {cons("SystemExternalID")}
    "PUBLIC" PublicLit SystemLit -> ExternalID {cons("PublicExternalID")}
    "PUBLIC" PublicLit           -> PublicID   {cons("PublicID")  }

  lexical syntax

    "\"" ~[\"]* "\""     -> SystemLit
    "'"  ~[\']* "'"     -> SystemLit
    "\"" PubIDChar* "\"" -> PublicLit
    "'"  PubIDChar* "'" -> PublicLit

    [a-zA-Z0-9] -> PubIDChar
    [\ \n\13\-\'\(\)\+\,\.\/\:\=\?\;\!\*\#\@\$\_\%] -> PubIDChar


module xml-pi
imports xml-names

exports
  context-free syntax
    "<?" PITarget PIChars "?>" -> PI {cons("PI")}

  lexical syntax
    NCName -> PITarget
    [Xx][Mm][Ll] -> PITarget {reject}

    ( ~[\?\>] | ( [\?] ~[\>] ) )* -> PIChars



module xml-prolog
imports xml-whitespace xml-names xml-comments xml-pi xml-external

exports
  context-free syntax

    XMLDecl? Misc* DocTypePrologue? -> Prologue {cons("Prologue")}
    Misc* -> Epilogue {cons("Epilogue")}
    Comment -> Misc {cons("Comment")}
    PI      -> Misc

  context-free syntax

    "<?xml" VersionInfo EncodingDecl? StandaloneDecl? "?>" -> XMLDecl {cons("XMLDecl")}

    "standalone" "=" StandaloneValue -> StandaloneDecl {cons("StandaloneDecl")}
    "version"    "=" VersionValue    -> VersionInfo    {cons("VersionDecl")}
    "encoding"   "=" EncodingValue   -> EncodingDecl   {cons("EncodingDecl")}

    "\"" YesNo "\"" -> StandaloneValue {cons("Standalone")}
    "'"  YesNo "'" -> StandaloneValue {cons("StandaloneSingle")}

    "\"" EncodingName "\"" -> EncodingValue {cons("Encoding")}
    "'"  EncodingName "'" -> EncodingValue {cons("EncodingSingle")}

    "\"" VersionNum "\"" -> VersionValue {cons("Version")}
    "'"  VersionNum "'"  -> VersionValue {cons("VersionSingle")}

  context-free syntax

    DocTypeDecl Misc* -> DocTypePrologue {cons("DocTypePrologue")}

    "<!DOCTYPE" QName ExternalID ">" -> DocTypeDecl {cons("DocTypeDecl")}

  lexical syntax

    [a-zA-Z0-9\_\.\:\-]+ -> VersionNum
    [A-Za-z] [A-Za-z0-9\.\_\-]* -> EncodingName

    "yes" -> YesNo
    "no"  -> YesNo


module xml-document
imports xml-prolog xml-whitespace xml-names xml-comments xml-text xml-attribute

exports
  sorts Document Element Content
  context-free syntax

    Prologue Element Epilogue -> Document {cons("Document")}

    "<" QName Attribute* "/>" -> Element {cons("EmptyElement")}

    Element -> Content
    Comment -> Content {cons("Comment")}
    PI      -> Content
  syntax

    CharData      -> <Content-CF>
    CDataSection  -> <Content-CF>

    "<"
    <LAYOUT?-CF> <QName-CF> <LAYOUT?-CF> <Attribute*-CF> <LAYOUT?-CF>
      ">" <Content-CF>* "</"
    <LAYOUT?-CF> <QName-CF> <LAYOUT?-CF>
    ">"  -> <Element-CF> {cons("Element")}

module xml-names

exports
  context-free syntax
    Qualifier? NCName -> QName     {cons("QName")}
    NCName ":"        -> Qualifier {cons("Prefix")}

  lexical syntax
    [A-Za-z\_] [A-Za-z0-9\.\-\_]* -> NCName

  lexical restrictions
    NCName -/- [A-Za-z0-9\.\-\_]

module xml-comments

exports
  lexical syntax
    "<!--" (~[\-] | Dash)* "-->" -> Comment
    "-" -> Dash

  lexical restrictions

    Dash -/- [\-]

module xml-whitespace

exports
  lexical syntax
    [\ \t\n\13] -> LAYOUT

  context-free restrictions
    LAYOUT? -/- [\ \t\n\13]

module xml-lexical
imports xml-whitespace xml-comments xml-names



module xml
imports xml-lexical xml-document
hiddens
  context-free start-symbols Document Content Attribute

module Stratego-xml
imports xml StrategoMix[StrategoHost]
hiddens
  context-free start-symbols Module[[StrategoHost]]

exports

  %% Term Quotation
  context-free syntax
    "%>" Document "<%" -> Term[[StrategoHost]]     {cons("ToTerm"), avoid}

    "@>" Attribute  "<@" -> Term[[StrategoHost]]   {cons("ToTerm"), prefer}
    "@>" Attribute* "<@" -> Term[[StrategoHost]]   {cons("ToTerm")}

  syntax
    "%>" <Content-CF>  "<%" -> <Term[[StrategoHost]]-CF> {cons("ToTerm"), prefer}
    "%>" <Content-CF>* "<%" -> <Term[[StrategoHost]]-CF> {cons("ToTerm")}

    "%>" <Content-CF>* "<%" <LAYOUT?-CF> "::" <LAYOUT?-CF> "*" -> <Term[[StrategoHost]]-CF> {cons("ToTerm")}

  %% Congruence Quotation
  context-free syntax  
    "%>" Document "<%" -> Strategy[[StrategoHost]] {cons("ToStrategy"), avoid}

  syntax
    "%>" <Content-CF>  "<%" -> <Strategy[[StrategoHost]]-CF> {cons("ToStrategy"), prefer}
    "%>" <Content-CF>* "<%" -> <Strategy[[StrategoHost]]-CF> {cons("ToStrategy")}

  %% Content Anti Quotation
  context-free syntax

    "<%=" Term[[StrategoHost]]                 "%>" -> Content {cons("FromTerm")}
    "<%=" Term[[StrategoHost]] "::" "content"  "%>" -> Content {cons("FromTerm")}

    "<%"  Strategy[[StrategoHost]]                 "%>" -> Content {cons("FromApp")}
    "<%"  Strategy[[StrategoHost]] "::" "content"  "%>" -> Content {cons("FromApp")}

  syntax

    "<%=" <LAYOUT?-CF> <Term[[StrategoHost]]-CF>    <LAYOUT?-CF> "::" <LAYOUT?-CF> "*"        <LAYOUT?-CF> "%>" -> <Content-CF>* {cons("FromTerm")}
    "<%" <LAYOUT?-CF> <Strategy[[StrategoHost]]-CF> <LAYOUT?-CF> "::" <LAYOUT?-CF> "*"        <LAYOUT?-CF> "%>" -> <Content-CF>* {cons("FromApp")}
    "<%" <LAYOUT?-CF> <Strategy[[StrategoHost]]-CF> <LAYOUT?-CF> "::" <LAYOUT?-CF> "content*" <LAYOUT?-CF> "%>" -> <Content-CF>* {cons("FromApp")}

  %% Character Data Anti Quotation
  syntax

    "<%" <LAYOUT?-CF> <Strategy[[StrategoHost]]-CF> <LAYOUT?-CF> "::" <LAYOUT?-CF> "cdata" <LAYOUT?-CF> "%>"
      -> FooCharDataText {cons("FromApp")}

    "<%=" <LAYOUT?-CF> <Term[[StrategoHost]]-CF> <LAYOUT?-CF> "::" <LAYOUT?-CF> "cdata" <LAYOUT?-CF> "%>"
      -> FooCharDataText {cons("FromTerm")}

  %% Anti quotation for attributes
  context-free syntax

    "<@"  Strategy[[StrategoHost]]          "@>" -> Attribute  {cons("FromApp")}
    "<@"  Strategy[[StrategoHost]] "::" "*" "@>" -> Attribute* {cons("FromApp")}

    "<@="  Term[[StrategoHost]]          "@>" -> Attribute  {cons("FromTerm")}
    "<@="  Term[[StrategoHost]] "::" "*" "@>" -> Attribute* {cons("FromTerm")}

  syntax
    %% obsolete
    "<"  <Term[[StrategoHost]]-CF> -> <Attribute-CF>  {cons("FromTerm")}
    "<*" <Term[[StrategoHost]]-CF> -> <Attribute*-CF> {cons("FromTerm")}

  %% Attribute Value Anti Quotation
  context-free syntax

    "<@"  Strategy[[StrategoHost]] "@>" -> AttValue   {cons("FromApp")}
    "<@=" Term[[StrategoHost]]     "@>" -> AttValue   {cons("FromTerm")}

    %% obsolete
    "<%"  Strategy[[StrategoHost]] "%>" -> AttValue   {cons("FromApp")}
    "<%=" Term[[StrategoHost]]     "%>" -> AttValue   {cons("FromTerm")}

  %% Attribute Character Data Anti Quotation
  syntax

    "<%" <LAYOUT?-CF> <Strategy[[StrategoHost]]-CF> <LAYOUT?-CF> "%>"
      -> FooDoubleQuotedText {cons("FromApp")}

    "<%=" <LAYOUT?-CF> <Term[[StrategoHost]]-CF> <LAYOUT?-CF> "%>"
      -> FooDoubleQuotedText {cons("FromTerm")}

    "<%" <LAYOUT?-CF> <Strategy[[StrategoHost]]-CF> <LAYOUT?-CF> "::" <LAYOUT?-CF> "cdata" <LAYOUT?-CF> "%>"
      -> FooDoubleQuotedText {cons("FromApp")}

    "<" <Term[[StrategoHost]]-CF> -> FooDoubleQuotedText {cons("FromTerm")}

  %% Anti quotation for element. This anti quotation is only used if anti quotation
  %% is used for the root element of an document.
  context-free syntax

    "<%" Strategy[[StrategoHost]] "%>" -> Element {cons("FromApp"), avoid}

  %% Name Anti-Quotation
  syntax

    "<"   <Term[[StrategoHost]]-CF> -> <NCName-CF> {cons("FromTerm")}
    "~n:" <Term[[StrategoHost]]-CF> -> <NCName-CF> {cons("FromTerm")}

  variables
    "@"    [0-9]*     -> Attribute
    "att"  [0-9]*     -> Attribute
    "@"    [0-9]* "*" -> Attribute*
    "att"  [0-9]* "*" -> Attribute*
    "atts" [0-9]*     -> Attribute*
    "qn"   [0-9]*     -> QName {prefer}

module DeriveMix

imports
  Derive

exports

  context-free syntax
    "derivebodyelem" "|[" DeriveBodyElement "]|" -> E {cons("ToMetaExpr")}
             
  variables
    "bodyelem" [0-9]*           -> DeriveBodyElement {prefer}
    "bodyelem_"[A-Za-z0-9]+     -> DeriveBodyElement {prefer}
    "bodyelem" [0-9]* "*"       -> DeriveBodyElement* {prefer}
    "bodyelem_"[A-Za-z0-9]+ "*" -> DeriveBodyElement* {prefer}

module StylingMix

imports
  Styling

exports

  context-free syntax
    "stsec"   "|[" StyleSection "]|" 				-> E {cons("ToMetaExpr")}
              "|[" StyleSection "]|" 				-> E {cons("ToMetaExpr")}
    "stsec*"  "|[" StyleSection* "]|" 				-> E {cons("ToMetaExpr")}
    "stdef"   "|[" StyleDefinition "]|" 			-> E {cons("ToMetaExpr")}
			  "|[" StyleDefinition "]|" 			-> E {cons("ToMetaExpr")}
    "stdef*"  "|[" StyleDefinition* "]|" 			-> E {cons("ToMetaExpr")}
    		  "|[" StyleDefinition* "]|" 			-> E {cons("ToMetaExpr")}
    "ststat"  "|[" StyleStatement "]|" 				-> E {cons("ToMetaExpr")}
              "|[" StyleStatement "]|" 				-> E {cons("ToMetaExpr")}
    "ststat*" "|[" StyleStatement* "]|" 			-> E {cons("ToMetaExpr")}
              "|[" StyleStatement* "]|" 			-> E {cons("ToMetaExpr")}
%%    "stdecl"  "|[" StyleDeclaration "]|" 			-> E {cons("ToMetaExpr")}
%%              "|[" StyleDeclaration "]|" 			-> E {cons("ToMetaExpr")}
%%    "stdecl*" "|[" StyleDeclaration* "]|" 			-> E {cons("ToMetaExpr")}

  variables
    "stsec"   [0-9]* 	 -> StyleSection  {prefer}
    "stsec*"  [0-9]* "*" -> StyleSection  {prefer}
    "stdef" [0-9]*     	 -> StyleDefinition  {prefer}
    "stdef" [0-9]* "*"   -> StyleDefinition* {prefer}
    "ststat"  [0-9]*     -> StyleStatement  {prefer}
    "ststat"  [0-9]* "*" -> StyleStatement* {prefer}
    "stdecl"  [0-9]*     -> StyleDeclaration  {prefer}
    "stdecl"  [0-9]* "*" -> StyleDeclaration* {prefer}
       
  context-free syntax
    "stsel" "|[" Selector "]|" -> E {cons("ToMetaExpr")}
    "stssel" "|[" SimpleSelector "]|" -> E {cons("ToMetaExpr")}
%%    "stssel" "|[" SimpleSelector "]|" -> E {cons("ToMetaExpr")}
    "stcomb" "|[" Combinator "]|" -> E {cons("ToMetaExpr")}
             "|[" (Combinator SimpleSelector) "]|" -> E {cons("ToMetaExpr")}
             "|[" (Combinator SimpleSelector)* "]|" -> E {cons("ToMetaExpr")}
             "|[" (Combinator SimpleSelector SelectorAttribute) "]|" -> E {cons("ToMetaExpr")}
             "|[" (Combinator SimpleSelector SelectorAttribute)* "]|" -> E {cons("ToMetaExpr")}
             
  variables
    "stsel" [0-9]*  		-> Selector {prefer}
    "stssel" [0-9]*  		-> SimpleSelector {prefer}
    "stcomb" [0-9]*  		-> Combinator {prefer}
    "stcombsel" [0-9]*  		-> (Combinator SimpleSelector) {prefer}
    
    "stmargs" [0-9]*  		-> MatchDefinitionArgs {prefer}
    "stmid"[0-9]* 			-> MatchIdent {prefer}
    [abc]"_"[A-Za-z0-9]+ 	-> MatchIdent {prefer}    

  context-free syntax
    "stprop"  "|[" StyleProperty "]|" 			-> E {cons("ToMetaExpr")}
    "stprop*" "|[" StyleProperty* "]|" 			-> E {cons("ToMetaExpr")}
    "stprop"  "|[" StylePropertyValue "]|" 		-> E {cons("ToMetaExpr")}
    "stprop*" "|[" StylePropertyValue* "]|" 		-> E {cons("ToMetaExpr")}
              "|[" StyleExpression "]|" 		-> E {cons("ToMetaExpr")}
              "|[" StyleValueExtension "]|" 		-> E {cons("ToMetaExpr")}
    "stval"   "|[" StyleValue "]|" 				-> E {cons("ToMetaExpr")}
    "stval*"  "|[" StyleValue* "]|" 				-> E {cons("ToMetaExpr")}

  variables
    "stprop" [0-9]*  	-> StyleProperty {prefer}
    "stprop" [0-9]* "*"  -> StyleProperty* {prefer}
    "stprop" [0-9]*  	-> StylePropertyValue {prefer}
    "stprop" [0-9]* "*"  -> StylePropertyValue* {prefer}
    "stexpr" [0-9]       -> StyleExpression {prefer}
    "stvalex" [0-9]       -> StyleValueExtension {prefer}
    "stval"  [0-9]*  	-> StyleValue {prefer}
    "stval"  [0-9]* "*"  -> StyleValue* {prefer}

module AccessControlMix

imports
  AccessControl

exports

  context-free syntax
    "acrule" "|[" AccessControlRule "]|" -> E {cons("ToMetaExpr")}
             "|[" AccessControlRule "]|" -> E {cons("ToMetaExpr")}
    "acdef"  "|[" AccessControlDefinition "]|" -> E {cons("ToMetaExpr")}
             "|[" AccessControlDefinition "]|" -> E {cons("ToMetaExpr")}


  variables
    "acrule" [0-9]*     -> AccessControlRule  {prefer}
    "acrule" [0-9]* "*" -> AccessControlRule* {prefer}
    "acdef"  [0-9]*     -> AccessControlDefinition  {prefer}
    "acdef"  [0-9]* "*" -> AccessControlDefinition* {prefer}
       
  context-free syntax
    "margs" "|[" MatchArgs "]|" -> E {cons("ToMetaExpr")}
            "|[" MatchArgs "]|" -> E {cons("ToMetaExpr")}
             
  variables
    "margs" [0-9]*  -> MatchArgs {prefer}
    
  context-free syntax
    "pexp"  "|[" PolicyExp "]|" -> E {cons("ToMetaExpr")}
            "|[" PolicyExp "]|" -> E {cons("ToMetaExpr")}        
             
  variables
    "pexp" [0-9]*  -> PolicyExp {prefer}
    
  variables
    "mid"[0-9]* -> MatchId {prefer}
    [xyz]"_"[A-Za-z0-9]+ -> MatchId {prefer}

module StringSelectEntity

%% syntax for string-select-entity

exports
  sorts TemplateDefinition

  context-free syntax
  
  "string-select-entity" Id "{" {String ","}* "}" -> TemplateDefinition {cons("StringSelectEntity")}

module TemplateMarkdown

exports

  sorts TemplateElement

context-free syntax

  "[" {PropertyAssignment ","}*"]" -> MDProps{cons("MDProps")}

  "*"  MDProps? TemplateElement		-> TemplateElement{cons("MDListItem")}
  "*"  MDProps? "{" TemplateElement* "}"	-> TemplateElement{cons("MDListItemMulti")}  
  "--" MDProps?						-> TemplateElement{cons("MDSpacer")}
  "="  MDProps? TemplateElement  "="-> TemplateElement{cons("MDHeader")} %%TemplateElement* would be amb
  "#" MDProps? "{" TemplateElement* "}"-> TemplateElement{cons("MDBlock")}
  "<"  MDProps? MDCol* ">" 			-> TemplateElement{cons("MDRow")}
  "<"  MDProps? TemplateElement* ">"-> TemplateElement{cons("MDRowNoCols")}  
  "|"  MDProps? TemplateElement*	-> MDCol{cons("MDCol")}
  "~"  MDProps? Exp ":" TemplateElement -> TemplateElement{cons("MDNavigate")}

module Procedures

exports
  sorts Section Definition

  context-free syntax

	"procedure" Id "(" FormalArg ")" "{"
	   ProcedureElement* 
	"}"                             -> Procedure {cons("Procedure")}

	"auto" "procedure" Id "(" FormalArg ")" "{"
	   ProcedureElement* 
	"}"                             -> Procedure {cons("AutoProcedure")}

  "extend" "procedure" Id "(" FormalArg ")" "{"
	   ProcedureElement* 
	"}"                             -> Definition {cons("ExtendProcedure")}

  Procedure                       -> Definition

	"who" "{" Exp "}"               -> ProcedureElement {cons("ProcedureWho")}
	"when" "{" Exp "}"					    -> ProcedureElement {cons("ProcedureWhen")}
	"do" Block							        -> ProcedureElement {cons("ProcedureDo")}
	"done" Block							      -> ProcedureElement {cons("ProcedureDone")}
	"enabled" Block							    -> ProcedureElement {cons("ProcedureEnabled")}
	"disabled" Block						    -> ProcedureElement {cons("ProcedureDisabled")}
	"view" "{" TemplateElement* "}" -> ProcedureElement {cons("ProcedureView")}
	
	"process" "{" ProcessExp "}"    -> ProcedureElement {cons("ProcedureProcess")}
	"processed" Block							  -> ProcedureElement {cons("ProcedureProcessed")}
	
  sorts ProcessExp
  
context-free syntax
    
    Id "(" Exp ")"                -> CallProcessExp {cons("ProcCall")} 
    CallProcessExp                -> ProcessExp                        
    ProcessExp ";" ProcessExp     -> ProcessExp {cons("ProcSeq"), left}
    
    "while" "(" Exp ")" "{" 
      ProcessExp 
    "}"                           -> ProcessExp {cons("ProcWhile")}
    
    "repeat" "{" 
      ProcessExp 
    "}" "until" CallProcessExp    -> ProcessExp {cons("ProcRepeatUntil")}

    "if" "(" Exp ")" "{" 
      ProcessExp 
     "}"                          -> ProcessExp {cons("ProcIfNoElse")}
    
    "if" "(" Exp ")" "{" 
      ProcessExp 
    "}" "else" "{" 
      ProcessExp 
    "}"                           -> ProcessExp {cons("ProcIf")}
    
    ProcessExp "xor" ProcessExp   -> ProcessExp {cons("ProcXor")}
    ProcessExp "and" ProcessExp   -> ProcessExp {cons("ProcAnd")}
    
    ProcessExp "+" ProcessExp     -> ProcessExp {cons("ProcPlus")}
    
    "(" ProcessExp ")"            -> ProcessExp {bracket}
  
  context-free priorities  
      {left:
        ProcessExp "and" ProcessExp  -> ProcessExp}
    > {left:
        ProcessExp "xor" ProcessExp  -> ProcessExp
        ProcessExp "+"   ProcessExp  -> ProcessExp }
    > {left:
        ProcessExp ";"   ProcessExp  -> ProcessExp {cons("ProcSeq"), left}}

module Derive

%% syntax for derivation of pages
exports

  sorts Derive DeriveType DeriveProperty

context-free syntax

  "derive" Id "from" Exp "for" "(" 
    {DeriveProperty ","}* 
  ")"                               -> TemplateElement {cons("Derive"), prefer}
  "derive" Id "from" Exp            -> TemplateElement {cons("Derive"), prefer}
  %%"derive" Id                       -> TemplateElement {cons("Derive"), prefer}
  %% Disabled this one for now because it is causing ambiguities, have a look at this Ruben!
  
  "derive" Id "from" Exp "for" "(" 
    {DeriveProperty ","}* 
  ")" DeriveBody                    -> TemplateElement {cons("Derive"), prefer}
  "derive" Id "from" Exp DeriveBody -> TemplateElement {cons("Derive"), prefer}
  "derive" Id DeriveBody            -> TemplateElement {cons("Derive"), prefer}
  
  Id                                -> DeriveProperty {cons("DeriveDefault")}
  Id "(" Id ")"                     -> DeriveProperty {cons("DeriveMode")}
  
  "{" DeriveBodyElement* "}"        -> DeriveBody {cons("DeriveBody")}
  
  Id "{" TemplateElement* "}"       -> DeriveBodyElement {cons("DeriveBodyElement")}
  
  "derive"                          -> TemplateCall {reject}

module PagedFor

%% syntax for paged enumerations

exports
  sorts TemplateElement

  context-free syntax

    "for" "(" Id ":" Sort Filter "per" Exp ")"
       "{" TemplateElement* "}"                             -> TemplateElement {cons("PagedForAll")}

    "for" "(" Id ":" Sort "per" Exp ")"
       "{" TemplateElement* "}"                             -> TemplateElement {cons("PagedForAllNoFilter")}

    "for" "(" Id ":" Sort "in" Exp Filter "per" Exp ")"
       "{" TemplateElement* "}"                             -> TemplateElement {cons("PagedFor")}

    "for" "(" Id ":" Sort "in" Exp "per" Exp ")"
       "{" TemplateElement* "}"                             -> TemplateElement {cons("PagedForNoFilter")}

module Enums

%% syntax for enumeration types

exports
  sorts Defintion EnumValue

  context-free syntax

  "enum" Id "{" {EnumValue ","}* "}"                    -> Definition {cons("Enum")}

  Id "(" String ")"                               -> EnumValue {cons("EnumValue")}

module Styling

%% syntax for styling of WebDSL applications

exports

  sorts
    Name StNum String UnaryOperator

  lexical syntax
    [a-zA-Z\_][a-zA-Z0-9\_\-]*			-> Identifier
    [a-zA-Z][a-zA-Z\-\_]+          		-> ValueName
    [a-z][a-z\-]+           	   		-> Value
    [a-f0-9][a-f0-9][a-f0-9][a-f0-9]* 		-> Hex
    [a-z\%]+                       		-> Unit
%%    [0-9]+                			-> StNum
%%    [0-9]* "." [0-9]+     			-> StNum
    "'" ~[\"\n]* "'"               		-> String
%%    [\-\+] StNum				-> StNumber

  lexical syntax
    [a-zA-Z][a-zA-Z0-9\_]*		 -> MatchIdent
%%    [a-zA-Z][a-zA-Z0-9\_]*[\*]? -> MatchIdent
%%    [\*]                        -> MatchIdent
%%    [\*]                        -> StWildCardArg 

  lexical restrictions
    ValueName 	-/- [a-zA-Z\-\_]
    Value 	-/- [a-z\-]
    Unit 	-/- [a-z\%]
    Hex 	-/- [a-f0-9]

exports

  sorts
     StNumber

  lexical syntax
    Float		      -> StNum
    SignedInteger	      -> StNum
    StNum                     -> StNumber
    StNum "%"                 -> Percentage {prefer}
    StNum "em"                -> Ems {prefer}
    StNum "ex"                -> Exs {prefer}
    StNum "px"                -> Length {prefer}
    StNum "cm"                -> Length {prefer}
    StNum "mm"                -> Length {prefer}
    StNum "in"                -> Length {prefer}
    StNum "pt"                -> Length {prefer}
    StNum "pc"                -> Length {prefer}
    StNum "deg"               -> Angle {prefer}
    StNum "rad"               -> Angle {prefer}
    StNum "grad"              -> Angle {prefer}
    StNum "ms"                -> Time {prefer}
    StNum "s"                 -> Time {prefer}
    StNum "hz"                -> Freq {prefer}
    StNum "khz"               -> Freq {prefer}
%%    StNum Id                  -> Dimension {prefer}

context-free syntax

  "theme" Modifier Id "(" ")" "{" StyleDeclaration* "}" -> Definition {cons("ThemeDefinition"), prefer}

context-free syntax %% Styling syntax

  "style" Id StyleDefinition*        -> Section {cons("StyleSection"), prefer}

  Selector "{" StyleStatement* "}"   -> StyleDefinition {cons("StyleDefinition")}

context-free syntax %% selectors

  SimpleSelector
    (Combinator SimpleSelector SelectorAttribute?)* -> Selector {cons("Selector")}

  Id MatchDefinition 			-> SimpleSelector {cons("SimpleSelector")}
  "#" Identifier			-> SimpleSelector {cons("IdSimpleSelector")}
  Id					-> SimpleSelector {cons("ElemSimpleSelector")}
  Id SelectorAttribute+		-> SimpleSelector {cons("ElemSimpleAttrSelector"), prefer}
  Id "." Identifier	SelectorAttribute+		-> SimpleSelector {cons("ElemClassAttrSelector"), prefer}
  "." Identifier 			-> SimpleSelector {cons("ClassSimpleSelector")}  
  MatchDefinition       		-> SimpleSelector {cons("SimpleSelector")}
  "*"			        	-> SimpleSelector {cons("UniversalSimpleSelector")}
  
  ":" ValueName				-> SelectorAttribute {cons("SelectorAttribute")}
  
  ">"                   		-> Combinator {cons("ChildCombinator")}
  ">>"                   		-> Combinator {cons("DescendantCombinator"), prefer}

  MatchIdent "(" MatchDefinitionArgs ")"		-> MatchDefinition {cons("MatchDefinition")}
  {FormalArg ","}*                                      -> MatchDefinitionArgs

  "const" Id ":" StyleSort ";" 				-> StyleVarDecl {cons("StyleVarDecl")}
  "const" Id ":" StyleSort ":=" StyleExpression ";" 	-> StyleVarDecl {cons("StyleVarDeclInit")}
  
  StyleVarDecl						-> StyleDefinition
  
  StyleProperty ":=" StyleExpression ";"      	        -> StyleStatement {cons("StyleDeclaration")}
%%  StylePropertyLocal ":=" StyleProperty ";"    	-> StyleStatement {cons("StyleDeclaration")}

  ValueName						-> StyleProperty {cons("StyleProperty")}

  MatchDefinition "." StyleProperty			-> StyleExpression {cons("StylePropertyValue")}

  Id 							-> StyleExpression {cons("StyleVar")}

  StyleValue 						-> StyleExpression
%%  StyleValues -> StyleExpression

  "(" Selector ")" "." StyleProperty 			-> StyleExpression {cons("StyleValueExpression")}

  StyleExpression "+" StyleExpression 			-> StyleExpression {cons("StyleAdd"),assoc}
  StyleExpression "-" StyleExpression 			-> StyleExpression {cons("StyleSub"),assoc}
  StyleExpression "*" StyleExpression 			-> StyleExpression {cons("StyleMul"),assoc}
  StyleExpression "/" StyleExpression 			-> StyleExpression {cons("StyleDiv"),assoc}

  StNumber Unit 					-> StyleValue {cons("StyleValue")}
  StNumber 						-> StyleValue {cons("StyleValue")}
  StyleSort StyleValueExtension+			-> StyleValue {cons("StyleValue")}
  Uri 							-> StyleValue {cons("StyleValue")}
  Hash 							-> StyleValue {cons("StyleValue")}
  Value		 					-> StyleValue {cons("StyleValue"), prefer}
  String	 					-> StyleValue {cons("StyleValue")}
  
  "." ValueName						-> StyleValueExtension {cons("StyleValueExtension") }

%%  {StyleValue "|"}* -> StyleValue {cons("StyleValueOptions") }

  Id Unit 						-> StyleSort {cons("StyleSort")}
  Id							-> StyleSort {cons("StyleSort")}

  "url" "(" String ")"    				-> Uri {cons("Uri")}
  "#" Hex                 				-> Hash {cons("Hash")}

  "const" 	-> Id {reject}  
%%  "layout" 	-> Id {reject}
%%  "style" 	-> Id {reject}
%%  "theme" 	-> Id {reject}

context-free priorities
  
  {left:
       StyleExpression "*" StyleExpression -> StyleExpression
       StyleExpression "/" StyleExpression -> StyleExpression }
  > {left:
       StyleExpression "+" StyleExpression -> StyleExpression
       StyleExpression "-" StyleExpression -> StyleExpression}

context-free syntax %% Layout syntax

  "layout" LayoutDefinition* 				-> Section {cons("LayoutSection"), prefer}

  Id MatchDefinition "{" LayoutStatement* "}"   	-> LayoutDefinition {cons("LayoutDefinition")}
  MatchDefinition "{" LayoutStatement* "}"   		-> LayoutDefinition {cons("LayoutDefinition")}
  
  StyleDefinition					-> LayoutDefinition
%%  StyleStatement					-> LayoutStatement
  
  "float" "{" MatchDefinition* "}" ";"			-> LayoutStatement {cons("FloatStatement")}
  
  LayoutExpression ";"                                  -> LayoutStatement {cons("LayoutStatement")}
  Id ":" "[" LayoutExpressions "]"     		        -> LayoutExpression {cons("NamedLayoutExpression")}
  {LayoutExpression "|"}+				-> LayoutExpressions
  Id			 				-> LayoutExpression {cons("LayoutExpression")}
  MatchDefinition 					-> LayoutExpression {cons("LayoutExpression")}

module ValidationAnnos
exports
  sorts Annotation PatternFlag

  context-free syntax
	%%string
    "length" "(" Int "," Int ")"              -> Annotation {cons("ValidationAnnoLength"),prefer}
    "minlength" "(" Int ")"                   -> Annotation {cons("ValidationAnnoMinLength"),prefer}   
    "maxlength" "(" Int ")"                   -> Annotation {cons("ValidationAnnoMaxLength"),prefer}    
 	"notempty"                                -> Annotation {cons("ValidationAnnoNotEmpty"),prefer}  
  	"email"                                   -> Annotation {cons("ValidationAnnoEmail"),prefer} 	 
  	"creditcardnumber"                        -> Annotation {cons("ValidationAnnoCreditCardNumber"),prefer} 	
 	"EAN"                                     -> Annotation {cons("ValidationAnnoEAN"),prefer} 
  	"pattern" "(" String ")"                  -> Annotation {cons("ValidationAnnoPattern"),prefer}   
  	"pattern" "(" String "," PatternFlag* ")" -> Annotation {cons("ValidationAnnoPatternWithFlags"),prefer}
  	
  	"canonicalequivalence"                    -> PatternFlag {cons("FlagCanonEq")} %% CANON_EQ Enables canonical equivalence.    
	"caseinsensitive"                         -> PatternFlag {cons("FlagCaseInsensitive")} %% CASE_INSENSITIVE Enables case-insensitive matching.
 	"comments"                                -> PatternFlag {cons("FlagComments")} %% COMMENTS Permits whitespace and comments in pattern.
 	"dotall"                                  -> PatternFlag {cons("FlagDotAll")} %% DOTALL Enables dotall mode.
 	"literal"                                 -> PatternFlag {cons("FlagLiteral")} %% LITERAL Enables literal parsing of the pattern.
 	"multiline"                               -> PatternFlag {cons("FlagMultiline")} %% MULTILINE Enables multiline mode.
 	"unicodecase"                             -> PatternFlag {cons("FlagUnicodeCase")} %% UNICODE_CASE Enables Unicode-aware case folding.
 	"unixlines"                               -> PatternFlag {cons("FlagUnixLines")} %% UNIX_LINES Enables Unix lines mode.
                 
	%%numeric or string representation of numeric
	"max" "(" Int ")"                         -> Annotation {cons("ValidationAnnoMax"),prefer} 
	"min" "(" Int ")"                         -> Annotation {cons("ValidationAnnoMin"),prefer}
    "range" "(" Int "," Int ")"               -> Annotation {cons("ValidationAnnoRange"),prefer}
    "minrange" "(" Int ")"                    -> Annotation {cons("ValidationAnnoMinRange"),prefer}   
    "maxrange" "(" Int ")"                    -> Annotation {cons("ValidationAnnoMaxRange"),prefer} 
    "digits" "(" Int "," Int ")"              -> Annotation {cons("ValidationAnnoDigits"),prefer}  
     
	%%date/calendar
	"past"                                    -> Annotation {cons("ValidationAnnoPast"),prefer} 
	"future"                                  -> Annotation {cons("ValidationAnnoFuture"),prefer} 	
	
	%%array, collection, map	
    "size" "(" Int "," Int ")"                -> Annotation {cons("ValidationAnnoSize"),prefer}
    "minsize" "(" Int ")"                     -> Annotation {cons("ValidationAnnoMinSize"),prefer}   
    "maxsize" "(" Int ")"                     -> Annotation {cons("ValidationAnnoMaxSize"),prefer} 
    
	%%object
  	"notnull"                                 -> Annotation {cons("ValidationAnnoNotNull"),prefer }
  	"asserttrue"                              -> Annotation {cons("ValidationAnnoAssertTrue"),prefer} 
  	"assertfalse"                             -> Annotation {cons("ValidationAnnoAssertFalse"),prefer} 
   	"valid"                                   -> Annotation {cons("ValidationAnnoValid"),prefer}

module AccessControl

%% syntax for access control  
exports

  sorts MatchId

  lexical syntax
    [a-zA-Z][a-zA-Z0-9\_]*[\*]? -> MatchId
    [\*]                        -> MatchId
    [\*]                        -> WildCardArg 

context-free syntax

  "access" "control" "rules" Id? AccessControlDefinition*  -> Section {cons("AccessControlDefinition")}
  %%deprecated: 
  "access" "control" "rules" "{" Id? AccessControlDefinition* "}"  -> Section {cons("AccessControlDefinition")}
  
  "principal" "is" Id "with" "credentials" {Id ","}+            -> Definition {cons("AccessControlPrincipal")} 
  "principal" "is" Id "with" "credentials" {Id ","}+            -> AccessControlDefinition {cons("AccessControlPrincipal")} 
  
  AccessControlRule                                             -> AccessControlDefinition
 
  "rule" Id MatchId "(" MatchArgs ")"
  "{" AccessControlCheck AccessControlRule* "}"                 -> AccessControlRule {cons("AccessControlRule")}
  %%deprecated:
  "rules" Id MatchId "(" MatchArgs ")"
  "{" AccessControlCheck AccessControlRule* "}"                 -> AccessControlRule {cons("AccessControlRule")}

  {FormalArg ","}* WildCardArg?                                 -> MatchArgs {cons("MatchArgs"),prefer}
  {Exp ","}* WildCardArg?                                       -> MatchArgs {cons("MatchArgs")}

  %% to prevent an AccessControlRule becoming an AccessControlCheck
  "rules"                                                       -> Exp {reject}

  Exp                                                           -> AccessControlCheck
  
  %% pagecheck
  %%"pagecheck" "<" Id "," Exp ">"  -> TemplateElement {cons("PageCheck"),prefer}
  %%"pagecheck" "(" Id "," Exp ")"  -> TemplateCall {reject}
  %%"pagecheck" "(" {Exp ","}* ")"                          -> TemplateCall {reject}
  
  "predicate" Id "(" {FormalArg ","}* ")" "{" Exp "}"           -> Definition {cons("Predicate")}
  "predicate" Id "(" {FormalArg ","}* ")" "{" Exp "}"           -> AccessControlDefinition {cons("Predicate")}
  
  Id MatchId "(" {Id ","}* WildCardArg? ")"                     -> AccessControlPointcutElement {cons("AccessControlPointcutElement")}
  
  "pointcut" Id "(" {FormalArg ","}* ")"
    "{" {AccessControlPointcutElement ","}* "}"                 -> AccessControlPointcut {cons("AccessControlPointcut")}
  
  AccessControlPointcut                                         -> AccessControlDefinition
  
  "access" "control" "policy" PolicyExp                         -> Section {cons("ACPolicy")}
  
  Id                                 -> PolicyExp {cons("Name")}
  "(" PolicyExp ")"                  -> PolicyExp {bracket}
  PolicyExp "AND" PolicyExp          -> PolicyExp {cons("PolicyAnd"), assoc}
  PolicyExp "OR" PolicyExp           -> PolicyExp {cons("PolicyOr"), assoc}
  
  
  %% hack for allowing multiple function checks to be added in different stages to a function call
  %%"acfunctioncheck" "(" Id "," Exp ")" Exp -> Exp {cons("ACFunctionCheck"), prefer}
  
context-free priorities
  {left:
       PolicyExp "AND" PolicyExp -> PolicyExp}
  > {left:
       PolicyExp "OR" PolicyExp -> PolicyExp}



context-free priorities
    Exp "in" Exp  -> Exp
  > Exp -> AccessControlCheck


module HQL

hiddens
  context-free start-symbols QueryRule Statement
  
exports
  lexical syntax
    [a-zA-Z\_][a-zA-Z0-9\_]* -> Identifier
  lexical restrictions
    Identifier -/- [a-zA-Z0-9\_]
    
  context-free syntax
   
    "from" | "select" | "by" | "order" -> Identifier {reject}

exports

%% header
%% {
%% //   $Id: hql.g 10164 2006-07-26 15:09:20Z steve.ebersole@jboss.com $
%% 
%% package org.hibernate.hql.antlr;
%% 
%% import org.hibernate.hql.ast.*;
%% import org.hibernate.hql.ast.util.*;
%% 
%% }
%% /**
%%  * Hibernate Query Language Grammar
%%  * <br>
%%  * This grammar parses the query language for Hibernate (an Open Source, Object-Relational
%%  * mapping library).  A partial BNF grammar description is available for reference here:
%%  * http://www.hibernate.org/Documentation/HQLBNF
%%  *
%%  * Text from the original reference BNF is prefixed with '//##'.
%%  * @author Joshua Davis (pgmjsd@sourceforge.net)
%%  */
%% class HqlBaseParser extends Parser;
%% 
%% options
%% {
%% 	exportVocab=Hql;
%% 	buildAST=true;
%% 	k=3;    // For 'not like', 'not in', etc.
%% }
%% 
%% tokens
%% {
%% 	// -- HQL Keyword tokens --
%% 	ALL="all";
%% 	ANY="any";
%% 	AND="and";
%% 	AS="as";
%% 	ASCENDING="asc";
%% 	AVG="avg";
%% 	BETWEEN="between";
%% 	CLASS="class";
%% 	COUNT="count";
%% 	DELETE="delete";
%% 	DESCENDING="desc";
%% 	DOT;
%% 	DISTINCT="distinct";
%% 	ELEMENTS="elements";
%% 	ESCAPE="escape";
%% 	EXISTS="exists";
%% 	FALSE="false";
%% 	FETCH="fetch";
%% 	FROM="from";
%% 	FULL="full";
%% 	GROUP="group";
%% 	HAVING="having";
%% 	IN="in";
%% 	INDICES="indices";
%% 	INNER="inner";
%% 	INSERT="insert";
%% 	INTO="into";
%% 	IS="is";
%% 	JOIN="join";
%% 	LEFT="left";
%% 	LIKE="like";
%% 	MAX="max";
%% 	MIN="min";
%% 	NEW="new";
%% 	NOT="not";
%% 	NULL="null";
%% 	OR="or";
%% 	ORDER="order";
%% 	OUTER="outer";
%% 	PROPERTIES="properties";
%% 	RIGHT="right";
%% 	SELECT="select";
%% 	SET="set";
%% 	SOME="some";
%% 	SUM="sum";
%% 	TRUE="true";
%% 	UNION="union";
%% 	UPDATE="update";
%% 	VERSIONED="versioned";
%% 	WHERE="where";
%% 
%% 	// -- SQL tokens --
%% 	// These aren't part of HQL, but the SQL fragment parser uses the HQL lexer, so they need to be declared here.
%% 	CASE="case";
%% 	END="end";
%% 	ELSE="else";
%% 	THEN="then";
%% 	WHEN="when";
%% 	ON="on";
%% 	WITH="with";
%% 
%% 	// -- EJBQL tokens --
%% 	BOTH="both";
%% 	EMPTY="empty";
%% 	LEADING="leading";
%% 	MEMBER="member";
%% 	OBJECT="object";
%% 	OF="of";
%% 	TRAILING="trailing";
%% 
%% 	// -- Synthetic token types --
%% 	AGGREGATE;		// One of the aggregate functions (e.g. min, max, avg)
%% 	ALIAS;
%% 	CONSTRUCTOR;
%% 	CASE2;
%% 	EXPR_LIST;
%% 	FILTER_ENTITY;		// FROM element injected because of a filter expression (happens during compilation phase 2)
%% 	IN_LIST;
%% 	INDEX_OP;
%% 	IS_NOT_NULL;
%% 	IS_NULL;			// Unary 'is null' operator.
%% 	METHOD_CALL;
%% 	NOT_BETWEEN;
%% 	NOT_IN;
%% 	NOT_LIKE;
%% 	ORDER_ELEMENT;
%% 	QUERY;
%% 	RANGE;
%% 	ROW_STAR;
%% 	SELECT_FROM;
%% 	UNARY_MINUS;
%% 	UNARY_PLUS;
%% 	VECTOR_EXPR;		// ( x, y, z )
%% 	WEIRD_IDENT;		// Identifiers that were keywords when they came in.
%% 
%% 	// Literal tokens.
%% 	CONSTANT;
%% 	NUM_DOUBLE;
%% 	NUM_FLOAT;
%% 	NUM_LONG;
%% 	JAVA_CONSTANT;
%% }
%% 
%% {
%%     /** True if this is a filter query (allow no FROM clause). **/
%% 	private boolean filter = false;
%% 
%% 	/**
%% 	 * Sets the filter flag.
%% 	 * @param f True for a filter query, false for a normal query.
%% 	 */
%% 	public void setFilter(boolean f) {
%% 		filter = f;
%% 	}
%% 
%% 	/**
%% 	 * Returns true if this is a filter query, false if not.
%% 	 * @return true if this is a filter query, false if not.
%% 	 */
%% 	public boolean isFilter() {
%% 		return filter;
%% 	}
%% 
%% 	/**
%% 	 * This method is overriden in the sub class in order to provide the
%% 	 * 'keyword as identifier' hack.
%% 	 * @param token The token to retry as an identifier.
%% 	 * @param ex The exception to throw if it cannot be retried as an identifier.
%% 	 */
%% 	public AST handleIdentifierError(Token token,RecognitionException ex) throws RecognitionException, TokenStreamException {
%% 		// Base implementation: Just re-throw the exception.
%% 		throw ex;
%% 	}
%% 
%%     /**
%%      * This method looks ahead and converts . <token> into . IDENT when
%%      * appropriate.
%%      */
%%     public void handleDotIdent() throws TokenStreamException {
%%     }
%% 
%% 	/**
%% 	 * Returns the negated equivalent of the expression.
%% 	 * @param x The expression to negate.
%% 	 */
%% 	public AST negateNode(AST x) {
%% 		// Just create a 'not' parent for the default behavior.
%% 		return ASTUtil.createParent(astFactory, NOT, "not", x);
%% 	}
%% 
%% 	/**
%% 	 * Returns the 'cleaned up' version of a comparison operator sub-tree.
%% 	 * @param x The comparison operator to clean up.
%% 	 */
%% 	public AST processEqualityExpression(AST x) throws RecognitionException {
%% 		return x;
%% 	}
%% 
%% 	public void weakKeywords() throws TokenStreamException { }
%% 
%% 	public void processMemberOf(Token n,AST p,ASTPair currentAST) { }
%% 
%% }

 
  sorts Statement UpdateStatement DeleteStatement SelectStatement InsertStatement
  
  context-free syntax

%% statement
%% 	: ( updateStatement | deleteStatement | selectStatement | insertStatement )
%% 	;

%%  UpdateStatement -> Statement
%%  DeleteStatement -> Statement
    SelectStatement -> Statement
%%  InsertStatement -> Statement

%% updateStatement
%% 	: UPDATE^ (VERSIONED)?
%% 		optionalFromTokenFromClause
%% 		setClause
%% 		(whereClause)?
%% 	;
%% 
%% setClause
%% 	: (SET^ assignment (COMMA! assignment)*)
%% 	;
%% 
%% assignment
%% 	: stateField EQ^ newValue
%% 	;
%% 
%% // "state_field" is the term used in the EJB3 sample grammar; used here for easy reference.
%% // it is basically a property ref
%% stateField
%% 	: path
%% 	;
%% 
%% // this still needs to be defined in the ejb3 spec; additiveExpression is currently just a best guess,
%% // although it is highly likely I would think that the spec may limit this even more tightly.
%% newValue
%% 	: concatenation
%% 	;
%% 
%% deleteStatement
%% 	: DELETE^
%% 		(optionalFromTokenFromClause)
%% 		(whereClause)?
%% 	;

%% optionalFromTokenFromClause!
%% 	: (FROM!)? f:path (a:asAlias)? {
%% 		AST #range = #([RANGE, "RANGE"], #f, #a);
%% 		#optionalFromTokenFromClause = #([FROM, "FROM"], #range);
%% 	}
%% 	;

  
%% selectStatement
%% 	: queryRule {
%% 		#selectStatement = #([QUERY,"query"], #selectStatement);
%% 	}
%% 	;

    QueryRule -> SelectStatement
    
%% insertStatement
%% 	// Would be nice if we could abstract the FromClause/FromElement logic
%% 	// out such that it could be reused here; something analogous to
%% 	// a "table" rule in sql-grammars
%% 	: INSERT^ intoClause selectStatement
%% 	;
%% 
%% intoClause
%% 	: INTO^ path { weakKeywords(); } insertablePropertySpec
%% 	;
%% 
%% insertablePropertySpec
%% 	: OPEN! primaryExpression ( COMMA! primaryExpression )* CLOSE! {
%% 		// Just need *something* to distinguish this on the hql-sql.g side
%% 		#insertablePropertySpec = #([RANGE, "column-spec"], #insertablePropertySpec);
%% 	}
%% 	;
%% 
%% union
%% 	: queryRule (UNION queryRule)*
%% 	;

    QueryRule "union" QueryRule -> Union {cons("QueryUnion")}
    
%% //## query:
%% //##     [selectClause] fromClause [whereClause] [groupByClause] [havingClause] [orderByClause];
%% 
%% queryRule
%% 	: selectFrom
%% 		(whereClause)?
%% 		(groupByClause)?
%% 		(orderByClause)?
%% 		;

    SelectFrom WhereClause? GroupByClause? OrderByClause? -> QueryRule {cons("QueryRule")}
    
%% selectFrom!
%% 	:  (s:selectClause)? (f:fromClause)? {
%% 		// If there was no FROM clause and this is a filter query, create a from clause.  Otherwise, throw
%% 		// an exception because non-filter queries must have a FROM clause.
%% 		if (#f == null) {
%% 			if (filter) {
%% 				#f = #([FROM,"{filter-implied FROM}"]);
%% 			}
%% 			else
%% 				throw new SemanticException("FROM expected (non-filter queries must contain a FROM clause)");
%% 		}
%% 			
%% 		// Create an artificial token so the 'FROM' can be placed
%% 		// before the SELECT in the tree to make tree processing
%% 		// simpler.
%% 		#selectFrom = #([SELECT_FROM,"SELECT_FROM"],f,s);
%% 	}
%% 	;

    SelectClause? FromClause -> SelectFrom {cons("SelectFrom")}
    
    %% inline this in the QueryRule production?
    %% suggests that query can be empty, that case should be avoided
    %% probably just say that FromClause is compulsary
    
%% //## selectClause:
%% //##     SELECT DISTINCT? selectedPropertiesList | ( NEW className OPEN selectedPropertiesList CLOSE );
%% 
%% selectClause
%% 	: SELECT^	// NOTE: The '^' after a token causes the corresponding AST node to be the root of the sub-tree.
%% 		{ weakKeywords(); }	// Weak keywords can appear immediately after a SELECT token.
%% 		(DISTINCT)? ( selectedPropertiesList | newExpression | selectObject )
%% 	;

    "select" Distinct? Selection -> SelectClause {cons("Select")}

    "distinct"                   -> Distinct {cons("Distinct")}
    
    SelectedPropertiesList -> Selection
    NewExpression          -> Selection
    SelectObject           -> Selection
    
%% newExpression
%% 	: (NEW! path) op:OPEN^ {#op.setType(CONSTRUCTOR);} selectedPropertiesList CLOSE!
%% 	;

  "new" Path "(" SelectedPropertiesList ")" -> NewExpression {cons("NewExpression")}
  
%% selectObject
%%    : OBJECT^ OPEN! identifier CLOSE!
%%    ;

  "object" "(" Identifier ")" -> SelectObject {cons("SelectObject")}
  
%% //## fromClause:
%% //##    FROM className AS? identifier (  ( COMMA className AS? identifier ) | ( joinType path AS? identifier ) )*;
%% 
%% // NOTE: This *must* begin with the "FROM" token, otherwise the sub-query rule will be ambiguous
%% // with the expression rule.
%% // Also note: after a comma weak keywords are allowed and should be treated as identifiers.
%% 
%% fromClause
%% 	: FROM^ { weakKeywords(); } fromRange ( fromJoin | COMMA! { weakKeywords(); } fromRange )*
%% 	;

    "from" {FromRangeJoin ","}+ -> FromClause {cons("FromClause")}
    
    FromRange FromJoin? -> FromRangeJoin {cons("FromRangeJoin")}
    
%% //## joinType:
%% //##     ( ( 'left'|'right' 'outer'? ) | 'full' | 'inner' )? JOIN FETCH?;
%% 
%% fromJoin
%% 	: ( ( ( LEFT | RIGHT ) (OUTER)? ) | FULL | INNER )? JOIN^ (FETCH)? 
%% 	  path (asAlias)? (propertyFetch)? (withClause)?
%% 	;

    "left"          -> JoinType {cons("LeftJoin")}
    "right"         -> JoinType {cons("RightJoin")}
    "left"  "outer" -> JoinType {cons("LeftOuterJoin")}
    "right" "outer" -> JoinType {cons("RightOuterJoin")}
    "full"          -> JoinType {cons("FullJoin")}
    "inner"         -> JoinType {cons("InnerJoin")}
    
    JoinType? "join" Fetch? Path AsAlias? PropertyFetch? WithClause? -> FromJoin {cons("FromJoin")}
    
    "fetch" -> Fetch {cons("Fetch")}
        
%% withClause
%% 	: WITH^ logicalExpression
%% 	;

  "with" Expression -> WithClause {cons("WithClause")}
  
%% fromRange
%% 	: fromClassOrOuterQueryPath
%% 	| inClassDeclaration
%% 	| inCollectionDeclaration
%% 	| inCollectionElementsDeclaration
%% 	;

    FromClassOrOuterQueryPath       -> FromRange
    InClassDeclaration              -> FromRange
    InCollectionDeclaration         -> FromRange
    InCollectionElementsDeclaration -> FromRange
    
%% fromClassOrOuterQueryPath!
%% 	: c:path { weakKeywords(); } (a:asAlias)? (p:propertyFetch)? {
%% 		#fromClassOrOuterQueryPath = #([RANGE, "RANGE"], #c, #a, #p);
%% 	}
%% 	;

    Path AsAlias? PropertyFetch? -> FromClassOrOuterQueryPath {cons("FromClass")}
    
%% inClassDeclaration!
%% 	: a:alias IN! CLASS! c:path {
%% 		#inClassDeclaration = #([RANGE, "RANGE"], #c, #a);
%% 	}
%% 	;

    Alias "in" "class" Path -> InClassDeclaration {cons("InClassDeclaration")}
    
%% inCollectionDeclaration!
%%     : IN! OPEN! p:path CLOSE! a:alias {
%%         #inCollectionDeclaration = #([JOIN, "join"], [INNER, "inner"], #p, #a);
%% 	}
%%     ;

    "in" "(" Path ")" Alias -> InCollectionDeclaration {cons("InCollection")}
    
%% inCollectionElementsDeclaration!
%% 	: a:alias IN! ELEMENTS! OPEN! p:path CLOSE! {
%%         #inCollectionElementsDeclaration = #([JOIN, "join"], [INNER, "inner"], #p, #a);
%% 	}
%%     ;

    Alias "in" "elements" "(" Path ")" -> InCollectionElementsDeclaration {cons("InCollectionElements")}

%% // Alias rule - Parses the optional 'as' token and forces an AST identifier node.
%% asAlias
%% 	: (AS!)? alias
%% 	;

  "as" Alias -> AsAlias {cons("AsAlias")}
  
%% alias
%% 	: a:identifier { #a.setType(ALIAS); }
%%     ;

  Identifier -> Alias {cons("Alias")}
  
%% propertyFetch
%% 	: FETCH ALL! PROPERTIES!
%% 	;

    "fetch" "all" "properties" -> PropertyFetch {cons("PropertyFetch")}
    
%% //## groupByClause:
%% //##     GROUP_BY path ( COMMA path )*;
%% 
%% groupByClause
%% 	: GROUP^ 
%% 		"by"! expression ( COMMA! expression )*
%% 		(havingClause)?
%% 	;

    "group" "by" {Expression ","}+ HavingClause? -> GroupByClause {cons("GroupBy")}
    
%% //## orderByClause:
%% //##     ORDER_BY selectedPropertiesList;
%% 
%% orderByClause
%% 	: ORDER^ "by"! orderElement ( COMMA! orderElement )*
%% 	;

    "order" "by" {OrderElement ","}+ -> OrderByClause {cons("OrderByClause")}
    
%% orderElement
%% 	: expression ( ascendingOrDescending )?
%% 	;

    Expression AscendingOrDescending? -> OrderElement {cons("OrderElement")}
    
%% ascendingOrDescending
%% 	: ( "asc" | "ascending" )	{ #ascendingOrDescending.setType(ASCENDING); }
%% 	| ( "desc" | "descending") 	{ #ascendingOrDescending.setType(DESCENDING); }
%% 	;

   "asc"       -> AscendingOrDescending {cons("Ascending")}
   "ascending" -> AscendingOrDescending {cons("Ascending")}
   
   "desc"      -> AscendingOrDescending {cons("Descending")}
   "descending" -> AscendingOrDescending {cons("Descending")}
   
%% //## havingClause:
%% //##     HAVING logicalExpression;

    "having" Expression -> HavingClause {cons("HavingClause")}
    
%% havingClause
%% 	: HAVING^ logicalExpression
%% 	;
%% 
%% //## whereClause:
%% //##     WHERE logicalExpression;

    "where" Expression -> WhereClause {cons("WhereClause")}
    
%% whereClause
%% 	: WHERE^ logicalExpression
%% 	;
%% 
%% //## selectedPropertiesList:
%% //##     ( path | aggregate ) ( COMMA path | aggregate )*;
%% 
%% selectedPropertiesList
%% 	: aliasedExpression ( COMMA! aliasedExpression )*
%% 	;

    {AliasedExpression ","}+ -> SelectedPropertiesList
    
%% aliasedExpression
%% 	: expression ( AS^ identifier )?
%% 	;

    Expression AsAlias? -> AliasedExpression {cons("AliasedExpression")}
    
    %% forget that AsAlias defined the same thing?
    
%% // expressions
%% // Note that most of these expressions follow the pattern
%% //   thisLevelExpression :
%% //       nextHigherPrecedenceExpression
%% //           (OPERATOR nextHigherPrecedenceExpression)*
%% // which is a standard recursive definition for a parsing an expression.
%% //
%% // Operator precedence in HQL
%% // lowest  --> ( 7)  OR
%% //             ( 6)  AND, NOT
%% //             ( 5)  equality: ==, <>, !=, is
%% //             ( 4)  relational: <, <=, >, >=,
%% //                   LIKE, NOT LIKE, BETWEEN, NOT BETWEEN, IN, NOT IN
%% //             ( 3)  addition and subtraction: +(binary) -(binary)
%% //             ( 2)  multiplication: * / %, concatenate: ||
%% // highest --> ( 1)  +(unary) -(unary)
%% //                   []   () (method call)  . (dot -- identifier qualification)
%% //                   aggregate function
%% //                   ()  (explicit parenthesis)
%% //
%% // Note that the above precedence levels map to the rules below...
%% // Once you have a precedence chart, writing the appropriate rules as below
%% // is usually very straightfoward
%% 
%% logicalExpression
%% 	: expression
%% 	;

    %% right, so we are not going to do *that*

    %%Expression -> LogicalExpression
    
%% // Main expression rule
%% expression
%% 	: logicalOrExpression
%% 	;

    %%LogicalOrExpression -> Expression
    
%% // level 7 - OR
%% logicalOrExpression
%% 	: logicalAndExpression ( OR^ logicalAndExpression )*
%% 	;

   %% {LogicalAndExpression "or"}+ -> LogicalOrExpression {cons("QueryLogicalOr")}
   
   Expression "or" Expression -> Expression {cons("QueryOr")}
   
%% // level 6 - AND, NOT
%% logicalAndExpression
%% 	: negatedExpression ( AND^ negatedExpression )*
%% 	;

    %% {NegatedExpression "and"}+ -> LogicalAndExpression {cons("QueryLogicalAnd")}
    
    Expression "and" Expression -> Expression {cons("QueryAnd")}
    
%% // NOT nodes aren't generated.  Instead, the operator in the sub-tree will be
%% // negated, if possible.   Expressions without a NOT parent are passed through.
%% negatedExpression!
%% { weakKeywords(); } // Weak keywords can appear in an expression, so look ahead.
%% 	: NOT^ x:negatedExpression { #negatedExpression = negateNode(#x); }
%% 	| y:equalityExpression { #negatedExpression = #y; }
%% 	;

    "not" Expression -> Expression {cons("QueryNot")}
    
%% //## OP: EQ | LT | GT | LE | GE | NE | SQL_NE | LIKE;
%% 
%% // level 5 - EQ, NE
%% equalityExpression
%% 	: x:relationalExpression (
%% 		( EQ^
%% 		| is:IS^	{ #is.setType(EQ); } (NOT! { #is.setType(NE); } )?
%% 		| NE^
%% 		| ne:SQL_NE^	{ #ne.setType(NE); }
%% 		) y:relationalExpression)* {
%% 			// Post process the equality expression to clean up 'is null', etc.
%% 			#equalityExpression = processEqualityExpression(#equalityExpression);
%% 		}
%% 	;

    Expression "=" Expression -> Expression {cons("EQ")}
    Expression "is" Expression -> Expression {cons("IS")}
    Expression "!=" Expression -> Expression {cons("NE")}
    Expression "<>" Expression -> Expression {cons("SQLNE")}
    Expression "like" Expression -> Expression {cons("LIKE")}
    Expression "not" "like" Expression -> Expression {cons("NOTLIKE")}

%% // level 4 - LT, GT, LE, GE, LIKE, NOT LIKE, BETWEEN, NOT BETWEEN
%% // NOTE: The NOT prefix for LIKE and BETWEEN will be represented in the
%% // token type.  When traversing the AST, use the token type, and not the
%% // token text to interpret the semantics of these nodes.
%% relationalExpression
%% 	: concatenation (
%% 		( ( ( LT^ | GT^ | LE^ | GE^ ) additiveExpression )* )
%% 		// Disable node production for the optional 'not'.
%% 		| (n:NOT!)? (
%% 			// Represent the optional NOT prefix using the token type by
%% 			// testing 'n' and setting the token type accordingly.
%% 			(i:IN^ {
%% 					#i.setType( (n == null) ? IN : NOT_IN);
%% 					#i.setText( (n == null) ? "in" : "not in");
%% 				}
%% 				inList)
%% 			| (b:BETWEEN^ {
%% 					#b.setType( (n == null) ? BETWEEN : NOT_BETWEEN);
%% 					#b.setText( (n == null) ? "between" : "not between");
%% 				}
%% 				betweenList )
%% 			| (l:LIKE^ {
%% 					#l.setType( (n == null) ? LIKE : NOT_LIKE);
%% 					#l.setText( (n == null) ? "like" : "not like");
%% 				}
%% 				concatenation likeEscape)
%% 			| (MEMBER! (OF!)? p:path! {
%% 				processMemberOf(n,#p,currentAST);
%% 			  } ) )
%% 		)
%% 	;

    Expression "<" Expression -> Expression {cons("LT")}
    
    Expression "in" Expression -> Expression {cons("In")}
    Expression "not" "in" Expression -> Expression {cons("NotIn")}
    
    Expression "member" "of" Expression -> Expression {cons("MemberOf")}
    Expression "not" "member" "of" Expression -> Expression {cons("NotMemberOf")}
  
%% likeEscape
%% 	: (ESCAPE^ concatenation)?
%% 	;
%% 
%% inList
%% 	: x:compoundExpr
%% 	{ #inList = #([IN_LIST,"inList"], #inList); }
%% 	;
%% 
%% betweenList
%% 	: concatenation AND! concatenation
%% 	;

    %%Expression "and" Expression -> Expression {cons("QueryAnd")}
    %% already had that one!
     
%% //level 4 - string concatenation
%% concatenation
%% 	: additiveExpression 
%% 	( c:CONCAT^ { #c.setType(EXPR_LIST); #c.setText("concatList"); } 
%% 	  additiveExpression
%% 	  ( CONCAT! additiveExpression )* 
%% 	  { #concatenation = #([METHOD_CALL, "||"], #([IDENT, "concat"]), #c ); } )?
%% 	;

    Expression "||" Expression -> Expression {cons("Concat")}
    
%% // level 3 - binary plus and minus
%% additiveExpression
%% 	: multiplyExpression ( ( PLUS^ | MINUS^ ) multiplyExpression )*
%% 	;

    Expression "+" Expression -> Expression {cons("Plus")}
    Expression "-" Expression -> Expression {cons("Minus")}

%% // level 2 - binary multiply and divide
%% multiplyExpression
%% 	: unaryExpression ( ( STAR^ | DIV^ ) unaryExpression )*
%% 	;

    Expression "*" Expression -> Expression {cons("Multiply")}
    Expression "/" Expression -> Expression {cons("Divide")}
    
%% // level 1 - unary minus, unary plus, not
%% unaryExpression
%% 	: MINUS^ {#MINUS.setType(UNARY_MINUS);} unaryExpression
%% 	| PLUS^ {#PLUS.setType(UNARY_PLUS);} unaryExpression
%% 	| caseExpression
%% 	| quantifiedExpression
%% 	| atom
%% 	;

    "-" Expression -> Expression {cons("UMinus")}
    
%% caseExpression
%% 	: CASE^ (whenClause)+ (elseClause)? END! 
%% 	| CASE^ { #CASE.setType(CASE2); } unaryExpression (altWhenClause)+ (elseClause)? END!
%% 	;

%%  "case" WhenClause+ ElseClause? "end" -> Expression {cons("Case")}
    
%% whenClause
%% 	: (WHEN^ logicalExpression THEN! unaryExpression)
%% 	;
%% 	
%% altWhenClause
%% 	: (WHEN^ unaryExpression THEN! unaryExpression)
%% 	;
%% 	
%% elseClause
%% 	: (ELSE^ unaryExpression)
%% 	;
%% 	
%% quantifiedExpression
%% 	: ( SOME^ | EXISTS^ | ALL^ | ANY^ ) 
%% 	( identifier | collectionExpr | (OPEN! ( subQuery ) CLOSE!) )
%% 	;
%% 
%% // level 0 - expression atom
%% // ident qualifier ('.' ident ), array index ( [ expr ] ),
%% // method call ( '.' ident '(' exprList ') )
%% atom
%% 	 : primaryExpression
%% 		(
%% 			DOT^ identifier
%% 				( options { greedy=true; } :
%% 					( op:OPEN^ {#op.setType(METHOD_CALL);} exprList CLOSE! ) )?
%% 		|	lb:OPEN_BRACKET^ {#lb.setType(INDEX_OP);} expression CLOSE_BRACKET!
%% 		)*
%% 	;
%% 
%% // level 0 - the basic element of an expression
%% primaryExpression
%% 	:   identPrimary ( options {greedy=true;} : DOT^ "class" )?
%% 	|   constant
%% 	|   COLON^ identifier
%% 	// TODO: Add parens to the tree so the user can control the operator evaluation order.
%% 	|   OPEN! (expressionOrVector | subQuery) CLOSE!
%% 	;

   %%syntax 
   %%  ":" <Identifier-CF> -> <Parameter-CF> {cons("IdParam")}
   %%  "?" <NumInt-CF>     -> <Parameter-CF> {cons("NumParam")}
   lexical syntax 
     ":" Identifier -> IdParameter 
     "?" NumInt     -> NumParameter
   context-free syntax
     IdParameter -> Expression {cons("IdParam")}
     NumParameter -> Expression {cons("NumParam")}
   
%% // This parses normal expression and a list of expressions separated by commas.  If a comma is encountered
%% // a parent VECTOR_EXPR node will be created for the list.
%% expressionOrVector!
%% 	: e:expression ( v:vectorExpr )? {
%% 		// If this is a vector expression, create a parent node for it.
%% 		if (#v != null)
%% 			#expressionOrVector = #([VECTOR_EXPR,"{vector}"], #e, #v);
%% 		else
%% 			#expressionOrVector = #e;
%% 	}
%% 	;
%% 
%% vectorExpr
%% 	: COMMA! expression (COMMA! expression)*
%% 	;
%% 
%% // identifier, followed by member refs (dot ident), or method calls.
%% // NOTE: handleDotIdent() is called immediately after the first IDENT is recognized because
%% // the method looks a head to find keywords after DOT and turns them into identifiers.
%% identPrimary
%% 	: identifier { handleDotIdent(); }
%% 			( options { greedy=true; } : DOT^ ( identifier | ELEMENTS | o:OBJECT { #o.setType(IDENT); } ) )*
%% 			( options { greedy=true; } :
%% 				( op:OPEN^ { #op.setType(METHOD_CALL);} exprList CLOSE! )
%% 			)?
%% 	// Also allow special 'aggregate functions' such as count(), avg(), etc.
%% 	| aggregate
%% 	;

    %%Identifier -> Expression
    
%% //## aggregate:
%% //##     ( aggregateFunction OPEN path CLOSE ) | ( COUNT OPEN STAR CLOSE ) | ( COUNT OPEN (DISTINCT | ALL) path CLOSE );
%% 
%% //## aggregateFunction:
%% //##     COUNT | 'sum' | 'avg' | 'max' | 'min';
%% 
%% aggregate
%% 	: ( SUM^ | AVG^ | MAX^ | MIN^ ) OPEN! additiveExpression CLOSE! { #aggregate.setType(AGGREGATE); }
%% 	// Special case for count - It's 'parameters' can be keywords.
%% 	|  COUNT^ OPEN! ( STAR { #STAR.setType(ROW_STAR); } | ( ( DISTINCT | ALL )? ( path | collectionExpr ) ) ) CLOSE!
%% 	|  collectionExpr
%% 	;

    "sum" "(" Expression ")" -> Expression {cons("Sum")}
    
%% //## collection: ( OPEN query CLOSE ) | ( 'elements'|'indices' OPEN path CLOSE );
%% 
%% collectionExpr
%% 	: (ELEMENTS^ | INDICES^) OPEN! path CLOSE!
%% 	;

     "elements" "(" Path ")" -> Expression {cons("Elements")}
     "indices" "(" Path ")" -> Expression {cons("Indices")}
                     
%% // NOTE: compoundExpr can be a 'path' where the last token in the path is '.elements' or '.indicies'
%% compoundExpr
%% 	: collectionExpr
%% 	| path
%% 	| (OPEN! ( (expression (COMMA! expression)*) | subQuery ) CLOSE!)
%% 	;

     Path                      -> Expression
     "(" {Expression ","}+ ")" -> Expression {cons("Paren")}
     
%% subQuery
%% 	: union
%% 	{ #subQuery = #([QUERY,"query"], #subQuery); }
%% 	;
%% 
%% exprList
%% {
%%    AST trimSpec = null;
%% }
%% 	: (t:TRAILING {#trimSpec = #t;} | l:LEADING {#trimSpec = #l;} | b:BOTH {#trimSpec = #b;})?
%% 	  		{ if(#trimSpec != null) #trimSpec.setType(IDENT); }
%% 	  ( 
%% 	  		expression ( (COMMA! expression)+ | FROM { #FROM.setType(IDENT); } expression | AS! identifier )? 
%% 	  		| FROM { #FROM.setType(IDENT); } expression
%% 	  )?
%% 			{ #exprList = #([EXPR_LIST,"exprList"], #exprList); }
%% 	;
%% 
%% constant
%% 	: NUM_INT
%% 	| NUM_FLOAT
%% 	| NUM_LONG
%% 	| NUM_DOUBLE
%% 	| QUOTED_STRING
%% 	| NULL
%% 	| TRUE
%% 	| FALSE
%% 	| EMPTY
%% 	;

    Constant -> Expression
    
    "true" -> Constant {cons("True")}
    "false" -> Constant {cons("False")}
    "empty" -> Constant {cons("Empty")}
    "null" -> Constant {cons("Null")}
    
    
%% //## quantifiedExpression: 'exists' | ( expression 'in' ) | ( expression OP 'any' | 'some' ) collection;
%% 
%% //## compoundPath: path ( OPEN_BRACKET expression CLOSE_BRACKET ( '.' path )? )*;
%% 
%% //## path: identifier ( '.' identifier )*;
%% 
%% path
%% 	: identifier ( DOT^ { weakKeywords(); } identifier )*
%% 	;

    {Identifier "."}+ -> Path {cons("Path")} 
    
%% // Wraps the IDENT token from the lexer, in order to provide
%% // 'keyword as identifier' trickery.
%% identifier
%% 	: IDENT
%% 	exception
%% 	catch [RecognitionException ex]
%% 	{
%% 		identifier_AST = handleIdentifierError(LT(1),ex);
%% 	}
%% 	; 
  
%% // **** LEXER ******************************************************************
%% 
%% /**
%%  * Hibernate Query Language Lexer
%%  * <br>
%%  * This lexer provides the HQL parser with tokens.
%%  * @author Joshua Davis (pgmjsd@sourceforge.net)
%%  */
%% class HqlBaseLexer extends Lexer;
%% 
%% options {
%% 	exportVocab=Hql;      // call the vocabulary "Hql"
%% 	testLiterals = false;
%% 	k=2; // needed for newline, and to distinguish '>' from '>='.
%% 	// HHH-241 : Quoted strings don't allow unicode chars - This should fix it.
%% 	charVocabulary='\u0000'..'\uFFFE';	// Allow any char but \uFFFF (16 bit -1, ANTLR's EOF character)
%% 	caseSensitive = false;
%% 	caseSensitiveLiterals = false;
%% }
%% 
%% // -- Declarations --
%% {
%% 	// NOTE: The real implementations are in the subclass.
%% 	protected void setPossibleID(boolean possibleID) {}
%% }
%% 
%% // -- Keywords --
%% 
%% EQ: '=';
%% LT: '<';
%% GT: '>';
%% SQL_NE: "<>";
%% NE: "!=" | "^=";
%% LE: "<=";
%% GE: ">=";
%% 
%% COMMA: ',';
%% 
%% OPEN: '(';
%% CLOSE: ')';
%% OPEN_BRACKET: '[';
%% CLOSE_BRACKET: ']';
%% 
%% CONCAT: "||";
%% PLUS: '+';
%% MINUS: '-';
%% STAR: '*';
%% DIV: '/';
%% COLON: ':';
%% PARAM: '?';
%% 
%% IDENT options { testLiterals=true; }
%% 	: ID_START_LETTER ( ID_LETTER )*
%% 		{
%%     		// Setting this flag allows the grammar to use keywords as identifiers, if necessary.
%% 			setPossibleID(true);
%% 		}
%% 	;
%% 
%% protected
%% ID_START_LETTER
%%     :    '_'
%%     |    '$'
%%     |    'a'..'z'
%%     |    '\u0080'..'\ufffe'       // HHH-558 : Allow unicode chars in identifiers
%%     ;
%% 
%% protected
%% ID_LETTER
%%     :    ID_START_LETTER
%%     |    '0'..'9'
%%     ;
%% 
%% QUOTED_STRING
%% 	  : '\'' ( (ESCqs)=> ESCqs | ~'\'' )* '\''
%% 	;

  context-free syntax
    QuotedString -> Constant {cons("String")}
    
  lexical syntax
    "'" (~[\'] | "\\'")* "'" -> QuotedString
     
%% protected
%% ESCqs
%% 	:
%% 		'\'' '\''
%% 	;
%% 
%% WS  :   (   ' '
%% 		|   '\t'
%% 		|   '\r' '\n' { newline(); }
%% 		|   '\n'      { newline(); }
%% 		|   '\r'      { newline(); }
%% 		)
%% 		{$setType(Token.SKIP);} //ignore this token
%% 	;

  lexical syntax
    [0-9]+ -> NumInt
  context-free syntax
    NumInt -> Constant
  
%% //--- From the Java example grammar ---
%% // a numeric literal
%% NUM_INT
%% 	{boolean isDecimal=false; Token t=null;}
%% 	:   '.' {_ttype = DOT;}
%% 			(	('0'..'9')+ (EXPONENT)? (f1:FLOAT_SUFFIX {t=f1;})?
%% 				{
%% 					if (t != null && t.getText().toUpperCase().indexOf('F')>=0)
%% 					{
%% 						_ttype = NUM_FLOAT;
%% 					}
%% 					else
%% 					{
%% 						_ttype = NUM_DOUBLE; // assume double
%% 					}
%% 				}
%% 			)?
%% 	|	(	'0' {isDecimal = true;} // special case for just '0'
%% 			(	('x')
%% 				(											// hex
%% 					// the 'e'|'E' and float suffix stuff look
%% 					// like hex digits, hence the (...)+ doesn't
%% 					// know when to stop: ambig.  ANTLR resolves
%% 					// it correctly by matching immediately.  It
%% 					// is therefore ok to hush warning.
%% 					options { warnWhenFollowAmbig=false; }
%% 				:	HEX_DIGIT
%% 				)+
%% 			|	('0'..'7')+									// octal
%% 			)?
%% 		|	('1'..'9') ('0'..'9')*  {isDecimal=true;}		// non-zero decimal
%% 		)
%% 		(	('l') { _ttype = NUM_LONG; }
%% 
%% 		// only check to see if it's a float if looks like decimal so far
%% 		|	{isDecimal}?
%% 			(   '.' ('0'..'9')* (EXPONENT)? (f2:FLOAT_SUFFIX {t=f2;})? 
%% 			|   EXPONENT (f3:FLOAT_SUFFIX {t=f3;})?
%% 			|   f4:FLOAT_SUFFIX {t=f4;}
%% 			)
%% 			{
%% 				if (t != null && t.getText().toUpperCase() .indexOf('F') >= 0)
%% 				{
%% 					_ttype = NUM_FLOAT;
%% 				}
%% 				else
%% 				{
%% 					_ttype = NUM_DOUBLE; // assume double
%% 				}
%% 			}     
%% 		)?
%% 	;
%% 
%% // hexadecimal digit (again, note it's protected!)
%% protected
%% HEX_DIGIT
%% 	:	('0'..'9'|'a'..'f')
%% 	;
%%  
%% // a couple protected methods to assist in matching floating point numbers
%% protected
%% EXPONENT
%% 	:	('e') ('+'|'-')? ('0'..'9')+
%% 	;
%% 
%% protected
%% FLOAT_SUFFIX
%% 	:	'f'|'d'
%% 	;
%% 
%% 


module MixHQL[Ctx0]
imports 
        HQL
          [ Path                            => Path[[Ctx0]]
            Constant                        => Constant[[Ctx0]]
            Expression                      => Expression[[Ctx0]]
            AliasedExpression               => AliasedExpression[[Ctx0]]
            SelectedPropertiesList          => SelectedPropertiesList[[Ctx0]]
            WhereClause                     => WhereClause[[Ctx0]]
            HavingClause                    => HavingClause[[Ctx0]]
            AscendingOrDescending           => AscendingOrDescending[[Ctx0]]
            OrderElement                    => OrderElement[[Ctx0]]
            OrderByClause                   => OrderByClause[[Ctx0]]
            GroupByClause                   => GroupByClause[[Ctx0]]
            PropertyFetch                   => PropertyFetch[[Ctx0]]
            Alias                           => Alias[[Ctx0]]
            AsAlias                         => AsAlias[[Ctx0]]
            InCollectionElementsDeclaration => InCollectionElementsDeclaration[[Ctx0]]
            InCollectionDeclaration         => InCollectionDeclaration[[Ctx0]]
            InClassDeclaration              => InClassDeclaration[[Ctx0]]
            FromClassOrOuterQueryPath       => FromClassOrOuterQueryPath[[Ctx0]]
            FromRange                       => FromRange[[Ctx0]]
            WithClause                      => WithClause[[Ctx0]]
            Fetch                           => Fetch[[Ctx0]]
            FromJoin                        => FromJoin[[Ctx0]]
            JoinType                        => JoinType[[Ctx0]]
            FromRangeJoin                   => FromRangeJoin[[Ctx0]]
            FromClause                      => FromClause[[Ctx0]]
            SelectObject                    => SelectObject[[Ctx0]]
            NewExpression                   => NewExpression[[Ctx0]]
            Selection                       => Selection[[Ctx0]]
            Distinct                        => Distinct[[Ctx0]]
            SelectClause                    => SelectClause[[Ctx0]]
            SelectFrom                      => SelectFrom[[Ctx0]]
            QueryRule                       => QueryRule[[Ctx0]]
            Union                           => Union[[Ctx0]]
            SelectStatement                 => SelectStatement[[Ctx0]]
            Statement                       => Statement[[Ctx0]]
            NumInt                          => NumInt[[Ctx0]]
            QuotedString                    => QuotedString[[Ctx0]]
            NumParameter                    => NumParameter[[Ctx0]]
            IdParameter                     => IdParameter[[Ctx0]]
            Identifier                      => Identifier[[Ctx0]] ]


module WebDSL

imports
  MixHQL[HQL]
  AccessControl
  ValidationAnnos
%%  InputValidation
  Styling
  Enums
  PagedFor
  Derive
  Procedures
  TemplateMarkdown
  StringSelectEntity

hiddens
  context-free start-symbols
    Application Module Unit

exports

  sorts
    Id QId Int ModuleName SectionHeader Float FloatDigits ExponentPart
    SignedInteger String UNDEFINED Eof

  lexical syntax
    [a-zA-Z][a-zA-Z0-9\_]* -> Id
    [a-zA-Z0-9\-\_]+       -> FileName
    {FileName "/"}+        -> ModuleName
    ~[\n\r]*               -> SectionName

  lexical restrictions
    Id         -/- [a-zA-Z0-9\_]
    ModuleName -/- [a-zA-Z0-9\/]

  lexical syntax
    "-"? [0-9]+            -> Int

  lexical syntax
    "-"? FloatDigits
     ExponentPart? [fFdD]? -> Float
    [0-9]* "." [0-9]*      -> FloatDigits
    [0-9]+                 -> FloatDigits
    [eE] SignedInteger     -> ExponentPart
    [\+\-]? [0-9]+         -> SignedInteger

    "-"? [0-9]+            -> Float {reject}
    "."                    -> FloatDigits  {reject}

  lexical syntax
    "\"" StringChar* "\""        -> String
    ~[\"\n]                        -> StringChar
    "\\\""                       -> StringChar
    [\ \t\n\r]                   -> LAYOUT
    "//" ~[\n\r]* ([\n\r] | Eof) -> LAYOUT
    "/*" CommentChar* "*/"       -> LAYOUT
                                 -> Eof
    ~[\*]                        -> CommentChar
    Asterisk                     -> CommentChar
    [\*]                         -> Asterisk

  lexical restrictions
    Asterisk   -/- [\/]
    Eof        -/- ~[]

  context-free restrictions
    LAYOUT?     -/- [\ \t\n\r]
    LAYOUT?     -/- [\/].[\/]
    LAYOUT?     -/- [\/].[\*]
    SectionName -/- ~[\n\r]

  context-free syntax
    Id         -> QId
    QId "." Id -> QId {cons("Qualified")}

  context-free restrictions
    "page" "local" "email" "feed" "template" -/- [a-zA-Z0-9]

exports

  sorts Word Unit

  lexical syntax
    ~[\ \t\n\r\}]+ -> Word
  lexical restrictions
     Word -/- ~[\ \t\n\r\}]

exports

  sorts Application
  
  syntax

    "section" <SectionName-CF> <LAYOUT?-CF> <Definition*-CF> -> <Section-CF> {cons("Section")}

  context-free syntax

    "application" QId Definition+ Section* -> Application {cons("ApplicationDefs")}
    "application" QId Section*      -> Application {cons("Application")}

    "description" "{" Word* "}"     -> Description {cons("Description")}

    "note" "{" Word* "}"            -> Description {cons("Note")}

    Description                   -> Definition
    %%Description                   -> Definition {prefer}

    "module" ModuleName Section*  -> Module {cons("Module")}
    "module" ModuleName Definition+ Section*  -> Module {cons("ModuleDefs")}

    "imports" ModuleName          -> Definition {cons("Imports")}
    
    Application                   -> Unit
    
    Module                        -> Unit

exports

  sorts Entity Property Sort Annotation

  context-free syntax

    "entity" Id ":" Id "{" Property* Function* "}"       -> Entity {cons("Entity")}
    "entity" Id "{" Property* Function* "}"              -> Entity {cons("EntityNoSuper")}
    "session" Id "{" Property* Function* "}"             -> Entity {cons("SessionEntity")}

    Entity                                   		     -> Definition

    "extend" "entity" Id "{" Property* Function* "}"	 -> Definition {cons("ExtendEntity")}
    "extend" "session" Id "{" Property* Function* "}"   -> Definition {cons("ExtendSessionEntity")}

    "globals" "{" GlobalsDef* "}"                        -> Definition {prefer,cons("GlobalsDefinition")}
    VarDecl                                              -> GlobalsDef
    Function                                             -> GlobalsDef
    GlobalsDef                                           -> Definition
    InitAction                                           -> Definition

    "function" Id "(" {FormalArg ","}* ")" ":" Sort
        Block                                            -> Function {cons("Function")}

    "function" Id "(" {FormalArg ","}* ")" 
        Block                                            -> FunctionNoReturn {cons("FunctionNoReturn")}

    FunctionNoReturn                                     -> Function

    "extend" FunctionNoReturn                            -> Function {cons("ExtendFunction")}

  sorts Property Annotation

  context-free syntax

    Id PropKind Sort "(" {Annotation ","}* ")" -> Property {cons("Property")}
    Id PropKind Sort                           -> Property {cons("PropertyNoAnno")}

    Id PropKind Sort "(" {Annotation ","}* ")" ":=" Exp -> Property {cons("DerivedProperty")}
    Id PropKind Sort ":=" Exp                           -> Property {cons("DerivedPropertyNoAnno")}


    "::" -> PropKind {cons("Simple")}
    "->" -> PropKind {cons("Ref")}
    "<>" -> PropKind {cons("Comp")}

  sorts Sort

  context-free syntax

    Id                     -> Sort {cons("SimpleSort")}
    Id "<" {Sort ","}+ ">" -> Sort {cons("GenericSort")}

    Id                           -> Annotation {cons("SimpleAnno")}
    "inverse" "=" Id "." Id      -> Annotation {cons("InverseAnno")}
    "inverseSlave" "=" Id "." Id -> Annotation {cons("InverseSlaveAnno")}
    "inline" "(" {Id ","}* ")"   -> Annotation {cons("InlineAnno")}
    "select" "=" Id              -> Annotation {cons("SelectAnno")}
%%  Id "(" {Annotation ","}* ")" -> Annotation {cons("ParamAnno")}

exports

  sorts TemplateDefinition Modifier Exp

  context-free syntax

    TemplateDefinition -> Definition

    "define" Modifier*
       Id "(" {FormalArg ","}* ")"
       "{" TemplateElement* "}"             -> TemplateDefinition {cons("Define")}

    "define" Modifier*
       Id UNDEFINED*
       "{" TemplateElement* "}"             -> TemplateDefinition {cons("Define")}
    
    "define" -> Id {reject}
    "for" -> Id {reject}

    "page"                                  -> Modifier {cons("Page")}
    "email"                                 -> Modifier {cons("Email")}
    "template"                              -> Modifier {cons("Template")}
    "feed"                                  -> Modifier {cons("Feed")}
    "local"                                 -> Modifier {cons("Local")}

    Id ":" Sort                             -> FormalArg {cons("Arg")}

    InitAction                              -> TemplateElement
    Action                                  -> TemplateElement
    VarDecl                                 -> TemplateElement
    TemplateDefinition                      -> TemplateElement
    TemplateCall                            -> TemplateElement {avoid}
    String                                  -> TemplateElement {cons("Text")}


    "where" Exp                              -> Filter {cons("FilterNoOrderByNoLimit")}
    "order" "by" OrderExp                    -> Filter {cons("FilterNoWhereNoLimit")}
    "where" Exp "order" "by" OrderExp        -> Filter {cons("FilterNoLimit")}
    "where" Exp Limit                        -> Filter {cons("FilterNoOrderBy")}
    "order" "by" OrderExp Limit              -> Filter {cons("FilterNoWhere")}
    Limit                                    -> Filter {cons("FilterNoWhereNoOrderBy")}
    "where" Exp "order" "by" OrderExp Limit  -> Filter {cons("Filter")}
    Exp                                      -> OrderExp {cons("OrderNonSpecific")}
    Exp "asc"                                -> OrderExp {cons("OrderAscending")}
    Exp "desc"                               -> OrderExp {cons("OrderDescending")}
    "limit" Exp "offset" Exp                 -> Limit {cons("Limit")}
    "limit" Exp                              -> Limit {cons("LimitNoOffset")}
    "offset" Exp                             -> Limit {cons("LimitNoLimit")}


    "for" "(" Id ":" Sort "in" Exp Filter ")"
       "{" TemplateElement* "}"                             -> TemplateElement {cons("For")}

    "for" "(" Id ":" Sort "in" Exp ")"
       "{" TemplateElement* "}"                             -> TemplateElement {cons("ForNoFilter")}

    "for" "(" Id ":" Sort Filter ")"
       "{" TemplateElement* "}"                             -> TemplateElement {cons("ForAll")}

    "for" "(" Id ":" Sort ")"
       "{" TemplateElement* "}"                             -> TemplateElement {cons("ForAllNoFilter")}


    "for" "(" Id ":" Sort "in" Exp ")"
       "{" TemplateElement* "}" 
    "separated-by" "{" TemplateElement* "}"               -> TemplateElement {cons("ForSepNoFilter")}

    "for" "(" Id ":" Sort "in" Exp Filter ")"
       "{" TemplateElement* "}" 
    "separated-by" "{" TemplateElement* "}"               -> TemplateElement {cons("ForSep")}

    %%

    "select" "(" Id ":" Sort "," String "," Exp ")" -> TemplateElement {cons("Select")}

    "select" "(" Exp "from" Exp ")" -> TemplateElement {cons("SelectFromList")}

    "if" "(" Exp ")" "{" TemplateElement* "}" "else" "{" TemplateElement* "}"
                                                   -> TemplateElement {cons("IfTempl"),prefer}
    "if" "(" Exp ")" "{" TemplateElement* "}"      -> TemplateElement {cons("IfNoElseTempl")}

  %%

    Id                                             -> TemplateCall {cons("TemplateCallNoArgs")}
    Id "(" {Exp ","}* ")"                          -> TemplateCall {cons("TemplateCallNoBody")}
    Id "(" {Exp ","}* ")" "{" TemplateElement* "}" -> TemplateCall {cons("TemplateCallNoAssigns")}
  
    Id "(" {Exp ","}* ")" "[" {PropertyAssignment ","}*"]" -> TemplateCall {cons("TemplateCallPropsNoBody")}
    Id "[" {PropertyAssignment ","}*"]" -> TemplateCall {cons("TemplateCallProps")}
    Id "[" {PropertyAssignment ","}*"]" "{" TemplateElement* "}" -> TemplateCall {cons("TemplateCallPropsNoArgs")}

    Id                    "{" TemplateElement* "}" -> TemplateCall {cons("TemplateCallBody")}
    Id "(" {Exp ","}* ")" "[" {PropertyAssignment ","}*"]" "{" TemplateElement* "}" -> TemplateCall {cons("TemplateCall")}

  %%
    
    "if" "(" Exp ")" "{" TemplateElement* "}"      -> TemplateCall {reject}
    "else" "{" TemplateElement* "}"                -> TemplateCall {reject}
    "separated-by" "{" TemplateElement* "}"                -> TemplateCall {reject}

  %%
    
    Id ":=" PropertyValue				           -> PropertyAssignment {cons("PropertyAssignment")}
    Id											   -> PropertyValue {prefer}
    String										   -> PropertyValue {cons("String"),prefer}  %% needed to deconfuse StyleValue and Exp
    Exp								        	   -> PropertyValue 
    "[" {PropertyValue "," }* "]"				   -> PropertyValue{cons("PropertyValueList"), prefer}
    StyleValue									   -> PropertyValue
  
    %%AJAX desugarings/ inline
    "action" Block -> Exp {cons("InlineAction"), prefer}
    "template" "{" TemplateElement* "}" -> Exp {cons("InlineTemplateCall"), prefer}    
   
    %% Template call without braces must be disambiguated in some cases
    "action" -> TemplateCall {reject}  %%this is an action definiton, not a templatecall without params
    "action" -> Exp {reject}		   %%this is an inline action, not a variable
    "action" -> PropertyValue {reject} %%this is an inline action, not an id

exports

  sorts Action Statements Statement Exp

  context-free syntax

    "init" Block  		-> InitAction {cons("InitAction"),prefer}
    "action" 
      Id "(" {FormalArg ","}* ")" 
      Block  			-> Action {cons("Action")}
    
    Action		       	-> Definition
    Statement*		   	-> Statements

    "{" Statements "}" 		-> Block {cons("Block")}
    Block              		-> Statement
    %%Assignment ";"	   	-> Statement {cons("Assign")}
    Exp ";"		       	-> Statement {cons("Stat")}

    "return" Exp ";"     	-> Statement {cons("Return")}
    
    "return" ";"         	-> Statement {cons("ReturnEmpty")}
    
  context-free syntax

    Id Id "<<" Id  ";" 	 	-> Statement {cons("AjaxActionIdParam"),prefer}
    Id Id "<<" ";"		-> Statement {cons("AjaxActionNoParam")}
    Id "<<" Exp ";"	 	-> Statement {cons("AjaxActionNoTarget")}
    Id Id "<<" Exp ";"   	-> Statement {cons("AjaxAction")}

    "cancel" Exp ";"     	-> Statement {cons("Cancel")}

    "goto" Exp ";"       	-> Statement {cons("GoTo")}

    "schedule" Exp "for" Exp ";" -> Statement {cons("Schedule")}
    "schedule" Exp ";"           -> Statement {cons("ScheduleNoFor")}

  context-free syntax

    "var" Id ":" Sort ";" 	-> VarDecl {cons("VarDecl")}
    "var" Id ":" Sort 		-> TemplateElement {cons("VarDecl")}

    "var" Id ":" Sort ":=" Exp ";" -> VarDecl {cons("VarDeclInit")}
    "var" Id ":=" Exp ";" -> VarDecl {cons("VarDeclInitInferred")}
    "var" Id ":" Sort ":=" Exp -> TemplateElement {cons("VarDeclInit")}
    "var" Id ":=" Exp -> TemplateElement {cons("VarDeclInitInferred")}

    VarDecl -> Statement

  context-free syntax

    "if" "(" Exp ")" Block "else" Block -> Statement {cons("If")}

    "if" "(" Exp ")" Block 		-> Statement {cons("IfNoElse")}

    "case" "(" Exp ")" "{" Case* "}" 	-> Statement {cons("Case")}
    ConstValue Block                 	-> Case {cons("CaseAlt")}
    "default"  Block                 	-> Case {cons("CaseDefault")}


  context-free syntax

    "for" "(" Id ":" Sort "in" Exp Filter ")"
      Block 				-> Statement {cons("ForStmt")}

    "for" "(" Id ":" Sort "in" Exp ")"
      Block 				-> Statement {cons("ForStmtNoFilter")}

    "for" "(" Id ":" Sort Filter ")"
      Block 				-> Statement {cons("ForAllStmt")}

    "for" "(" Id ":" Sort ")"
      Block 				-> Statement {cons("ForAllStmtNoFilter")}

    "for" "(" Id ":" "Int" "from" Exp "to" Exp ")" Block -> Statement {cons("ForCountStmt")}

    "while" "(" Exp ")" Block -> Statement {cons("WhileStmt")}


exports

  sorts Rules Rule

  context-free syntax

    "rules" Rule* -> Definition {cons("Rules")}

    Exp "=" Exp -> Rule {cons("Equation")}

exports

  sorts ConstValue Exp

  context-free syntax
    Int                    -> ConstValue {cons("Int")}
    Float                  -> ConstValue {cons("Float")}
    String                 -> ConstValue {cons("String")}

    ConstValue                  -> Exp

    Id			   -> Exp {cons("Var")}
    "in"                   -> Exp {reject}
    "return"               -> Id {reject}
        
    %% to be able to refer to page or template farg/var from actions when names clashing with farg/var in action
    "externalscope" "." Id -> Exp {cons("ExternalScopeVar")}

    Exp "." Id             -> Exp {cons("FieldAccess"),prefer}

    Sort "{" ObjectPropertyAssignment* "}"         -> Exp {cons("ObjectCreation")}
    Sort "{" { ObjectPropertyAssignment "," }* "}" -> Exp {cons("ObjectCreation"), prefer}

    Id ":=" Exp           -> ObjectPropertyAssignment {cons("ObjectPropertyAssignment")}

    QId ":=" Exp           -> Assignment {cons("Assignment")}
    Assignment				-> Exp

    "[" Mapping* "]"       -> Exp {cons("MapCreation")}
    Exp "->" Exp           -> Mapping {cons("Mapping")}

    "[" {Exp ","}* "]"     -> Exp {cons("ListCreation")}

    "{" {Exp ","}* "}"     -> Exp {cons("SetCreation")}

    "List" "<" Sort ">" "(" {Exp ","}* ")" -> Exp {cons("TypedListCreation"), prefer}
    "Set" "<" Sort ">" "(" {Exp ","}* ")" -> Exp {cons("TypedSetCreation"), prefer}

    Id "(" {Exp ","}* ")"  -> Exp {cons("ThisCall")}
    "!" "(" {Exp ","}* ")"  -> Exp {reject}

    Exp "." Id "(" {Exp ","}* ")"  -> Exp {cons("Call")}

    Exp "is" "a" Sort      -> Exp {cons("IsA")}
    Exp "as" Sort          -> Exp {cons("Cast"), avoid} %% Casting, hooray!

    Exp "in" Exp           -> Exp {cons("InColl")}

    Exp "==" Exp           -> Exp {cons("Eq")}
    Exp "!=" Exp           -> Exp {cons("NotEq")}
    Exp ">" Exp           -> Exp {cons("LargerThan")}
    Exp ">=" Exp           -> Exp {cons("LargerThanOrEqual")}
    Exp "<" Exp           -> Exp {cons("SmallerThan")}
    Exp "<=" Exp           -> Exp {cons("SmallerThanOrEqual")}

    "true"                 -> Exp {prefer,cons("True")}
    "false"                -> Exp {prefer,cons("False")}

    "null"                 -> Exp {prefer,cons("Null")}

    Exp "&&" Exp          -> Exp {cons("And"), assoc}
    Exp "||" Exp           -> Exp {cons("Or"), assoc}
    "!" Exp              -> Exp {cons("Not")}

    "(" Exp ")"            -> Exp {bracket}


    "[" Exp "for" "(" Id ":" Sort "in" Exp Filter ")" "]" -> ForExp {cons("ForExp")}
    "[" Exp "for" "(" Id ":" Sort "in" Exp ")" "]"        -> ForExp {cons("ForExpNoFilter")}
    "[" Exp "|" Id ":" Sort "in" Exp Filter "]"           -> ForExp {cons("ForExp")}
    "[" Exp "|" Id ":" Sort "in" Exp "]"                  -> ForExp {cons("ForExpNoFilter")}
    ForExp                                                -> Exp

    "And" ForExp                                          -> Exp {cons("AndForExp")}
    "Or"  ForExp                                          -> Exp {cons("OrForExp")}


    Exp "*" Exp  -> Exp {cons("Mul"),assoc}
    Exp "/" Exp  -> Exp {cons("Div"),assoc}
    Exp "%" Exp  -> Exp {cons("Mod"),assoc}
    Exp "+" Exp  -> Exp {cons("Add"),assoc}
    Exp "-" Exp  -> Exp {cons("Sub"),assoc}

context-free priorities
  {left:
    Exp "." Id "(" {Exp ","}* ")"  -> Exp
    Exp "." Id  -> Exp }
  > Exp "as" Sort -> Exp
  > "!" Exp -> Exp
  > Exp "in" Exp -> Exp
  > {left:
       Exp "*" Exp -> Exp
       Exp "%" Exp -> Exp
       Exp "/" Exp -> Exp }
  > {left:
       Exp "+" Exp -> Exp
       Exp "-" Exp -> Exp }
  > {left:
       Exp "==" Exp -> Exp
       Exp "!=" Exp -> Exp
       Exp ">" Exp -> Exp
       Exp ">=" Exp -> Exp
       Exp "<" Exp -> Exp
       Exp "<=" Exp -> Exp }
  > {left:
       Exp "&&" Exp -> Exp }
  > {left:
       Exp "||" Exp -> Exp }
  > Assignment -> Exp 

exports

  context-free syntax

    QueryRule[[HQL]] -> Exp {cons("HqlQuery"), prefer}

    "~" Exp -> Expression[[HQL]] {cons("DslExp")}

module WebDslMix[E]

imports
  WebDSL
  AccessControlMix
  StylingMix
  DeriveMix

exports

  lexical syntax

    [0-9]* -> MetaVarSuffix
    "_" [A-Za-z0-9\_\-]+ -> MetaVarSuffix

  context-free syntax
    "webdsl"  "|[" Application      "]|" -> E {cons("ToMetaExpr")}
              "|[" Application      "]|" -> E {cons("ToMetaExpr")}
    "webdsl"  "|[" Section          "]|" -> E {cons("ToMetaExpr")}
              "|[" Section          "]|" -> E {cons("ToMetaExpr")}
    "webdsl"  "|[" Section*         "]|" -> E {cons("ToMetaExpr")}
              "|[" Section*         "]|" -> E {cons("ToMetaExpr")}
    "webdsl"  "|[" TemplateElement  "]|" -> E {cons("ToMetaExpr")}
    "webdsl*" "|[" TemplateElement* "]|" -> E {cons("ToMetaExpr")}

    "def"   "|[" Definition  "]|" -> E {cons("ToMetaExpr")}
    "def*"  "|[" Definition* "]|" -> E {cons("ToMetaExpr")}
    "fun"   "|[" Function  "]|"   -> E {cons("ToMetaExpr")}
    "fun*"  "|[" Function* "]|"   -> E {cons("ToMetaExpr")}
    "sdef"  "|["  SecurityDefinition   "]|" -> E {cons("ToMetaExpr")}
    "sdef*" "|["  SecurityDefinition*  "]|" -> E {cons("ToMetaExpr")}

    "webdsl" "|[" Description "]|" -> E {cons("ToMetaExpr")}
             "|[" Description "]|" -> E {cons("ToMetaExpr")}

  variables

    "app" [0-9]*                -> Application {prefer}
    "sec" [0-9]*                -> Section     {prefer}
    "sec" [0-9]* "*"            -> Section*    {prefer}
    "def" [0-9]*                -> Definition  {prefer}
    "def" [0-9]* "*"            -> Definition* {prefer}
    "procelem" [0-9]*           -> ProcedureElement  {prefer}
    "procelem" [0-9]* "*"       -> ProcedureElement* {prefer}
    "procelem_"[A-Za-z0-9]+     -> ProcedureElement  {prefer}
    "procelem_"[A-Za-z0-9]+ "*" -> ProcedureElement* {prefer}
    "processexp" [0-9]*         -> ProcessExp  {prefer}
    "processexp" [0-9]* "*"     -> ProcessExp* {prefer}
    "desc"[0-9]*                -> Description {prefer}
    "mod" [0-9]*                -> Modifier    {prefer}
    "mod" [0-9]* "*"            -> Modifier*   {prefer}

  context-free syntax

    "webdsl" "|[" Entity            "]|" -> E {cons("ToMetaExpr")}
             "|[" Entity            "]|" -> E {cons("ToMetaExpr")}
    "webdsl" "|[" Property          "]|" -> E {cons("ToMetaExpr")}
             "|[" Property          "]|" -> E {cons("ToMetaExpr")}
    "webdsl" "|[" Property*         "]|" -> E {cons("ToMetaExpr")}
             "|[" Property*         "]|" -> E {cons("ToMetaExpr")}
    "webdsl" "|[" Sort              "]|" -> E {cons("ToMetaExpr")}
             "|[" Sort              "]|" -> E {cons("ToMetaExpr")}
    "webdsl" "|[" {Sort ","}*       "]|" -> E {cons("ToMetaExpr")}
             "|[" {Sort ","}*       "]|" -> E {cons("ToMetaExpr")}
    "webdsl" "|[" Annotation        "]|" -> E {cons("ToMetaExpr")}
             "|[" Annotation        "]|" -> E {cons("ToMetaExpr")}
    "webdsl" "|[" {Annotation ","}* "]|" -> E {cons("ToMetaExpr")}
             "|[" {Annotation ","}* "]|" -> E {cons("ToMetaExpr")}

  variables
    "ent" [0-9]*     -> Entity            {prefer}
    "prop"[0-9]*     -> Property          {prefer}
    "prop"[0-9]* "*" -> Property*         {prefer}
    "srt" [0-9]*     -> Sort              {prefer}
    "srt" [0-9]* "*" -> {Sort ","}*       {prefer}
    "ann" [0-9]*     -> Annotation        {prefer}
    "ann" [0-9]* "*" -> {Annotation ","}* {prefer}
    "k"   [0-9]*     -> PropKind          {prefer}
    
    "dprop"[0-9]*     -> DeriveProperty   {prefer}
    "dprop"[0-9]* "*" -> {DeriveProperty ","}*  {prefer}

  context-free syntax
    "tdef"      "|[" TemplateDefinition  "]|" -> E {cons("ToMetaExpr")}
    "farg"      "|[" FormalArg           "]|" -> E {cons("ToMetaExpr")}
    "farg*"     "|[" {FormalArg ","}*    "]|" -> E {cons("ToMetaExpr")}
    "procelem"  "|[" ProcedureElement    "]|" -> E {cons("ToMetaExpr")}
    "procelem*" "|[" ProcedureElement*   "]|" -> E {cons("ToMetaExpr")}
    "elem"      "|[" TemplateElement     "]|" -> E {cons("ToMetaExpr")}
    "elem*"     "|[" TemplateElement*    "]|" -> E {cons("ToMetaExpr")}
    "call"      "|[" TemplateCall        "]|" -> E {cons("ToMetaExpr")}
    "call*"     "|[" TemplateCall*       "]|" -> E {cons("ToMetaExpr")}
    "exp"       "|[" Exp                 "]|" -> E {cons("ToMetaExpr")}
    "passign"   "|[" PropertyAssignment  "]|" -> E {cons("ToMetaExpr")}
    "passign*"  "|[" PropertyAssignment* "]|" -> E {cons("ToMetaExpr")}

  variables
    "tdef"[0-9]*     -> TemplateDefinition {prefer}
    "farg"[0-9]*     -> FormalArg          {prefer}
    "farg" MetaVarSuffix "*" -> {FormalArg ","}*   {prefer}
    "elem"[0-9]*     -> TemplateElement    {prefer}
    "elem"[0-9]* "*" -> TemplateElement*   {prefer}
    "elem_"[A-Za-z0-9]+     -> TemplateElement    {prefer}
    "elem_"[A-Za-z0-9]+ "*" -> TemplateElement*   {prefer}
    "call"[0-9]*     -> TemplateCall       {prefer}
    "call"[0-9]* "*" -> TemplateCall*      {prefer}
    "passign" MetaVarSuffix     -> PropertyAssignment          {prefer}
    "passign" MetaVarSuffix "*" -> {PropertyAssignment ","}*   {prefer}
 
  context-free syntax
    "webdsl" "|[" Action     "]|" -> E {cons("ToMetaExpr")}
             "|[" Action     "]|" -> E {cons("ToMetaExpr")}
    "webdsl" "|[" Statement  "]|" -> E {cons("ToMetaExpr")}
             "|[" Statement  "]|" -> E {cons("ToMetaExpr")}
    "stat"   "|[" Statement  "]|" -> E {cons("ToMetaExpr")}
    "webdsl" "|[" Statement* "]|" -> E {cons("ToMetaExpr")}
             "|[" Statement* "]|" -> E {cons("ToMetaExpr")}
    "webdsl" "|[" Case       "]|" -> E {cons("ToMetaExpr")}
             "|[" Case       "]|" -> E {cons("ToMetaExpr")}

  variables

    "_act" [0-9]*          -> Action     {prefer}
    "stat" [0-9]*          -> Statement  {prefer}
    "stat" [0-9]* "*"      -> Statement* {prefer}
    "stat_"[A-Za-z0-9]*    -> Statement  {prefer}
    "stat_"[A-Za-z0-9]*"*" -> Statement* {prefer}
    "block"[0-9]*          -> Block      {prefer}

    "alt"[0-9]*            -> Case {prefer}
    "alt"[0-9]* "*"        -> Case* {prefer}

  context-free syntax
    "webdsl:e" "|[" Exp         "]|" -> E {cons("ToMetaExpr")}
    "|[" Exp         "]|" -> E {cons("ToMetaExpr")}
    "|[" Assignment  "]|" -> E {cons("ToMetaExpr")}
    "|[" Assignment* "]|" -> E {cons("ToMetaExpr")}

  variables

    "e"   [0-9\']*           -> Exp         {prefer}
    "e_"  [A-Za-z0-9\']+     -> Exp         {prefer}
    "e"   [0-9\']* "*"       -> {Exp ","}*  {prefer}
    "e_"  [A-Za-z0-9\']+ "*" -> {Exp ","}*  {prefer}
    "fltr"[0-9]*             -> Filter      {prefer}
    "asgn"[0-9]*             -> Assignment  {prefer}
    "asgn"[0-9]* "*"         -> Assignment* {prefer}
    "fun"[0-9]*              -> Function    {prefer}
    "fun"[0-9]* "*"          -> Function*   {prefer}

  variables

    "qid"[0-9]*                -> QId     {prefer}
    [xyz][0-9]*                -> Id      {prefer}
    [xyz]"_"[A-Za-z0-9]+       -> Id      {prefer}
    %%[xyz]"_"[A-Za-z0-9\']+ "*" -> Id*     {prefer}
    [xyz][0-9]*                -> MatchId {prefer}
    [xyz]"_"[A-Za-z0-9]+       -> MatchId {prefer}
    "str"[0-9]*                -> String  {prefer}

    "const"[0-9]*              -> ConstValue {prefer}

  lexical syntax

    [\$][A-Za-z0-9]* -> IdVar
    [\$][A-Za-z0-9]* -> Id[[StrategoHost]]

  lexical restrictions

    IdVar -/- [A-Za-z0-9]

  variables

    IdVar -> Id {prefer}

module Stratego-Sugar-Overlays
imports
  Stratego-Core-Identifiers
  Stratego-Sugar-Terms

exports
  sorts Overlay
  context-free syntax
    Id 			 "=" Term 	-> Overlay {cons("OverlayNoArgs")}
    Id "(" {Id ","}* ")" "=" Term 	-> Overlay {cons("Overlay")}

module Stratego-Sugar-DynamicRules
imports
  Stratego-Core-Identifiers
  Stratego-Sugar-Strategies
  Stratego-Sugar-Rules

exports
 
  sorts ScopeLabels
  context-free syntax

    "{|" ScopeLabels ":" Strategy "|}" -> Strategy {cons("DynRuleScope")}

    {DynRuleScopeId ","}*   -> ScopeLabels
    "~" Term		    -> ScopeLabels {cons("ScopeLabels")}

  sorts DynRuleDef DynRuleId DynRuleScopeId RuleDec
  context-free syntax

    "rules" "(" DynRuleDef* ")" -> Strategy {cons("GenDynRules")}

    Id "+" Term                 -> DynRuleDef {cons("AddScopeLabel")} 
    DynRuleId ":-"  Term        -> DynRuleDef {cons("UndefineDynRule")}
    DynRuleId ":"   Rule        -> DynRuleDef {cons("SetDynRule")}
    DynRuleId ":+"  Rule        -> DynRuleDef {cons("AddDynRule")}
    DynRuleId ":"   Term        -> DynRuleDef {cons("SetDynRuleMatch")}

    DynRuleId ":="  Term        -> DynRuleDef {cons("DynRuleAssign")}
    DynRuleId ":+="  Term       -> DynRuleDef {cons("DynRuleAssignAdd")}

    DynRuleId ":"   Rule "depends" "on" Term -> DynRuleDef {cons("SetDynRuleDepends")}

    RuleDec "." Term            -> DynRuleId {cons("LabeledDynRuleId")}
    RuleDec "+" Term            -> DynRuleId {cons("AddLabelDynRuleId")}
    RuleDec                     -> DynRuleId {cons("DynRuleId")}

    Id "." Term                 -> DynRuleScopeId {cons("LabeledDynRuleScopeId")}
    Id                          -> DynRuleScopeId {cons("DynRuleScopeId")}

  context-free syntax

    Id                          -> RuleDec {cons("RDecNoArgs")}
    Id "(" {Typedid ","}* ")"   -> RuleDec {cons("RDec")}
    Id "(" {Typedid ","}* 
       "|" {Typedid ","}* ")"   -> RuleDec {cons("RDecT")}

  sorts RuleNames
  context-free syntax
    {Id ","}*				  -> RuleNames
    "~" Term				  -> RuleNames {cons("RuleNames")}

    "/" RuleNames "\\*" Strategy          -> Strategy {cons("DynRuleIntersectFix")}

  syntax
    %% no space after RuleNames
    "\\" <LAYOUT?-CF> <RuleNames-CF> "/*" <LAYOUT?-CF> <Strategy-CF>
      -> <Strategy-CF> {cons("DynRuleUnionFix")}

    %% 1 space after RuleNames
    "\\" <LAYOUT?-CF> <RuleNames-CF> " /*" <LAYOUT?-CF> <Strategy-CF>
      -> <Strategy-CF> {cons("DynRuleUnionFix")}

    %% no space after RuleNames
    "/"  <LAYOUT?-CF> <RuleNames-CF> <LAYOUT?-CF> "\\"
        <LAYOUT?-CF> <RuleNames-CF> "/*" <LAYOUT?-CF> <Strategy-CF>
      -> <Strategy-CF> {cons("DynRuleIntersectUnionFix")}

    %% 1 space after RuleNames
    "/"  <LAYOUT?-CF> <RuleNames-CF> <LAYOUT?-CF> "\\"
        <LAYOUT?-CF> <RuleNames-CF> " /*" <LAYOUT?-CF> <Strategy-CF>
      -> <Strategy-CF> {cons("DynRuleIntersectUnionFix")}


  context-free syntax
    Strategy "/" RuleNames"\\" Strategy  -> Strategy {cons("DynRuleIntersect"),right}
    Strategy "\\" RuleNames "/" Strategy  -> Strategy {cons("DynRuleUnion"),right}

    Strategy "/" RuleNames "\\" 
                 RuleNames "/"  Strategy  -> Strategy {cons("DynRuleIntersectUnion"),right}

  priorities
    <StrategyAngle-CF> <LAYOUT?-CF> <Term-CF> -> <Strategy-CF> {cons("BA")}
  > {

    %% no space after RuleNames
    "\\" <LAYOUT?-CF> <RuleNames-CF> "/*" <LAYOUT?-CF> <Strategy-CF>
      -> <Strategy-CF> {cons("DynRuleUnionFix")}

    %% 1 space after RuleNames
    "\\" <LAYOUT?-CF> <RuleNames-CF> " /*" <LAYOUT?-CF> <Strategy-CF>
      -> <Strategy-CF> {cons("DynRuleUnionFix")}

    %% no space after RuleNames
    "/"  <LAYOUT?-CF> <RuleNames-CF> <LAYOUT?-CF> "\\"
        <LAYOUT?-CF> <RuleNames-CF> "/*" <LAYOUT?-CF> <Strategy-CF>
      -> <Strategy-CF> {cons("DynRuleIntersectUnionFix")}

    %% 1 space after RuleNames
    "/"  <LAYOUT?-CF> <RuleNames-CF> <LAYOUT?-CF> "\\"
        <LAYOUT?-CF> <RuleNames-CF> " /*" <LAYOUT?-CF> <Strategy-CF>
      -> <Strategy-CF> {cons("DynRuleIntersectUnionFix")}

    }
  > <Strategy-CF> <LAYOUT?-CF> "=>" <LAYOUT?-CF> <Term-CF> -> <Strategy-CF> {cons("AM")}

  context-free priorities
    StrategyAngle Term 		          -> Strategy {cons("BA")}
  > "/" RuleNames "\\*" Strategy          -> Strategy {cons("DynRuleIntersectFix")}
  > Strategy "=>" Term 		  	  -> Strategy {cons("AM")}
  > Strategy "/" RuleNames "\\" Strategy  -> Strategy {cons("DynRuleIntersect"),right}
  > Strategy "\\" RuleNames "/" Strategy  -> Strategy {cons("DynRuleUnion"),right}
  > Strategy "/" RuleNames "\\" 
                 RuleNames "/"  Strategy  -> Strategy {cons("DynRuleIntersectUnion"),right}
  > Strategy ";" Strategy 		  -> Strategy {cons("Seq"),right}

module Stratego-Sugar-Rules
imports Stratego-Sugar-Strategies
exports

  sorts RuleDef
  context-free syntax
    Id ":" Rule 				-> RuleDef {cons("RDefNoArgs")}

    Id "(" {Typedid ","}* ")" ":" Rule 		-> RuleDef {cons("RDef")}

    Id "(" {Typedid ","}* 
       "|" {Typedid ","}* ")" ":" Rule 		-> RuleDef {cons("RDefT")}

  sorts Rule RuleCond
  context-free syntax
    Term "->" Term           	    -> Rule {cons("RuleNoCond")} %% backward comp.
    Term "->" Term "where" Strategy -> Rule {cons("Rule")}       %% backward comp.
    Term "->" Term RuleCond+	    -> Rule {cons("Rule"), avoid}

    "where" Strategy -> RuleCond {cons("WhereClause")}
    "with"  Strategy -> RuleCond {cons("WithClause")}

module Stratego-Sugar-Strategies
imports
  Stratego-Core-Strategies
  Stratego-Sugar-Terms
  Stratego-Sugar-Constants
  Stratego-Sugar-Signatures

exports
  context-free syntax
    Id  		      "=" Strategy -> StrategyDef {cons("SDefNoArgs")}
    Id "(" {Typedid ","}* ")" "=" Strategy -> StrategyDef {cons("SDef")}

  context-free syntax
    ID 				  	  -> Typedid {cons("DefaultVarDec")}

  sorts Rule

  sorts StrategyParen StrategyCurly StrategyAngle
  context-free syntax

    %% Abstraction

    SVar "(" {Strategy ","}* ")" 	  -> Strategy {cons("Call")}

    %% Match and build

    "{" Strategy "}" 			  -> Strategy {cons("ScopeDefault")}

     %%"<" Strategy ">" Term 		  -> Strategy {cons("BA")}
     StrategyAngle Term 		  -> Strategy {cons("BA")}
     "<" Strategy ">"			  -> StrategyAngle {bracket} %% {cons("AngleStrat")}

    %% Combinators

    Strategy "<+" Strategy 		  -> Strategy {cons("LChoice"),right}

    "rec" Id "(" Strategy ")" 		  -> Strategy {cons("Rec")}

    "not"   "(" Strategy ")" 		  -> Strategy {cons("Not")}
    "where" "(" Strategy ")" 		  -> Strategy {cons("Where")}
    "with"  "(" Strategy ")" 		  -> Strategy {cons("With"), prefer}
    "test"  "(" Strategy ")" 		  -> Strategy {cons("Test")}

    %% Primitives

    "prim" "(" String ")" 		  -> Strategy {cons("PrimNoArgs")}
    "prim" "(" String "," {Term ","}* ")" -> Strategy {cons("Prim")}

    %% Congruence operators

    String 				  -> Strategy {cons("StrCong")}
    Int 				  -> Strategy {cons("IntCong")}
    Real 				  -> Strategy {cons("RealCong")}
    Char 			 	  -> Strategy {cons("CharCong")}

    String "(" {Strategy ","}* ")" 	  -> Strategy {cons("CongQ")}

    %%"(" {Strategy ","}* ")" 		  -> Strategy {cons("TupleCong"),avoid}

    Strategy StrategyCurly		  -> Strategy {cons("AnnoCong")}
    "{" Strategy "}"		  	  -> StrategyCurly {cons("StrategyCurly")}

    "("  ")" 		  		  -> Strategy {cons("EmptyTupleCong")}
   "(" Strategy  ")" 		          -> Strategy {bracket}
    "(" Strategy "," {Strategy ","}+ ")"  -> Strategy {cons("TupleCong")}

%%    Mod 	  			  -> Strategy {cons("ModCongNoArgs")}
%%    Mod "(" {Strategy ","}* ")"	  	  -> Strategy {cons("ModCong")}
%%    Id "^" Id				  -> Mod {cons("Mod")}
    "[" {Strategy ","}* "]" 		  -> Strategy {cons("ListCongNoTail")}
    "[" {Strategy ","}* "|" Strategy "]"  -> Strategy {cons("ListCong")}

%%    Strategy "#" "(" StrategyInj ")" 	  -> Strategy {cons("ExplodeCong")}
%%    Strategy "#" "(" Strategy ")" 	  -> Strategy {cons("ExplodeCong")}
    Strategy "#" StrategyParen	  	  -> Strategy {cons("ExplodeCong")}

  %% Syntactic sugar sugar

  sorts SwitchCase
  context-free syntax

    SVar  		  		  -> Strategy {cons("CallNoArgs")}
    "\\" Rule "\\" 			  -> Strategy {cons("LRule")}
    "(" Rule ")" 			  -> Strategy {cons("SRule")}
    Strategy "+" Strategy 		  -> Strategy {cons("Choice"),right} 
    Strategy "+>" Strategy 		  -> Strategy {cons("RChoice"),right}

    "if" Strategy "then" Strategy 
                  "else" Strategy "end"   -> Strategy {cons("CondChoice")}
    "if" Strategy "then" Strategy "end"   -> Strategy {cons("IfThen")}

    "switch" Strategy SwitchCase* "end"   -> Strategy {cons("SwitchChoiceNoOtherwise")}
    "switch" Strategy SwitchCase*
         "otherwise" ":" Strategy "end"   -> Strategy {cons("SwitchChoice")}

    "case" Strategy ":" Strategy          -> SwitchCase {cons("SwitchCase")}

    Strategy "=>" Term 		  	  -> Strategy {cons("AM")}

    Term ":=" Term			  -> Strategy {cons("Assign")}

  %% Priorities

  context-free priorities
    { Strategy StrategyCurly		  -> Strategy
      Strategy "#" StrategyParen          -> Strategy
    }
  > { "!" Term 				  -> Strategy
      "?" Term 				  -> Strategy
    }
  > StrategyAngle Term 		          -> Strategy
  > Strategy "=>" Term 		  	  -> Strategy
  > Strategy ";" Strategy 		  -> Strategy
  > {right: 
     Strategy "+" Strategy 		  -> Strategy
     Strategy "<+" Strategy 		  -> Strategy
     Strategy "+>" Strategy 		  -> Strategy
     
     Strategy "<" StrategyMid 
              "+" Strategy 		  -> Strategy
    }

  context-free priorities
    Strategy 				  -> StrategyMid
  > Strategy "+" Strategy 		  -> Strategy

  context-free priorities
    { Strategy StrategyCurly      -> Strategy
      Strategy "#" StrategyParen  -> Strategy
    }
    .> Term ":=" Term -> Strategy


module Stratego-Sugar-Terms
imports
  Stratego-Core-Terms
  Stratego-Sugar-Strategies

exports
  sorts LID
  context-free syntax
    LId 			-> LID  {cons("ListVar")}
    LID				-> Var  {cons("Var")}
    LID				-> ID

  context-free syntax
    "_" PreTerm 		 -> PreTerm {cons("BuildDefaultPT")}
    "_" Term 			 -> Term {cons("BuildDefault"),prefer}

    Char 			 -> PreTerm {cons("Char")}

    PreTerm "{" {Term ","}* "}"	 -> Term {cons("AnnoList")}
    PreTerm                      -> Term {cons("NoAnnoList")}

    "<" Strategy ">" Term 	 -> PreTerm {cons("App")}
    "<" Strategy ">" Term 	 -> Term {cons("App"),prefer}

    StrategyAngle		 -> PreTerm {cons("RootApp")}
    StrategyAngle		 -> Term {cons("RootApp"),prefer}

    "(" {Term ","}* ")" 	 -> PreTerm {cons("Tuple")}
    "[" {Term ","}* "]" 	 -> PreTerm {cons("List")}
    "[" {Term ","}* "|" Term "]" -> PreTerm {cons("ListTail")}

  context-free priorities
    Term "#" "(" Term ")" 	 -> PreTerm {cons("Explode")}
  > PreTerm "{" {Term ","}* "}"	 -> Term {cons("AnnoList")}
  > Var "@" Term 		 -> Term {cons("As")}

module Stratego-Sugar-Signatures
imports
  Stratego-Core-Signatures
  Stratego-Sugar-Constants

exports

  sorts Sort
  context-free syntax
    "[" {Sort ","}* "]"		 -> Sort {cons("SortList")}
    "[" {Sort ","}* "|" Sort "]" -> Sort {cons("SortListTl")}
    "(" {Sort ","}* ")"		 -> Sort {cons("SortTuple")}

  sorts Kind
  context-free syntax
    "*" 			-> Kind {cons("Star")}
    "**" 			-> Kind {cons("StarStar")}

module Stratego-Core-Signatures
imports
  Stratego-Core-Identifiers
  Stratego-Core-Constants
exports
  sorts Sdecl
  context-free syntax
    "sorts" Sort* 		-> Sdecl {cons("Sorts")}
    "constructors" Opdecl* 	-> Sdecl {cons("Constructors")}

  sorts Sort
  context-free syntax
    LCID 			 -> Sort {cons("SortVar")}
    UCID 			 -> Sort {cons("SortNoArgs")}
    Id "(" {Sort ","}* ")" 	 -> Sort {cons("Sort")}

  sorts Opdecl
  context-free syntax
    Id     ":" Type 		-> Opdecl {cons("OpDecl")}
    String ":" Type 		-> Opdecl {cons("OpDeclQ")}
           ":" Type 		-> Opdecl {cons("OpDeclInj")}

  context-free syntax
    "external" Id     ":" Type 	-> Opdecl {cons("ExtOpDecl")}
    "external" String ":" Type 	-> Opdecl {cons("ExtOpDeclQ")}
    "external"        ":" Type 	-> Opdecl {cons("ExtOpDeclInj")}

  sorts Type ArgType ConstType FunType RetType
  context-free syntax
    Sort	                -> ConstType {cons("ConstType")}
    {ArgType "*"}+ "->" RetType -> FunType {cons("FunType")}
    "(" Type ")"                -> ArgType {bracket}
    ConstType			-> ArgType
    Type	                -> RetType
    FunType			-> RetType {reject}

    FunType			-> Type
    ConstType			-> Type

  %%%
   %% Restriction is required for the Sort* in Sdecl: List(a) is
   %% ambiguous.
   %%%
  context-free restrictions
    Sort -/- [\(]

module Stratego-Core-Terms
imports
  Stratego-Core-Identifiers
  Stratego-Core-Constants

exports
  sorts ID Var Wld
  context-free syntax
    Id 				-> Var  {cons("Var")}
    Id				-> ID
    %% ":" Var                  -> Var  {cons("SeqVar")}

  sorts Term PreTerm
  context-free syntax
    Var 			 -> PreTerm 
    Var 			 -> Term {prefer}

    "_" 			 -> Wld {cons("Wld")}
    Wld 			 -> PreTerm
    Wld 			 -> Term {prefer}

    Int 			 -> PreTerm {cons("Int")}
    Real 			 -> PreTerm {cons("Real")}
    String 			 -> PreTerm {cons("Str")}

    Id "(" {Term ","}* ")" 	 -> PreTerm {cons("Op")}
    String "(" {Term ","}* ")" 	 -> PreTerm {cons("OpQ")}
    Term "#" "(" Term ")" 	 -> PreTerm {cons("Explode")}

    PreTerm "{^" PreTerm "}"	 -> Term {cons("Anno")}

    Var "@" Term 		 -> Term {cons("As"),prefer}
    Var "@" PreTerm 		 -> PreTerm {cons("As")}

  context-free priorities
    Term "#" "(" Term ")" 	 -> PreTerm {cons("Explode")}
  > Var "@" Term 		 -> Term {cons("As")}

module Stratego-Core-Strategies
imports
  Stratego-Core-Terms
  Stratego-Core-Constants
  Stratego-Core-Signatures

exports
  sorts Def
  context-free syntax
    StrategyDef					 -> Def 
    Id						 -> SVar {cons("SVar")}
    "let" Def* "in" Strategy "end"		 -> Strategy {cons("Let")}
    SVar "(" {Strategy ","}* "|" {Term ","}* ")" -> Strategy {cons("CallT")}

    "call" "(" Term "|" {Strategy ","}* "|" {Term ","}* ")" -> Strategy {cons("CallDynamic")}


  sorts StrategyDef
  context-free syntax
    Id "(" {Typedid ","}* 
       "|" {Typedid ","}* ")" "=" Strategy -> StrategyDef {cons("SDefT")}

    "external"
    Id "(" {Typedid ","}* 
       "|" {Typedid ","}* ")" "=" Strategy -> StrategyDef {cons("ExtSDefInl")}

    "external"
    Id "(" {Typedid ","}* 
       "|" {Typedid ","}* ")"		   -> StrategyDef {cons("ExtSDef")}


  sorts Typedid
  context-free syntax
    ID ":" Type 			  -> Typedid {cons("VarDec")}


  sorts Strategy SVar StrategyParen StrategyMid 
  context-free syntax
    "(" Strategy ")"			  -> StrategyParen {cons("ParenStrat")}

    "fail" 				  -> Strategy {cons("Fail")}
    "id" 				  -> Strategy {cons("Id")}

    %% Match and build

    "?" Term 				  -> Strategy {cons("Match")}
    "!" Term 				  -> Strategy {cons("Build")}
    "{" {ID ","}* ":" Strategy "}" 	  -> Strategy {cons("Scope")}

    %% Combinators

    Strategy ";" Strategy 		  -> Strategy {cons("Seq"),right}
    Strategy "<" StrategyMid 
             "+" Strategy 		  -> Strategy {cons("GuardedLChoice"),right}
    Strategy 				  -> StrategyMid

    %% Primitives

    "prim" "(" String "," {Strategy ","}* "|" {Term ","}*")"  -> Strategy {cons("PrimT")}

    %% Traversal

    "some" "(" Strategy ")" 		  -> Strategy {cons("Some")}
    "one" "(" Strategy ")" 		  -> Strategy {cons("One")}
    "all" "(" Strategy ")" 		  -> Strategy {cons("All")}

  %% Priorities

  context-free priorities
    { "!" Term 				  -> Strategy {cons("Build")}
      "?" Term 				  -> Strategy {cons("Match")}
    }
  > Strategy ";" Strategy 		  -> Strategy {cons("Seq"),right}
  > {right: 
     Strategy "<" StrategyMid 
              "+" Strategy 		  -> Strategy {cons("GuardedLChoice"),right}
    }

  context-free syntax
    "import-term" "(" ModName ")" -> Strategy {cons("ImportTerm")}

module Stratego-Core-Modules
imports
  Stratego-Core-Identifiers
  Stratego-Core-Strategies
  Stratego-Core-Signatures

exports 
  sorts Module
  context-free syntax
    "module" ModName Decl* 	 -> Module {cons("Module")}
    "specification" Decl*	 -> Module {cons("Specification")}

  sorts Decl 
  context-free syntax
    "imports" ImportModName* 	-> Decl {cons("Imports")}
    "strategies" Def* 		-> Decl {cons("Strategies")}
    "signature" Sdecl*  	-> Decl {cons("Signature")}

  sorts ImportModName
  context-free syntax
    ModName              -> ImportModName {cons("Import")}
  syntax
    <ModName-CF> "/" "-" -> <ImportModName-CF> {cons("ImportWildcard")}

module Stratego-Sugar-Modules
imports
  Stratego-Core-Modules
  Stratego-Sugar-Strategies
  Stratego-Sugar-Signatures
  Stratego-Sugar-Overlays
  Stratego-Sugar-Rules

exports 

  sorts Decl Def
  context-free syntax
    "rules" Def* 		-> Decl {cons("Rules")}
    "overlays" Overlay* 	-> Decl {cons("Overlays")}

    RuleDef 			-> Def 


module Stratego-Core-Constants
exports
  sorts Int Real String StrChar
  lexical syntax
    [\-]? [0-9]+ 		-> Int
    [\-]? [0-9]+ [\.] [0-9]+ 	-> Real
    "\"" StrChar* "\"" 		-> String
    ~[\"\\] 			-> StrChar
    [\\] [\"tnr\\] 		-> StrChar


module Stratego-Sugar-Constants
imports Stratego-Core-Identifiers Stratego-Core-Constants
exports
  sorts Char CharChar
  lexical syntax
    "'" CharChar "'"		-> Char
    ~[\']			-> CharChar
    [\\] [\'ntr\ ]		-> CharChar
    Char		 	-> Id {reject}

module Stratego-Core-Identifiers
exports
  sorts ModName ModNamePart
  lexical syntax
    {ModNamePart "/"}+ -> ModName
    [a-zA-Z\.\_] [a-zA-Z0-9\'\.\-\_]* -> ModNamePart
  lexical restrictions
    ModName -/- [a-zA-Z0-9\'\.\-\_]
  lexical syntax
    "imports" 		-> ModName {reject}
    "overlays" 		-> ModName {reject}
    "rules" 		-> ModName {reject}
    "signature" 	-> ModName {reject}
    "strategies" 	-> ModName {reject}

  sorts Id LId LCID UCID Wld
  lexical syntax
    [a-zA-Z\_] [a-zA-Z0-9\'\-\_]*     -> Id
    [a-zA-Z\_] [a-zA-Z0-9\'\-\_]* "*" -> LId
    [\'] [a-z]+                       -> Id

    [a-z] [a-zA-Z0-9\'\-\_]*  -> LCID
    [A-Z] [a-zA-Z0-9\'\-\_]*  -> UCID

  lexical restrictions
    Id   -/- [a-zA-Z0-9\'\-\_\*]
    LId  -/- [a-zA-Z0-9\'\-\_]
    LCID -/- [a-zA-Z0-9\'\-\_]
    UCID -/- [a-zA-Z0-9\'\-\_]

  lexical syntax
    "_"     -> Id {reject}
    "'"     -> Id {reject}

    Keyword -> Id   {reject}
    Keyword -> LId  {reject}
    Keyword -> LCID {reject}
    Keyword -> UCID {reject}

  lexical restrictions
    "all"
    "case" %% not reserved kw
    "constructors"
    "else" %% not reserved kw
    "end" %% not reserved kw
    "external" %% not reserved kw
    "fail"
    "id"
    "if" %% not reserved kw
    "in"
    "imports" %% not reserved kw
    "let"
    "module"
    "not"
    "one"
    "overlays"
    "otherwise" %% not reserved kw
    "prim"
    "rec" %% not reserved kw
    "rules"
    "script"
    "signature"
    "some"
    "sorts"
    "strategies"
    "stratego"
    "switch" %% not reserved kw
    "test"
    "then" %% not reserved kw
    "where"
    "import-term"
      -/- [a-zA-Z0-9\'\-\_]
  
  context-free restrictions
    Wld -/- [a-zA-Z0-9\'\-\_]

  sorts Keyword
  lexical syntax
    "all"               -> Keyword
    "constructors" 	-> Keyword
    "fail" 		-> Keyword
    "id" 		-> Keyword
    "in" 		-> Keyword
    "let" 		-> Keyword
    "module" 		-> Keyword
    "not" 		-> Keyword
    "one" 		-> Keyword
    "overlays" 		-> Keyword
    "prim" 		-> Keyword
    "rules" 		-> Keyword
    "script" 		-> Keyword
    "signature" 	-> Keyword
    "some" 		-> Keyword
    "sorts" 		-> Keyword
    "strategies" 	-> Keyword
    "stratego" 		-> Keyword
    "test" 		-> Keyword
    "where" 		-> Keyword
    "import-term"	-> Keyword


module Stratego-Core-Layout
exports
  sorts Ws ShortCom LongCom CommChar Asterisk Eof 
  lexical syntax
    [\t\ \n\r]			-> Ws

    "//" ~[\n]* ([\n] | Eof)	-> ShortCom
    "/*" CommChar* "*/"	-> LongCom
				-> Eof  

    ~[\*]     -> CommChar

    "*"       -> Asterisk
    Asterisk  -> CommChar

  lexical restrictions
    Asterisk -/- [\/]
    Eof      -/- ~[]

  lexical syntax
    ShortCom 	-> LAYOUT
    LongCom 	-> LAYOUT
    Ws 		-> LAYOUT

  context-free restrictions
    LAYOUT? -/- [\ \t\n\r]
    LAYOUT? -/- [\/].[\*]
    LAYOUT? -/- [\/].[\/]

module Stratego-Sugar-Layout
imports Stratego-Core-Layout
%%exports
%%  sorts VeryLongCom Eof VLCchar Backslash
%%  lexical syntax
%%    "\\end{code}" VLCchar* "\\begin{code}" -> VeryLongCom
%%    "\\begin{code}" 			   -> VeryLongCom
%%    "\\end{code}" VLCchar* Eof 		   -> VeryLongCom
%%    "\\literate" VLCchar* "\\begin{code}"  -> VeryLongCom
%%    ~[\\] 				   -> VLCchar
%%    Backslash 				   -> VLCchar
%%    [\\] 				   -> Backslash

%%  lexical restrictions
%%    Backslash -/- [b].[e].[g].[i].[n].[\{].[c].[o].[d].[e].[\}]
%%    Eof -/- ~[]

%%  lexical syntax
%%    VeryLongCom -> LAYOUT



module Stratego-Sugar
imports
  Stratego-Sugar-Layout
  Stratego-Core-Identifiers
  Stratego-Sugar-Constants 
  Stratego-Sugar-Modules
  Stratego-Sugar-Signatures
  Stratego-Sugar-Terms
  Stratego-Sugar-Strategies
  Stratego-Sugar-Rules
  Stratego-Sugar-DynamicRules
  Stratego-Sugar-Overlays

hiddens
  context-free start-symbols Module

module Stratego
imports Stratego-Sugar
hiddens
  context-free start-symbols Module

module StrategoMix[Ctx0]
imports Stratego
          [ RuleNames      => RuleNames[[Ctx0]]
            RuleDec        => RuleDec[[Ctx0]]
            DynRuleScopeId => DynRuleScopeId[[Ctx0]]
            DynRuleId      => DynRuleId[[Ctx0]]
            DynRuleDef     => DynRuleDef[[Ctx0]]
            ScopeLabels    => ScopeLabels[[Ctx0]]
            RuleCond       => RuleCond[[Ctx0]]
            Rule           => Rule[[Ctx0]]
            RuleDef        => RuleDef[[Ctx0]]
            Overlay        => Overlay[[Ctx0]]
            SwitchCase     => SwitchCase[[Ctx0]]
            StrategyCurly  => StrategyCurly[[Ctx0]]
            StrategyAngle  => StrategyAngle[[Ctx0]]
            Kind           => Kind[[Ctx0]]
            LID            => LID[[Ctx0]]
            ImportModName  => ImportModName[[Ctx0]]
            Decl           => Decl[[Ctx0]]
            Module         => Module[[Ctx0]]
            StrategyParen  => StrategyParen[[Ctx0]]
            Typedid        => Typedid[[Ctx0]]
            StrategyDef    => StrategyDef[[Ctx0]]
            SVar           => SVar[[Ctx0]]
            Def            => Def[[Ctx0]]
            Type           => Type[[Ctx0]]
            RetType        => RetType[[Ctx0]]
            ArgType        => ArgType[[Ctx0]]
            FunType        => FunType[[Ctx0]]
            ConstType      => ConstType[[Ctx0]]
            Opdecl         => Opdecl[[Ctx0]]
            Sort           => Sort[[Ctx0]]
            Sdecl          => Sdecl[[Ctx0]]
            Wld            => Wld[[Ctx0]]
            ID             => ID[[Ctx0]]
            Var            => Var[[Ctx0]]
            CharChar       => CharChar[[Ctx0]]
            Char           => Char[[Ctx0]]
            StrChar        => StrChar[[Ctx0]]
            String         => String[[Ctx0]]
            Real           => Real[[Ctx0]]
            Int            => Int[[Ctx0]]
            Keyword        => Keyword[[Ctx0]]
            UCID           => UCID[[Ctx0]]
            LCID           => LCID[[Ctx0]]
            LId            => LId[[Ctx0]]
            Id             => Id[[Ctx0]]
            ModNamePart    => ModNamePart[[Ctx0]]
            ModName        => ModName[[Ctx0]]
            PreTerm        => PreTerm[[Ctx0]]
            Term           => Term[[Ctx0]]
            StrategyMid    => StrategyMid[[Ctx0]]
            Strategy       => Strategy[[Ctx0]] ]


module StrategoWebDSL

imports
  StrategoMix[StrategoHost]
  WebDslMix[ Term[[StrategoHost]] ]

hiddens
  context-free start-symbols Module[[StrategoHost]]

module Stratego-WebDSL-Java-XML

imports
  StrategoWebDSL
  Stratego-xml
  languages/java/EmbeddedJavaMix[Java Term[[StrategoHost]]]
  languages/java/eblock/JavaEBlockMix[Java]

hiddens
  context-free start-symbols Module[[StrategoHost]] 

exports

  context-free syntax
  
    %% concat-ids extension for java; see java-concat-ids.str
  
  	{ ID[[Java]] "#" }+ -> ID[[Java]] {cons("ConcatIds")}