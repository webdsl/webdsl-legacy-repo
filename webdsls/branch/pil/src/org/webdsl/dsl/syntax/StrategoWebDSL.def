definition
module DeriveMix

imports
  Derive

exports

  context-free syntax
    "derivebodyelem" "|[" DeriveBodyElement "]|" -> E {cons("ToMetaExpr")}
             
  variables
    "bodyelem" [0-9]*           -> DeriveBodyElement {prefer}
    "bodyelem_"[A-Za-z0-9]+     -> DeriveBodyElement {prefer}
    "bodyelem" [0-9]* "*"       -> DeriveBodyElement* {prefer}
    "bodyelem_"[A-Za-z0-9]+ "*" -> DeriveBodyElement* {prefer}

module StylingMix

imports
  Styling

exports

  context-free syntax
    "stsec"   "|[" StyleSection "]|" 				-> E {cons("ToMetaExpr")}
              "|[" StyleSection "]|" 				-> E {cons("ToMetaExpr")}
    "stsec*"  "|[" StyleSection* "]|" 				-> E {cons("ToMetaExpr")}
    "stdef"   "|[" StyleDefinition "]|" 			-> E {cons("ToMetaExpr")}
			  "|[" StyleDefinition "]|" 			-> E {cons("ToMetaExpr")}
    "stdef*"  "|[" StyleDefinition* "]|" 			-> E {cons("ToMetaExpr")}
    		  "|[" StyleDefinition* "]|" 			-> E {cons("ToMetaExpr")}
    "ststat"  "|[" StyleStatement "]|" 				-> E {cons("ToMetaExpr")}
              "|[" StyleStatement "]|" 				-> E {cons("ToMetaExpr")}
    "ststat*" "|[" StyleStatement* "]|" 			-> E {cons("ToMetaExpr")}
              "|[" StyleStatement* "]|" 			-> E {cons("ToMetaExpr")}
%%    "stdecl"  "|[" StyleDeclaration "]|" 			-> E {cons("ToMetaExpr")}
%%              "|[" StyleDeclaration "]|" 			-> E {cons("ToMetaExpr")}
%%    "stdecl*" "|[" StyleDeclaration* "]|" 			-> E {cons("ToMetaExpr")}

  variables
    "stsec"   [0-9]* 	 -> StyleSection  {prefer}
    "stsec*"  [0-9]* "*" -> StyleSection  {prefer}
    "stdef" [0-9]*     	 -> StyleDefinition  {prefer}
    "stdef" [0-9]* "*"   -> StyleDefinition* {prefer}
    "ststat"  [0-9]*     -> StyleStatement  {prefer}
    "ststat"  [0-9]* "*" -> StyleStatement* {prefer}
    "stdecl"  [0-9]*     -> StyleDeclaration  {prefer}
    "stdecl"  [0-9]* "*" -> StyleDeclaration* {prefer}
       
  context-free syntax
    "stsel" "|[" Selector "]|" -> E {cons("ToMetaExpr")}
    "stssel" "|[" SimpleSelector "]|" -> E {cons("ToMetaExpr")}
%%    "stssel" "|[" SimpleSelector "]|" -> E {cons("ToMetaExpr")}
    "stcomb" "|[" Combinator "]|" -> E {cons("ToMetaExpr")}
             "|[" (Combinator SimpleSelector) "]|" -> E {cons("ToMetaExpr")}
             "|[" (Combinator SimpleSelector)* "]|" -> E {cons("ToMetaExpr")}
             "|[" (Combinator SimpleSelector SelectorAttribute) "]|" -> E {cons("ToMetaExpr")}
             "|[" (Combinator SimpleSelector SelectorAttribute)* "]|" -> E {cons("ToMetaExpr")}
             
  variables
    "stsel" [0-9]*  		-> Selector {prefer}
    "stssel" [0-9]*  		-> SimpleSelector {prefer}
    "stcomb" [0-9]*  		-> Combinator {prefer}
    "stcombsel" [0-9]*  		-> (Combinator SimpleSelector) {prefer}
    
    "stmargs" [0-9]*  		-> MatchDefinitionArgs {prefer}
    "stmid"[0-9]* 			-> MatchIdent {prefer}
    [abc]"_"[A-Za-z0-9]+ 	-> MatchIdent {prefer}    

  context-free syntax
    "stprop"  "|[" StyleProperty "]|" 			-> E {cons("ToMetaExpr")}
    "stprop*" "|[" StyleProperty* "]|" 			-> E {cons("ToMetaExpr")}
    "stprop"  "|[" StylePropertyValue "]|" 		-> E {cons("ToMetaExpr")}
    "stprop*" "|[" StylePropertyValue* "]|" 		-> E {cons("ToMetaExpr")}
              "|[" StyleExpression "]|" 		-> E {cons("ToMetaExpr")}
              "|[" StyleValueExtension "]|" 		-> E {cons("ToMetaExpr")}
    "stval"   "|[" StyleValue "]|" 				-> E {cons("ToMetaExpr")}
    "stval*"  "|[" StyleValue* "]|" 				-> E {cons("ToMetaExpr")}

  variables
    "stprop" [0-9]*  	-> StyleProperty {prefer}
    "stprop" [0-9]* "*"  -> StyleProperty* {prefer}
    "stprop" [0-9]*  	-> StylePropertyValue {prefer}
    "stprop" [0-9]* "*"  -> StylePropertyValue* {prefer}
    "stexpr" [0-9]       -> StyleExpression {prefer}
    "stvalex" [0-9]       -> StyleValueExtension {prefer}
    "stval"  [0-9]*  	-> StyleValue {prefer}
    "stval"  [0-9]* "*"  -> StyleValue* {prefer}

module AccessControlMix

imports
  AccessControl

exports

  context-free syntax
    "acrule" "|[" AccessControlRule "]|" -> E {cons("ToMetaExpr")}
             "|[" AccessControlRule "]|" -> E {cons("ToMetaExpr")}
    "acdef"  "|[" AccessControlDefinition "]|" -> E {cons("ToMetaExpr")}
             "|[" AccessControlDefinition "]|" -> E {cons("ToMetaExpr")}


  variables
    "acrule" [0-9]*     -> AccessControlRule  {prefer}
    "acrule" [0-9]* "*" -> AccessControlRule* {prefer}
    "acdef"  [0-9]*     -> AccessControlDefinition  {prefer}
    "acdef"  [0-9]* "*" -> AccessControlDefinition* {prefer}
       
  context-free syntax
    "margs" "|[" MatchArgs "]|" -> E {cons("ToMetaExpr")}
            "|[" MatchArgs "]|" -> E {cons("ToMetaExpr")}
             
  variables
    "margs" [0-9]*  -> MatchArgs {prefer}
    
  context-free syntax
    "pexp"  "|[" PolicyExp "]|" -> E {cons("ToMetaExpr")}
            "|[" PolicyExp "]|" -> E {cons("ToMetaExpr")}        
             
  variables
    "pexp" [0-9]*  -> PolicyExp {prefer}
    
  variables
    "mid"[0-9]* -> MatchId {prefer}
    [xyz]"_"[A-Za-z0-9]+ -> MatchId {prefer}

module StringSelectEntity

%% syntax for string-select-entity

exports
  sorts TemplateDefinition

  context-free syntax
  
  "string-select-entity" Id "{" {String ","}* "}" -> TemplateDefinition {cons("StringSelectEntity")}

module TemplateMarkdown

exports

  sorts TemplateElement

context-free syntax

  "[" {PropertyAssignment ","}*"]" -> MDProps{cons("MDProps")}

  "*"  MDProps? TemplateElement		-> TemplateElement{cons("MDListItem")}
  "*"  MDProps? "{" TemplateElement* "}"	-> TemplateElement{cons("MDListItemMulti")}  
  "--" MDProps?						-> TemplateElement{cons("MDSpacer")}
  "="  MDProps? TemplateElement  "="-> TemplateElement{cons("MDHeader")} %%TemplateElement* would be amb
  "#" MDProps? "{" TemplateElement* "}"-> TemplateElement{cons("MDBlock")}
  "<"  MDProps? MDCol* ">" 			-> TemplateElement{cons("MDRow")}
  "<"  MDProps? TemplateElement* ">"-> TemplateElement{cons("MDRowNoCols")}  
  "|"  MDProps? TemplateElement*	-> MDCol{cons("MDCol")}
  "~"  MDProps? Exp ":" TemplateElement -> TemplateElement{cons("MDNavigate")}

module Procedures

exports
  sorts Section Definition

  context-free syntax

	"procedure" Id "(" FormalArg ")" "{"
	   ProcedureElement* 
	"}"                             -> Procedure {cons("Procedure")}

	"auto" "procedure" Id "(" FormalArg ")" "{"
	   ProcedureElement* 
	"}"                             -> Procedure {cons("AutoProcedure")}

  "extend" "procedure" Id "(" FormalArg ")" "{"
	   ProcedureElement* 
	"}"                             -> Definition {cons("ExtendProcedure")}

  Procedure                       -> Definition

	"who" "{" Exp "}"               -> ProcedureElement {cons("ProcedureWho")}
	"when" "{" Exp "}"					    -> ProcedureElement {cons("ProcedureWhen")}
	"do" Block							        -> ProcedureElement {cons("ProcedureDo")}
	"done" Block							      -> ProcedureElement {cons("ProcedureDone")}
	"enabled" Block							    -> ProcedureElement {cons("ProcedureEnabled")}
	"disabled" Block						    -> ProcedureElement {cons("ProcedureDisabled")}
	"view" "{" TemplateElement* "}" -> ProcedureElement {cons("ProcedureView")}
	
	"process" "{" ProcessExp "}"    -> ProcedureElement {cons("ProcedureProcess")}
	"processed" Block							  -> ProcedureElement {cons("ProcedureProcessed")}
	
  sorts ProcessExp
  
context-free syntax
    
    Id "(" Exp ")"                -> CallProcessExp {cons("ProcCall")} 
    CallProcessExp                -> ProcessExp                        
    ProcessExp ";" ProcessExp     -> ProcessExp {cons("ProcSeq"), left}
    
    "while" "(" Exp ")" "{" 
      ProcessExp 
    "}"                           -> ProcessExp {cons("ProcWhile")}
    
    "repeat" "{" 
      ProcessExp 
    "}" "until" CallProcessExp    -> ProcessExp {cons("ProcRepeatUntil")}

    "if" "(" Exp ")" "{" 
      ProcessExp 
     "}"                          -> ProcessExp {cons("ProcIfNoElse")}
    
    "if" "(" Exp ")" "{" 
      ProcessExp 
    "}" "else" "{" 
      ProcessExp 
    "}"                           -> ProcessExp {cons("ProcIf")}
    
    ProcessExp "xor" ProcessExp   -> ProcessExp {cons("ProcXor")}
    ProcessExp "and" ProcessExp   -> ProcessExp {cons("ProcAnd")}
    
    ProcessExp "+" ProcessExp     -> ProcessExp {cons("ProcPlus")}
    
    "(" ProcessExp ")"            -> ProcessExp {bracket}
  
  context-free priorities  
      {left:
        ProcessExp "and" ProcessExp  -> ProcessExp}
    > {left:
        ProcessExp "xor" ProcessExp  -> ProcessExp
        ProcessExp "+"   ProcessExp  -> ProcessExp }
    > {left:
        ProcessExp ";"   ProcessExp  -> ProcessExp {cons("ProcSeq"), left}}

module Derive

%% syntax for derivation of pages
exports

  sorts Derive DeriveType DeriveProperty

context-free syntax

  "derive" Id "from" Exp "for" "(" 
    {DeriveProperty ","}* 
  ")"                               -> TemplateElement {cons("Derive"), prefer}
  "derive" Id "from" Exp            -> TemplateElement {cons("Derive"), prefer}
  %%"derive" Id                       -> TemplateElement {cons("Derive"), prefer}
  %% Disabled this one for now because it is causing ambiguities, have a look at this Ruben!
  
  "derive" Id "from" Exp "for" "(" 
    {DeriveProperty ","}* 
  ")" DeriveBody                    -> TemplateElement {cons("Derive"), prefer}
  "derive" Id "from" Exp DeriveBody -> TemplateElement {cons("Derive"), prefer}
  "derive" Id DeriveBody            -> TemplateElement {cons("Derive"), prefer}
  
  Id                                -> DeriveProperty {cons("DeriveDefault")}
  Id "(" Id ")"                     -> DeriveProperty {cons("DeriveMode")}
  
  "{" DeriveBodyElement* "}"        -> DeriveBody {cons("DeriveBody")}
  
  Id "{" TemplateElement* "}"       -> DeriveBodyElement {cons("DeriveBodyElement")}
  
  "derive"                          -> TemplateCall {reject}

module PagedFor

%% syntax for paged enumerations

exports
  sorts TemplateElement

  context-free syntax

    "for" "(" Id ":" Sort Filter "per" Exp ")"
       "{" TemplateElement* "}"                             -> TemplateElement {cons("PagedForAll")}

    "for" "(" Id ":" Sort "per" Exp ")"
       "{" TemplateElement* "}"                             -> TemplateElement {cons("PagedForAllNoFilter")}

    "for" "(" Id ":" Sort "in" Exp Filter "per" Exp ")"
       "{" TemplateElement* "}"                             -> TemplateElement {cons("PagedFor")}

    "for" "(" Id ":" Sort "in" Exp "per" Exp ")"
       "{" TemplateElement* "}"                             -> TemplateElement {cons("PagedForNoFilter")}

module Enums

%% syntax for enumeration types

exports
  sorts Defintion EnumValue

  context-free syntax

  "enum" Id "{" {EnumValue ","}* "}"                    -> Definition {cons("Enum")}

  Id "(" String ")"                               -> EnumValue {cons("EnumValue")}

module Styling

%% syntax for styling of WebDSL applications

exports

  sorts
    Name StNum String UnaryOperator

  lexical syntax
    [a-zA-Z\_][a-zA-Z0-9\_\-]*			-> Identifier
    [a-zA-Z][a-zA-Z\-\_]+          		-> ValueName
    [a-z][a-z\-]+           	   		-> Value
    [a-f0-9][a-f0-9][a-f0-9][a-f0-9]* 		-> Hex
    [a-z\%]+                       		-> Unit
%%    [0-9]+                			-> StNum
%%    [0-9]* "." [0-9]+     			-> StNum
    "'" ~[\"\n]* "'"               		-> String
%%    [\-\+] StNum				-> StNumber

  lexical syntax
    [a-zA-Z][a-zA-Z0-9\_]*		 -> MatchIdent
%%    [a-zA-Z][a-zA-Z0-9\_]*[\*]? -> MatchIdent
%%    [\*]                        -> MatchIdent
%%    [\*]                        -> StWildCardArg 

  lexical restrictions
    ValueName 	-/- [a-zA-Z\-\_]
    Value 	-/- [a-z\-]
    Unit 	-/- [a-z\%]
    Hex 	-/- [a-f0-9]

exports

  sorts
     StNumber

  lexical syntax
    Float		      -> StNum
    SignedInteger	      -> StNum
    StNum                     -> StNumber
    StNum "%"                 -> Percentage {prefer}
    StNum "em"                -> Ems {prefer}
    StNum "ex"                -> Exs {prefer}
    StNum "px"                -> Length {prefer}
    StNum "cm"                -> Length {prefer}
    StNum "mm"                -> Length {prefer}
    StNum "in"                -> Length {prefer}
    StNum "pt"                -> Length {prefer}
    StNum "pc"                -> Length {prefer}
    StNum "deg"               -> Angle {prefer}
    StNum "rad"               -> Angle {prefer}
    StNum "grad"              -> Angle {prefer}
    StNum "ms"                -> Time {prefer}
    StNum "s"                 -> Time {prefer}
    StNum "hz"                -> Freq {prefer}
    StNum "khz"               -> Freq {prefer}
%%    StNum Id                  -> Dimension {prefer}

context-free syntax

  "theme" Modifier Id "(" ")" "{" StyleDeclaration* "}" -> Definition {cons("ThemeDefinition"), prefer}

context-free syntax %% Styling syntax

  "style" Id StyleDefinition*        -> Section {cons("StyleSection"), prefer}

  Selector "{" StyleStatement* "}"   -> StyleDefinition {cons("StyleDefinition")}

context-free syntax %% selectors

  SimpleSelector
    (Combinator SimpleSelector SelectorAttribute?)* -> Selector {cons("Selector")}

  Id MatchDefinition 			-> SimpleSelector {cons("SimpleSelector")}
  "#" Identifier			-> SimpleSelector {cons("IdSimpleSelector")}
  Id					-> SimpleSelector {cons("ElemSimpleSelector")}
  Id SelectorAttribute+		-> SimpleSelector {cons("ElemSimpleAttrSelector"), prefer}
  Id "." Identifier	SelectorAttribute+		-> SimpleSelector {cons("ElemClassAttrSelector"), prefer}
  "." Identifier 			-> SimpleSelector {cons("ClassSimpleSelector")}  
  MatchDefinition       		-> SimpleSelector {cons("SimpleSelector")}
  "*"			        	-> SimpleSelector {cons("UniversalSimpleSelector")}
  
  ":" ValueName				-> SelectorAttribute {cons("SelectorAttribute")}
  
  ">"                   		-> Combinator {cons("ChildCombinator")}
  ">>"                   		-> Combinator {cons("DescendantCombinator"), prefer}

  MatchIdent "(" MatchDefinitionArgs ")"		-> MatchDefinition {cons("MatchDefinition")}
  {FormalArg ","}*                                      -> MatchDefinitionArgs

  "const" Id ":" StyleSort ";" 				-> StyleVarDecl {cons("StyleVarDecl")}
  "const" Id ":" StyleSort ":=" StyleExpression ";" 	-> StyleVarDecl {cons("StyleVarDeclInit")}
  
  StyleVarDecl						-> StyleDefinition
  
  StyleProperty ":=" StyleExpression ";"      	        -> StyleStatement {cons("StyleDeclaration")}
%%  StylePropertyLocal ":=" StyleProperty ";"    	-> StyleStatement {cons("StyleDeclaration")}

  ValueName						-> StyleProperty {cons("StyleProperty")}

  MatchDefinition "." StyleProperty			-> StyleExpression {cons("StylePropertyValue")}

  Id 							-> StyleExpression {cons("StyleVar")}

  StyleValue 						-> StyleExpression
%%  StyleValues -> StyleExpression

  "(" Selector ")" "." StyleProperty 			-> StyleExpression {cons("StyleValueExpression")}

  StyleExpression "+" StyleExpression 			-> StyleExpression {cons("StyleAdd"),assoc}
  StyleExpression "-" StyleExpression 			-> StyleExpression {cons("StyleSub"),assoc}
  StyleExpression "*" StyleExpression 			-> StyleExpression {cons("StyleMul"),assoc}
  StyleExpression "/" StyleExpression 			-> StyleExpression {cons("StyleDiv"),assoc}

  StNumber Unit 					-> StyleValue {cons("StyleValue")}
  StNumber 						-> StyleValue {cons("StyleValue")}
  StyleSort StyleValueExtension+			-> StyleValue {cons("StyleValue")}
  Uri 							-> StyleValue {cons("StyleValue")}
  Hash 							-> StyleValue {cons("StyleValue")}
  Value		 					-> StyleValue {cons("StyleValue"), prefer}
  String	 					-> StyleValue {cons("StyleValue")}
  
  "." ValueName						-> StyleValueExtension {cons("StyleValueExtension") }

%%  {StyleValue "|"}* -> StyleValue {cons("StyleValueOptions") }

  Id Unit 						-> StyleSort {cons("StyleSort")}
  Id							-> StyleSort {cons("StyleSort")}

  "url" "(" String ")"    				-> Uri {cons("Uri")}
  "#" Hex                 				-> Hash {cons("Hash")}

  "const" 	-> Id {reject}  
%%  "layout" 	-> Id {reject}
%%  "style" 	-> Id {reject}
%%  "theme" 	-> Id {reject}

context-free priorities
  
  {left:
       StyleExpression "*" StyleExpression -> StyleExpression
       StyleExpression "/" StyleExpression -> StyleExpression }
  > {left:
       StyleExpression "+" StyleExpression -> StyleExpression
       StyleExpression "-" StyleExpression -> StyleExpression}

context-free syntax %% Layout syntax

  "layout" LayoutDefinition* 				-> Section {cons("LayoutSection"), prefer}

  Id MatchDefinition "{" LayoutStatement* "}"   	-> LayoutDefinition {cons("LayoutDefinition")}
  MatchDefinition "{" LayoutStatement* "}"   		-> LayoutDefinition {cons("LayoutDefinition")}
  
  StyleDefinition					-> LayoutDefinition
%%  StyleStatement					-> LayoutStatement
  
  "float" "{" MatchDefinition* "}" ";"			-> LayoutStatement {cons("FloatStatement")}
  
  LayoutExpression ";"                                  -> LayoutStatement {cons("LayoutStatement")}
  Id ":" "[" LayoutExpressions "]"     		        -> LayoutExpression {cons("NamedLayoutExpression")}
  {LayoutExpression "|"}+				-> LayoutExpressions
  Id			 				-> LayoutExpression {cons("LayoutExpression")}
  MatchDefinition 					-> LayoutExpression {cons("LayoutExpression")}

module ValidationAnnos
exports
  sorts Annotation PatternFlag

  context-free syntax
	%%string
    "length" "(" Int "," Int ")"              -> Annotation {cons("ValidationAnnoLength"),prefer}
    "minlength" "(" Int ")"                   -> Annotation {cons("ValidationAnnoMinLength"),prefer}   
    "maxlength" "(" Int ")"                   -> Annotation {cons("ValidationAnnoMaxLength"),prefer}    
 	"notempty"                                -> Annotation {cons("ValidationAnnoNotEmpty"),prefer}  
  	"email"                                   -> Annotation {cons("ValidationAnnoEmail"),prefer} 	 
  	"creditcardnumber"                        -> Annotation {cons("ValidationAnnoCreditCardNumber"),prefer} 	
 	"EAN"                                     -> Annotation {cons("ValidationAnnoEAN"),prefer} 
  	"pattern" "(" String ")"                  -> Annotation {cons("ValidationAnnoPattern"),prefer}   
  	"pattern" "(" String "," PatternFlag* ")" -> Annotation {cons("ValidationAnnoPatternWithFlags"),prefer}
  	
  	"canonicalequivalence"                    -> PatternFlag {cons("FlagCanonEq")} %% CANON_EQ Enables canonical equivalence.    
	"caseinsensitive"                         -> PatternFlag {cons("FlagCaseInsensitive")} %% CASE_INSENSITIVE Enables case-insensitive matching.
 	"comments"                                -> PatternFlag {cons("FlagComments")} %% COMMENTS Permits whitespace and comments in pattern.
 	"dotall"                                  -> PatternFlag {cons("FlagDotAll")} %% DOTALL Enables dotall mode.
 	"literal"                                 -> PatternFlag {cons("FlagLiteral")} %% LITERAL Enables literal parsing of the pattern.
 	"multiline"                               -> PatternFlag {cons("FlagMultiline")} %% MULTILINE Enables multiline mode.
 	"unicodecase"                             -> PatternFlag {cons("FlagUnicodeCase")} %% UNICODE_CASE Enables Unicode-aware case folding.
 	"unixlines"                               -> PatternFlag {cons("FlagUnixLines")} %% UNIX_LINES Enables Unix lines mode.
                 
	%%numeric or string representation of numeric
	"max" "(" Int ")"                         -> Annotation {cons("ValidationAnnoMax"),prefer} 
	"min" "(" Int ")"                         -> Annotation {cons("ValidationAnnoMin"),prefer}
    "range" "(" Int "," Int ")"               -> Annotation {cons("ValidationAnnoRange"),prefer}
    "minrange" "(" Int ")"                    -> Annotation {cons("ValidationAnnoMinRange"),prefer}   
    "maxrange" "(" Int ")"                    -> Annotation {cons("ValidationAnnoMaxRange"),prefer} 
    "digits" "(" Int "," Int ")"              -> Annotation {cons("ValidationAnnoDigits"),prefer}  
     
	%%date/calendar
	"past"                                    -> Annotation {cons("ValidationAnnoPast"),prefer} 
	"future"                                  -> Annotation {cons("ValidationAnnoFuture"),prefer} 	
	
	%%array, collection, map	
    "size" "(" Int "," Int ")"                -> Annotation {cons("ValidationAnnoSize"),prefer}
    "minsize" "(" Int ")"                     -> Annotation {cons("ValidationAnnoMinSize"),prefer}   
    "maxsize" "(" Int ")"                     -> Annotation {cons("ValidationAnnoMaxSize"),prefer} 
    
	%%object
  	"notnull"                                 -> Annotation {cons("ValidationAnnoNotNull"),prefer }
  	"asserttrue"                              -> Annotation {cons("ValidationAnnoAssertTrue"),prefer} 
  	"assertfalse"                             -> Annotation {cons("ValidationAnnoAssertFalse"),prefer} 
   	"valid"                                   -> Annotation {cons("ValidationAnnoValid"),prefer}

module AccessControl

%% syntax for access control  
exports

  sorts MatchId

  lexical syntax
    [a-zA-Z][a-zA-Z0-9\_]*[\*]? -> MatchId
    [\*]                        -> MatchId
    [\*]                        -> WildCardArg 

context-free syntax

  "access" "control" "rules" Id? AccessControlDefinition*  -> Section {cons("AccessControlDefinition")}
  %%deprecated: 
  "access" "control" "rules" "{" Id? AccessControlDefinition* "}"  -> Section {cons("AccessControlDefinition")}
  
  "principal" "is" Id "with" "credentials" {Id ","}+            -> Definition {cons("AccessControlPrincipal")} 
  "principal" "is" Id "with" "credentials" {Id ","}+            -> AccessControlDefinition {cons("AccessControlPrincipal")} 
  
  AccessControlRule                                             -> AccessControlDefinition
 
  "rule" Id MatchId "(" MatchArgs ")"
  "{" AccessControlCheck AccessControlRule* "}"                 -> AccessControlRule {cons("AccessControlRule")}
  %%deprecated:
  "rules" Id MatchId "(" MatchArgs ")"
  "{" AccessControlCheck AccessControlRule* "}"                 -> AccessControlRule {cons("AccessControlRule")}

  {FormalArg ","}* WildCardArg?                                 -> MatchArgs {cons("MatchArgs"),prefer}
  {Exp ","}* WildCardArg?                                       -> MatchArgs {cons("MatchArgs")}

  %% to prevent an AccessControlRule becoming an AccessControlCheck
  "rules"                                                       -> Exp {reject}

  Exp                                                           -> AccessControlCheck
  
  %% pagecheck
  %%"pagecheck" "<" Id "," Exp ">"  -> TemplateElement {cons("PageCheck"),prefer}
  %%"pagecheck" "(" Id "," Exp ")"  -> TemplateCall {reject}
  %%"pagecheck" "(" {Exp ","}* ")"                          -> TemplateCall {reject}
  
  "predicate" Id "(" {FormalArg ","}* ")" "{" Exp "}"           -> Definition {cons("Predicate")}
  "predicate" Id "(" {FormalArg ","}* ")" "{" Exp "}"           -> AccessControlDefinition {cons("Predicate")}
  
  Id MatchId "(" {Id ","}* WildCardArg? ")"                     -> AccessControlPointcutElement {cons("AccessControlPointcutElement")}
  
  "pointcut" Id "(" {FormalArg ","}* ")"
    "{" {AccessControlPointcutElement ","}* "}"                 -> AccessControlPointcut {cons("AccessControlPointcut")}
  
  AccessControlPointcut                                         -> AccessControlDefinition
  
  "access" "control" "policy" PolicyExp                         -> Section {cons("ACPolicy")}
  
  Id                                 -> PolicyExp {cons("Name")}
  "(" PolicyExp ")"                  -> PolicyExp {bracket}
  PolicyExp "AND" PolicyExp          -> PolicyExp {cons("PolicyAnd"), assoc}
  PolicyExp "OR" PolicyExp           -> PolicyExp {cons("PolicyOr"), assoc}
  
  
  %% hack for allowing multiple function checks to be added in different stages to a function call
  %%"acfunctioncheck" "(" Id "," Exp ")" Exp -> Exp {cons("ACFunctionCheck"), prefer}
  
context-free priorities
  {left:
       PolicyExp "AND" PolicyExp -> PolicyExp}
  > {left:
       PolicyExp "OR" PolicyExp -> PolicyExp}



context-free priorities
    Exp "in" Exp  -> Exp
  > Exp -> AccessControlCheck


module HQL

hiddens
  context-free start-symbols QueryRule Statement
  
exports
  lexical syntax
    [a-zA-Z\_][a-zA-Z0-9\_]* -> Identifier
  lexical restrictions
    Identifier -/- [a-zA-Z0-9\_]
    
  context-free syntax
   
    "from" | "select" | "by" | "order" -> Identifier {reject}

exports

%% header
%% {
%% //   $Id: hql.g 10164 2006-07-26 15:09:20Z steve.ebersole@jboss.com $
%% 
%% package org.hibernate.hql.antlr;
%% 
%% import org.hibernate.hql.ast.*;
%% import org.hibernate.hql.ast.util.*;
%% 
%% }
%% /**
%%  * Hibernate Query Language Grammar
%%  * <br>
%%  * This grammar parses the query language for Hibernate (an Open Source, Object-Relational
%%  * mapping library).  A partial BNF grammar description is available for reference here:
%%  * http://www.hibernate.org/Documentation/HQLBNF
%%  *
%%  * Text from the original reference BNF is prefixed with '//##'.
%%  * @author Joshua Davis (pgmjsd@sourceforge.net)
%%  */
%% class HqlBaseParser extends Parser;
%% 
%% options
%% {
%% 	exportVocab=Hql;
%% 	buildAST=true;
%% 	k=3;    // For 'not like', 'not in', etc.
%% }
%% 
%% tokens
%% {
%% 	// -- HQL Keyword tokens --
%% 	ALL="all";
%% 	ANY="any";
%% 	AND="and";
%% 	AS="as";
%% 	ASCENDING="asc";
%% 	AVG="avg";
%% 	BETWEEN="between";
%% 	CLASS="class";
%% 	COUNT="count";
%% 	DELETE="delete";
%% 	DESCENDING="desc";
%% 	DOT;
%% 	DISTINCT="distinct";
%% 	ELEMENTS="elements";
%% 	ESCAPE="escape";
%% 	EXISTS="exists";
%% 	FALSE="false";
%% 	FETCH="fetch";
%% 	FROM="from";
%% 	FULL="full";
%% 	GROUP="group";
%% 	HAVING="having";
%% 	IN="in";
%% 	INDICES="indices";
%% 	INNER="inner";
%% 	INSERT="insert";
%% 	INTO="into";
%% 	IS="is";
%% 	JOIN="join";
%% 	LEFT="left";
%% 	LIKE="like";
%% 	MAX="max";
%% 	MIN="min";
%% 	NEW="new";
%% 	NOT="not";
%% 	NULL="null";
%% 	OR="or";
%% 	ORDER="order";
%% 	OUTER="outer";
%% 	PROPERTIES="properties";
%% 	RIGHT="right";
%% 	SELECT="select";
%% 	SET="set";
%% 	SOME="some";
%% 	SUM="sum";
%% 	TRUE="true";
%% 	UNION="union";
%% 	UPDATE="update";
%% 	VERSIONED="versioned";
%% 	WHERE="where";
%% 
%% 	// -- SQL tokens --
%% 	// These aren't part of HQL, but the SQL fragment parser uses the HQL lexer, so they need to be declared here.
%% 	CASE="case";
%% 	END="end";
%% 	ELSE="else";
%% 	THEN="then";
%% 	WHEN="when";
%% 	ON="on";
%% 	WITH="with";
%% 
%% 	// -- EJBQL tokens --
%% 	BOTH="both";
%% 	EMPTY="empty";
%% 	LEADING="leading";
%% 	MEMBER="member";
%% 	OBJECT="object";
%% 	OF="of";
%% 	TRAILING="trailing";
%% 
%% 	// -- Synthetic token types --
%% 	AGGREGATE;		// One of the aggregate functions (e.g. min, max, avg)
%% 	ALIAS;
%% 	CONSTRUCTOR;
%% 	CASE2;
%% 	EXPR_LIST;
%% 	FILTER_ENTITY;		// FROM element injected because of a filter expression (happens during compilation phase 2)
%% 	IN_LIST;
%% 	INDEX_OP;
%% 	IS_NOT_NULL;
%% 	IS_NULL;			// Unary 'is null' operator.
%% 	METHOD_CALL;
%% 	NOT_BETWEEN;
%% 	NOT_IN;
%% 	NOT_LIKE;
%% 	ORDER_ELEMENT;
%% 	QUERY;
%% 	RANGE;
%% 	ROW_STAR;
%% 	SELECT_FROM;
%% 	UNARY_MINUS;
%% 	UNARY_PLUS;
%% 	VECTOR_EXPR;		// ( x, y, z )
%% 	WEIRD_IDENT;		// Identifiers that were keywords when they came in.
%% 
%% 	// Literal tokens.
%% 	CONSTANT;
%% 	NUM_DOUBLE;
%% 	NUM_FLOAT;
%% 	NUM_LONG;
%% 	JAVA_CONSTANT;
%% }
%% 
%% {
%%     /** True if this is a filter query (allow no FROM clause). **/
%% 	private boolean filter = false;
%% 
%% 	/**
%% 	 * Sets the filter flag.
%% 	 * @param f True for a filter query, false for a normal query.
%% 	 */
%% 	public void setFilter(boolean f) {
%% 		filter = f;
%% 	}
%% 
%% 	/**
%% 	 * Returns true if this is a filter query, false if not.
%% 	 * @return true if this is a filter query, false if not.
%% 	 */
%% 	public boolean isFilter() {
%% 		return filter;
%% 	}
%% 
%% 	/**
%% 	 * This method is overriden in the sub class in order to provide the
%% 	 * 'keyword as identifier' hack.
%% 	 * @param token The token to retry as an identifier.
%% 	 * @param ex The exception to throw if it cannot be retried as an identifier.
%% 	 */
%% 	public AST handleIdentifierError(Token token,RecognitionException ex) throws RecognitionException, TokenStreamException {
%% 		// Base implementation: Just re-throw the exception.
%% 		throw ex;
%% 	}
%% 
%%     /**
%%      * This method looks ahead and converts . <token> into . IDENT when
%%      * appropriate.
%%      */
%%     public void handleDotIdent() throws TokenStreamException {
%%     }
%% 
%% 	/**
%% 	 * Returns the negated equivalent of the expression.
%% 	 * @param x The expression to negate.
%% 	 */
%% 	public AST negateNode(AST x) {
%% 		// Just create a 'not' parent for the default behavior.
%% 		return ASTUtil.createParent(astFactory, NOT, "not", x);
%% 	}
%% 
%% 	/**
%% 	 * Returns the 'cleaned up' version of a comparison operator sub-tree.
%% 	 * @param x The comparison operator to clean up.
%% 	 */
%% 	public AST processEqualityExpression(AST x) throws RecognitionException {
%% 		return x;
%% 	}
%% 
%% 	public void weakKeywords() throws TokenStreamException { }
%% 
%% 	public void processMemberOf(Token n,AST p,ASTPair currentAST) { }
%% 
%% }

 
  sorts Statement UpdateStatement DeleteStatement SelectStatement InsertStatement
  
  context-free syntax

%% statement
%% 	: ( updateStatement | deleteStatement | selectStatement | insertStatement )
%% 	;

%%  UpdateStatement -> Statement
%%  DeleteStatement -> Statement
    SelectStatement -> Statement
%%  InsertStatement -> Statement

%% updateStatement
%% 	: UPDATE^ (VERSIONED)?
%% 		optionalFromTokenFromClause
%% 		setClause
%% 		(whereClause)?
%% 	;
%% 
%% setClause
%% 	: (SET^ assignment (COMMA! assignment)*)
%% 	;
%% 
%% assignment
%% 	: stateField EQ^ newValue
%% 	;
%% 
%% // "state_field" is the term used in the EJB3 sample grammar; used here for easy reference.
%% // it is basically a property ref
%% stateField
%% 	: path
%% 	;
%% 
%% // this still needs to be defined in the ejb3 spec; additiveExpression is currently just a best guess,
%% // although it is highly likely I would think that the spec may limit this even more tightly.
%% newValue
%% 	: concatenation
%% 	;
%% 
%% deleteStatement
%% 	: DELETE^
%% 		(optionalFromTokenFromClause)
%% 		(whereClause)?
%% 	;

%% optionalFromTokenFromClause!
%% 	: (FROM!)? f:path (a:asAlias)? {
%% 		AST #range = #([RANGE, "RANGE"], #f, #a);
%% 		#optionalFromTokenFromClause = #([FROM, "FROM"], #range);
%% 	}
%% 	;

  
%% selectStatement
%% 	: queryRule {
%% 		#selectStatement = #([QUERY,"query"], #selectStatement);
%% 	}
%% 	;

    QueryRule -> SelectStatement
    
%% insertStatement
%% 	// Would be nice if we could abstract the FromClause/FromElement logic
%% 	// out such that it could be reused here; something analogous to
%% 	// a "table" rule in sql-grammars
%% 	: INSERT^ intoClause selectStatement
%% 	;
%% 
%% intoClause
%% 	: INTO^ path { weakKeywords(); } insertablePropertySpec
%% 	;
%% 
%% insertablePropertySpec
%% 	: OPEN! primaryExpression ( COMMA! primaryExpression )* CLOSE! {
%% 		// Just need *something* to distinguish this on the hql-sql.g side
%% 		#insertablePropertySpec = #([RANGE, "column-spec"], #insertablePropertySpec);
%% 	}
%% 	;
%% 
%% union
%% 	: queryRule (UNION queryRule)*
%% 	;

    QueryRule "union" QueryRule -> Union {cons("QueryUnion")}
    
%% //## query:
%% //##     [selectClause] fromClause [whereClause] [groupByClause] [havingClause] [orderByClause];
%% 
%% queryRule
%% 	: selectFrom
%% 		(whereClause)?
%% 		(groupByClause)?
%% 		(orderByClause)?
%% 		;

    SelectFrom WhereClause? GroupByClause? OrderByClause? -> QueryRule {cons("QueryRule")}
    
%% selectFrom!
%% 	:  (s:selectClause)? (f:fromClause)? {
%% 		// If there was no FROM clause and this is a filter query, create a from clause.  Otherwise, throw
%% 		// an exception because non-filter queries must have a FROM clause.
%% 		if (#f == null) {
%% 			if (filter) {
%% 				#f = #([FROM,"{filter-implied FROM}"]);
%% 			}
%% 			else
%% 				throw new SemanticException("FROM expected (non-filter queries must contain a FROM clause)");
%% 		}
%% 			
%% 		// Create an artificial token so the 'FROM' can be placed
%% 		// before the SELECT in the tree to make tree processing
%% 		// simpler.
%% 		#selectFrom = #([SELECT_FROM,"SELECT_FROM"],f,s);
%% 	}
%% 	;

    SelectClause? FromClause -> SelectFrom {cons("SelectFrom")}
    
    %% inline this in the QueryRule production?
    %% suggests that query can be empty, that case should be avoided
    %% probably just say that FromClause is compulsary
    
%% //## selectClause:
%% //##     SELECT DISTINCT? selectedPropertiesList | ( NEW className OPEN selectedPropertiesList CLOSE );
%% 
%% selectClause
%% 	: SELECT^	// NOTE: The '^' after a token causes the corresponding AST node to be the root of the sub-tree.
%% 		{ weakKeywords(); }	// Weak keywords can appear immediately after a SELECT token.
%% 		(DISTINCT)? ( selectedPropertiesList | newExpression | selectObject )
%% 	;

    "select" Distinct? Selection -> SelectClause {cons("Select")}

    "distinct"                   -> Distinct {cons("Distinct")}
    
    SelectedPropertiesList -> Selection
    NewExpression          -> Selection
    SelectObject           -> Selection
    
%% newExpression
%% 	: (NEW! path) op:OPEN^ {#op.setType(CONSTRUCTOR);} selectedPropertiesList CLOSE!
%% 	;

  "new" Path "(" SelectedPropertiesList ")" -> NewExpression {cons("NewExpression")}
  
%% selectObject
%%    : OBJECT^ OPEN! identifier CLOSE!
%%    ;

  "object" "(" Identifier ")" -> SelectObject {cons("SelectObject")}
  
%% //## fromClause:
%% //##    FROM className AS? identifier (  ( COMMA className AS? identifier ) | ( joinType path AS? identifier ) )*;
%% 
%% // NOTE: This *must* begin with the "FROM" token, otherwise the sub-query rule will be ambiguous
%% // with the expression rule.
%% // Also note: after a comma weak keywords are allowed and should be treated as identifiers.
%% 
%% fromClause
%% 	: FROM^ { weakKeywords(); } fromRange ( fromJoin | COMMA! { weakKeywords(); } fromRange )*
%% 	;

    "from" {FromRangeJoin ","}+ -> FromClause {cons("FromClause")}
    
    FromRange FromJoin? -> FromRangeJoin {cons("FromRangeJoin")}
    
%% //## joinType:
%% //##     ( ( 'left'|'right' 'outer'? ) | 'full' | 'inner' )? JOIN FETCH?;
%% 
%% fromJoin
%% 	: ( ( ( LEFT | RIGHT ) (OUTER)? ) | FULL | INNER )? JOIN^ (FETCH)? 
%% 	  path (asAlias)? (propertyFetch)? (withClause)?
%% 	;

    "left"          -> JoinType {cons("LeftJoin")}
    "right"         -> JoinType {cons("RightJoin")}
    "left"  "outer" -> JoinType {cons("LeftOuterJoin")}
    "right" "outer" -> JoinType {cons("RightOuterJoin")}
    "full"          -> JoinType {cons("FullJoin")}
    "inner"         -> JoinType {cons("InnerJoin")}
    
    JoinType? "join" Fetch? Path AsAlias? PropertyFetch? WithClause? -> FromJoin {cons("FromJoin")}
    
    "fetch" -> Fetch {cons("Fetch")}
        
%% withClause
%% 	: WITH^ logicalExpression
%% 	;

  "with" Expression -> WithClause {cons("WithClause")}
  
%% fromRange
%% 	: fromClassOrOuterQueryPath
%% 	| inClassDeclaration
%% 	| inCollectionDeclaration
%% 	| inCollectionElementsDeclaration
%% 	;

    FromClassOrOuterQueryPath       -> FromRange
    InClassDeclaration              -> FromRange
    InCollectionDeclaration         -> FromRange
    InCollectionElementsDeclaration -> FromRange
    
%% fromClassOrOuterQueryPath!
%% 	: c:path { weakKeywords(); } (a:asAlias)? (p:propertyFetch)? {
%% 		#fromClassOrOuterQueryPath = #([RANGE, "RANGE"], #c, #a, #p);
%% 	}
%% 	;

    Path AsAlias? PropertyFetch? -> FromClassOrOuterQueryPath {cons("FromClass")}
    
%% inClassDeclaration!
%% 	: a:alias IN! CLASS! c:path {
%% 		#inClassDeclaration = #([RANGE, "RANGE"], #c, #a);
%% 	}
%% 	;

    Alias "in" "class" Path -> InClassDeclaration {cons("InClassDeclaration")}
    
%% inCollectionDeclaration!
%%     : IN! OPEN! p:path CLOSE! a:alias {
%%         #inCollectionDeclaration = #([JOIN, "join"], [INNER, "inner"], #p, #a);
%% 	}
%%     ;

    "in" "(" Path ")" Alias -> InCollectionDeclaration {cons("InCollection")}
    
%% inCollectionElementsDeclaration!
%% 	: a:alias IN! ELEMENTS! OPEN! p:path CLOSE! {
%%         #inCollectionElementsDeclaration = #([JOIN, "join"], [INNER, "inner"], #p, #a);
%% 	}
%%     ;

    Alias "in" "elements" "(" Path ")" -> InCollectionElementsDeclaration {cons("InCollectionElements")}

%% // Alias rule - Parses the optional 'as' token and forces an AST identifier node.
%% asAlias
%% 	: (AS!)? alias
%% 	;

  "as" Alias -> AsAlias {cons("AsAlias")}
  
%% alias
%% 	: a:identifier { #a.setType(ALIAS); }
%%     ;

  Identifier -> Alias {cons("Alias")}
  
%% propertyFetch
%% 	: FETCH ALL! PROPERTIES!
%% 	;

    "fetch" "all" "properties" -> PropertyFetch {cons("PropertyFetch")}
    
%% //## groupByClause:
%% //##     GROUP_BY path ( COMMA path )*;
%% 
%% groupByClause
%% 	: GROUP^ 
%% 		"by"! expression ( COMMA! expression )*
%% 		(havingClause)?
%% 	;

    "group" "by" {Expression ","}+ HavingClause? -> GroupByClause {cons("GroupBy")}
    
%% //## orderByClause:
%% //##     ORDER_BY selectedPropertiesList;
%% 
%% orderByClause
%% 	: ORDER^ "by"! orderElement ( COMMA! orderElement )*
%% 	;

    "order" "by" {OrderElement ","}+ -> OrderByClause {cons("OrderByClause")}
    
%% orderElement
%% 	: expression ( ascendingOrDescending )?
%% 	;

    Expression AscendingOrDescending? -> OrderElement {cons("OrderElement")}
    
%% ascendingOrDescending
%% 	: ( "asc" | "ascending" )	{ #ascendingOrDescending.setType(ASCENDING); }
%% 	| ( "desc" | "descending") 	{ #ascendingOrDescending.setType(DESCENDING); }
%% 	;

   "asc"       -> AscendingOrDescending {cons("Ascending")}
   "ascending" -> AscendingOrDescending {cons("Ascending")}
   
   "desc"      -> AscendingOrDescending {cons("Descending")}
   "descending" -> AscendingOrDescending {cons("Descending")}
   
%% //## havingClause:
%% //##     HAVING logicalExpression;

    "having" Expression -> HavingClause {cons("HavingClause")}
    
%% havingClause
%% 	: HAVING^ logicalExpression
%% 	;
%% 
%% //## whereClause:
%% //##     WHERE logicalExpression;

    "where" Expression -> WhereClause {cons("WhereClause")}
    
%% whereClause
%% 	: WHERE^ logicalExpression
%% 	;
%% 
%% //## selectedPropertiesList:
%% //##     ( path | aggregate ) ( COMMA path | aggregate )*;
%% 
%% selectedPropertiesList
%% 	: aliasedExpression ( COMMA! aliasedExpression )*
%% 	;

    {AliasedExpression ","}+ -> SelectedPropertiesList
    
%% aliasedExpression
%% 	: expression ( AS^ identifier )?
%% 	;

    Expression AsAlias? -> AliasedExpression {cons("AliasedExpression")}
    
    %% forget that AsAlias defined the same thing?
    
%% // expressions
%% // Note that most of these expressions follow the pattern
%% //   thisLevelExpression :
%% //       nextHigherPrecedenceExpression
%% //           (OPERATOR nextHigherPrecedenceExpression)*
%% // which is a standard recursive definition for a parsing an expression.
%% //
%% // Operator precedence in HQL
%% // lowest  --> ( 7)  OR
%% //             ( 6)  AND, NOT
%% //             ( 5)  equality: ==, <>, !=, is
%% //             ( 4)  relational: <, <=, >, >=,
%% //                   LIKE, NOT LIKE, BETWEEN, NOT BETWEEN, IN, NOT IN
%% //             ( 3)  addition and subtraction: +(binary) -(binary)
%% //             ( 2)  multiplication: * / %, concatenate: ||
%% // highest --> ( 1)  +(unary) -(unary)
%% //                   []   () (method call)  . (dot -- identifier qualification)
%% //                   aggregate function
%% //                   ()  (explicit parenthesis)
%% //
%% // Note that the above precedence levels map to the rules below...
%% // Once you have a precedence chart, writing the appropriate rules as below
%% // is usually very straightfoward
%% 
%% logicalExpression
%% 	: expression
%% 	;

    %% right, so we are not going to do *that*

    %%Expression -> LogicalExpression
    
%% // Main expression rule
%% expression
%% 	: logicalOrExpression
%% 	;

    %%LogicalOrExpression -> Expression
    
%% // level 7 - OR
%% logicalOrExpression
%% 	: logicalAndExpression ( OR^ logicalAndExpression )*
%% 	;

   %% {LogicalAndExpression "or"}+ -> LogicalOrExpression {cons("QueryLogicalOr")}
   
   Expression "or" Expression -> Expression {cons("QueryOr")}
   
%% // level 6 - AND, NOT
%% logicalAndExpression
%% 	: negatedExpression ( AND^ negatedExpression )*
%% 	;

    %% {NegatedExpression "and"}+ -> LogicalAndExpression {cons("QueryLogicalAnd")}
    
    Expression "and" Expression -> Expression {cons("QueryAnd")}
    
%% // NOT nodes aren't generated.  Instead, the operator in the sub-tree will be
%% // negated, if possible.   Expressions without a NOT parent are passed through.
%% negatedExpression!
%% { weakKeywords(); } // Weak keywords can appear in an expression, so look ahead.
%% 	: NOT^ x:negatedExpression { #negatedExpression = negateNode(#x); }
%% 	| y:equalityExpression { #negatedExpression = #y; }
%% 	;

    "not" Expression -> Expression {cons("QueryNot")}
    
%% //## OP: EQ | LT | GT | LE | GE | NE | SQL_NE | LIKE;
%% 
%% // level 5 - EQ, NE
%% equalityExpression
%% 	: x:relationalExpression (
%% 		( EQ^
%% 		| is:IS^	{ #is.setType(EQ); } (NOT! { #is.setType(NE); } )?
%% 		| NE^
%% 		| ne:SQL_NE^	{ #ne.setType(NE); }
%% 		) y:relationalExpression)* {
%% 			// Post process the equality expression to clean up 'is null', etc.
%% 			#equalityExpression = processEqualityExpression(#equalityExpression);
%% 		}
%% 	;

    Expression "=" Expression -> Expression {cons("EQ")}
    Expression "is" Expression -> Expression {cons("IS")}
    Expression "!=" Expression -> Expression {cons("NE")}
    Expression "<>" Expression -> Expression {cons("SQLNE")}
    Expression "like" Expression -> Expression {cons("LIKE")}
    Expression "not" "like" Expression -> Expression {cons("NOTLIKE")}

%% // level 4 - LT, GT, LE, GE, LIKE, NOT LIKE, BETWEEN, NOT BETWEEN
%% // NOTE: The NOT prefix for LIKE and BETWEEN will be represented in the
%% // token type.  When traversing the AST, use the token type, and not the
%% // token text to interpret the semantics of these nodes.
%% relationalExpression
%% 	: concatenation (
%% 		( ( ( LT^ | GT^ | LE^ | GE^ ) additiveExpression )* )
%% 		// Disable node production for the optional 'not'.
%% 		| (n:NOT!)? (
%% 			// Represent the optional NOT prefix using the token type by
%% 			// testing 'n' and setting the token type accordingly.
%% 			(i:IN^ {
%% 					#i.setType( (n == null) ? IN : NOT_IN);
%% 					#i.setText( (n == null) ? "in" : "not in");
%% 				}
%% 				inList)
%% 			| (b:BETWEEN^ {
%% 					#b.setType( (n == null) ? BETWEEN : NOT_BETWEEN);
%% 					#b.setText( (n == null) ? "between" : "not between");
%% 				}
%% 				betweenList )
%% 			| (l:LIKE^ {
%% 					#l.setType( (n == null) ? LIKE : NOT_LIKE);
%% 					#l.setText( (n == null) ? "like" : "not like");
%% 				}
%% 				concatenation likeEscape)
%% 			| (MEMBER! (OF!)? p:path! {
%% 				processMemberOf(n,#p,currentAST);
%% 			  } ) )
%% 		)
%% 	;

    Expression "<" Expression -> Expression {cons("LT")}
    
    Expression "in" Expression -> Expression {cons("In")}
    Expression "not" "in" Expression -> Expression {cons("NotIn")}
    
    Expression "member" "of" Expression -> Expression {cons("MemberOf")}
    Expression "not" "member" "of" Expression -> Expression {cons("NotMemberOf")}
  
%% likeEscape
%% 	: (ESCAPE^ concatenation)?
%% 	;
%% 
%% inList
%% 	: x:compoundExpr
%% 	{ #inList = #([IN_LIST,"inList"], #inList); }
%% 	;
%% 
%% betweenList
%% 	: concatenation AND! concatenation
%% 	;

    %%Expression "and" Expression -> Expression {cons("QueryAnd")}
    %% already had that one!
     
%% //level 4 - string concatenation
%% concatenation
%% 	: additiveExpression 
%% 	( c:CONCAT^ { #c.setType(EXPR_LIST); #c.setText("concatList"); } 
%% 	  additiveExpression
%% 	  ( CONCAT! additiveExpression )* 
%% 	  { #concatenation = #([METHOD_CALL, "||"], #([IDENT, "concat"]), #c ); } )?
%% 	;

    Expression "||" Expression -> Expression {cons("Concat")}
    
%% // level 3 - binary plus and minus
%% additiveExpression
%% 	: multiplyExpression ( ( PLUS^ | MINUS^ ) multiplyExpression )*
%% 	;

    Expression "+" Expression -> Expression {cons("Plus")}
    Expression "-" Expression -> Expression {cons("Minus")}

%% // level 2 - binary multiply and divide
%% multiplyExpression
%% 	: unaryExpression ( ( STAR^ | DIV^ ) unaryExpression )*
%% 	;

    Expression "*" Expression -> Expression {cons("Multiply")}
    Expression "/" Expression -> Expression {cons("Divide")}
    
%% // level 1 - unary minus, unary plus, not
%% unaryExpression
%% 	: MINUS^ {#MINUS.setType(UNARY_MINUS);} unaryExpression
%% 	| PLUS^ {#PLUS.setType(UNARY_PLUS);} unaryExpression
%% 	| caseExpression
%% 	| quantifiedExpression
%% 	| atom
%% 	;

    "-" Expression -> Expression {cons("UMinus")}
    
%% caseExpression
%% 	: CASE^ (whenClause)+ (elseClause)? END! 
%% 	| CASE^ { #CASE.setType(CASE2); } unaryExpression (altWhenClause)+ (elseClause)? END!
%% 	;

%%  "case" WhenClause+ ElseClause? "end" -> Expression {cons("Case")}
    
%% whenClause
%% 	: (WHEN^ logicalExpression THEN! unaryExpression)
%% 	;
%% 	
%% altWhenClause
%% 	: (WHEN^ unaryExpression THEN! unaryExpression)
%% 	;
%% 	
%% elseClause
%% 	: (ELSE^ unaryExpression)
%% 	;
%% 	
%% quantifiedExpression
%% 	: ( SOME^ | EXISTS^ | ALL^ | ANY^ ) 
%% 	( identifier | collectionExpr | (OPEN! ( subQuery ) CLOSE!) )
%% 	;
%% 
%% // level 0 - expression atom
%% // ident qualifier ('.' ident ), array index ( [ expr ] ),
%% // method call ( '.' ident '(' exprList ') )
%% atom
%% 	 : primaryExpression
%% 		(
%% 			DOT^ identifier
%% 				( options { greedy=true; } :
%% 					( op:OPEN^ {#op.setType(METHOD_CALL);} exprList CLOSE! ) )?
%% 		|	lb:OPEN_BRACKET^ {#lb.setType(INDEX_OP);} expression CLOSE_BRACKET!
%% 		)*
%% 	;
%% 
%% // level 0 - the basic element of an expression
%% primaryExpression
%% 	:   identPrimary ( options {greedy=true;} : DOT^ "class" )?
%% 	|   constant
%% 	|   COLON^ identifier
%% 	// TODO: Add parens to the tree so the user can control the operator evaluation order.
%% 	|   OPEN! (expressionOrVector | subQuery) CLOSE!
%% 	;

   %%syntax 
   %%  ":" <Identifier-CF> -> <Parameter-CF> {cons("IdParam")}
   %%  "?" <NumInt-CF>     -> <Parameter-CF> {cons("NumParam")}
   lexical syntax 
     ":" Identifier -> IdParameter 
     "?" NumInt     -> NumParameter
   context-free syntax
     IdParameter -> Expression {cons("IdParam")}
     NumParameter -> Expression {cons("NumParam")}
   
%% // This parses normal expression and a list of expressions separated by commas.  If a comma is encountered
%% // a parent VECTOR_EXPR node will be created for the list.
%% expressionOrVector!
%% 	: e:expression ( v:vectorExpr )? {
%% 		// If this is a vector expression, create a parent node for it.
%% 		if (#v != null)
%% 			#expressionOrVector = #([VECTOR_EXPR,"{vector}"], #e, #v);
%% 		else
%% 			#expressionOrVector = #e;
%% 	}
%% 	;
%% 
%% vectorExpr
%% 	: COMMA! expression (COMMA! expression)*
%% 	;
%% 
%% // identifier, followed by member refs (dot ident), or method calls.
%% // NOTE: handleDotIdent() is called immediately after the first IDENT is recognized because
%% // the method looks a head to find keywords after DOT and turns them into identifiers.
%% identPrimary
%% 	: identifier { handleDotIdent(); }
%% 			( options { greedy=true; } : DOT^ ( identifier | ELEMENTS | o:OBJECT { #o.setType(IDENT); } ) )*
%% 			( options { greedy=true; } :
%% 				( op:OPEN^ { #op.setType(METHOD_CALL);} exprList CLOSE! )
%% 			)?
%% 	// Also allow special 'aggregate functions' such as count(), avg(), etc.
%% 	| aggregate
%% 	;

    %%Identifier -> Expression
    
%% //## aggregate:
%% //##     ( aggregateFunction OPEN path CLOSE ) | ( COUNT OPEN STAR CLOSE ) | ( COUNT OPEN (DISTINCT | ALL) path CLOSE );
%% 
%% //## aggregateFunction:
%% //##     COUNT | 'sum' | 'avg' | 'max' | 'min';
%% 
%% aggregate
%% 	: ( SUM^ | AVG^ | MAX^ | MIN^ ) OPEN! additiveExpression CLOSE! { #aggregate.setType(AGGREGATE); }
%% 	// Special case for count - It's 'parameters' can be keywords.
%% 	|  COUNT^ OPEN! ( STAR { #STAR.setType(ROW_STAR); } | ( ( DISTINCT | ALL )? ( path | collectionExpr ) ) ) CLOSE!
%% 	|  collectionExpr
%% 	;

    "sum" "(" Expression ")" -> Expression {cons("Sum")}
    
%% //## collection: ( OPEN query CLOSE ) | ( 'elements'|'indices' OPEN path CLOSE );
%% 
%% collectionExpr
%% 	: (ELEMENTS^ | INDICES^) OPEN! path CLOSE!
%% 	;

     "elements" "(" Path ")" -> Expression {cons("Elements")}
     "indices" "(" Path ")" -> Expression {cons("Indices")}
                     
%% // NOTE: compoundExpr can be a 'path' where the last token in the path is '.elements' or '.indicies'
%% compoundExpr
%% 	: collectionExpr
%% 	| path
%% 	| (OPEN! ( (expression (COMMA! expression)*) | subQuery ) CLOSE!)
%% 	;

     Path                      -> Expression
     "(" {Expression ","}+ ")" -> Expression {cons("Paren")}
     
%% subQuery
%% 	: union
%% 	{ #subQuery = #([QUERY,"query"], #subQuery); }
%% 	;
%% 
%% exprList
%% {
%%    AST trimSpec = null;
%% }
%% 	: (t:TRAILING {#trimSpec = #t;} | l:LEADING {#trimSpec = #l;} | b:BOTH {#trimSpec = #b;})?
%% 	  		{ if(#trimSpec != null) #trimSpec.setType(IDENT); }
%% 	  ( 
%% 	  		expression ( (COMMA! expression)+ | FROM { #FROM.setType(IDENT); } expression | AS! identifier )? 
%% 	  		| FROM { #FROM.setType(IDENT); } expression
%% 	  )?
%% 			{ #exprList = #([EXPR_LIST,"exprList"], #exprList); }
%% 	;
%% 
%% constant
%% 	: NUM_INT
%% 	| NUM_FLOAT
%% 	| NUM_LONG
%% 	| NUM_DOUBLE
%% 	| QUOTED_STRING
%% 	| NULL
%% 	| TRUE
%% 	| FALSE
%% 	| EMPTY
%% 	;

    Constant -> Expression
    
    "true" -> Constant {cons("True")}
    "false" -> Constant {cons("False")}
    "empty" -> Constant {cons("Empty")}
    "null" -> Constant {cons("Null")}
    
    
%% //## quantifiedExpression: 'exists' | ( expression 'in' ) | ( expression OP 'any' | 'some' ) collection;
%% 
%% //## compoundPath: path ( OPEN_BRACKET expression CLOSE_BRACKET ( '.' path )? )*;
%% 
%% //## path: identifier ( '.' identifier )*;
%% 
%% path
%% 	: identifier ( DOT^ { weakKeywords(); } identifier )*
%% 	;

    {Identifier "."}+ -> Path {cons("Path")} 
    
%% // Wraps the IDENT token from the lexer, in order to provide
%% // 'keyword as identifier' trickery.
%% identifier
%% 	: IDENT
%% 	exception
%% 	catch [RecognitionException ex]
%% 	{
%% 		identifier_AST = handleIdentifierError(LT(1),ex);
%% 	}
%% 	; 
  
%% // **** LEXER ******************************************************************
%% 
%% /**
%%  * Hibernate Query Language Lexer
%%  * <br>
%%  * This lexer provides the HQL parser with tokens.
%%  * @author Joshua Davis (pgmjsd@sourceforge.net)
%%  */
%% class HqlBaseLexer extends Lexer;
%% 
%% options {
%% 	exportVocab=Hql;      // call the vocabulary "Hql"
%% 	testLiterals = false;
%% 	k=2; // needed for newline, and to distinguish '>' from '>='.
%% 	// HHH-241 : Quoted strings don't allow unicode chars - This should fix it.
%% 	charVocabulary='\u0000'..'\uFFFE';	// Allow any char but \uFFFF (16 bit -1, ANTLR's EOF character)
%% 	caseSensitive = false;
%% 	caseSensitiveLiterals = false;
%% }
%% 
%% // -- Declarations --
%% {
%% 	// NOTE: The real implementations are in the subclass.
%% 	protected void setPossibleID(boolean possibleID) {}
%% }
%% 
%% // -- Keywords --
%% 
%% EQ: '=';
%% LT: '<';
%% GT: '>';
%% SQL_NE: "<>";
%% NE: "!=" | "^=";
%% LE: "<=";
%% GE: ">=";
%% 
%% COMMA: ',';
%% 
%% OPEN: '(';
%% CLOSE: ')';
%% OPEN_BRACKET: '[';
%% CLOSE_BRACKET: ']';
%% 
%% CONCAT: "||";
%% PLUS: '+';
%% MINUS: '-';
%% STAR: '*';
%% DIV: '/';
%% COLON: ':';
%% PARAM: '?';
%% 
%% IDENT options { testLiterals=true; }
%% 	: ID_START_LETTER ( ID_LETTER )*
%% 		{
%%     		// Setting this flag allows the grammar to use keywords as identifiers, if necessary.
%% 			setPossibleID(true);
%% 		}
%% 	;
%% 
%% protected
%% ID_START_LETTER
%%     :    '_'
%%     |    '$'
%%     |    'a'..'z'
%%     |    '\u0080'..'\ufffe'       // HHH-558 : Allow unicode chars in identifiers
%%     ;
%% 
%% protected
%% ID_LETTER
%%     :    ID_START_LETTER
%%     |    '0'..'9'
%%     ;
%% 
%% QUOTED_STRING
%% 	  : '\'' ( (ESCqs)=> ESCqs | ~'\'' )* '\''
%% 	;

  context-free syntax
    QuotedString -> Constant {cons("String")}
    
  lexical syntax
    "'" (~[\'] | "\\'")* "'" -> QuotedString
     
%% protected
%% ESCqs
%% 	:
%% 		'\'' '\''
%% 	;
%% 
%% WS  :   (   ' '
%% 		|   '\t'
%% 		|   '\r' '\n' { newline(); }
%% 		|   '\n'      { newline(); }
%% 		|   '\r'      { newline(); }
%% 		)
%% 		{$setType(Token.SKIP);} //ignore this token
%% 	;

  lexical syntax
    [0-9]+ -> NumInt
  context-free syntax
    NumInt -> Constant
  
%% //--- From the Java example grammar ---
%% // a numeric literal
%% NUM_INT
%% 	{boolean isDecimal=false; Token t=null;}
%% 	:   '.' {_ttype = DOT;}
%% 			(	('0'..'9')+ (EXPONENT)? (f1:FLOAT_SUFFIX {t=f1;})?
%% 				{
%% 					if (t != null && t.getText().toUpperCase().indexOf('F')>=0)
%% 					{
%% 						_ttype = NUM_FLOAT;
%% 					}
%% 					else
%% 					{
%% 						_ttype = NUM_DOUBLE; // assume double
%% 					}
%% 				}
%% 			)?
%% 	|	(	'0' {isDecimal = true;} // special case for just '0'
%% 			(	('x')
%% 				(											// hex
%% 					// the 'e'|'E' and float suffix stuff look
%% 					// like hex digits, hence the (...)+ doesn't
%% 					// know when to stop: ambig.  ANTLR resolves
%% 					// it correctly by matching immediately.  It
%% 					// is therefore ok to hush warning.
%% 					options { warnWhenFollowAmbig=false; }
%% 				:	HEX_DIGIT
%% 				)+
%% 			|	('0'..'7')+									// octal
%% 			)?
%% 		|	('1'..'9') ('0'..'9')*  {isDecimal=true;}		// non-zero decimal
%% 		)
%% 		(	('l') { _ttype = NUM_LONG; }
%% 
%% 		// only check to see if it's a float if looks like decimal so far
%% 		|	{isDecimal}?
%% 			(   '.' ('0'..'9')* (EXPONENT)? (f2:FLOAT_SUFFIX {t=f2;})? 
%% 			|   EXPONENT (f3:FLOAT_SUFFIX {t=f3;})?
%% 			|   f4:FLOAT_SUFFIX {t=f4;}
%% 			)
%% 			{
%% 				if (t != null && t.getText().toUpperCase() .indexOf('F') >= 0)
%% 				{
%% 					_ttype = NUM_FLOAT;
%% 				}
%% 				else
%% 				{
%% 					_ttype = NUM_DOUBLE; // assume double
%% 				}
%% 			}     
%% 		)?
%% 	;
%% 
%% // hexadecimal digit (again, note it's protected!)
%% protected
%% HEX_DIGIT
%% 	:	('0'..'9'|'a'..'f')
%% 	;
%%  
%% // a couple protected methods to assist in matching floating point numbers
%% protected
%% EXPONENT
%% 	:	('e') ('+'|'-')? ('0'..'9')+
%% 	;
%% 
%% protected
%% FLOAT_SUFFIX
%% 	:	'f'|'d'
%% 	;
%% 
%% 


module MixHQL[Ctx0]
imports 
        HQL
          [ Path                            => Path[[Ctx0]]
            Constant                        => Constant[[Ctx0]]
            Expression                      => Expression[[Ctx0]]
            AliasedExpression               => AliasedExpression[[Ctx0]]
            SelectedPropertiesList          => SelectedPropertiesList[[Ctx0]]
            WhereClause                     => WhereClause[[Ctx0]]
            HavingClause                    => HavingClause[[Ctx0]]
            AscendingOrDescending           => AscendingOrDescending[[Ctx0]]
            OrderElement                    => OrderElement[[Ctx0]]
            OrderByClause                   => OrderByClause[[Ctx0]]
            GroupByClause                   => GroupByClause[[Ctx0]]
            PropertyFetch                   => PropertyFetch[[Ctx0]]
            Alias                           => Alias[[Ctx0]]
            AsAlias                         => AsAlias[[Ctx0]]
            InCollectionElementsDeclaration => InCollectionElementsDeclaration[[Ctx0]]
            InCollectionDeclaration         => InCollectionDeclaration[[Ctx0]]
            InClassDeclaration              => InClassDeclaration[[Ctx0]]
            FromClassOrOuterQueryPath       => FromClassOrOuterQueryPath[[Ctx0]]
            FromRange                       => FromRange[[Ctx0]]
            WithClause                      => WithClause[[Ctx0]]
            Fetch                           => Fetch[[Ctx0]]
            FromJoin                        => FromJoin[[Ctx0]]
            JoinType                        => JoinType[[Ctx0]]
            FromRangeJoin                   => FromRangeJoin[[Ctx0]]
            FromClause                      => FromClause[[Ctx0]]
            SelectObject                    => SelectObject[[Ctx0]]
            NewExpression                   => NewExpression[[Ctx0]]
            Selection                       => Selection[[Ctx0]]
            Distinct                        => Distinct[[Ctx0]]
            SelectClause                    => SelectClause[[Ctx0]]
            SelectFrom                      => SelectFrom[[Ctx0]]
            QueryRule                       => QueryRule[[Ctx0]]
            Union                           => Union[[Ctx0]]
            SelectStatement                 => SelectStatement[[Ctx0]]
            Statement                       => Statement[[Ctx0]]
            NumInt                          => NumInt[[Ctx0]]
            QuotedString                    => QuotedString[[Ctx0]]
            NumParameter                    => NumParameter[[Ctx0]]
            IdParameter                     => IdParameter[[Ctx0]]
            Identifier                      => Identifier[[Ctx0]] ]


module WebDSL

imports
  MixHQL[HQL]
  AccessControl
  ValidationAnnos
%%  InputValidation
  Styling
  Enums
  PagedFor
  Derive
  Procedures
  TemplateMarkdown
  StringSelectEntity

hiddens
  context-free start-symbols
    Application Module Unit

exports

  sorts
    Id QId Int ModuleName SectionHeader Float FloatDigits ExponentPart
    SignedInteger String UNDEFINED Eof

  lexical syntax
    [a-zA-Z][a-zA-Z0-9\_]* -> Id
    [a-zA-Z0-9\-\_]+       -> FileName
    {FileName "/"}+        -> ModuleName
    ~[\n\r]*               -> SectionName

  lexical restrictions
    Id         -/- [a-zA-Z0-9\_]
    ModuleName -/- [a-zA-Z0-9\/]

  lexical syntax
    "-"? [0-9]+            -> Int

  lexical syntax
    "-"? FloatDigits
     ExponentPart? [fFdD]? -> Float
    [0-9]* "." [0-9]*      -> FloatDigits
    [0-9]+                 -> FloatDigits
    [eE] SignedInteger     -> ExponentPart
    [\+\-]? [0-9]+         -> SignedInteger

    "-"? [0-9]+            -> Float {reject}
    "."                    -> FloatDigits  {reject}

  lexical syntax
    "\"" StringChar* "\""        -> String
    ~[\"\n]                        -> StringChar
    "\\\""                       -> StringChar
    [\ \t\n\r]                   -> LAYOUT
    "//" ~[\n\r]* ([\n\r] | Eof) -> LAYOUT
    "/*" CommentChar* "*/"       -> LAYOUT
                                 -> Eof
    ~[\*]                        -> CommentChar
    Asterisk                     -> CommentChar
    [\*]                         -> Asterisk

  lexical restrictions
    Asterisk   -/- [\/]
    Eof        -/- ~[]

  context-free restrictions
    LAYOUT?     -/- [\ \t\n\r]
    LAYOUT?     -/- [\/].[\/]
    LAYOUT?     -/- [\/].[\*]
    SectionName -/- ~[\n\r]

  context-free syntax
    Id         -> QId
    QId "." Id -> QId {cons("Qualified")}

  context-free restrictions
    "page" "local" "email" "feed" "template" -/- [a-zA-Z0-9]

exports

  sorts Word Unit

  lexical syntax
    ~[\ \t\n\r\}]+ -> Word
  lexical restrictions
     Word -/- ~[\ \t\n\r\}]

exports

  sorts Application
  
  syntax

    "section" <SectionName-CF> <LAYOUT?-CF> <Definition*-CF> -> <Section-CF> {cons("Section")}

  context-free syntax

    "application" QId Definition+ Section* -> Application {cons("ApplicationDefs")}
    "application" QId Section*      -> Application {cons("Application")}

    "description" "{" Word* "}"     -> Description {cons("Description")}

    "note" "{" Word* "}"            -> Description {cons("Note")}

    Description                   -> Definition
    %%Description                   -> Definition {prefer}

    "module" ModuleName Section*  -> Module {cons("Module")}
    "module" ModuleName Definition+ Section*  -> Module {cons("ModuleDefs")}

    "imports" ModuleName          -> Definition {cons("Imports")}
    
    Application                   -> Unit
    
    Module                        -> Unit

exports

  sorts Entity Property Sort Annotation

  context-free syntax

    "entity" Id ":" Id "{" Property* Function* "}"       -> Entity {cons("Entity")}
    "entity" Id "{" Property* Function* "}"              -> Entity {cons("EntityNoSuper")}
    "session" Id "{" Property* Function* "}"             -> Entity {cons("SessionEntity")}

    Entity                                   		     -> Definition

    "extend" "entity" Id "{" Property* Function* "}"	 -> Definition {cons("ExtendEntity")}
    "extend" "session" Id "{" Property* Function* "}"   -> Definition {cons("ExtendSessionEntity")}

    "globals" "{" GlobalsDef* "}"                        -> Definition {prefer,cons("GlobalsDefinition")}
    VarDecl                                              -> GlobalsDef
    Function                                             -> GlobalsDef
    GlobalsDef                                           -> Definition
    InitAction                                           -> Definition

    "function" Id "(" {FormalArg ","}* ")" ":" Sort
        Block                                            -> Function {cons("Function")}

    "function" Id "(" {FormalArg ","}* ")" 
        Block                                            -> FunctionNoReturn {cons("FunctionNoReturn")}

    FunctionNoReturn                                     -> Function

    "extend" FunctionNoReturn                            -> Function {cons("ExtendFunction")}

  sorts Property Annotation

  context-free syntax

    Id PropKind Sort "(" {Annotation ","}* ")" -> Property {cons("Property")}
    Id PropKind Sort                           -> Property {cons("PropertyNoAnno")}

    Id PropKind Sort "(" {Annotation ","}* ")" ":=" Exp -> Property {cons("DerivedProperty")}
    Id PropKind Sort ":=" Exp                           -> Property {cons("DerivedPropertyNoAnno")}


    "::" -> PropKind {cons("Simple")}
    "->" -> PropKind {cons("Ref")}
    "<>" -> PropKind {cons("Comp")}

  sorts Sort

  context-free syntax

    Id                     -> Sort {cons("SimpleSort")}
    Id "<" {Sort ","}+ ">" -> Sort {cons("GenericSort")}

    Id                           -> Annotation {cons("SimpleAnno")}
    "inverse" "=" Id "." Id      -> Annotation {cons("InverseAnno")}
    "inverseSlave" "=" Id "." Id -> Annotation {cons("InverseSlaveAnno")}
    "inline" "(" {Id ","}* ")"   -> Annotation {cons("InlineAnno")}
    "select" "=" Id              -> Annotation {cons("SelectAnno")}
%%  Id "(" {Annotation ","}* ")" -> Annotation {cons("ParamAnno")}

exports

  sorts TemplateDefinition Modifier Exp

  context-free syntax

    TemplateDefinition -> Definition

    "define" Modifier*
       Id "(" {FormalArg ","}* ")"
       "{" TemplateElement* "}"             -> TemplateDefinition {cons("Define")}

    "define" Modifier*
       Id UNDEFINED*
       "{" TemplateElement* "}"             -> TemplateDefinition {cons("Define")}
    
    "define" -> Id {reject}
    "for" -> Id {reject}

    "page"                                  -> Modifier {cons("Page")}
    "email"                                 -> Modifier {cons("Email")}
    "template"                              -> Modifier {cons("Template")}
    "feed"                                  -> Modifier {cons("Feed")}
    "local"                                 -> Modifier {cons("Local")}

    Id ":" Sort                             -> FormalArg {cons("Arg")}

    InitAction                              -> TemplateElement
    Action                                  -> TemplateElement
    VarDecl                                 -> TemplateElement
    TemplateDefinition                      -> TemplateElement
    TemplateCall                            -> TemplateElement {avoid}
    String                                  -> TemplateElement {cons("Text")}


    "where" Exp                              -> Filter {cons("FilterNoOrderByNoLimit")}
    "order" "by" OrderExp                    -> Filter {cons("FilterNoWhereNoLimit")}
    "where" Exp "order" "by" OrderExp        -> Filter {cons("FilterNoLimit")}
    "where" Exp Limit                        -> Filter {cons("FilterNoOrderBy")}
    "order" "by" OrderExp Limit              -> Filter {cons("FilterNoWhere")}
    Limit                                    -> Filter {cons("FilterNoWhereNoOrderBy")}
    "where" Exp "order" "by" OrderExp Limit  -> Filter {cons("Filter")}
    Exp                                      -> OrderExp {cons("OrderNonSpecific")}
    Exp "asc"                                -> OrderExp {cons("OrderAscending")}
    Exp "desc"                               -> OrderExp {cons("OrderDescending")}
    "limit" Exp "offset" Exp                 -> Limit {cons("Limit")}
    "limit" Exp                              -> Limit {cons("LimitNoOffset")}
    "offset" Exp                             -> Limit {cons("LimitNoLimit")}


    "for" "(" Id ":" Sort "in" Exp Filter ")"
       "{" TemplateElement* "}"                             -> TemplateElement {cons("For")}

    "for" "(" Id ":" Sort "in" Exp ")"
       "{" TemplateElement* "}"                             -> TemplateElement {cons("ForNoFilter")}

    "for" "(" Id ":" Sort Filter ")"
       "{" TemplateElement* "}"                             -> TemplateElement {cons("ForAll")}

    "for" "(" Id ":" Sort ")"
       "{" TemplateElement* "}"                             -> TemplateElement {cons("ForAllNoFilter")}


    "for" "(" Id ":" Sort "in" Exp ")"
       "{" TemplateElement* "}" 
    "separated-by" "{" TemplateElement* "}"               -> TemplateElement {cons("ForSepNoFilter")}

    "for" "(" Id ":" Sort "in" Exp Filter ")"
       "{" TemplateElement* "}" 
    "separated-by" "{" TemplateElement* "}"               -> TemplateElement {cons("ForSep")}

    %%

    "select" "(" Id ":" Sort "," String "," Exp ")" -> TemplateElement {cons("Select")}

    "select" "(" Exp "from" Exp ")" -> TemplateElement {cons("SelectFromList")}

    "if" "(" Exp ")" "{" TemplateElement* "}" "else" "{" TemplateElement* "}"
                                                   -> TemplateElement {cons("IfTempl"),prefer}
    "if" "(" Exp ")" "{" TemplateElement* "}"      -> TemplateElement {cons("IfNoElseTempl")}

  %%

    Id                                             -> TemplateCall {cons("TemplateCallNoArgs")}
    Id "(" {Exp ","}* ")"                          -> TemplateCall {cons("TemplateCallNoBody")}
    Id "(" {Exp ","}* ")" "{" TemplateElement* "}" -> TemplateCall {cons("TemplateCallNoAssigns")}
  
    Id "(" {Exp ","}* ")" "[" {PropertyAssignment ","}*"]" -> TemplateCall {cons("TemplateCallPropsNoBody")}
    Id "[" {PropertyAssignment ","}*"]" -> TemplateCall {cons("TemplateCallProps")}
    Id "[" {PropertyAssignment ","}*"]" "{" TemplateElement* "}" -> TemplateCall {cons("TemplateCallPropsNoArgs")}

    Id                    "{" TemplateElement* "}" -> TemplateCall {cons("TemplateCallBody")}
    Id "(" {Exp ","}* ")" "[" {PropertyAssignment ","}*"]" "{" TemplateElement* "}" -> TemplateCall {cons("TemplateCall")}

  %%
    
    "if" "(" Exp ")" "{" TemplateElement* "}"      -> TemplateCall {reject}
    "else" "{" TemplateElement* "}"                -> TemplateCall {reject}
    "separated-by" "{" TemplateElement* "}"                -> TemplateCall {reject}

  %%
    
    Id ":=" PropertyValue				           -> PropertyAssignment {cons("PropertyAssignment")}
    Id											   -> PropertyValue {prefer}
    String										   -> PropertyValue {cons("String"),prefer}  %% needed to deconfuse StyleValue and Exp
    Exp								        	   -> PropertyValue 
    "[" {PropertyValue "," }* "]"				   -> PropertyValue{cons("PropertyValueList"), prefer}
    StyleValue									   -> PropertyValue
  
    %%AJAX desugarings/ inline
    "action" Block -> Exp {cons("InlineAction"), prefer}
    "template" "{" TemplateElement* "}" -> Exp {cons("InlineTemplateCall"), prefer}    
   
    %% Template call without braces must be disambiguated in some cases
    "action" -> TemplateCall {reject}  %%this is an action definiton, not a templatecall without params
    "action" -> Exp {reject}		   %%this is an inline action, not a variable
    "action" -> PropertyValue {reject} %%this is an inline action, not an id

exports

  sorts Action Statements Statement Exp

  context-free syntax

    "init" Block  		-> InitAction {cons("InitAction"),prefer}
    "action" 
      Id "(" {FormalArg ","}* ")" 
      Block  			-> Action {cons("Action")}
    
    Action		       	-> Definition
    Statement*		   	-> Statements

    "{" Statements "}" 		-> Block {cons("Block")}
    Block              		-> Statement
    %%Assignment ";"	   	-> Statement {cons("Assign")}
    Exp ";"		       	-> Statement {cons("Stat")}

    "return" Exp ";"     	-> Statement {cons("Return")}
    
    "return" ";"         	-> Statement {cons("ReturnEmpty")}
    
  context-free syntax

    Id Id "<<" Id  ";" 	 	-> Statement {cons("AjaxActionIdParam"),prefer}
    Id Id "<<" ";"		-> Statement {cons("AjaxActionNoParam")}
    Id "<<" Exp ";"	 	-> Statement {cons("AjaxActionNoTarget")}
    Id Id "<<" Exp ";"   	-> Statement {cons("AjaxAction")}

    "cancel" Exp ";"     	-> Statement {cons("Cancel")}

    "goto" Exp ";"       	-> Statement {cons("GoTo")}

    "schedule" Exp "for" Exp ";" -> Statement {cons("Schedule")}
    "schedule" Exp ";"           -> Statement {cons("ScheduleNoFor")}

  context-free syntax

    "var" Id ":" Sort ";" 	-> VarDecl {cons("VarDecl")}
    "var" Id ":" Sort 		-> TemplateElement {cons("VarDecl")}

    "var" Id ":" Sort ":=" Exp ";" -> VarDecl {cons("VarDeclInit")}
    "var" Id ":=" Exp ";" -> VarDecl {cons("VarDeclInitInferred")}
    "var" Id ":" Sort ":=" Exp -> TemplateElement {cons("VarDeclInit")}
    "var" Id ":=" Exp -> TemplateElement {cons("VarDeclInitInferred")}

    VarDecl -> Statement

  context-free syntax

    "if" "(" Exp ")" Block "else" Block -> Statement {cons("If")}

    "if" "(" Exp ")" Block 		-> Statement {cons("IfNoElse")}

    "case" "(" Exp ")" "{" Case* "}" 	-> Statement {cons("Case")}
    ConstValue Block                 	-> Case {cons("CaseAlt")}
    "default"  Block                 	-> Case {cons("CaseDefault")}


  context-free syntax

    "for" "(" Id ":" Sort "in" Exp Filter ")"
      Block 				-> Statement {cons("ForStmt")}

    "for" "(" Id ":" Sort "in" Exp ")"
      Block 				-> Statement {cons("ForStmtNoFilter")}

    "for" "(" Id ":" Sort Filter ")"
      Block 				-> Statement {cons("ForAllStmt")}

    "for" "(" Id ":" Sort ")"
      Block 				-> Statement {cons("ForAllStmtNoFilter")}

    "for" "(" Id ":" "Int" "from" Exp "to" Exp ")" Block -> Statement {cons("ForCountStmt")}

    "while" "(" Exp ")" Block -> Statement {cons("WhileStmt")}


exports

  sorts Rules Rule

  context-free syntax

    "rules" Rule* -> Definition {cons("Rules")}

    Exp "=" Exp -> Rule {cons("Equation")}

exports

  sorts ConstValue Exp

  context-free syntax
    Int                    -> ConstValue {cons("Int")}
    Float                  -> ConstValue {cons("Float")}
    String                 -> ConstValue {cons("String")}

    ConstValue                  -> Exp

    Id			   -> Exp {cons("Var")}
    "in"                   -> Exp {reject}
    "return"               -> Id {reject}
        
    %% to be able to refer to page or template farg/var from actions when names clashing with farg/var in action
    "externalscope" "." Id -> Exp {cons("ExternalScopeVar")}

    Exp "." Id             -> Exp {cons("FieldAccess"),prefer}

    Sort "{" ObjectPropertyAssignment* "}"         -> Exp {cons("ObjectCreation")}
    Sort "{" { ObjectPropertyAssignment "," }* "}" -> Exp {cons("ObjectCreation"), prefer}

    Id ":=" Exp           -> ObjectPropertyAssignment {cons("ObjectPropertyAssignment")}

    QId ":=" Exp           -> Assignment {cons("Assignment")}
    Assignment				-> Exp

    "[" Mapping* "]"       -> Exp {cons("MapCreation")}
    Exp "->" Exp           -> Mapping {cons("Mapping")}

    "[" {Exp ","}* "]"     -> Exp {cons("ListCreation")}

    "{" {Exp ","}* "}"     -> Exp {cons("SetCreation")}

    "List" "<" Sort ">" "(" {Exp ","}* ")" -> Exp {cons("TypedListCreation"), prefer}
    "Set" "<" Sort ">" "(" {Exp ","}* ")" -> Exp {cons("TypedSetCreation"), prefer}

    Id "(" {Exp ","}* ")"  -> Exp {cons("ThisCall")}
    "!" "(" {Exp ","}* ")"  -> Exp {reject}

    Exp "." Id "(" {Exp ","}* ")"  -> Exp {cons("Call")}

    Exp "is" "a" Sort      -> Exp {cons("IsA")}
    Exp "as" Sort          -> Exp {cons("Cast"), avoid} %% Casting, hooray!

    Exp "in" Exp           -> Exp {cons("InColl")}

    Exp "==" Exp           -> Exp {cons("Eq")}
    Exp "!=" Exp           -> Exp {cons("NotEq")}
    Exp ">" Exp           -> Exp {cons("LargerThan")}
    Exp ">=" Exp           -> Exp {cons("LargerThanOrEqual")}
    Exp "<" Exp           -> Exp {cons("SmallerThan")}
    Exp "<=" Exp           -> Exp {cons("SmallerThanOrEqual")}

    "true"                 -> Exp {prefer,cons("True")}
    "false"                -> Exp {prefer,cons("False")}

    "null"                 -> Exp {prefer,cons("Null")}

    Exp "&&" Exp          -> Exp {cons("And"), assoc}
    Exp "||" Exp           -> Exp {cons("Or"), assoc}
    "!" Exp              -> Exp {cons("Not")}

    "(" Exp ")"            -> Exp {bracket}


    "[" Exp "for" "(" Id ":" Sort "in" Exp Filter ")" "]" -> ForExp {cons("ForExp")}
    "[" Exp "for" "(" Id ":" Sort "in" Exp ")" "]"        -> ForExp {cons("ForExpNoFilter")}
    "[" Exp "|" Id ":" Sort "in" Exp Filter "]"           -> ForExp {cons("ForExp")}
    "[" Exp "|" Id ":" Sort "in" Exp "]"                  -> ForExp {cons("ForExpNoFilter")}
    ForExp                                                -> Exp

    "And" ForExp                                          -> Exp {cons("AndForExp")}
    "Or"  ForExp                                          -> Exp {cons("OrForExp")}


    Exp "*" Exp  -> Exp {cons("Mul"),assoc}
    Exp "/" Exp  -> Exp {cons("Div"),assoc}
    Exp "%" Exp  -> Exp {cons("Mod"),assoc}
    Exp "+" Exp  -> Exp {cons("Add"),assoc}
    Exp "-" Exp  -> Exp {cons("Sub"),assoc}

context-free priorities
  {left:
    Exp "." Id "(" {Exp ","}* ")"  -> Exp
    Exp "." Id  -> Exp }
  > Exp "as" Sort -> Exp
  > "!" Exp -> Exp
  > Exp "in" Exp -> Exp
  > {left:
       Exp "*" Exp -> Exp
       Exp "%" Exp -> Exp
       Exp "/" Exp -> Exp }
  > {left:
       Exp "+" Exp -> Exp
       Exp "-" Exp -> Exp }
  > {left:
       Exp "==" Exp -> Exp
       Exp "!=" Exp -> Exp
       Exp ">" Exp -> Exp
       Exp ">=" Exp -> Exp
       Exp "<" Exp -> Exp
       Exp "<=" Exp -> Exp }
  > {left:
       Exp "&&" Exp -> Exp }
  > {left:
       Exp "||" Exp -> Exp }
  > Assignment -> Exp 

exports

  context-free syntax

    QueryRule[[HQL]] -> Exp {cons("HqlQuery"), prefer}

    "~" Exp -> Expression[[HQL]] {cons("DslExp")}

module WebDslMix[E]

imports
  WebDSL
  AccessControlMix
  StylingMix
  DeriveMix

exports

  lexical syntax

    [0-9]* -> MetaVarSuffix
    "_" [A-Za-z0-9\_\-]+ -> MetaVarSuffix

  context-free syntax
    "webdsl"  "|[" Application      "]|" -> E {cons("ToMetaExpr")}
              "|[" Application      "]|" -> E {cons("ToMetaExpr")}
    "webdsl"  "|[" Section          "]|" -> E {cons("ToMetaExpr")}
              "|[" Section          "]|" -> E {cons("ToMetaExpr")}
    "webdsl"  "|[" Section*         "]|" -> E {cons("ToMetaExpr")}
              "|[" Section*         "]|" -> E {cons("ToMetaExpr")}
    "webdsl"  "|[" TemplateElement  "]|" -> E {cons("ToMetaExpr")}
    "webdsl*" "|[" TemplateElement* "]|" -> E {cons("ToMetaExpr")}

    "def"   "|[" Definition  "]|" -> E {cons("ToMetaExpr")}
    "def*"  "|[" Definition* "]|" -> E {cons("ToMetaExpr")}
    "fun"   "|[" Function  "]|"   -> E {cons("ToMetaExpr")}
    "fun*"  "|[" Function* "]|"   -> E {cons("ToMetaExpr")}
    "sdef"  "|["  SecurityDefinition   "]|" -> E {cons("ToMetaExpr")}
    "sdef*" "|["  SecurityDefinition*  "]|" -> E {cons("ToMetaExpr")}

    "webdsl" "|[" Description "]|" -> E {cons("ToMetaExpr")}
             "|[" Description "]|" -> E {cons("ToMetaExpr")}

  variables

    "app" [0-9]*                -> Application {prefer}
    "sec" [0-9]*                -> Section     {prefer}
    "sec" [0-9]* "*"            -> Section*    {prefer}
    "def" [0-9]*                -> Definition  {prefer}
    "def" [0-9]* "*"            -> Definition* {prefer}
    "procelem" [0-9]*           -> ProcedureElement  {prefer}
    "procelem" [0-9]* "*"       -> ProcedureElement* {prefer}
    "procelem_"[A-Za-z0-9]+     -> ProcedureElement  {prefer}
    "procelem_"[A-Za-z0-9]+ "*" -> ProcedureElement* {prefer}
    "processexp" [0-9]*         -> ProcessExp  {prefer}
    "processexp" [0-9]* "*"     -> ProcessExp* {prefer}
    "desc"[0-9]*                -> Description {prefer}
    "mod" [0-9]*                -> Modifier    {prefer}
    "mod" [0-9]* "*"            -> Modifier*   {prefer}

  context-free syntax

    "webdsl" "|[" Entity            "]|" -> E {cons("ToMetaExpr")}
             "|[" Entity            "]|" -> E {cons("ToMetaExpr")}
    "webdsl" "|[" Property          "]|" -> E {cons("ToMetaExpr")}
             "|[" Property          "]|" -> E {cons("ToMetaExpr")}
    "webdsl" "|[" Property*         "]|" -> E {cons("ToMetaExpr")}
             "|[" Property*         "]|" -> E {cons("ToMetaExpr")}
    "webdsl" "|[" Sort              "]|" -> E {cons("ToMetaExpr")}
             "|[" Sort              "]|" -> E {cons("ToMetaExpr")}
    "webdsl" "|[" {Sort ","}*       "]|" -> E {cons("ToMetaExpr")}
             "|[" {Sort ","}*       "]|" -> E {cons("ToMetaExpr")}
    "webdsl" "|[" Annotation        "]|" -> E {cons("ToMetaExpr")}
             "|[" Annotation        "]|" -> E {cons("ToMetaExpr")}
    "webdsl" "|[" {Annotation ","}* "]|" -> E {cons("ToMetaExpr")}
             "|[" {Annotation ","}* "]|" -> E {cons("ToMetaExpr")}

  variables
    "ent" [0-9]*     -> Entity            {prefer}
    "prop"[0-9]*     -> Property          {prefer}
    "prop"[0-9]* "*" -> Property*         {prefer}
    "srt" [0-9]*     -> Sort              {prefer}
    "srt" [0-9]* "*" -> {Sort ","}*       {prefer}
    "ann" [0-9]*     -> Annotation        {prefer}
    "ann" [0-9]* "*" -> {Annotation ","}* {prefer}
    "k"   [0-9]*     -> PropKind          {prefer}
    
    "dprop"[0-9]*     -> DeriveProperty   {prefer}
    "dprop"[0-9]* "*" -> {DeriveProperty ","}*  {prefer}

  context-free syntax
    "tdef"      "|[" TemplateDefinition  "]|" -> E {cons("ToMetaExpr")}
    "farg"      "|[" FormalArg           "]|" -> E {cons("ToMetaExpr")}
    "farg*"     "|[" {FormalArg ","}*    "]|" -> E {cons("ToMetaExpr")}
    "procelem"  "|[" ProcedureElement    "]|" -> E {cons("ToMetaExpr")}
    "procelem*" "|[" ProcedureElement*   "]|" -> E {cons("ToMetaExpr")}
    "elem"      "|[" TemplateElement     "]|" -> E {cons("ToMetaExpr")}
    "elem*"     "|[" TemplateElement*    "]|" -> E {cons("ToMetaExpr")}
    "call"      "|[" TemplateCall        "]|" -> E {cons("ToMetaExpr")}
    "call*"     "|[" TemplateCall*       "]|" -> E {cons("ToMetaExpr")}
    "exp"       "|[" Exp                 "]|" -> E {cons("ToMetaExpr")}
    "passign"   "|[" PropertyAssignment  "]|" -> E {cons("ToMetaExpr")}
    "passign*"  "|[" PropertyAssignment* "]|" -> E {cons("ToMetaExpr")}

  variables
    "tdef"[0-9]*     -> TemplateDefinition {prefer}
    "farg"[0-9]*     -> FormalArg          {prefer}
    "farg" MetaVarSuffix "*" -> {FormalArg ","}*   {prefer}
    "elem"[0-9]*     -> TemplateElement    {prefer}
    "elem"[0-9]* "*" -> TemplateElement*   {prefer}
    "elem_"[A-Za-z0-9]+     -> TemplateElement    {prefer}
    "elem_"[A-Za-z0-9]+ "*" -> TemplateElement*   {prefer}
    "call"[0-9]*     -> TemplateCall       {prefer}
    "call"[0-9]* "*" -> TemplateCall*      {prefer}
    "passign" MetaVarSuffix     -> PropertyAssignment          {prefer}
    "passign" MetaVarSuffix "*" -> {PropertyAssignment ","}*   {prefer}
 
  context-free syntax
    "webdsl" "|[" Action     "]|" -> E {cons("ToMetaExpr")}
             "|[" Action     "]|" -> E {cons("ToMetaExpr")}
    "webdsl" "|[" Statement  "]|" -> E {cons("ToMetaExpr")}
             "|[" Statement  "]|" -> E {cons("ToMetaExpr")}
    "stat"   "|[" Statement  "]|" -> E {cons("ToMetaExpr")}
    "webdsl" "|[" Statement* "]|" -> E {cons("ToMetaExpr")}
             "|[" Statement* "]|" -> E {cons("ToMetaExpr")}
    "webdsl" "|[" Case       "]|" -> E {cons("ToMetaExpr")}
             "|[" Case       "]|" -> E {cons("ToMetaExpr")}

  variables

    "_act" [0-9]*          -> Action     {prefer}
    "stat" [0-9]*          -> Statement  {prefer}
    "stat" [0-9]* "*"      -> Statement* {prefer}
    "stat_"[A-Za-z0-9]*    -> Statement  {prefer}
    "stat_"[A-Za-z0-9]*"*" -> Statement* {prefer}
    "block"[0-9]*          -> Block      {prefer}

    "alt"[0-9]*            -> Case {prefer}
    "alt"[0-9]* "*"        -> Case* {prefer}

  context-free syntax
    "webdsl:e" "|[" Exp         "]|" -> E {cons("ToMetaExpr")}
    "|[" Exp         "]|" -> E {cons("ToMetaExpr")}
    "|[" Assignment  "]|" -> E {cons("ToMetaExpr")}
    "|[" Assignment* "]|" -> E {cons("ToMetaExpr")}

  variables

    "e"   [0-9\']*           -> Exp         {prefer}
    "e_"  [A-Za-z0-9\']+     -> Exp         {prefer}
    "e"   [0-9\']* "*"       -> {Exp ","}*  {prefer}
    "e_"  [A-Za-z0-9\']+ "*" -> {Exp ","}*  {prefer}
    "fltr"[0-9]*             -> Filter      {prefer}
    "asgn"[0-9]*             -> Assignment  {prefer}
    "asgn"[0-9]* "*"         -> Assignment* {prefer}
    "fun"[0-9]*              -> Function    {prefer}
    "fun"[0-9]* "*"          -> Function*   {prefer}

  variables

    "qid"[0-9]*                -> QId     {prefer}
    [xyz][0-9]*                -> Id      {prefer}
    [xyz]"_"[A-Za-z0-9]+       -> Id      {prefer}
    %%[xyz]"_"[A-Za-z0-9\']+ "*" -> Id*     {prefer}
    [xyz][0-9]*                -> MatchId {prefer}
    [xyz]"_"[A-Za-z0-9]+       -> MatchId {prefer}
    "str"[0-9]*                -> String  {prefer}

    "const"[0-9]*              -> ConstValue {prefer}

  lexical syntax

    [\$][A-Za-z0-9]* -> IdVar
    [\$][A-Za-z0-9]* -> Id[[StrategoHost]]

  lexical restrictions

    IdVar -/- [A-Za-z0-9]

  variables

    IdVar -> Id {prefer}

module Stratego-Sugar-Overlays
imports
  Stratego-Core-Identifiers
  Stratego-Sugar-Terms

exports
  sorts Overlay
  context-free syntax
    Id 			 "=" Term 	-> Overlay {cons("OverlayNoArgs")}
    Id "(" {Id ","}* ")" "=" Term 	-> Overlay {cons("Overlay")}

module Stratego-Sugar-DynamicRules
imports
  Stratego-Core-Identifiers
  Stratego-Sugar-Strategies
  Stratego-Sugar-Rules

exports
 
  sorts ScopeLabels
  context-free syntax

    "{|" ScopeLabels ":" Strategy "|}" -> Strategy {cons("DynRuleScope")}

    {DynRuleScopeId ","}*   -> ScopeLabels
    "~" Term		    -> ScopeLabels {cons("ScopeLabels")}

  sorts DynRuleDef DynRuleId DynRuleScopeId RuleDec
  context-free syntax

    "rules" "(" DynRuleDef* ")" -> Strategy {cons("GenDynRules")}

    Id "+" Term                 -> DynRuleDef {cons("AddScopeLabel")} 
    DynRuleId ":-"  Term        -> DynRuleDef {cons("UndefineDynRule")}
    DynRuleId ":"   Rule        -> DynRuleDef {cons("SetDynRule")}
    DynRuleId ":+"  Rule        -> DynRuleDef {cons("AddDynRule")}
    DynRuleId ":"   Term        -> DynRuleDef {cons("SetDynRuleMatch")}

    DynRuleId ":="  Term        -> DynRuleDef {cons("DynRuleAssign")}
    DynRuleId ":+="  Term       -> DynRuleDef {cons("DynRuleAssignAdd")}

    DynRuleId ":"   Rule "depends" "on" Term -> DynRuleDef {cons("SetDynRuleDepends")}

    RuleDec "." Term            -> DynRuleId {cons("LabeledDynRuleId")}
    RuleDec "+" Term            -> DynRuleId {cons("AddLabelDynRuleId")}
    RuleDec                     -> DynRuleId {cons("DynRuleId")}

    Id "." Term                 -> DynRuleScopeId {cons("LabeledDynRuleScopeId")}
    Id                          -> DynRuleScopeId {cons("DynRuleScopeId")}

  context-free syntax

    Id                          -> RuleDec {cons("RDecNoArgs")}
    Id "(" {Typedid ","}* ")"   -> RuleDec {cons("RDec")}
    Id "(" {Typedid ","}* 
       "|" {Typedid ","}* ")"   -> RuleDec {cons("RDecT")}

  sorts RuleNames
  context-free syntax
    {Id ","}*				  -> RuleNames
    "~" Term				  -> RuleNames {cons("RuleNames")}

    "/" RuleNames "\\*" Strategy          -> Strategy {cons("DynRuleIntersectFix")}

  syntax
    %% no space after RuleNames
    "\\" <LAYOUT?-CF> <RuleNames-CF> "/*" <LAYOUT?-CF> <Strategy-CF>
      -> <Strategy-CF> {cons("DynRuleUnionFix")}

    %% 1 space after RuleNames
    "\\" <LAYOUT?-CF> <RuleNames-CF> " /*" <LAYOUT?-CF> <Strategy-CF>
      -> <Strategy-CF> {cons("DynRuleUnionFix")}

    %% no space after RuleNames
    "/"  <LAYOUT?-CF> <RuleNames-CF> <LAYOUT?-CF> "\\"
        <LAYOUT?-CF> <RuleNames-CF> "/*" <LAYOUT?-CF> <Strategy-CF>
      -> <Strategy-CF> {cons("DynRuleIntersectUnionFix")}

    %% 1 space after RuleNames
    "/"  <LAYOUT?-CF> <RuleNames-CF> <LAYOUT?-CF> "\\"
        <LAYOUT?-CF> <RuleNames-CF> " /*" <LAYOUT?-CF> <Strategy-CF>
      -> <Strategy-CF> {cons("DynRuleIntersectUnionFix")}


  context-free syntax
    Strategy "/" RuleNames"\\" Strategy  -> Strategy {cons("DynRuleIntersect"),right}
    Strategy "\\" RuleNames "/" Strategy  -> Strategy {cons("DynRuleUnion"),right}

    Strategy "/" RuleNames "\\" 
                 RuleNames "/"  Strategy  -> Strategy {cons("DynRuleIntersectUnion"),right}

  priorities
    <StrategyAngle-CF> <LAYOUT?-CF> <Term-CF> -> <Strategy-CF> {cons("BA")}
  > {

    %% no space after RuleNames
    "\\" <LAYOUT?-CF> <RuleNames-CF> "/*" <LAYOUT?-CF> <Strategy-CF>
      -> <Strategy-CF> {cons("DynRuleUnionFix")}

    %% 1 space after RuleNames
    "\\" <LAYOUT?-CF> <RuleNames-CF> " /*" <LAYOUT?-CF> <Strategy-CF>
      -> <Strategy-CF> {cons("DynRuleUnionFix")}

    %% no space after RuleNames
    "/"  <LAYOUT?-CF> <RuleNames-CF> <LAYOUT?-CF> "\\"
        <LAYOUT?-CF> <RuleNames-CF> "/*" <LAYOUT?-CF> <Strategy-CF>
      -> <Strategy-CF> {cons("DynRuleIntersectUnionFix")}

    %% 1 space after RuleNames
    "/"  <LAYOUT?-CF> <RuleNames-CF> <LAYOUT?-CF> "\\"
        <LAYOUT?-CF> <RuleNames-CF> " /*" <LAYOUT?-CF> <Strategy-CF>
      -> <Strategy-CF> {cons("DynRuleIntersectUnionFix")}

    }
  > <Strategy-CF> <LAYOUT?-CF> "=>" <LAYOUT?-CF> <Term-CF> -> <Strategy-CF> {cons("AM")}

  context-free priorities
    StrategyAngle Term 		          -> Strategy {cons("BA")}
  > "/" RuleNames "\\*" Strategy          -> Strategy {cons("DynRuleIntersectFix")}
  > Strategy "=>" Term 		  	  -> Strategy {cons("AM")}
  > Strategy "/" RuleNames "\\" Strategy  -> Strategy {cons("DynRuleIntersect"),right}
  > Strategy "\\" RuleNames "/" Strategy  -> Strategy {cons("DynRuleUnion"),right}
  > Strategy "/" RuleNames "\\" 
                 RuleNames "/"  Strategy  -> Strategy {cons("DynRuleIntersectUnion"),right}
  > Strategy ";" Strategy 		  -> Strategy {cons("Seq"),right}

module Stratego-Sugar-Rules
imports Stratego-Sugar-Strategies
exports

  sorts RuleDef
  context-free syntax
    Id ":" Rule 				-> RuleDef {cons("RDefNoArgs")}

    Id "(" {Typedid ","}* ")" ":" Rule 		-> RuleDef {cons("RDef")}

    Id "(" {Typedid ","}* 
       "|" {Typedid ","}* ")" ":" Rule 		-> RuleDef {cons("RDefT")}

  sorts Rule RuleCond
  context-free syntax
    Term "->" Term           	    -> Rule {cons("RuleNoCond")} %% backward comp.
    Term "->" Term "where" Strategy -> Rule {cons("Rule")}       %% backward comp.
    Term "->" Term RuleCond+	    -> Rule {cons("Rule"), avoid}

    "where" Strategy -> RuleCond {cons("WhereClause")}
    "with"  Strategy -> RuleCond {cons("WithClause")}

module Stratego-Sugar-Strategies
imports
  Stratego-Core-Strategies
  Stratego-Sugar-Terms
  Stratego-Sugar-Constants
  Stratego-Sugar-Signatures

exports
  context-free syntax
    Id  		      "=" Strategy -> StrategyDef {cons("SDefNoArgs")}
    Id "(" {Typedid ","}* ")" "=" Strategy -> StrategyDef {cons("SDef")}

  context-free syntax
    ID 				  	  -> Typedid {cons("DefaultVarDec")}

  sorts Rule

  sorts StrategyParen StrategyCurly StrategyAngle
  context-free syntax

    %% Abstraction

    SVar "(" {Strategy ","}* ")" 	  -> Strategy {cons("Call")}

    %% Match and build

    "{" Strategy "}" 			  -> Strategy {cons("ScopeDefault")}

     %%"<" Strategy ">" Term 		  -> Strategy {cons("BA")}
     StrategyAngle Term 		  -> Strategy {cons("BA")}
     "<" Strategy ">"			  -> StrategyAngle {bracket} %% {cons("AngleStrat")}

    %% Combinators

    Strategy "<+" Strategy 		  -> Strategy {cons("LChoice"),right}

    "rec" Id "(" Strategy ")" 		  -> Strategy {cons("Rec")}

    "not"   "(" Strategy ")" 		  -> Strategy {cons("Not")}
    "where" "(" Strategy ")" 		  -> Strategy {cons("Where")}
    "with"  "(" Strategy ")" 		  -> Strategy {cons("With"), prefer}
    "test"  "(" Strategy ")" 		  -> Strategy {cons("Test")}

    %% Primitives

    "prim" "(" String ")" 		  -> Strategy {cons("PrimNoArgs")}
    "prim" "(" String "," {Term ","}* ")" -> Strategy {cons("Prim")}

    %% Congruence operators

    String 				  -> Strategy {cons("StrCong")}
    Int 				  -> Strategy {cons("IntCong")}
    Real 				  -> Strategy {cons("RealCong")}
    Char 			 	  -> Strategy {cons("CharCong")}

    String "(" {Strategy ","}* ")" 	  -> Strategy {cons("CongQ")}

    %%"(" {Strategy ","}* ")" 		  -> Strategy {cons("TupleCong"),avoid}

    Strategy StrategyCurly		  -> Strategy {cons("AnnoCong")}
    "{" Strategy "}"		  	  -> StrategyCurly {cons("StrategyCurly")}

    "("  ")" 		  		  -> Strategy {cons("EmptyTupleCong")}
   "(" Strategy  ")" 		          -> Strategy {bracket}
    "(" Strategy "," {Strategy ","}+ ")"  -> Strategy {cons("TupleCong")}

%%    Mod 	  			  -> Strategy {cons("ModCongNoArgs")}
%%    Mod "(" {Strategy ","}* ")"	  	  -> Strategy {cons("ModCong")}
%%    Id "^" Id				  -> Mod {cons("Mod")}
    "[" {Strategy ","}* "]" 		  -> Strategy {cons("ListCongNoTail")}
    "[" {Strategy ","}* "|" Strategy "]"  -> Strategy {cons("ListCong")}

%%    Strategy "#" "(" StrategyInj ")" 	  -> Strategy {cons("ExplodeCong")}
%%    Strategy "#" "(" Strategy ")" 	  -> Strategy {cons("ExplodeCong")}
    Strategy "#" StrategyParen	  	  -> Strategy {cons("ExplodeCong")}

  %% Syntactic sugar sugar

  sorts SwitchCase
  context-free syntax

    SVar  		  		  -> Strategy {cons("CallNoArgs")}
    "\\" Rule "\\" 			  -> Strategy {cons("LRule")}
    "(" Rule ")" 			  -> Strategy {cons("SRule")}
    Strategy "+" Strategy 		  -> Strategy {cons("Choice"),right} 
    Strategy "+>" Strategy 		  -> Strategy {cons("RChoice"),right}

    "if" Strategy "then" Strategy 
                  "else" Strategy "end"   -> Strategy {cons("CondChoice")}
    "if" Strategy "then" Strategy "end"   -> Strategy {cons("IfThen")}

    "switch" Strategy SwitchCase* "end"   -> Strategy {cons("SwitchChoiceNoOtherwise")}
    "switch" Strategy SwitchCase*
         "otherwise" ":" Strategy "end"   -> Strategy {cons("SwitchChoice")}

    "case" Strategy ":" Strategy          -> SwitchCase {cons("SwitchCase")}

    Strategy "=>" Term 		  	  -> Strategy {cons("AM")}

    Term ":=" Term			  -> Strategy {cons("Assign")}

  %% Priorities

  context-free priorities
    { Strategy StrategyCurly		  -> Strategy
      Strategy "#" StrategyParen          -> Strategy
    }
  > { "!" Term 				  -> Strategy
      "?" Term 				  -> Strategy
    }
  > StrategyAngle Term 		          -> Strategy
  > Strategy "=>" Term 		  	  -> Strategy
  > Strategy ";" Strategy 		  -> Strategy
  > {right: 
     Strategy "+" Strategy 		  -> Strategy
     Strategy "<+" Strategy 		  -> Strategy
     Strategy "+>" Strategy 		  -> Strategy
     
     Strategy "<" StrategyMid 
              "+" Strategy 		  -> Strategy
    }

  context-free priorities
    Strategy 				  -> StrategyMid
  > Strategy "+" Strategy 		  -> Strategy

  context-free priorities
    { Strategy StrategyCurly      -> Strategy
      Strategy "#" StrategyParen  -> Strategy
    }
    .> Term ":=" Term -> Strategy


module Stratego-Sugar-Terms
imports
  Stratego-Core-Terms
  Stratego-Sugar-Strategies

exports
  sorts LID
  context-free syntax
    LId 			-> LID  {cons("ListVar")}
    LID				-> Var  {cons("Var")}
    LID				-> ID

  context-free syntax
    "_" PreTerm 		 -> PreTerm {cons("BuildDefaultPT")}
    "_" Term 			 -> Term {cons("BuildDefault"),prefer}

    Char 			 -> PreTerm {cons("Char")}

    PreTerm "{" {Term ","}* "}"	 -> Term {cons("AnnoList")}
    PreTerm                      -> Term {cons("NoAnnoList")}

    "<" Strategy ">" Term 	 -> PreTerm {cons("App")}
    "<" Strategy ">" Term 	 -> Term {cons("App"),prefer}

    StrategyAngle		 -> PreTerm {cons("RootApp")}
    StrategyAngle		 -> Term {cons("RootApp"),prefer}

    "(" {Term ","}* ")" 	 -> PreTerm {cons("Tuple")}
    "[" {Term ","}* "]" 	 -> PreTerm {cons("List")}
    "[" {Term ","}* "|" Term "]" -> PreTerm {cons("ListTail")}

  context-free priorities
    Term "#" "(" Term ")" 	 -> PreTerm {cons("Explode")}
  > PreTerm "{" {Term ","}* "}"	 -> Term {cons("AnnoList")}
  > Var "@" Term 		 -> Term {cons("As")}

module Stratego-Sugar-Signatures
imports
  Stratego-Core-Signatures
  Stratego-Sugar-Constants

exports

  sorts Sort
  context-free syntax
    "[" {Sort ","}* "]"		 -> Sort {cons("SortList")}
    "[" {Sort ","}* "|" Sort "]" -> Sort {cons("SortListTl")}
    "(" {Sort ","}* ")"		 -> Sort {cons("SortTuple")}

  sorts Kind
  context-free syntax
    "*" 			-> Kind {cons("Star")}
    "**" 			-> Kind {cons("StarStar")}

module Stratego-Core-Signatures
imports
  Stratego-Core-Identifiers
  Stratego-Core-Constants
exports
  sorts Sdecl
  context-free syntax
    "sorts" Sort* 		-> Sdecl {cons("Sorts")}
    "constructors" Opdecl* 	-> Sdecl {cons("Constructors")}

  sorts Sort
  context-free syntax
    LCID 			 -> Sort {cons("SortVar")}
    UCID 			 -> Sort {cons("SortNoArgs")}
    Id "(" {Sort ","}* ")" 	 -> Sort {cons("Sort")}

  sorts Opdecl
  context-free syntax
    Id     ":" Type 		-> Opdecl {cons("OpDecl")}
    String ":" Type 		-> Opdecl {cons("OpDeclQ")}
           ":" Type 		-> Opdecl {cons("OpDeclInj")}

  context-free syntax
    "external" Id     ":" Type 	-> Opdecl {cons("ExtOpDecl")}
    "external" String ":" Type 	-> Opdecl {cons("ExtOpDeclQ")}
    "external"        ":" Type 	-> Opdecl {cons("ExtOpDeclInj")}

  sorts Type ArgType ConstType FunType RetType
  context-free syntax
    Sort	                -> ConstType {cons("ConstType")}
    {ArgType "*"}+ "->" RetType -> FunType {cons("FunType")}
    "(" Type ")"                -> ArgType {bracket}
    ConstType			-> ArgType
    Type	                -> RetType
    FunType			-> RetType {reject}

    FunType			-> Type
    ConstType			-> Type

  %%%
   %% Restriction is required for the Sort* in Sdecl: List(a) is
   %% ambiguous.
   %%%
  context-free restrictions
    Sort -/- [\(]

module Stratego-Core-Terms
imports
  Stratego-Core-Identifiers
  Stratego-Core-Constants

exports
  sorts ID Var Wld
  context-free syntax
    Id 				-> Var  {cons("Var")}
    Id				-> ID
    %% ":" Var                  -> Var  {cons("SeqVar")}

  sorts Term PreTerm
  context-free syntax
    Var 			 -> PreTerm 
    Var 			 -> Term {prefer}

    "_" 			 -> Wld {cons("Wld")}
    Wld 			 -> PreTerm
    Wld 			 -> Term {prefer}

    Int 			 -> PreTerm {cons("Int")}
    Real 			 -> PreTerm {cons("Real")}
    String 			 -> PreTerm {cons("Str")}

    Id "(" {Term ","}* ")" 	 -> PreTerm {cons("Op")}
    String "(" {Term ","}* ")" 	 -> PreTerm {cons("OpQ")}
    Term "#" "(" Term ")" 	 -> PreTerm {cons("Explode")}

    PreTerm "{^" PreTerm "}"	 -> Term {cons("Anno")}

    Var "@" Term 		 -> Term {cons("As"),prefer}
    Var "@" PreTerm 		 -> PreTerm {cons("As")}

  context-free priorities
    Term "#" "(" Term ")" 	 -> PreTerm {cons("Explode")}
  > Var "@" Term 		 -> Term {cons("As")}

module Stratego-Core-Strategies
imports
  Stratego-Core-Terms
  Stratego-Core-Constants
  Stratego-Core-Signatures

exports
  sorts Def
  context-free syntax
    StrategyDef					 -> Def 
    Id						 -> SVar {cons("SVar")}
    "let" Def* "in" Strategy "end"		 -> Strategy {cons("Let")}
    SVar "(" {Strategy ","}* "|" {Term ","}* ")" -> Strategy {cons("CallT")}

    "call" "(" Term "|" {Strategy ","}* "|" {Term ","}* ")" -> Strategy {cons("CallDynamic")}


  sorts StrategyDef
  context-free syntax
    Id "(" {Typedid ","}* 
       "|" {Typedid ","}* ")" "=" Strategy -> StrategyDef {cons("SDefT")}

    "external"
    Id "(" {Typedid ","}* 
       "|" {Typedid ","}* ")" "=" Strategy -> StrategyDef {cons("ExtSDefInl")}

    "external"
    Id "(" {Typedid ","}* 
       "|" {Typedid ","}* ")"		   -> StrategyDef {cons("ExtSDef")}


  sorts Typedid
  context-free syntax
    ID ":" Type 			  -> Typedid {cons("VarDec")}


  sorts Strategy SVar StrategyParen StrategyMid 
  context-free syntax
    "(" Strategy ")"			  -> StrategyParen {cons("ParenStrat")}

    "fail" 				  -> Strategy {cons("Fail")}
    "id" 				  -> Strategy {cons("Id")}

    %% Match and build

    "?" Term 				  -> Strategy {cons("Match")}
    "!" Term 				  -> Strategy {cons("Build")}
    "{" {ID ","}* ":" Strategy "}" 	  -> Strategy {cons("Scope")}

    %% Combinators

    Strategy ";" Strategy 		  -> Strategy {cons("Seq"),right}
    Strategy "<" StrategyMid 
             "+" Strategy 		  -> Strategy {cons("GuardedLChoice"),right}
    Strategy 				  -> StrategyMid

    %% Primitives

    "prim" "(" String "," {Strategy ","}* "|" {Term ","}*")"  -> Strategy {cons("PrimT")}

    %% Traversal

    "some" "(" Strategy ")" 		  -> Strategy {cons("Some")}
    "one" "(" Strategy ")" 		  -> Strategy {cons("One")}
    "all" "(" Strategy ")" 		  -> Strategy {cons("All")}

  %% Priorities

  context-free priorities
    { "!" Term 				  -> Strategy {cons("Build")}
      "?" Term 				  -> Strategy {cons("Match")}
    }
  > Strategy ";" Strategy 		  -> Strategy {cons("Seq"),right}
  > {right: 
     Strategy "<" StrategyMid 
              "+" Strategy 		  -> Strategy {cons("GuardedLChoice"),right}
    }

  context-free syntax
    "import-term" "(" ModName ")" -> Strategy {cons("ImportTerm")}

module Stratego-Core-Modules
imports
  Stratego-Core-Identifiers
  Stratego-Core-Strategies
  Stratego-Core-Signatures

exports 
  sorts Module
  context-free syntax
    "module" ModName Decl* 	 -> Module {cons("Module")}
    "specification" Decl*	 -> Module {cons("Specification")}

  sorts Decl 
  context-free syntax
    "imports" ImportModName* 	-> Decl {cons("Imports")}
    "strategies" Def* 		-> Decl {cons("Strategies")}
    "signature" Sdecl*  	-> Decl {cons("Signature")}

  sorts ImportModName
  context-free syntax
    ModName              -> ImportModName {cons("Import")}
  syntax
    <ModName-CF> "/" "-" -> <ImportModName-CF> {cons("ImportWildcard")}

module Stratego-Sugar-Modules
imports
  Stratego-Core-Modules
  Stratego-Sugar-Strategies
  Stratego-Sugar-Signatures
  Stratego-Sugar-Overlays
  Stratego-Sugar-Rules

exports 

  sorts Decl Def
  context-free syntax
    "rules" Def* 		-> Decl {cons("Rules")}
    "overlays" Overlay* 	-> Decl {cons("Overlays")}

    RuleDef 			-> Def 


module Stratego-Core-Constants
exports
  sorts Int Real String StrChar
  lexical syntax
    [\-]? [0-9]+ 		-> Int
    [\-]? [0-9]+ [\.] [0-9]+ 	-> Real
    "\"" StrChar* "\"" 		-> String
    ~[\"\\] 			-> StrChar
    [\\] [\"tnr\\] 		-> StrChar


module Stratego-Sugar-Constants
imports Stratego-Core-Identifiers Stratego-Core-Constants
exports
  sorts Char CharChar
  lexical syntax
    "'" CharChar "'"		-> Char
    ~[\']			-> CharChar
    [\\] [\'ntr\ ]		-> CharChar
    Char		 	-> Id {reject}

module Stratego-Core-Identifiers
exports
  sorts ModName ModNamePart
  lexical syntax
    {ModNamePart "/"}+ -> ModName
    [a-zA-Z\.\_] [a-zA-Z0-9\'\.\-\_]* -> ModNamePart
  lexical restrictions
    ModName -/- [a-zA-Z0-9\'\.\-\_]
  lexical syntax
    "imports" 		-> ModName {reject}
    "overlays" 		-> ModName {reject}
    "rules" 		-> ModName {reject}
    "signature" 	-> ModName {reject}
    "strategies" 	-> ModName {reject}

  sorts Id LId LCID UCID Wld
  lexical syntax
    [a-zA-Z\_] [a-zA-Z0-9\'\-\_]*     -> Id
    [a-zA-Z\_] [a-zA-Z0-9\'\-\_]* "*" -> LId
    [\'] [a-z]+                       -> Id

    [a-z] [a-zA-Z0-9\'\-\_]*  -> LCID
    [A-Z] [a-zA-Z0-9\'\-\_]*  -> UCID

  lexical restrictions
    Id   -/- [a-zA-Z0-9\'\-\_\*]
    LId  -/- [a-zA-Z0-9\'\-\_]
    LCID -/- [a-zA-Z0-9\'\-\_]
    UCID -/- [a-zA-Z0-9\'\-\_]

  lexical syntax
    "_"     -> Id {reject}
    "'"     -> Id {reject}

    Keyword -> Id   {reject}
    Keyword -> LId  {reject}
    Keyword -> LCID {reject}
    Keyword -> UCID {reject}

  lexical restrictions
    "all"
    "case" %% not reserved kw
    "constructors"
    "else" %% not reserved kw
    "end" %% not reserved kw
    "external" %% not reserved kw
    "fail"
    "id"
    "if" %% not reserved kw
    "in"
    "imports" %% not reserved kw
    "let"
    "module"
    "not"
    "one"
    "overlays"
    "otherwise" %% not reserved kw
    "prim"
    "rec" %% not reserved kw
    "rules"
    "script"
    "signature"
    "some"
    "sorts"
    "strategies"
    "stratego"
    "switch" %% not reserved kw
    "test"
    "then" %% not reserved kw
    "where"
    "import-term"
      -/- [a-zA-Z0-9\'\-\_]
  
  context-free restrictions
    Wld -/- [a-zA-Z0-9\'\-\_]

  sorts Keyword
  lexical syntax
    "all"               -> Keyword
    "constructors" 	-> Keyword
    "fail" 		-> Keyword
    "id" 		-> Keyword
    "in" 		-> Keyword
    "let" 		-> Keyword
    "module" 		-> Keyword
    "not" 		-> Keyword
    "one" 		-> Keyword
    "overlays" 		-> Keyword
    "prim" 		-> Keyword
    "rules" 		-> Keyword
    "script" 		-> Keyword
    "signature" 	-> Keyword
    "some" 		-> Keyword
    "sorts" 		-> Keyword
    "strategies" 	-> Keyword
    "stratego" 		-> Keyword
    "test" 		-> Keyword
    "where" 		-> Keyword
    "import-term"	-> Keyword


module Stratego-Core-Layout
exports
  sorts Ws ShortCom LongCom CommChar Asterisk Eof 
  lexical syntax
    [\t\ \n\r]			-> Ws

    "//" ~[\n]* ([\n] | Eof)	-> ShortCom
    "/*" CommChar* "*/"	-> LongCom
				-> Eof  

    ~[\*]     -> CommChar

    "*"       -> Asterisk
    Asterisk  -> CommChar

  lexical restrictions
    Asterisk -/- [\/]
    Eof      -/- ~[]

  lexical syntax
    ShortCom 	-> LAYOUT
    LongCom 	-> LAYOUT
    Ws 		-> LAYOUT

  context-free restrictions
    LAYOUT? -/- [\ \t\n\r]
    LAYOUT? -/- [\/].[\*]
    LAYOUT? -/- [\/].[\/]

module Stratego-Sugar-Layout
imports Stratego-Core-Layout
%%exports
%%  sorts VeryLongCom Eof VLCchar Backslash
%%  lexical syntax
%%    "\\end{code}" VLCchar* "\\begin{code}" -> VeryLongCom
%%    "\\begin{code}" 			   -> VeryLongCom
%%    "\\end{code}" VLCchar* Eof 		   -> VeryLongCom
%%    "\\literate" VLCchar* "\\begin{code}"  -> VeryLongCom
%%    ~[\\] 				   -> VLCchar
%%    Backslash 				   -> VLCchar
%%    [\\] 				   -> Backslash

%%  lexical restrictions
%%    Backslash -/- [b].[e].[g].[i].[n].[\{].[c].[o].[d].[e].[\}]
%%    Eof -/- ~[]

%%  lexical syntax
%%    VeryLongCom -> LAYOUT



module Stratego-Sugar
imports
  Stratego-Sugar-Layout
  Stratego-Core-Identifiers
  Stratego-Sugar-Constants 
  Stratego-Sugar-Modules
  Stratego-Sugar-Signatures
  Stratego-Sugar-Terms
  Stratego-Sugar-Strategies
  Stratego-Sugar-Rules
  Stratego-Sugar-DynamicRules
  Stratego-Sugar-Overlays

hiddens
  context-free start-symbols Module

module Stratego
imports Stratego-Sugar
hiddens
  context-free start-symbols Module

module StrategoMix[Ctx0]
imports Stratego
          [ RuleNames      => RuleNames[[Ctx0]]
            RuleDec        => RuleDec[[Ctx0]]
            DynRuleScopeId => DynRuleScopeId[[Ctx0]]
            DynRuleId      => DynRuleId[[Ctx0]]
            DynRuleDef     => DynRuleDef[[Ctx0]]
            ScopeLabels    => ScopeLabels[[Ctx0]]
            RuleCond       => RuleCond[[Ctx0]]
            Rule           => Rule[[Ctx0]]
            RuleDef        => RuleDef[[Ctx0]]
            Overlay        => Overlay[[Ctx0]]
            SwitchCase     => SwitchCase[[Ctx0]]
            StrategyCurly  => StrategyCurly[[Ctx0]]
            StrategyAngle  => StrategyAngle[[Ctx0]]
            Kind           => Kind[[Ctx0]]
            LID            => LID[[Ctx0]]
            ImportModName  => ImportModName[[Ctx0]]
            Decl           => Decl[[Ctx0]]
            Module         => Module[[Ctx0]]
            StrategyParen  => StrategyParen[[Ctx0]]
            Typedid        => Typedid[[Ctx0]]
            StrategyDef    => StrategyDef[[Ctx0]]
            SVar           => SVar[[Ctx0]]
            Def            => Def[[Ctx0]]
            Type           => Type[[Ctx0]]
            RetType        => RetType[[Ctx0]]
            ArgType        => ArgType[[Ctx0]]
            FunType        => FunType[[Ctx0]]
            ConstType      => ConstType[[Ctx0]]
            Opdecl         => Opdecl[[Ctx0]]
            Sort           => Sort[[Ctx0]]
            Sdecl          => Sdecl[[Ctx0]]
            Wld            => Wld[[Ctx0]]
            ID             => ID[[Ctx0]]
            Var            => Var[[Ctx0]]
            CharChar       => CharChar[[Ctx0]]
            Char           => Char[[Ctx0]]
            StrChar        => StrChar[[Ctx0]]
            String         => String[[Ctx0]]
            Real           => Real[[Ctx0]]
            Int            => Int[[Ctx0]]
            Keyword        => Keyword[[Ctx0]]
            UCID           => UCID[[Ctx0]]
            LCID           => LCID[[Ctx0]]
            LId            => LId[[Ctx0]]
            Id             => Id[[Ctx0]]
            ModNamePart    => ModNamePart[[Ctx0]]
            ModName        => ModName[[Ctx0]]
            PreTerm        => PreTerm[[Ctx0]]
            Term           => Term[[Ctx0]]
            StrategyMid    => StrategyMid[[Ctx0]]
            Strategy       => Strategy[[Ctx0]] ]


module StrategoWebDSL

imports
  StrategoMix[StrategoHost]
  WebDslMix[ Term[[StrategoHost]] ]

hiddens
  context-free start-symbols Module[[StrategoHost]]