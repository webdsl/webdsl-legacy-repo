module org/webdsl/dsl/to-java-servlet/search/search

imports
  libstrategolib
  libjava-front

imports
  libwebdsl-front
  libback-end-transformations
  org/webdsl/dsl/to-java-servlet/-

strategies

  property-to-index-annos :
    Property(_, propkind, type, anno*) -> index-annos
    where not (<?Ref()<+?Comp() > propkind)
    	; searchable-annos := <filter(is-searchable-anno)> anno*
    	; not(?[])
    	; date-bridge-anno := <type-to-date-bridge-anno <+ ![] >type
    	; if (<?[]> date-bridge-anno)
    	  then index-annos := <searchable-annos-to-index-annos> searchable-annos
    	  else index-annos := [date-bridge-anno |<searchable-annos-to-index-annos> searchable-annos] end
  
  property-to-index-annos :
    DerivedProperty(x, _, type, anno*, _) -> index-annos
    where searchable-annos := <filter(is-searchable-anno)> anno*
    	; not(?[])
    	; date-bridge-anno := <type-to-date-bridge-anno <+ ![] >type
    	; if (<?[]> date-bridge-anno)
    	  then index-annos := <searchable-annos-to-index-annos> searchable-annos
    	  else index-annos := [date-bridge-anno |<searchable-annos-to-index-annos> searchable-annos] end
          
  type-to-date-bridge-anno :
  	SimpleSort("Time") -> anno|[ @org.hibernate.search.annotations.DateBridge(resolution = org.hibernate.search.annotations.Resolution.MINUTE) ]|
  type-to-date-bridge-anno :
  	SimpleSort("DateTime") -> anno|[ @org.hibernate.search.annotations.DateBridge(resolution = org.hibernate.search.annotations.Resolution.MINUTE) ]|
  type-to-date-bridge-anno :
  	SimpleSort("Date") -> anno|[ @org.hibernate.search.annotations.DateBridge(resolution = org.hibernate.search.annotations.Resolution.DAY) ]|
    	  
  //Reference/Composite properties are embedded index fields, one level of depth right now
  property-to-index-annos :
    Property(x, propkind, srt, anno*) -> [anno|[ @org.hibernate.search.annotations.IndexedEmbedded(depth=1, prefix="~x" + ".") ]|]
    where  <?Ref()<+?Comp() > propkind
    	; <fetch(?SearchableAnno(_))> anno*
  
  //Other side (inverse) of embedded index field needs containedin annotation 
  property-to-contained-in:
  	p@Property(_, _, _, anno*) -> [anno|[ @org.hibernate.search.annotations.ContainedIn]|]
	where <has-anno(InverseOfSearchable)> p

strategies //field annotations
	
  searchable-annos-to-index-annos:
  	searchable-annos -> index-annos
  	with rules(CurrentAnalyzerAnnoDef := []) 
	    ; fields-anno := Anno(TypeName(Id("org.hibernate.search.annotations.Fields")), [ElemValArrayInit(<map(searchable-to-field-anno);flatten-list> searchable-annos)])
	    ; analyzer-def-annos := <bagof-CurrentAnalyzerAnnoDef;flatten-list;wrap-in-analyzer-defs-anno>
	    ; numeric-field-annos := <filter(to-numeric-field-anno);wrap-in-numeric-fields-anno> searchable-annos
	    ; index-annos := <flatten-list>[fields-anno, analyzer-def-annos, numeric-field-annos]

  searchable-to-field-anno :
  	SearchableAnno(sa-args) -> field-anno
  	with  field-args := <filter(to-java-field-arg)> sa-args
  	    ; field-anno := Anno(TypeName(Id("org.hibernate.search.annotations.Field")),field-args)
  
  to-java-field-arg :
  	SA-Argument("analyzer", analyzer-name) -> ElemValPair(Id("analyzer"),anno|[ @org.hibernate.search.annotations.Analyzer(definition="~analyzer-name") ]|)
  	where not(<?"no" <+ ?"null"> analyzer-name)
  	with <do-once(create-and-record-analyzer-definition|"create analyzer def")<+ ![]> analyzer-name

  to-java-field-arg :
	SA-Argument("analyzer", analyzer-name) -> ElemValPair(Id("index"),ExprName(AmbName(Id("org.hibernate.search.annotations.Index")), Id("UN_TOKENIZED")))
	where (<?"no" <+ ?"null"> analyzer-name)
	
  to-java-field-arg :
  	SA-Argument("name", field-name) -> ElemValPair(Id("name"),Lit(String([Chars(field-name)])))
  
  to-java-field-arg :
  	SA-Argument("boost", field-boost) -> ElemValPair(Id("boost"),anno|[ @org.hibernate.search.annotations.Boost(e_boost) ]|) 
  	with e_boost := expr |[ ~float:Float(<concat-strings> [field-boost,"f"]) ]| 	
  
  to-numeric-field-anno:
  	SearchableAnno(sa-args) -> anno|[ @org.hibernate.search.annotations.NumericField(forField = "~field-name") ]|
  	where <fetch(?SA-Argument("numeric",_))> sa-args
  		; <fetch(?SA-Argument("name", field-name))> sa-args

  wrap-in-numeric-fields-anno:
  	list-> Anno(TypeName(Id("org.hibernate.search.annotations.NumericFields")), [ElemValArrayInit(list)])
  	where not (?[])
 
  wrap-in-numeric-fields-anno:
  	list -> list
  	where ?[]
strategies //analyzers, analyzers

  create-and-record-analyzer-definition = 
  	SearchConfigFromName; analyzer-def-anno := <search-config-to-analyzer-def>; rules(CurrentAnalyzerAnnoDef :+= analyzer-def-anno)
  	
  search-config-to-analyzer-def:
  	SearchConfig(_,name, body) -> <to-analyzer-def(|name)> body

  to-analyzer-def(|analyzerName):
  	SearchConfigBody(charFilters*, tokenizer, tokenFilters*) -> result
  	with charFiltersDef* := <map(to-char-filter-def)> charFilters*
  	   ; tokenizerDef := <to-tokenizer-def> tokenizer
  	   ; tokenFilterDef* := <map(to-token-filter-def)> tokenFilters*
  	   ; name_arg := ElemValPair(Id("name"),Lit(String([Chars(analyzerName)])))
  	   ; charfilter_arg := ElemValPair(Id("charFilters"),ElemValArrayInit(charFiltersDef*))
  	   ; tokenizer_arg := ElemValPair(Id("tokenizer"), tokenizerDef)
  	   ; tokenfilter_arg := ElemValPair(Id("filters"),ElemValArrayInit(tokenFilterDef*))
  	   ; result := Anno(TypeName(Id("org.hibernate.search.annotations.AnalyzerDef")),[name_arg, charfilter_arg,tokenizer_arg,tokenfilter_arg])     

  to-tokenizer-def:
  	Tokenizer(tokenizername, args) -> result
  	with   e_analyzerargs := <map(to-analyzer-arg)> args
  		; tokenizername' := <to-fully-qlfd-name> tokenizername
  		; result := Anno(TypeName(Id("org.hibernate.search.annotations.TokenizerDef")), [ ElemValPair(Id("factory"), Lit(Class(ClassOrInterfaceType(TypeName(Id(tokenizername')),None()))))
                              , ElemValPair(Id("params"), ElemValArrayInit(e_analyzerargs))
                              ])
  
  to-token-filter-def:
  	TokenFilter(filtername, args) -> result
  	with  e_analyzerargs := <map(to-analyzer-arg)> args
		; filtername' := <to-fully-qlfd-name> filtername
  		; result := Anno(TypeName(Id("org.hibernate.search.annotations.TokenFilterDef")), [ ElemValPair(Id("factory"), Lit(Class(ClassOrInterfaceType(TypeName(Id(filtername')),None()))))
                              , ElemValPair(Id("params"), ElemValArrayInit(e_analyzerargs))
                              ])
  	
  to-char-filter-def:
  	CharFilter(filtername, args) -> result
  	with  e_analyzerargs := <map(to-analyzer-arg)> args
  		; filtername' := <to-fully-qlfd-name> filtername
  		; result := Anno(TypeName(Id("org.hibernate.search.annotations.CharFilterDef")), [ ElemValPair(Id("factory"), Lit(Class(ClassOrInterfaceType(TypeName(Id(filtername')),None()))))
                              , ElemValPair(Id("params"), ElemValArrayInit(e_analyzerargs))
                              ])
                                
  to-analyzer-arg:
  	Argument(x_name, x_value) ->   anno|[ @org.hibernate.search.annotations.Parameter(name = "~x_name", value = x_value) ]|
  
  to-fully-qlfd-name:
  	name -> name'
  	with
  		if (<string-starts-with(|String("org.apache.solr.analysis."))>name) then name' := name
  		else name' := <conc-strings>("org.apache.solr.analysis.",name) end
  		  	
  wrap-in-analyzer-defs-anno:
  	list-> Anno(TypeName(Id("org.hibernate.search.annotations.AnalyzerDefs")), [ElemValArrayInit(list)])
  	where not (?[])
 
  wrap-in-analyzer-defs-anno:
  	list -> list
  	where ?[]

strategies

  GenerateCodeJavaServlet = generate-java-search-functions; fail
  GenerateCodeJavaServlet = generate-java-searchquery-class ; fail


  generate-java-searchquery-class :
  	ent -> <emit-java-code-local> compilation-unit |[
  	package pkgname;
  	
  	import utils.*;
  	import java.io.File;
  	import java.util.Date;
  	import java.util.ArrayList;
	import java.util.List;
  	import org.webdsl.search.SearchSuggester;
  	import org.apache.lucene.store.Directory;
  	import org.hibernate.search.FullTextSession;
  	import org.hibernate.search.store.FSDirectoryProvider;
  	import org.apache.lucene.search.SortField;
  	
	public class x_class#SearchQuery extends org.webdsl.search.SearchQuery<x_class> {
		
		public x_class#SearchQuery (){
			entityClass = x_Class.class;
			searchFields = new String[]{ e_sf* };
			untokenizedFields = new String[]{ e_utf* };
			mltSearchFields = new String[]{ e_mltsf* };
			fullTextSession = org.hibernate.search.Search.getFullTextSession(e_HibSession);
			analyzer = fullTextSession.getSearchFactory().getAnalyzer(entityClass);
		}
		public static File spellDirectoryForField(String field){
				return new File( utils.IndexManager.indexDirSpellCheck(x_Class.class, field));
		}
		public static File autoCompleteDirectoryForField(String field){
				return new File( utils.IndexManager.indexDirAutoComplete(x_Class.class, field));
		}
		
		public static ArrayList<String> spellSuggest(String toSuggestOn, List<String> fields, float accuracy, int noSug){
			String baseDir = utils.IndexManager.indexDirSpellCheck(x_Class.class, "");
			return SearchSuggester.findSpellSuggestions(x_Class.class, baseDir, fields, noSug, accuracy, toSuggestOn);
		}
	
		public static ArrayList<String> spellSuggest(String toSuggestOn, String field, float accuracy, int noSug){
			String baseDir = utils.IndexManager.indexDirSpellCheck(x_Class.class, "");
			return SearchSuggester.findSpellSuggestionsForField(x_Class.class, baseDir, field, noSug, accuracy, true, toSuggestOn);
		}
		
		public static ArrayList<String> autoCompleteSuggest(String toSuggestOn, List<String> fields, int noSug){
			String baseDir = utils.IndexManager.indexDirAutoComplete(x_Class.class, "");
			return SearchSuggester.findAutoCompletions(x_Class.class, baseDir, fields, noSug, toSuggestOn);
		}
		
		public static ArrayList<String> autoCompleteSuggest(String toSuggestOn, String field, int noSug){
			String baseDir = utils.IndexManager.indexDirAutoComplete(x_Class.class, "");
			return SearchSuggester.findAutoCompletionsForField(x_Class.class, baseDir, field, noSug, toSuggestOn);			
	
		}
		
		public Class<?> fieldType(String field){			
			bstm*
			return String.class;
		}
		
		protected FullTextSession getFullTextSession() {
		if(fullTextSession == null) {
			fullTextSession = org.hibernate.search.Search.getFullTextSession(e_HibSession);
			updateFullTextQuery = true;
		}
		return fullTextSession;
		}
	}	
  	]|
    where (x_class, _) := <get-entity-def> ent
       ; x_props := <get-anno(?IndexedAnno(<id>,_,_,_,_))> ent
       ; x_propsUntokenized := <get-anno(?IndexedAnno(_,<id>,_,_,_))> ent
       ; x_javaTypeNames := <get-anno(?IndexedAnno(_,_,<id>,_,_))> ent
    with e_sf* := <map(\name -> expr |[ "~name" ]| \)> x_props
       ; e_utf* := <map(\name -> expr |[ "~name" ]| \)> x_propsUntokenized
       ; e_mltsf* := <diff>(e_sf*,e_utf*)
       ; pkgname := <DomainPackage>
       ; bstm* := <zip(field-to-java-type-name-condition)> (x_propsUntokenized, x_javaTypeNames)
       ; x_Class := <concat-strings> [<pp-java5-to-string> <DomainPackage>, ".", x_class]
         
  field-to-java-type-name-condition:
  	(fieldName, sortType) -> java:stm |[ if(field.equals("~fieldName")) return e_tp;]|
  	where e_tp := ExprName(AmbName(Id(sortType)), Id("class"))

  generate-java-search-functions:
    ent -> <emit-java-code-local> compilation-unit |[
  
      package pkgname;
      
      @Partial
      public class x_class {
      
        public static java.util.List<x_Class> x#_(String searchQuery)  {
          return x#_(searchQuery, 1000, 0);
        }
        public static java.util.List<x_Class> x#_(String searchQuery, int limit)  {
          return x#_(searchQuery, limit, 0);
        }
        public static java.util.List<x_Class> x#_(String searchQuery, int limit, int offset)  {
           return new x_Class#SearchQuery().terms(searchQuery).firstResult(offset).maxResults(limit).list();
        }
      }
    ]|
    where (
        (x_class, _) := <get-entity-def> ent
      ; x_props := <get-anno(?IndexedAnno(<id>,_,_,_,_))> ent
    )
    with x := <concat-strings> ["_static_", "search", x_class]
       ; pkgname := <DomainPackage>
       ; x_Class := <concat-strings> [<pp-java5-to-string> <DomainPackage>, ".", x_class]

strategies

  generate-code-java-servlet-once =
      bagof-IndexedEntities
    ; string-sort-annos
    ; cached-generate(generate-java-servlet-indexmanager | "internal_IndexManager")
    ; fail


  generate-java-servlet-indexmanager :
    x_class* ->
    <emit-java-code-local> compilation-unit|[
      package utils;
  
      import java.util.List;
      import java.io.File;
      import java.io.IOException;
      import org.apache.lucene.index.IndexReader;
	  import org.apache.lucene.search.spell.SpellChecker;
	  import org.apache.lucene.search.spell.Dictionary;
	  import org.apache.lucene.search.spell.LuceneDictionary;
  	  import org.hibernate.search.SearchFactory;
	  import org.hibernate.search.reader.ReaderProvider;
	  import org.hibernate.search.store.DirectoryProvider;
	  import org.hibernate.search.store.FSDirectoryProvider;
	  import org.webdsl.search.AutoCompleter;
  
      import utils.*;
      import pkgname.*;
      
      import org.webdsl.lang.*;
  
      @SuppressWarnings("all")
      public class IndexManager {
      	
      	protected static java.util.Properties props = new java.util.Properties();
      	
        public static void main(String[] args) {
        	reindex();
        	System.exit(0);
        }
        
        private static void reindex() {
          java.io.PrintWriter out = new java.io.PrintWriter(System.out);
          ThreadLocalOut.push(out);
          // @TODO Globals are not loaded yet
          System.out.println("Starting reindexing of all searchable data...");
          long time = System.currentTimeMillis();
          
          org.hibernate.search.FullTextSession session = org.hibernate.search.Search.getFullTextSession(HibernateUtilConfigured.getSessionFactory().getCurrentSession());
		  
		  bstm*
		  
		  indexSuggestions();		  
			 			
		  time = System.currentTimeMillis() - time;
	      System.out.println("Reindexing finished in " + time + "ms total.");
        }
        
        private static boolean reindexEntityClass(Class<?> c, org.hibernate.search.FullTextSession session){
        	String entityName = c.getName().substring(c.getPackage().getName().length() + 1);
        	System.out.println("reindexing: " + entityName + "...");
        	long time = System.currentTimeMillis();
        	try {
        		session.createIndexer(c)
        		.progressMonitor(new org.webdsl.search.IndexProgressMonitor(2000, entityName))
 				.batchSizeToLoadObjects( 50 )
				.threadsToLoadObjects( 3 )
 				.threadsForSubsequentFetching( 4 )
 				.startAndWait();
 				
 			}
 			catch(java.lang.InterruptedException ex){
 				ex.printStackTrace();
 				return false;
 			}
 			time = System.currentTimeMillis() - time;
 			System.out.println("done in " + time + "ms.");
 			return true;
        }
        public static void indexSuggestions(){
        	bstm2*
        }
        
        private static void createOrUpdateSpellIndex(Class<?> indexedClass, String[] searchFields){
		    
		    org.hibernate.search.FullTextSession session = org.hibernate.search.Search.getFullTextSession(HibernateUtilConfigured.getSessionFactory().getCurrentSession());
		    SearchFactory searchFactory = session.getSearchFactory();			
		 
		    DirectoryProvider[] directoryProviders = searchFactory.getDirectoryProviders(indexedClass);
		 
		    ReaderProvider readerProvider = searchFactory.getReaderProvider();
		    IndexReader reader = readerProvider.openReader(directoryProviders);
		    
    		String indexBase = indexDir();
    		String entityName = indexedClass.getName().substring(indexedClass.getPackage().getName().length() + 1);
    		System.out.println(new java.util.Date() + ": Creating/updating spell check index for entity: " + entityName);
    		try{
		        for(int c=0;c<searchFields.length;c++){
		        	//System.out.println(new java.util.Date() + ": Spellcheck update: " + entityName + "." + searchFields[c]);
		        	SpellChecker sp = null;
		        	try {
			        	FSDirectoryProvider dir = new FSDirectoryProvider();
		        		File path = new File( indexDirSpellCheck(indexedClass, searchFields[c]) );	        		
			        	sp = new SpellChecker(dir.getDirectory().open(path));		        	
				        Dictionary dictionary = new LuceneDictionary(reader, searchFields[c]);
				        sp.indexDictionary(dictionary);
					} catch (IOException ex) {
			        	ex.printStackTrace();
			        	System.out.println("Failed to create spellcheck index for " + entityName + ", field: " + searchFields[c]);		        
				    } finally {
				    	if(sp!=null){
				    		try {
								sp.close();
							} catch (IOException ex) {
								ex.printStackTrace();
							}
				    	}			    	
				    }
			    }
		    } finally{
		    	if (reader != null)
					searchFactory.getReaderProvider().closeReader(reader);
		    }
		    System.out.println(new java.util.Date() + ": Done with spellcheck index for (" + entityName + ")");
		}
        private static void createOrUpdateAutoCompleteIndex(Class<?> indexedClass, String[] searchFields){
		    
		    org.hibernate.search.FullTextSession session = org.hibernate.search.Search.getFullTextSession(HibernateUtilConfigured.getSessionFactory().getCurrentSession());
		    SearchFactory searchFactory = session.getSearchFactory();			
		 
		    DirectoryProvider[] directoryProviders = searchFactory.getDirectoryProviders(indexedClass);
		 
		    ReaderProvider readerProvider = searchFactory.getReaderProvider();
		    IndexReader reader = readerProvider.openReader(directoryProviders);
		    
    		String indexBase = indexDir();
    		String entityName = indexedClass.getName().substring(indexedClass.getPackage().getName().length() + 1);
    		System.out.println(new java.util.Date() + ": Creating/updating autocomplete index for entity: " + entityName);
    		try{
		        for(int c=0;c<searchFields.length;c++){
		        	//System.out.println(new java.util.Date() + ": Spellcheck update: " + entityName + "." + searchFields[c]);
		        	AutoCompleter ac = null;
		        	try {
			        	FSDirectoryProvider dir = new FSDirectoryProvider();
		        		File path = new File( indexDirAutoComplete(indexedClass, searchFields[c]) );	        		
			        	ac = new AutoCompleter(dir.getDirectory().open(path));		        	
				        Dictionary dictionary = new LuceneDictionary(reader, searchFields[c]);
				        ac.indexDictionary(dictionary);
					} catch (IOException ex) {
			        	ex.printStackTrace();
			        	System.out.println("Failed to create autocomplete index for " + entityName + ", field: " + searchFields[c]);		        
				    } finally {
				    	if(ac!=null){
				    		try {
								ac.close();
							} catch (IOException ex) {
								ex.printStackTrace();
							}
				    	}			    	
				    }
			    }
		    } finally{
		    	if (reader != null)
					searchFactory.getReaderProvider().closeReader(reader);
		    }
		    System.out.println(new java.util.Date() + ": Done with autocomplete index for (" + entityName + ")");
		}
		

        public static void optimizeIndex(){
        	System.out.println(new java.util.Date() + ": Optimizing search index started.");
        	org.hibernate.search.Search.getFullTextSession(HibernateUtilConfigured.getSessionFactory().getCurrentSession()).getSearchFactory().optimize();
        	System.out.println(new java.util.Date() + ": Optimizing search index finished succesfully.");
        }
        
        public static String indexDir(){
        	return e_indexdir;
        }
        
        public static String indexDirSpellCheck(Class<?> entityClass, String field){
        	return indexDir() + "/SpellCheck/" + entityClass.getName() + "/" + field;
        }
        public static String indexDirAutoComplete(Class<?> entityClass, String field){
        	return indexDir() + "/AutoComplete/" + entityClass.getName() + "/" + field;
        }

      }
    ]|
    with pkgname := <DomainPackage>
	    ; x_class_set := <make-set> x_class*
	    ; bstm* := <map(\ x_name -> java|[ reindexEntityClass(x_name.class, session);]|\)> x_class_set
	    ; bstm2* := <map(class-to-index-suggestions); flatten-list> x_class_set
	    ; indexdir := <concat-strings>[<IndexDir>,"/",<AppName>]
	    ; e_indexdir := expr|[ "~indexdir" ]|

class-to-index-suggestions:
	x_name -> [result1,result2]
	with scfields := <ClassToSpellCheckFields> x_name
		; e_spellcheckfield* := <map(\fieldname -> expr |[ "~fieldname" ]| \)> scfields
		; if (<?[]>e_spellcheckfield*) 
		  then result1 := []
		  else result1 := java |[ createOrUpdateSpellIndex(x_name.class, new String[]{ e_spellcheckfield* });]| end
		; acfields := <ClassToAutoCompleteFields> x_name	    
	    ; e_autocompletefield* := <map(\fieldname -> expr |[ "~fieldname" ]| \)> acfields
		; if (<?[]>e_autocompletefield*) 
		  then result2 := []
	      else result2 := java |[ createOrUpdateAutoCompleteIndex(x_name.class, new String[]{ e_autocompletefield* });]| end
		
strategies

is-searchable-anno = ?SearchableAnno(_)
