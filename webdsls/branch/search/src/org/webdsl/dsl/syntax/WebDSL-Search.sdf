module WebDSL-Search

imports
	WebDSL-Lexical
	
exports
	sorts Definition Annotation
	
	context-free syntax
		
	SearchConfig 			-> Definition
	
	DEFAULT? "searchconfig" Id "{" SearchConfigBody "}" 	-> SearchConfig{cons("SearchConfig")}
	
	CharFilter* Tokenizer TokenFilter*	-> SearchConfigBody{cons("SearchConfigBody")}
	
	"charfilter" "=" CHARFILTERNAME "(" {Argument ","}* ")"	-> CharFilter{cons("CharFilter")}
	"charfilter" "=" CHARFILTERNAME							-> CharFilter{cons("CharFilterNoArgs")}
	"tokenizer" "=" TOKENIZERNAME "(" {Argument ","}* ")"	-> Tokenizer{cons("Tokenizer")}
	"tokenizer" "=" TOKENIZERNAME 							-> Tokenizer{cons("TokenizerNoArgs")}
	"tokenfilter" "=" TOKENFILTERNAME "(" {Argument ","}* ")"	-> TokenFilter{cons("TokenFilter")}
	"tokenfilter" "=" TOKENFILTERNAME							-> TokenFilter{cons("TokenFilterNoArgs")}
	
	
	
	Id "=" String						-> Argument{cons("Argument")}
	
	Id	-> CHARFILTERNAME
	Id	-> TOKENIZERNAME
	Id	-> TOKENFILTERNAME
		
    context-free syntax
    	
    %%searchable without params is left as SimpleAnno, but desugared to SearchableAnno,
    %%because "searchable" won't get rejected as Id (sdf strangeness).
    "searchable"							-> SearchableAnno {cons("SearchableAnno"), prefer}
    "searchable" "(" {SA-Argument ","}* ")"	-> SearchableAnno {cons("SearchableAnno")}
    SearchableAnno	"~" Float				-> Annotation {cons("SearchableAnnoBoost")}
    SearchableAnno							-> Annotation
    
    SA-Key "=" SA-Value						-> SA-Argument{cons("SA-Argument")}
    
  	lexical syntax
    "analyzer" 	-> SA-Key
    "name" 		-> SA-Key
    "default"	-> DEFAULT
    Id 			-> SA-Value
    Float		-> SA-Value
    