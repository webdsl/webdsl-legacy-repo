module org/webdsl/dsl/languages/data-model/constraints

imports
  libstrategolib

imports
  libwebdsl-front

signature constructors
  
  EntityOfProperty : Term -> Term

rules

  constraint-error-global =
      all-keys-EntDecl
    ; map(bagof-EntDecl)
    ; concat
    ; try(constraint-double-decls(
        get-entity-def; Fst; lower-case
      , {
            Snd; get-entity-def
          ; Fst => name
          ; rules(EntityDeclaredTwice :+ name -> name)
          ; !["Entity '", name, "' is defined multiple times."]
        }
    ))
    // only check properties for entities which are not defined multiple times
    ; all-keys-EntDecl; remove-all(EntityDeclaredTwice)
    ; filter(constraint-error-global-nondouble-entities; fatal-err(|"INTERNAL ERROR: Rule should fail"))
    ; fail
  
  constraint-error-data =
    (?ent@Entity(x_id, _, entbodydecs) <+ ?ent@EntityNoSuper(x_id, entbodydecs) <+ ?ent@SessionEntity(x_id, entbodydecs))
    ; names := <map(get-property-name)> entbodydecs
    ; <filter(try(check-with-procedures(|ent)))> names
    ; fail

  check-with-procedures(|ent) : 
    name -> <add-error(|["Property name and procedure name coincide: ", name])> ent
    where <IsProcedure> name
    
  constraint-error-data :
    Entity(x_class, s, _) -> <add-error(|["Super entity ", <pp-webdsl> s, " for ", x_class, " does not exist."])>
    where not(<typecheck-supertype> s)

  typecheck-supertype: x_class -> x_class
    where IsEntity <+ ?"Object"

  constraint-error-data =
    (  ?DerivedProperty(x, _, s, _, e)
    <+ ?DerivedPropertyNoAnno(x, _, s, e) )
    ; where(
        te := <type-of> e
      )
      ; not(<type-compatible> (te, s))
      ; add-error(|["The expression of the derived property ", x, " should have type ", <pp-webdsl> s])

  constraint-error-data :
    InverseAnno(ent, fld) -> <add-error(|["The entity ", ent, " does not exist"])>
    where not(<IsEntity> ent)

  constraint-error-data :
    InverseAnno(ent, fld) -> <add-error(|["The field ", ent, ".", fld, " does not exist"])>
    where not(<type-of-property> (ent, fld))

  constraint-error-data :
    InverseAnno(ent, fld) -> <add-error(|["Inverse annotations cannot be declared on both sides. Remove either the (inverse=", ent, ".", fld, ") or the (inverse=", i_ent, ".", i_fld, ") annotation"])>
    where [inverse_prop] := <filter(?Property(fld, _, _, annos))> <Properties> ent
        ; not([] := <filter(?InverseAnno(i_ent, i_fld))> annos)

  constraint-error-data :
    InverseAnno(ent, fld) -> <add-error(|["In a many-to-one bidirectional association the inverse annotation should be declared on the many side. (inverse=", i_ent, ".", i_fld, ")"])>
    where <filter(?Property(fld, _, _, annos))> <Properties> ent
        ; [InverseSlaveAnno(i_ent, i_fld)] := <filter(?InverseSlaveAnno(_, _))> annos
        ; SimpleSort(_) := <type-of-property> (ent, fld)
        ; GenericSort(_, _) := <type-of-property> (i_ent, i_fld)
  
/**
 * Check inverse annotations for
 * - type-compatibility between srt2 and e2
 * - type-compatibility between srt1 and e1
 *
 * Code example
 *   entity e1 {
 *     instance2 -> srt2 (inverse=e2.instance1)
 *   }
 *   entity e2 {
 *     instance1 -> srt1
 *   }
 */
  // check all properties in the context of an entity. This is necessary for the inverse check on attribute type
  constraint-error-data =
    (  ?Entity(ent1, _, entbodydecs) 
    <+ ?EntityNoSuper(ent1, entbodydecs) 
    <+ ?ExtendEntity(ent1, entbodydecs)  )
    ; where (
        <filter(check-property-inverse-annos(|ent1))> entbodydecs
      )
    ; fail
  
  // takes care of different constructor types of properties
  check-property-inverse-annos(|ent1) =
    (?p@Property(_, proptype, srt2, annos) <+ ?p@DerivedProperty(_, proptype, srt2, annos, _))
    ; (   <check-entity-type-inverse-annos(|ent1, srt2, annos, proptype)> p
       <+ <check-property-inverse-annos(|ent1, srt2, annos)> p
      )

  // check that inverse is declared on entity type properties
  check-entity-type-inverse-annos(|ent1, srt2, annos, proptype) :
    p -> <add-error(|["Inverse is only allowed on reference type properties."])>
    where <fetch(?InverseAnno(ent2, fld2))> annos
        ; not(<?Ref()> proptype)  
        
  // check type-compatibility of inverse
  check-property-inverse-annos(|ent1, srt2, annos) :
    p -> <add-error(|["Inverse not allowed between types ", <pp-webdsl> srt2, " and ", <pp-webdsl> type_other_side, " (inverse property ",ent2, ".", fld2, ")."])>
    where <fetch(?InverseAnno(ent2, fld2))> annos
        ; type_other_side := <TypeOfProperty> (ent2,fld2)
        ; not( <inverse-compatible> (SimpleSort(ent1), SimpleSort(ent2), srt2, type_other_side) )
      
  /**
   *  (e1,e2,srt2,srt1)
   */
  
  inverse-compatible = ?(srt1, srt2, srt2, srt1)
  
  inverse-compatible = ?(srt1, srt2, GenericSort("Set", [srt2]), srt1)
  inverse-compatible = ?(srt1, srt2, srt2, GenericSort("Set", [srt1]))
  inverse-compatible = ?(srt1, srt2, GenericSort("Set", [srt2]), GenericSort("Set", [srt1]))
  
  inverse-compatible = ?(srt1, srt2, GenericSort("List", [srt2]), srt1)
  inverse-compatible = ?(srt1, srt2, srt2, GenericSort("List", [srt1]))
  
  constraint-error-data =
    (  ?Property(x, propkind, srt, _)
    <+ ?PropertyNoAnno(x, propkind, srt)
    <+ ?DerivedProperty(x, propkind, srt, _, _)
    <+ ?DerivedPropertyNoAnno(x, propkind, srt, _) )
    ; where(
           check-no-null-attribute(|x, srt)          // check for wrong attribute types
        <+ check-no-void-attribute(|x, srt) 
        <+ check-simple-propkind(|propkind, srt)    // check for incompatible propkinds, such as :: Set<User> (which should be -> Set<User>)
        <+ check-complex-propkind(|propkind, srt)
        <+ check-builtin-property(|x)
        <+ check-forbidden-property(|x)
      )
    ; fail
      
  check-builtin-property(|x): prop -> <add-error(|["Cannot override the builtin property '",x,"'"])>
    where "id" := x <+ "version" := x
    
  check-forbidden-property(|x): prop -> <add-error(|["Cannot use the reserved property name '",x,"'"])>
    where "class" := x
  
  check-no-null-attribute(|x, srt) :
    _ -> <add-error(|["Attribute type Null is not allowed in attribute ", <pp-webdsl> x])>
    where srt := SimpleSort("Null")

  check-no-void-attribute(|x, srt) :
    _ -> <add-error(|["Attribute type Void is not allowed in attribute ", <pp-webdsl> x])>
    where srt := SimpleSort("Void")
    
  check-simple-propkind(|propkind, srt) :
    _ -> <add-error(|["Expected: Simple type. Encountered: ", <pp-webdsl> srt])>
    where <is-webdsl-type> srt
    where not(<is-simple-sort> srt)
        ; Simple() := propkind

  check-complex-propkind(|propkind, srt) :
    _ -> <add-error(|["Expected: Reference type or Composite type. Encountered: ", <pp-webdsl> srt])>
    where <is-webdsl-type> srt
    where <?Ref() <+ ?Comp()> propkind
        ; <is-simple-sort> srt
    
  check-complex-propkind(|propkind, srt) :
    _ -> <add-error(|["Expected: collection of Entity types. Encountered: ", <pp-webdsl> srt])>
    where <is-webdsl-type> srt
    where <?GenericSort(_, [x])> srt
        ; <is-simple-sort> x
      
/*  constraint-error-data =
    (?Property(_, Simple, srt, _) <+ ?DerivedProperty(_, Simple, srt, _, _)); <check-propkind> srt

  check-propkind-simple :
    srt -> <add-error(|["Expecting simple type, encountered ", <pp-webdsl> srt])>
    where not(<is-simple-type> srt)
*/    

  constraint-error-data : 
  p@Property(_, _, srt, annos) -> <add-error(|["Inverse between lists not allowed"])>
  where GenericSort("List",_) := srt
      ; <fetch(?InverseAnno(ent, fld))> annos
      ; GenericSort("List", _) := <type-of-property> (ent, fld)
      
rules //check for illegal entity names; built-ins are reserved

  constraint-error-data =
    (  ?Entity(x, _, _) 
    <+ ?EntityNoSuper(x, _) 
    <+ ?SessionEntity(<capitalize-string;?x>, _)  
    )
    ; where (reserved-type-constraint-error(|x))

  reserved-type-constraint-error(|entname) :
    x -> <add-error(|["Entity name: \"",entname,"\" is not allowed"])>
    where <is-simple-sort> SimpleSort(entname)
       <+ <reserved-entity-name> entname

rules //assignment to derived property is not allowed
  
  constraint-error:
    Assignment(FieldAccess(e1,prop),e2) -> <add-error(|["Assignment to derived property is not allowed."])>
    where  SimpleSort(x) := <type-of> e1
        ;  <is-derived-property> (x,<strip-annos> prop)
  
  constraint-error:
    Assignment(Var(prop), e2) -> <add-error(|["Assignment to derived property is not allowed."])>
    where x := <IsEntPropGetEntName> prop
        ; <is-derived-property> (x,<strip-annos> prop)
  
  constraint-error-templatecall(|p,arg*) :
    _ -> <add-error(|["Derived property is not allowed in 'input'."])>
    where "input" := p
        ; FieldAccess(e1,prop) := <Hd> arg*
        ; SimpleSort(x) := <type-of> e1
        ; <is-derived-property> (x,<strip-annos> prop)
  
  constraint-error:
    ObjectCreation(SimpleSort(x_class), objectpropassign*) -> <fail>
    where <map(try(constraint-error-object-prop-derived(|x_class)))> objectpropassign* 
    
  constraint-error-object-prop-derived(|x_class):
    ObjectPropertyAssignment(prop,_) -> <add-error(|["Assignment to derived property is not allowed."])>
    where <is-derived-property> (x_class,<strip-annos> prop)

rules //subclassing the entity itself
  
  constraint-error =
    get-entity-class-name
  ; ?x_class
  ; <check-entity-extends-itself(|x_class)> <Extends> x_class
    
  check-entity-extends-itself(|x_class):  
    x -> <add-error(|["Entity may not inherit from itself."])> x_class
    where <?x> x_class
    
  check-entity-extends-itself(|x_class):  
    x -> <check-entity-extends-itself(|x_class)> <Extends> x
    where not(<?x> x_class)
    where not(<?x> "Entity") // in case the application contains an incorrect 'entity Entity' (catched by another check, but shouldn't cause this to loop)
            