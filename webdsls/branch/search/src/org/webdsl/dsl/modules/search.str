module org/webdsl/dsl/modules/search

imports
  libstrategolib
  libwebdsl-front

strategies

  // Do after normal declare; we now know whether there is a searchable property is an extend entity
  declare-override = all-keys-EntDecl; filter(declare-search-functions); fail
  
  declare-search-functions: x_class -> x_class
    where <IndexedEntity> x_class
    with  x_fun := <concat-strings> ["search", x_class]
        ; <declare-static-function(|x_class,x_fun)> fun |[ function x_fun(query : String) : List<x_class> {} ]|
        ; <declare-static-function(|x_class,x_fun)> fun |[ function x_fun(query : String, limit : Int) : List<x_class> {} ]|
        ; <declare-static-function(|x_class,x_fun)> fun |[ function x_fun(query : String, limit : Int, offset : Int) : List<x_class> {} ]|
        
rules

	add-backend-annotation =
			?ent
		; where(
					(x_class, body) := <get-entity-def> ent
				; <has-no-anno(?IndexedAnno(_))> ent
				;	props := <all-properties> x_class
				; searchable := <filter(searchable-property-to-name); flatten-list; uniq> props
				; not([] := searchable)
			)
		; add-anno(|IndexedAnno(searchable))
		
	searchable-property-to-name :
    Property(name, propkind, _, anno*) -> name
    where not([] := <filter(?SimpleAnno("searchable"))> anno*)
    ; not (<?Ref()<+?Comp() > propkind)
      
    searchable-property-to-name :
    Property(name, propkind, srt, anno*) -> embeddedNames
    where not([] := <filter(?SimpleAnno("searchable"))> anno*)
    ; <?Ref()<+?Comp() > propkind
    // 1 level of depth right now, so only simple types are supported
    // TODO: all-properties does not return desugared version of properties, what to use? 
    with embeddedSearchable :=  <srt-to-type; all-properties; filter(is-simple-prop);filter(searchable-property-to-name); uniq> srt
    ; embeddedNames := <map(embedded-name(|name))> embeddedSearchable

  searchable-property-to-name :
    DerivedProperty(name, _, _, anno*, _) -> name
    where not([] := <filter(?SimpleAnno("searchable"))> anno*)
    
  is-simple-prop :
  	p@Property(_, propkind, _, _) -> p
  	where not (<?Ref()> propkind)
  
  srt-to-type:
  	GenericSort(_,[SimpleSort(type)]) -> type
  
  srt-to-type:
  	SimpleSort(type) -> type
  
  embedded-name(|prefix) :
  propname -> <concat-strings> [prefix, ".", propname] 
  	
