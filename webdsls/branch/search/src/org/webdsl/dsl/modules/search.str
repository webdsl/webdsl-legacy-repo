module org/webdsl/dsl/modules/search

imports
  libstrategolib
  libwebdsl-front

strategies

  // Do after normal declare; we now know whether there is a searchable property is an extend entity
  declare-override = all-keys-EntDecl; filter(declare-search-functions); fail
  
  declare-search-functions: x_class -> x_class
    where <IndexedEntity> x_class
    with  x_fun := <concat-strings> ["search", x_class]
        ; <declare-static-function(|x_class,x_fun)> fun |[ function x_fun(query : String) : List<x_class> {} ]|
        ; <declare-static-function(|x_class,x_fun)> fun |[ function x_fun(query : String, limit : Int) : List<x_class> {} ]|
        ; <declare-static-function(|x_class,x_fun)> fun |[ function x_fun(query : String, limit : Int, offset : Int) : List<x_class> {} ]|
        
rules

	add-backend-annotation =
			?ent
		; where(
		  	    (x_class, body) := <get-entity-def> ent
				; <has-no-anno(?IndexedAnno(_,_,_))> ent
       			; ourprops := <filter(is-property-cons)> body
				; searchable := <filter(searchable-property-to-name(|x_class)); flatten-list; uniq> ourprops
				; not([] := searchable)
				; ngramfields := <concat; flatten-list; uniq>[<bagof-NGramFields>x_class,<bagof-NGramFieldsEmbedded>x_class]
				; untokenizedfields := <concat; flatten-list; uniq>[<bagof-UntokenizedFields>x_class,<bagof-UntokenizedFieldsEmbedded>x_class] 
			)
		; add-anno(|IndexedAnno(searchable,ngramfields,untokenizedfields))
		
	searchable-property-to-name(|x_class) :
	    Property(name, propkind, _, anno*) -> names
	    where not (<?Ref()<+?Comp() > propkind)
	    	; searchable-annos := <filter(?SearchableAnno(_))> anno*
	    	; not(?[])
	    with names := <map(name-from-searchable-anno)> searchable-annos
	    	; <map(try(record-special-fields(|x_class)))> searchable-annos
	    	  
    record-special-fields(|x_class):
    	s@SearchableAnno(sa-args) -> s
    	where <fetch(?SA-Argument("analyzer", analyzer-name))> sa-args
    	; field-name := <name-from-searchable-anno> s
    	; if (<UsesNGramFilter> analyzer-name) then rules (NGramFields : x_class -> field-name) end
    	; if (<?"no" <+ ?"null"> analyzer-name) then rules (UntokenizedFields : x_class -> field-name) end
    
    searchable-property-to-name(|x_class) :
	    Property(name, propkind, srt, anno*) -> embeddedNames
	    where (<?Ref()<+?Comp() > propkind; <fetch(?SearchableAnno(_))> anno*)
	    // 1 level of depth right now, so only simple types are supported
	    // TODO: all-properties does not return desugared version of properties, what to use? 
	    with embeddedType := <srt-to-type> srt
	    ; embeddedSearchable :=  <all-properties; desugar-top ; filter(is-simple-prop);filter(searchable-property-to-name(|embeddedType)); flatten-list; uniq> embeddedType
	    ; embeddedNames := <map(embedded-name(|name))> embeddedSearchable
	    ; embeddedNGramFields :=  <bagof-NGramFields; map(embedded-name(|name))> (<srt-to-type>srt)
	    ; <map(embeddedName:= <id>;rules(NGramFieldsEmbedded : x_class -> embeddedName))> embeddedNGramFields
	    ; embeddedUntokenizedFields := <bagof-UntokenizedFields; map(embedded-name(|name))> (<srt-to-type>srt)	    
		; <map(embeddedName:= <id>;rules(UntokenizedFieldsEmbedded : x_class -> embeddedName))> embeddedNGramFields

    name-from-searchable-anno :
    	SearchableAnno(sa-args) -> field-name
    	with <fetch(?SA-Argument("name", field-name))> sa-args 
    	
  searchable-property-to-name(|x_class) :
    DerivedProperty(name, _, _, anno*, _) -> name
    where (is-searchable-prop)
  
  is-simple-prop :
  	p@Property(_, propkind, _, _) -> p
  	where not (<?Ref()> propkind)
  
  srt-to-type:
  	GenericSort(_,[SimpleSort(type)]) -> type
  
  srt-to-type:
  	SimpleSort(type) -> type
  
  embedded-name(|prefix) :
  propname -> <concat-strings> [prefix, ".", propname]
