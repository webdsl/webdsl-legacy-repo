module org/webdsl/dsl/modules/search

imports
  libstrategolib
  libwebdsl-front

strategies

  // Do after normal declare; we now know whether there is a searchable property is an extend entity
  declare-override = all-keys-EntDecl; filter(declare-search-functions); fail
  
  declare-search-functions: x_class -> x_class
    where <IndexedEntity> x_class
    with  x_fun := <concat-strings> ["search", x_class]
        ; <declare-static-function(|x_class,x_fun)> fun |[ function x_fun(query : String) : List<x_class> {} ]|
        ; <declare-static-function(|x_class,x_fun)> fun |[ function x_fun(query : String, limit : Int) : List<x_class> {} ]|
        ; <declare-static-function(|x_class,x_fun)> fun |[ function x_fun(query : String, limit : Int, offset : Int) : List<x_class> {} ]|
        
rules

	add-backend-annotation =
			?ent
		; where(
		  	    (x_class, body) := <get-entity-def> ent
				; <has-no-anno(?IndexedAnno(_,_,_))> ent
       			; props := <filter(is-property-cons)> body
       			  //Get super properties, redundant desugaring for now (all-properties returns untouched props)
       			; if not("Entity" := <Extends> x_class)
       			  then ourprops := <concat> [props, <Extends;all-properties; desugar-top> x_class]
       			  else ourprops := props end       			  
				; searchable := <filter(searchable-property-to-name(|x_class)); flatten-list; uniq> ourprops
				; not([] := searchable)
				; untokenizedfields := <bagof-UntokenizedFields;uniq>x_class
				; lucenesorttypes := <map(fieldname-to-lucene-sort-type(|x_class))> untokenizedfields
			)
		; add-anno(|IndexedAnno(searchable,untokenizedfields,lucenesorttypes))

	fieldname-to-lucene-sort-type(|x_class):
		fieldname -> lst
		with
			lst := <fieldNameToType; to-lucene-sort-type <+ to-lucene-default-sort-type> (x_class, fieldname)
	    	  
    record-untokenized-fields(|x_class):
    	s@SearchableAnno(sa-args) -> field-name
    	where <fetch(?SA-Argument("analyzer", analyzer-name))> sa-args
    	; <?"no" <+ ?"null"> analyzer-name
    	; field-name := <name-from-searchable-anno> s
    	; <record-untokenized-field>(x_class, field-name)
    
    record-untokenized-field:
    	a@(x_class, field-name) -> a 
    	with rules(UntokenizedFields :+ x_class -> field-name)
    	
	record-field-name-to-type(|x_class, embedded_type):
		q@(fieldName, embedded_fieldName) -> q
		with type := <fieldNameToType> (embedded_type, fieldName)
		; rules(fieldNameToType :+ (x_class, embedded_fieldName) -> type)
    
    searchable-property-to-name(|x_class) :
	    Property(name, propkind, srt, anno*) -> names
	    where not (<?Ref()<+?Comp() > propkind)
	    ; searchable-annos := <filter(?SearchableAnno(_))> anno*
	    ; not(?[])
	    with names := <map(name-from-searchable-anno)> searchable-annos
	    ; untokenizedFields := <filter(record-untokenized-fields(|x_class))> searchable-annos
	    ; tp := <srt-to-type> srt
	    ; <map(fieldname := <id>; rules(fieldNameToType :+ (x_class, fieldname) -> tp))> untokenizedFields 
    
    searchable-property-to-name(|x_class) :
	    Property(name, propkind, srt, anno*) -> embeddedNames
	    where (<?Ref()<+?Comp() > propkind; <fetch(?SearchableAnno(_))> anno*)
	    // 1 level of depth right now, so only simple types are supported
	    // TODO: all-properties does not return desugared version of properties, what to use? 
	    with embeddedType := <srt-to-type> srt
	    ; embeddedSearchable :=  <all-properties; desugar-top ; filter(is-simple-prop);filter(searchable-property-to-name(|embeddedType)); flatten-list; uniq> embeddedType
	    ; embeddedNames := <map(embedded-name(|name))> embeddedSearchable
	    ; embeddedUntokenizedFields := <bagof-UntokenizedFields; map(embedded-name(|name))> embeddedType   
		; <map(embeddedName2:= <id>; <record-untokenized-field>(x_class, embeddedName2))> embeddedUntokenizedFields
		; <zip(record-field-name-to-type(|x_class,embeddedType))> ( <bagof-UntokenizedFields> embeddedType , embeddedUntokenizedFields )
		  
  	searchable-property-to-name(|x_class) :
    	DerivedProperty(name, propkind, srt, anno*, _) -> name
    	where not (<?Ref()<+?Comp() > propkind)
	    ; searchable-annos := <filter(?SearchableAnno(_))> anno*
	    ; not(?[])
	    with names := <map(name-from-searchable-anno)> searchable-annos
	    ; untokenizedFields := <filter(record-untokenized-fields(|x_class))> searchable-annos
	    ; tp := <srt-to-type> srt
	    ; <map(fieldname := <id>; rules(fieldNameToType :+ (x_class, fieldname) -> tp))> untokenizedFields 

  	searchable-property-to-name(|x_class) :
	    DerivedProperty(name, propkind, srt, anno*, _) -> embeddedNames
	    where (<?Ref()<+?Comp() > propkind; <fetch(?SearchableAnno(_))> anno*)
	    // 1 level of depth right now, so only simple types are supported
	    // TODO: all-properties does not return desugared version of properties, what to use? 
	    with embeddedType := <srt-to-type> srt
	    ; embeddedSearchable :=  <all-properties; desugar-top ; filter(is-simple-prop);filter(searchable-property-to-name(|embeddedType)); flatten-list; uniq> embeddedType
	    ; embeddedNames := <map(embedded-name(|name))> embeddedSearchable
	    ; embeddedUntokenizedFields := <bagof-UntokenizedFields; map(embedded-name(|name))> embeddedType   
		; <map(embeddedName2:= <id>; <record-untokenized-field>(x_class, embeddedName2))> embeddedUntokenizedFields
		; <zip(record-field-name-to-type(|x_class,embeddedType))> ( <bagof-UntokenizedFields> embeddedType , embeddedUntokenizedFields )

    name-from-searchable-anno :
    	SearchableAnno(sa-args) -> field-name
    	with <fetch(?SA-Argument("name", field-name))> sa-args 

  to-lucene-sort-type: "Int" -> "INT"
  to-lucene-sort-type: "Float" -> "FLOAT"
  to-lucene-default-sort-type: _ -> "STRING"
  	  
  is-simple-prop :
  	p@Property(_, propkind, _, _) -> p
  	where not (<?Ref()> propkind)
  
  srt-to-type:
  	GenericSort(_,[SimpleSort(type)]) -> type
  
  srt-to-type:
  	SimpleSort(type) -> type
  
  embedded-name(|prefix) :
  propname -> <concat-strings> [prefix, ".", propname]
