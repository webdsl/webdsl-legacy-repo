module org/webdsl/dsl/languages/action/typechecker/declare

imports
  libwebdsl-front
  org/webdsl/dsl/generation/webdsl-generator

strategies

// TODO: function resolving is now done for each type-of call and again in aggregate-and-combine-functions.
//        Result can be stored (annotation?).

  declare-function(|x_class) =
    ?ExtendFunction(_)

  normalize-declare: FunctionNoReturn(f, args, body) -> Function(f, args, SimpleSort("Void"), body)
  
  declare-function(|x_class): f@FunctionNoReturn(_,_,_) -> f
    with  f2 := <with-origin(normalize-declare)> f
        ; <declare-function(|x_class)> f2

  // callee can be a SimpleSort(x_entity) or ClassSort(x_native_class) 
  CheckFunctionSignature: p@(callee, f, t*) -> s
    where resolve-function-call-to-decl; ?Function(_,_, s, _)
        
  declare-function(|x_class) =
    ?def@Function(f, args, sort, _)
    ; with(id
      ; t1* := <map(?Arg(_,<id>))> args
      ; rules( CheckFunctionSignatureArgumentTypes :+
                    (SimpleSort(x_class), f, t2*) -> t1*
                       where <zip(type-compatible)> (t1*, t2*)
               EntityFunctionDecl :+ (x_class, f, t1*) -> def
             )
      )
      
  normalize-declare: PredicateInEntity(name,args,body) -> Function(name,args,SimpleSort("Bool"),[])
      
  declare-function(|x_class) :
    p@PredicateInEntity(name,args,body) -> p
    with f := <with-origin(normalize-declare)> p
       ; <declare-function(|x_class)> f

  declare-action = declare-global-func

  CheckGlobalFunctionSignature: p@(None(), fname, t*) -> s
    where resolve-function-call-to-decl; ?Function(_,_, s, _)
        
  declare-global-func = where (
    ?decl@Function(f, args, s, b)//;<debug(!"DECLARE")> (f,args,s)
    //  ; t1* := <map(?Arg(<type-of>,_))> args // type-of of name will get converted type: RefSort(srt) -> srt{IsRefSort}   // @TODO doesn't work atm, some function args are not renamed yet    
    ; t1* := <map(?Arg(_,<id>))> args
    ; t1refsortstripped* := <map(strip-ref-sort)> t1* //ref arg not used in overload resolution
    ; rules(FunctionDecl :+ (f, t1*) -> decl) 
    ; f2 := f
    ; rules ( 
              CheckGlobalFunctionSignatureArgumentTypes :+ (None(), f2, t2*) -> t1* // TODO: Mapping of FunctionCall() to Function using this info
                       where <zip(type-compatible)> (t1refsortstripped*, t2*)
              IsGlobalFunctionSignature : (f, t1*)
              IsGlobalFunction : (f, args, s)
              IsGlobalFunction : f
              GlobalFunctionArgs : f -> args
      )
    ; if None() := b then
        rules ( IsNativeFunction : f )
      end
    )

  declare-global-func = ?ef@ExtendFunction(_)
      // no declare, but save for constraints
    ; rules(ExtendGlobalFunctions :+= ef)

  normalize-declare: NativeFunction(fname, args, s) -> Function(fname, args, s, None())
  
  declare-global-func = 
    ?FunctionNoReturn(_,_,_); declare-normalized

  declare-global-func =
    ?NativeFunction(_,_,_); declare-normalized
    
  // Do not go into an init action; otherwise the definitions will be declared globally
  declare-action = ?InitAction(_)
  declare-action = ?DataBindAction(_)
  declare-action = ?ValidateAction(_)
  declare-action = ?RenderAction(_)
  
/**
 * static entity methods
 */
rules
  
  eq-type-of :
    Var(e) -> EntitySort(e)
    where <IsEntity> e
  
rules 
  
  normalize-declare: StaticEntityFunction(f, args, ReturnType(r), body) -> Function(f, args, r, body)
  
  declare-function(|x_class): f@StaticEntityFunction(_,_,_,_) -> f
    with  f2 := <with-origin(normalize-declare)> f
        ; <declare-function(|x_class)> f2
        ; <declare-static-function(|x_class)> f2
        
  declare-static-function(|x_class) =
    ?def@Function(f, args, sort, _)
    ; with(id
      ; t1* := <map(?Arg(_,<id>))> args
      ; rules( CheckFunctionSignatureArgumentTypesStatic :+
                    (EntitySort(x_class), f, t2*) -> t1*
                       where <zip(type-compatible)> (t1*, t2*)
               EntityFunctionDeclStatic :+ (x_class, f, t1*) -> def
             )
      ) 
      