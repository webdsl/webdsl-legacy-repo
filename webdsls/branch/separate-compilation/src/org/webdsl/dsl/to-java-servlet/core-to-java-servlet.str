module org/webdsl/dsl/to-java-servlet/core-to-java-servlet

imports
  libwebdsl-front
  
imports
  org/webdsl/dsl/to-java-servlet/-
  org/webdsl/dsl/to-java-servlet/types/-
  org/webdsl/dsl/to-java-servlet/uicomponents/-
  org/webdsl/dsl/to-java-servlet/ajax/- 
  org/webdsl/dsl/to-java-servlet/email/-
  org/webdsl/dsl/to-java-servlet/stratego-interface/-
  org/webdsl/dsl/to-java-servlet/data-validation/-
  org/webdsl/dsl/to-java-servlet/test/-
  org/webdsl/dsl/to-java-servlet/debug/-
  org/webdsl/dsl/to-java-servlet/native/-
  libback-end-transformations

imports		// local generation
  libjava-transformations
  libwrite-files

strategies

  set-DomainPackage(|pkg) = rules( DomainPackage := pkg )
  
  core-to-java-servlet(|qid) =
      prepare-core-to-java-servlet(|qid)
    ; log-time(not(generate-code-java-servlet-once) |"generate-code-java-servlet-once")
    ; log-time(generate-code-java-servlet      |"generate-code-java-servlet")
    ; transform-java-code
    
  transform-java-code =
    where(  pkgname1 := <TemplatePackage>
          ; pkgname2 := <DomainPackage>
          ; pkgname3 := <ActionPackage>
          ; pkgname4 := <TestPackage>)
  ; <flatten-list>
      [  <log-time(bagof-JavaClassesToEmit; get-java-artifacts-java-servlet | "get-java-artifacts")>
       , <log-time(get-web-xml                    |"get-web-xml")>
       , JavaFile([<GeneratedOutputDir>], compilation-unit|[package pkgname2 ; public class Force_Domain_Package_Creation {} ]|) 
       , JavaFile([<GeneratedOutputDir>], compilation-unit|[package pkgname3 ; public class Force_Action_Package_Creation {} ]|)                   
       , JavaFile([<GeneratedOutputDir>], compilation-unit|[package pkgname4 ; public class Force_Test_Package_Creation {} ]|)                   
      ]
  
  get-web-xml =
    WebXMLToEmit
  
  prepare-core-to-java-servlet(|qid) =
    where(
        rules(
          Package         := <qid-to-package-name> qid        
          TemplatePackage := <qid-to-package-name> Qualified(qid, "templates")
          ActionPackage   := <qid-to-package-name> Qualified(qid, "actions")
          TestPackage     := <qid-to-package-name> Qualified(qid, "test")
          FunctionPackage := <qid-to-package-name> Qualified(qid, "functions")
        )
      ; set-DomainPackage(|<qid-to-package-name> Qualified(qid, "domain")) //strategy/rule shared with seam back-end
    )
    ; annotate-pagecalls
    ; log-time(get-all-top-level-template-names|"get-all-top-level-template-names") //TODO should be available in a dynamic rule somewhere
    ; is-logging-of-ac-principle-possible
      
  is-logging-of-ac-principle-possible =
    try(oncetd(\e@EntityNoSuper("RequestLogEntry",body) -> e where <oncetd(?Property("principal",_,_,_))> body; rules( ACPrincipalAvailable := True() ) \))

  generate-code-java-servlet =
    ?def@Define(mods, name, args, targs, elems) ;
      {| ThisEmail, JavaThisPage, ThisTemplateName,ThisTemplateClassName, Variables, TemplateFormalArguments, ThisAjaxTemplateName: //Variables: to hold arguments/variables of parent templates/pages
          with (
              if ThisTemplateName   then debug(!"\nERROR: inline local template found in back-end, should have been desugared:\n");<exit> 1 end
            ; if <fetch(Page)>  mods then rules ( JavaThisPage := name ) end
            ; if <fetch(Email)> mods then rules ( ThisEmail := name ) end
            ; if <fetch(AjaxTemplate)> mods then rules ( ThisAjaxTemplateName := name ) end
            ; rules ( 
              ThisTemplateName := name
              ThisTemplateClassName := <get-template-class-name> def
              //TemplateFormalArguments := args
            )
            // generate if: nested templates (no caching), or cache miss
            ; if not(CachingEnabled) <+ not(check-cache-equality(|name)) then
                scope-local-emit(
                  annotate-with-unique-element-ids
                ; log-time(not(GenerateCodeJavaServlet)|"generate code define")
                ; all(generate-code-java-servlet)
                | name
                )
              end
          )
       |}
   <+(?Action(_, _, _) <+ ?InitAction(_) <+ ?DataBindAction(_)) ;
         {| InAction, Variables:
           rules ( InAction := True() )
         ; log-time(not(GenerateCodeJavaServlet)|"generate code action")
         ; all(generate-code-java-servlet)
         |}
   <+?Function(_,_,_,_) /*;  handled with dynamic rule that holds all functions
         {| Variables://InFunction, Variables:
           //rules ( InFunction := <id> )
           not(GenerateCodeJavaServlet)
         ; all(generate-code-java-servlet)
         |}*/
   <+(?Entity(ent_name,_,_)<+?SessionEntity(ent_name,_)<+?EntityNoSuper(ent_name,_)) ;
         {| JavaInEntity:
           rules ( JavaInEntity := <id> )
         ; if not(CachingEnabled) <+ not(check-cache-equality(get-entity-def; ?(<id>,_))) then
             scope-local-emit(
               log-time(not(GenerateCodeJavaServlet)|"generate code entity")
               ; all(generate-code-java-servlet)
               | ent_name
             )
           end
         |}
   <+ ?LocalRedefine(_,_,_,_,_); //avoid page code generation for Arg constructors in LocalRedefine
       {| InLocalRedefine:
           rules ( InLocalRedefine := True() )
         ; log-time(not(GenerateCodeJavaServlet)|"generate code local redefine")
         ; all(generate-code-java-servlet)
         |}
   <+{?el@elem|[ var x : srt := e ]|
         ; where(<elem> (el,<bagof-AllGlobalVars>))}
   <+      log-time(not(GenerateCodeJavaServlet)|"generate code other")
         ; all(generate-code-java-servlet)

// some helping annotations to create uniqueness among the static elements

signature
  constructors
    TemplateCallNumber : String -> Annotation
    FormNumber : String -> Annotation
    InputNumber : String -> Annotation
    ActionNumber : String -> Annotation //action calls/actionLink
    TemplateClassName : String -> Annotation
    RefArgClassNameFirstPart : String -> Annotation
    RefArgClassNameSecondPart : String -> Annotation
   /* ActionClassName : String -> Annotation*/
        
rules

  get-templatecallnumber :
    _{anno*} -> compid
    where TemplateCallNumber(compid) := <collect(?TemplateCallNumber(_));Hd> anno*
 
  get-formnumber :
    _{anno*} -> compid
    where FormNumber(compid) := <collect(?FormNumber(_));Hd> anno* 
    
  get-inputnumber :
    _{anno*} -> compid
    where InputNumber(compid) := <collect(?InputNumber(_));Hd> anno* 
    
  get-actionnumber :
    _{anno*} -> compid
    where ActionNumber(compid) := <collect(?ActionNumber(_));Hd> anno* 
    
  get-refargclassname-first :
    _{anno*} -> compid
    where RefArgClassNameFirstPart(compid) := <collect(?RefArgClassNameFirstPart(_));Hd> anno* 
  get-refargclassname-second :
    _{anno*} -> compid
    where RefArgClassNameSecondPart(compid) := <collect(?RefArgClassNameSecondPart(_));Hd> anno* 
    
  get-template-class-name :
    _{anno*} -> compid
    where TemplateClassName(compid) := <collect(?TemplateClassName(_));Hd> anno* 
 /*
  get-action-class-name :
    _{anno*} -> compid
    where ActionClassName(compid) := <collect(?ActionClassName(_));Hd> anno* 
   */        

strategies

  annotate-pagecalls = 
    alltd(annotate-pagecall)

rules

  annotate-pagecall:
    Define(a,name,b,c,elems) -> Define(a,name,b,c,elems1)
    with {| ThisTemplateName: 
           rules(ThisTemplateName := name)
         ; elems1 := <alltd(annotate-pagecall)> elems
         |}

  annotate-pagecall :
    PageCall(pagename,arg*){anno*} -> PageCall(pagename,arg1*){anno*} 
    where not("url" := pagename) //TODO url variant of navigate should have different cons
    with  get-anno(?PageArgsAnno(farg*))
        ; farg1* := <add-farg-numbers> farg*
        ; arg1* := <zip(add-ref-arg-class-names(|pagename)<+?(_,<id>))> (farg1*,arg*)
          
  add-ref-arg-class-names(|pagename) :
    (farg{anno*},arg@FieldAccess(_,_){anno1*}) -> result // not for Var since that would be a template var, which is not available through a page or ajax link
    where <?Arg(_,RefSort(_))> farg
        ; not(<has-ref-type> arg)
    with  <fetch(?ArgNumber(argnum))> anno*
        ; first := <gen-page-ref-arg-class-name-first-part> (pagename,argnum)
        ; second := <gen-page-ref-arg-class-name-second-part>
        ; newid := <concat-strings> [first,second]
        ; rules( RefArgClassName :+= newid)
        ; result := arg{RefArgClassNameFirstPart(first),RefArgClassNameSecondPart(second),anno1*}

  /**
   *  first part, used for all calls to this particular argument of the page
   */ 
  gen-page-ref-arg-class-name-first-part : (pagename,argnum) -> <concat-strings> ["RefArg_",pagename,"_",<int-to-string> argnum,"_"]
          
  /**
   *  second part, added in URL, which selects a particular call site (templatename + (pagecall) number in template) to determine the RefArg class to use
   *  ThisTemplateName is unique, so there is no newname overlap with other templates
   *  since these names are used in a global lookup hashmap, otherwise caches can become invalid
   */
  gen-page-ref-arg-class-name-second-part  = <concat-strings;newname> [<ThisTemplateName>,"pc"]
  
  /**
   *  ajax template calls
   */
  annotate-pagecall = annotate-ajaxcall
  
  annotate-ajaxcall :
    TemplateCall(tname,arg*,a,b){anno*} -> TemplateCall(tname,arg1*,a,b){anno*} 
    where get-anno(?CalledTemplateArgs(farg*))
    with  farg1* := <add-farg-numbers> farg*
        ; arg1* := <zip(add-ref-arg-class-names(|tname)<+?(_,<id>))> (farg1*,arg*)
  
strategies

  annotate-with-unique-element-ids = 
    topdown(try(java-servlet-element-id))
    
rules

  java-servlet-element-id :
    tc@TemplateCall(name, args,passign*, _){anno*} -> tc{TemplateCallNumber(newid),anno*} 
    where <get-anno(?CallToDefinedAnno() <+ ?CallToRequiredAnno())> tc
        //; <TemplateSignature <+ LocalTemplateSignature <+ !<strip-annos> name;TemplateWithGenerics> (name,t*)
        ; newid := <newname> "tcall"
    
  java-servlet-element-id :
    tc@TemplateCall("form", attrs,passign*, elems){anno*} -> tc{FormNumber(newid),anno*} 
    where  newid := <newname> "form"
  
  java-servlet-element-id :
    tc@PropertySubmit(_,_){anno*} -> tc{ActionNumber(newid),anno*} 
    where  newid := <newname> "action"
  java-servlet-element-id-template-call : 
    tc -> tc{InputNumber(newid),anno*} 
    with  _{anno*} := tc
        ; newid := <newname> "input" 
    
  get-all-top-level-template-names =
    alltd(register-top-level-template-name)
  register-top-level-template-name = 
    ?tmplt@webdsl|[ define mod* x(farg*)  req*  { elem* } ]|
    ; with(
        // TemplateFormalArguments used in dispatch-servlet.str
          if <fetch(Email)> mod* then rules ( AllEmailNames :+= x ) end
        ; if "errorTemplateInputListString"  := x then rules ( ErrorTemplateInput := tmplt ) end
        ; if "errorTemplateFormListString"   := x then rules ( ErrorTemplateForm := tmplt ) end
        ; if "errorTemplateActionListString" := x then rules ( ErrorTemplateAction := tmplt ) end
        ; if "templateSuccessListString"     := x then rules ( TemplateSuccess := tmplt ) end
      )
    ; !<register-template-name(|True())> tmplt
    
  template-name-to-class-name: name -> $[[name]_Template]
  email-name-to-class-name: name -> $[[name]_Email]
    
  register-template-name(|toplevel)  :
    tc@Define(mod*,x,farg*, targs, elem*) -> Define(mod*,x,farg*, targs, elem1*){TemplateClassName(newid),anno*} 
    with  _{anno*} := tc
        ; if <oncetd(?Email())> mod* then
            newid := <email-name-to-class-name> x
          else
            newid := <template-name-to-class-name> x
          end
        ; elem1* := <alltd(register-template-name(|False()))> elem*
          