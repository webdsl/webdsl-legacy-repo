module org/webdsl/dsl/transformation/desugar

imports
  libstrategolib
  libjava-front

imports
  libwebdsl-front
  org/webdsl/dsl/generation/webdsl-generator
  org/webdsl/dsl/separation/-

strategies
    
  innermost-rep-aux(s) = 
        InnermostNormalForm
    <+
        all(innermost-rep-aux(s))
      ; try({
           s
         ; rules(InnermostApplied := True() )
         ; innermost-rep-aux(s) })
      ; {?q; rules( InnermostNormalForm : q )}
    
  innermost-rep(s) =
    {| InnermostNormalForm :
        innermost-rep-aux(s)
    |}
      
  desugar-top =
    // Load desugar dependencies
      if not(DesugarRulesLoaded) then
	        if (used-rules,created-rules) := <file-exists; ReadFromFile> "testdr-rev.aterm" then
	            <map(\(key, defs) -> <rules(RuleUser : key -> defs)> defs\)> used-rules
	          ; <map(\(key, defs) -> <rules(RuleProvider : key -> defs)> defs\)> created-rules
	        else
	            load-all-definitions
	        end
        ; rules(DesugarRulesLoaded := True())
      end
    ; {| RuleResolvingEnabled: 
          rules(RuleResolvingEnabled := True())
		    ; repeat(
		      {| InnermostApplied:
		         transform-defs(desugar-toplevel)
		       ; try(desugar-emit-all-defs)
		       ; where(InnermostApplied)
		      |}
		    )
		  |}
    
  ignore-dr-tracking = 
      ?"RuleResolvingEnabled"
    <+ ?"RuleUser"
    <+ ?"RuleProvider"
    <+ ?"TopLevelDefinitions"
    
    <+ ?"ProcedureEntities"
    <+ ?"DoneOnce"
    <+ ?"InTypeCheckingPhase"
    <+ ?"InPage"
    <+ ?"InnermostNormalForm"
    <+ ?"DesugarInDefineContextApplied"
    <+ ?"InTemplate"
    
  
  dynamic-rule-resolver: (rulename, key) -> (rulename, key)
     where RuleResolvingEnabled
        ; defs := <RuleProvider/* <+ debug(!"No rule providers for: "); fail*/> (rulename, key)
     with   <debug(!"Got rule:" )> (rulename, key)
          ; <debug(!"Providers: ")> defs
          ; not-loaded := <filter(not(TopLevelDefinitions))> defs
          ; if [] := not-loaded then
                <debug> "All defs loaded"
            else
                <debug(!"Loading defs: ")> not-loaded
                  // some defs are generated by the desugar phase. they are not cached, so UnmodifiedDefRules fails. 
              ; <filter(where(UnmodifiedDefRules); load-unmodified-def-with-rename)> not-loaded
            end
      
  save-desugar-rules =
      where(
        // save desugar rules
          all-keys-DesugarRulesUsed
          // Def to rules
        ; map(!(<id>, <bagof-DesugarRulesUsed; concat; uniq>, <bagof-DesugarRulesCreated; concat; uniq>))
        ; <WriteToBinaryFile> (<concat-strings> [<id/*newname*/> "testdr", ".aterm"], <id>)
    ; try(
         // Rules to def
         all-keys-DesugarRulesUsed
        ; {| RuleToDef:
            map({def:
                 ?def
               ; bagof-DesugarRulesUsed; concat
               ; map({rulekey:
                   ?rulekey;
                     rules(RuleToDef :+ rulekey -> def )
                 })
            })
          ; all-keys-RuleToDef
          ; filter({rulekey:
               ?rulekey
             ; bagof-RuleToDef
             ; uniq
             //; where(not(length => 1))
             ; !(rulekey, <id>)
            })
          ; ?used-rule-to-def
          |}
//        ; !""; debug(!"Got used-rule-to-def "
        ; all-keys-DesugarRulesUsed
        ; {| RuleToDef:
            filter({def:
                 ?def
               ; bagof-DesugarRulesCreated; concat
               ; map({rulekey:
                    ?rulekey;
                     rules(RuleToDef :+ rulekey -> def )
                 })
            })
          ; all-keys-RuleToDef
          ; filter({rulekey:
               ?rulekey
             ; bagof-RuleToDef
             ; uniq
             //; where(not(length => 1))
             ; !(rulekey, <id>)
            })
          ; ?created-rule-to-def
          |}
//        ; !""; debug(!"Got created-rule-to-def ")
        ; <WriteToBinaryFile> (<concat-strings> [</*newname*/id> "testdr-rev", ".aterm"], (used-rule-to-def, created-rule-to-def))
      )
     )
     
  desugar-toplevel = track-rules(with-toplevel-name(innermost-rep(desugar)))
     
  transform-defs-tracked(s) = transform-defs(track-rules(s))
  
  track-rules(s) = 
    {| CreatedRules:
        track-rules-internal(s)
    |}
  
  track-rules-with-creates(s) =
      track-rules-internal(s)
  
  track-rules-internal(s) = 
      not(DebugDesugarRules)
    ; s
     
  track-rules-internal(s) =
      where(CurrentDefinitionKey => key)
    ; start-record-dynamic-rules
    ; {| DynamicRulesUsed:
        enable-dr-usage-tracking
      ; s => result
      ; disable-dr-usage-tracking
      ; all-keys-DynamicRulesUsed
      ; remove-dr-dummies
      ; remove-all(?("InnermostNormalForm",_))
      ; ?used-rules
      |}
    ; end-record-dynamic-rules
    ; ?all-created-rules
      // Get a list of (name, keys*) pairs
    ; rules(CreatedRules :+ key -> all-created-rules)
    ; map(\(name, keyvals) -> <map(\(key,vals) -> (name, key)\)> keyvals \); concat
    ; remove-all(?("InnermostApplied",_))
    //; remove-all({x: ?(_, [DR_DUMMY()]); Fst; ?x; rules(EmptyLeftHand : x) })
    ; ?created-rules
    ; rules(DesugarRulesCreated :+ key -> created-rules)
    ; !used-rules
    //; remove-all(RuleOwner; ?key) // remove own rules
    //; ?used-rules2
    ; rules(DesugarRulesUsed :+ key -> used-rules)
    ; !result
    
rules //extend entity functions create dr
  
  rename-all-vars :
    (t, []) -> (t, [])

  rename-all-vars :
    (t, [(from, to)|rst]) -> <rename-all-vars> (t2, rst)
    where t2 := <rename-var(|from, to)> t

rules
  
  desugar = fetch(?RemoveMe()); remove-all(?RemoveMe())
  
rules
  /**
   *  Many desugar rules require a rename of the entire 'define' in order to "see" all the visible vars in Rename dynamic rules.
   *  Also for constructing the closure used in definition/function lifting it is necessary to rename the whole define.
   *  To reduce the number of full 'define' renamings, this rule provides a hook for other desugar rules working in the context of a 'define'.
   *  Maybe faster with innermost, though elems contained in this define are already desugared by normal 'desugar' rules.
   *  Should only be used for simple rewrites, since after one application the elems in the define are probably no longer all properly renamed.
   *  Used in translation of outputFile and outputImage.
   */   
  desugar : 
    def1@Define(mods, name, args, targs, elems1) -> result
    where not(<EnclosingDefinition> name) //not for local (re)defines
        ; result := <desugar-in-context-helper> def1
  
  desugar : 
    def1@Entity(_, _, _) -> result
    where result := <desugar-in-context-helper> def1
  desugar : 
    def1@EntityNoSuper(_, _) -> result
    where result := <desugar-in-context-helper> def1
  desugar : 
    def1@SessionEntity(_, _) -> result
    where result := <desugar-in-context-helper> def1
    
  // Only for global functions: entity functions must be desugared in entity context
  desugar : 
    def1@Function(name, fargs, ret, elems) -> result
    where has-no-anno(EntityFunctionAnno())
      ; result := <desugar-in-context-helper> def1
           
  desugar-in-context-helper : 
    def1 -> result
    where {| DesugarInDefineContextApplied :
            def2 := <alltd(desugar-in-define-context; where(rules(DesugarInDefineContextApplied := True())))> def1
          ; DesugarInDefineContextApplied
          ; result := <rename> def2
           |}
