module org/webdsl/dsl/transformation/dsl-to-core

imports
  libstrategolib
  libjava-front

imports
  libwebdsl-front
  org/webdsl/dsl/separation/-
  org/webdsl/dsl/transformation/-
  org/webdsl/dsl/analysis/-
  org/webdsl/dsl/typechecker/-
  org/webdsl/dsl/modules/-
  org/webdsl/dsl/languages/composition

signature constructors
  
  ApplicationName : Term -> Term
  
strategies

  dsl-to-core =
      dsl-to-core-analysis
      // TODO: first save parse cache (only for files without errors), then exit if errors found
    ; if FoundErrors then <exit> 1 end //exit if parsing error in modules, exit here instead of in dsl-to-core-analysis for compatibility with editor support
    ; with( 
          if-only-typechecking(<exit> 0)
        ; add-builtins-to-ast
        ; dsl-to-core-generation
      )
    ; get-all-toplevel-definitions
  
  dsl-to-core-analysis =
      if not(FoundErrors) //stop if parsing error in modules
      then
          log-time(transform-defs(remove-string-position-annos) | "remove string pos annos")
        ; stage(typecheck|"typechecking")
      end
    ; transform-defs(remove-position-annos)
    ; update-parse-cache
      
  dsl-to-core-generation = with(
      log-timed(load-desugar-rules | "load-desugar-rules")
    ; stage(desugar-top|"model-to-model")
    ; if-extra-typechecking(stage(typecheck|"extra typechecking"))
    ; stage(access-control-stage | "access control")
    ; check-for-ajax
    ; stage(
        analyze-all
      //collect all the functions in a dynamic rule and handles overloading
      ; aggregate-and-combine-functions
      |"performing analysis")
  )
    
  // load-unmodified-def is used if rename+constraints must be performed again
  // load-unmodified-def-with-rules is used if only needed for desugar
   
  load-unmodified-def: key -> key
    where not(<TopLevelDefinitions> key)    // is not already loaded
  	with	def := <UnmodifiedDef> key
  	    ; <mark-renamings> def
  	    ; rules(TopLevelDefinitions : key -> def)
  			; rules(UnmodifiedDef :- key)
        ; rules(UnmodifiedDefRules :- key)
  
  /*
  load-unmodified-def-with-rename: key -> key
    where not(<TopLevelDefinitions> key)    // is not already loaded
    with  <UnmodifiedDefRules; load-dynamic-rule-closure> key
        ; <load-unmodified-def> key   // load ast
  */
  
  load-unmodified-def-with-rename: key -> key
    with  <load-unmodified-def> key
        ; <TopLevelDefinitions; rename-top> key
      
  load-all-definitions =
      all-keys-UnmodifiedDef
    ; filter(not(TopLevelDefinitions))
      // definitions are loaded by file (multiple at a time) 
    ; map(TopLevelDefinitions <+ load-unmodified-def-with-rename)
       
  
strategies // IDE Plugin stuff

  webdsl-collect-all-errors =
    {| AllErrors, AllWarnings:
      rules(
        // Override the error reporting behavior to collect errors
        AddError(|msgs):   node -> node where rules(AllErrors   :+= (node, <error-to-string> msgs))
        AddWarning(|msgs): node -> node where rules(AllWarnings :+= (node, <error-to-string> msgs))
      )
    ; with(
        dsl-to-core-analysis
      )
    ; !(<bagof-AllErrors <+ ![]>, <bagof-AllWarnings <+ ![]>, [])
    |}
    
strategies // module imports

  emit-import :
    x -> <rules( ExtraModulesToImport :+= x )>

  already-imported :
    Imports(name) -> Note([])
    where <Imported> <strip-annos> name

  import-module: Imports(name) -> file
    with xtcfile := FILE(<concat-strings>[<DirName>, "/", name, ".app"])
       ; name1 := <strip-annos> name
       ; rules( Imported : name1 )
       ; {| ImportedBy:
            rules(ImportedBy := name)
          ; file := <read-webdsl-file> xtcfile
         |}
     
  read-webdsl-application =
    {| ModuleAst:
    	// Read modified files, starting at the main app file
      read-webdsl-file
      // Import builtin files
    ; {| ExtraModulesToImport:
         try(import-extra-modules-hook; debug(!"INTERNAL ERROR: import-extra-modules-hook strategies must fail");<exit>1)
       ; extramodules := <bagof-ExtraModulesToImport>
      |}
    ; <map(import-module)> extramodules
      // Store top-level elements
    ; all-keys-ModuleAst
    ; map(\path -> <ModuleAst; module-ast-to-toplevel-elements(|path)> \)
    |}

  read-webdsl-file = with(
      // Read main app
      ?xtcfile
    ; where(path := <path-of-xtc-file>)
    ; xtc-parse-webdsl
    ; ?(real-file, cached-file)
    ; if <UnmodifiedFile> xtcfile then
          // OPTIMIZATION: do not load unmodified definitions
          // PROBLEM: need imports to traverse app files
          !cached-file
        ; map({
              ?(key, def, ruleset)
            ; keyfile := <def-key-to-file> key
            ; rules(UnmodifiedDef : key -> def)
            ; rules(UnmodifiedDefRules : key -> ruleset)
            ; rules(IsUnmodifiedFile : keyfile)
          })
        ; <alltd(?Imports(_); (already-imported <+ import-module))> cached-file
      else
          rules(ModuleAst : path -> real-file)
        ; rules(CachedVersion : path -> cached-file)
        ; !real-file
        ; if not(ImportedBy) then // main app file
            ?Application(<id>,_); set-qualified-appname 
            <+
            not(add-error(|"Main .app file needs to start with \"application\""))
          end
        ; <alltd(?Imports(_); (already-imported <+ import-module))> real-file
      end
  )

	set-qualified-appname = ?name; rules(QualifiedAppName := name)

strategies // toplevel definitions
  
  // IMPORTANT: If a file is not read at all (no dynamic rules set), it is modified.
  is-unmodified-def =
    where(
        with(def-key-to-file => file)
      ; <IsUnmodifiedFile> file
    )
  
  is-modified-def = not(is-unmodified-def)
  
  // dynamic rule oddity: removing with :- does not remove the key
  // so all-keys-X; map(x) will fails for 'removed' keys
  toplevel-definition-keys =    
      all-keys-TopLevelDefinitions
    ; filter(where(TopLevelDefinitions))
  
  // Perform s on all definitions, without changing the definitions
  map-defs(s) =
      toplevel-definition-keys 
    ; map(with-definition-key(s))

  // Get a list of all toplevel definitions
  get-all-toplevel-definitions = 
    map-defs(id)

  // Filter all definitions for which s succeeds, without actually removing them from the list of definitions 
  filter-defs(s) =
      toplevel-definition-keys 
    ; filter(with-definition-key(s))
      
  transform-defs(s) = 
      toplevel-definition-keys 
    ; map(
        { key, newdef:
            ?key
          ; with-definition-key(s)
          ; ?newdef
          ; rules(TopLevelDefinitions : key -> newdef) } )
  
   // Remove all defs for which s succeeds
  remove-defs(s) =
      toplevel-definition-keys 
    ; filter(\key -> <try(with-definition-key(s); rules(TopLevelDefinitions :- key))> key\)  
  
  with-definition-key(s) =
      ?key
    ; TopLevelDefinitions
    ; {| CurrentDefinitionKey:
        rules(CurrentDefinitionKey := key)
      ; s
      |}
   
  /*
    TopLevelDefinitions : toplevel definition name -> definition
  */ 
    
  module-ast-to-toplevel-elements(|path): ast -> ast
    with  if ?Application(appname, appdefs) then
            ![Section("", [ApplicationName(appname)]) | appdefs]
          else
            ?Module(_, <id>)
          end
        ; try(?[]; ![Section("", [])])     // at least on section so module gets stored
        ; deflist := <mapconcat(module-section-to-toplevel-elements(|path))>
        ; rules(ModuleToDefs : path -> deflist)
    
  module-section-to-toplevel-elements(|mod): sect -> deflist 
    with  <(?Section(name, defs*) <+ ?AccessControlDefinition(name, _); defs* := [<id>])> sect
        ; deflist := <map(store-module-def(|mod))> defs*
  
  declare =
      ?ApplicationName(name)
    ; rules(QualifiedAppName := name)
      
  // NOTE: mod is a Qid(...) for the application file
  store-module-def(|mod): def -> defname
    with  with-toplevel-name( //give each toplevel definition a name before storing
		          defname := <get-def-key> def
		        ; try(<TopLevelDefinitions> defname; !defname; debug(!"Two definitions with the same unique name: ")) 
		        ; rules(TopLevelDefinitions : defname -> def)
		        ; deffile := <def-key-to-file> defname
		        ; <mark-renamings> def
		      )

  get-def-key: def -> key
    with  key := <get-anno(?At(_,_,_)) <+ !At(<concat-strings; newname> ["(gen)",<TopLevelDefineName>], 0, 0)> def
        
  def-key-to-file = ?At(<id>,_,_)
  
strategies  // position info
    
  remove-position-annos =
    topdown-l(try(keep-position-anno <+ remove-position-anno))

  remove-string-position-annos =
    topdown(try(remove-string-position-anno))

  remove-string-position-anno =
    (is-string + ?SimpleSort(_) + ?GenericSort(_, _))
    ; strip-annos

  remove-position-anno :
    s{anno*} -> result
    where anno2* := <remove-all(?At(_, _, _))> anno*
        ; if [] := anno2* then
            result := s{}
          else
            result := s{anno2*}
          end

