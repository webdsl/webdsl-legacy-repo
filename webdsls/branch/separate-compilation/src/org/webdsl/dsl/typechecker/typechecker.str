/**

  Type rules for WebDSL

*/

module org/webdsl/dsl/typechecker/typechecker

imports
  libstrategolib
  libjava-front

imports
  libwebdsl-front
  org/webdsl/dsl/separation/-
  org/webdsl/dsl/typechecker/-
  org/webdsl/dsl/transformation/-

strategies

  dep-path = <concat-strings> [<DirName>, "/.webdsl.compiler.deps"]

  typecheck =
  	 // Load cached data (file may not exist)
  	  try(load-dependency-data)
  	// Typecheck modified data (updates dependency data)
    ; in-typechecking-phase(
        typecheck-init
      ; log-time(typecheck-declare | "declare")
      ; log-time(find-changed-rules | "compare dependencies")
      ; typechecker-after-declare
      ; log-time(typecheck-rename | "rename")
      ; if-typechecking(
          where(
              log-time(typecheck-constraints | "constraint-error" )
            // do not apply on Application, it would show the entire AST with the error at command line
            ; log-time(not(<constraint-error-global> "") | "constraint-error-global")
            ; write-dependency-data
          )
        , 
          id)
    )

	// TODO: move to rename.str
	typecheck-rename = transform-defs-tracked(
	  {key:
	      where(CurrentDefinitionKey => key)
	    ; rename-top
	    ; rules(RenameRules : key -> [])
	  }
	)
	
	//typecheck-rename = transform-defs(rename-and-store)
  
	rename-and-store =
			where(CurrentDefinitionKey => key)
		; rename-top
		; start-record-dynamic-rules
		; rename-top => renamed
    ; end-record-dynamic-rules
    //; store-dynamic-rules-owner
//		; filter(where(Fst; is-used-dr))
		//; map-dr-values-with-key(strip-dr-value)  
		    // TODO: too much stripping; ie. VarDeclInit(..,..,expr) the expr is needed in backend to determine type (by anno)
		; ?ruleset
		; rules(RenameRules : key -> ruleset)
		; !renamed
		  
  // NB: Rules can be owner by any number of owners, using :+
		  
		  /*
  store-dynamic-rules-owner: ruleset -> ruleset
    with  CurrentDefinitionKey => owner
        ; !ruleset
        ; map(\(name,keyvals) -> (name, <map(Fst)> keyvals )\)
        //; where(filter({rulekey: ?rulekey; RuleOwner; not(?owner); !(owner, <id>, rulekey); debug(!"Overwriting rule owner: ")}))
        ; map({rulekey: ?rulekey; rules(RuleOwner : rulekey -> owner)})
      */
    
  no-dependent-modified = id
    
  typecheck-constraints =
      map-defs(
      { key, def, used-ruleset:
          ?def
        ; CurrentDefinitionKey => key
        ; !key; debug(!"Typechecking: ")
        ; <constraint-error-def> def
      }
   )

  constraint-error-def =
    {| DynamicRulesUsed:
        // Check
        enable-dr-usage-tracking
      ; constraint-error-all
      ; disable-dr-usage-tracking
        
        // Store
      ; all-keys-DynamicRulesUsed
      ; remove-dr-dummies => drs
      ; CurrentDefinitionKey => key
      ; rules(RulesUsedBy : key -> drs)
    |}
  
  //call resolving/overloading is done during rename, typechecking errors are produced by constraint-error strategy
  //when no longer in typechecking, but e.g. during desugaring a failed resolve should give an error
  in-typechecking-phase(s) =
    {| InTypeCheckingPhase:
        rules(InTypeCheckingPhase := True())
      ; s
    |}
    
  // This must be called *before* any declares as it sets up the built-in types
  typecheck-init = 
      not(built-in-template-rule-setup
	       ; fatal-err-msg(|"error in typechecker.str, failure should not occur here, make sure built-in-template-setup rules end with ';fail'")
	    ) // setup dyn rules for checks
  
  // TODO: move all emitting to desugar phase
  exclude-from-dr-stripping = ?"AddWebDSLDefs"
  
  strip-dr-value(|name,key) =
      where(<exclude-from-dr-stripping> name)
      <+ try(with-origin(alltd(strip-bodies)))
        
	load-ast: key -> key
    where <not(TopLevelDefinitions)> key
    with  file := <def-key-to-file> key
        ; module-ast-to-toplevel-elements
  
  // Declare globally visible webdsl elements
  typecheck-declare =
  	  // Load dynamic rule sets for unmodified files
   	  all-keys-DeclaredRules
   	//; debug(!"All keys in DeclaredRules: ")
   	; remove-all(is-modified-def)
   	//; debug(!"Unmodified ones: ")
   	; map(with(DeclaredRules; load-dynamic-rule-closure))
      // Declare modified files
    ; map-defs(
        { key:
            where(CurrentDefinitionKey => key)
          ; track-rules(declare-all)
          ; rules(DeclaredRules : key -> [])
        }
      )
      /*
    ; map-defs(
      { def, key, ruleset:
          ?def
        ; CurrentDefinitionKey => key
        ; !def
        ; start-record-dynamic-rules
        ; declare-all
        ; end-record-dynamic-rules
        //; store-dynamic-rules-owner
        //; filter(where(Fst; is-used-dr))
        //; map-dr-values-with-key(strip-dr-value)
        ; ?ruleset
        ; rules( DeclaredRules : key -> ruleset )
      }
      */
    
  typechecker-after-declare =
      log-time(declare-all-override | "declare-all-override")
    ; log-time(
        not(
            after-tc-declare-hook
          ; fatal-err-msg(|"error in typechecker.str, failure should not occur here, make sure after-tc-declare-hook rules end with ';fail'")
        ) // setup dyn rules for checks
        | "after-tc-declare-hook")

	constraint-error-all =
      bottomup(
		    try(
		      constraint-error; where(stage-newline-once); debug(!"INTERNAL ERROR: constraint-error succeeded for: ")))
    
  catch-errors-editor(s) = 
    {| AllErrors, AllWarnings:
      rules(
        // Override the error reporting behavior to collect errors
        AddError(|msgs):   node -> node where rules(AllErrors   :+= (node, <error-to-string> msgs))
        AddWarning(|msgs): node -> node where rules(AllWarnings :+= (node, <error-to-string> msgs))
      )
      ; s
      ; !(<bagof-AllErrors <+ ![]>, <bagof-AllWarnings <+ ![]>)
    |}
  
rules

	get-toplevel-name = get-anno(?TopLevelName(<id>))

rules // with-toplevel-name
	
	create-toplevel-name = 
			modname := <get-anno(?At(<id>, _, _); clean-module-name)>
		; <concat-strings; newname> [modname, "_topdef"]
	
	// in desugaring, new elements do not have position information
	create-toplevel-name = <concat-strings; newname> ["topdef"]
		
	clean-module-name = string-as-chars(filter(is-alpha))
		
	// Find toplevel name for element and do s
	with-toplevel-name(s) =
		(		where(name := <get-toplevel-name>)
		<+	where(name := <create-toplevel-name>)
			; add-anno(|TopLevelName(name))
		)
		; with-toplevel-name(s|name)
		
	with-toplevel-name(s|name) = {| TopLevelDefineName:
			rules(TopLevelDefineName := name)
  	; s
  |}

      