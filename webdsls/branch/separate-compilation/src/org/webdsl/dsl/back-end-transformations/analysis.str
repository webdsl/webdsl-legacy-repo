module org/webdsl/dsl/back-end-transformations/analysis

imports
  libwebdsl-front
  org/webdsl/dsl/back-end-transformations/back-end-transformations

rules // analyze-elem for global elements

  // entity
  analyze-elem: ent -> ent
    where class := <?Entity(<id>,_,body) <+ ?EntityNoSuper(<id>,body) <+ ?SessionEntity(<capitalize-string>,body)>
        ; rules (AllEntityNames :+= class)
        ; rules (EntityFromName : class -> ent)
        ; <try(get-anno(?IndexedAnno(_)); rules(IndexedEntities :+= class))> ent
        ; rules (AllEntities :+= ent)
  			; fail
  
  // test
  analyze-elem =
      ?Test(name,body); rules (AllTestNames :+= name)
    ; fail
  
  // global var
  analyze-elem =
      ?VarDeclInit(_,_,_)
    ; rules(AllGlobalVars :+= <id>)
    ; fail
  
  // session entity
  analyze-elem =
      ?SessionEntity(_, _)
    ; rules(SessionEntities :+= <id>)
    ; fail
 
  // invoke every
  analyze-elem-global =
      ?InvokeEvery(_,_)
    ; rules(AllInvokeEvery :+= <id>)
    ; fail
      
  // defines
  analyze-elem-global =
      ?def@Define(mod*,x,farg*,_,_)
    ; classname := <any-template-name-to-classname> (mod*, x)
    // Pages
    ; if <fetch(Page)> mod* then
          rules( AllPageNames :+= x )
      end
    // Emails
    ; if <fetch(Email)> mod* then
          rules ( AllEmailNames :+= x )
      end
    // Toplevel templates
    ; if <not(fetch(Page <+ Email))> mod* then
          // used to create lookup hashmap in java-base-page.str
          rules( AllTopLevelTemplateNamesJavaServlet :+= x ) 
        ; if <fetch(AjaxTemplate)> mod* then rules ( AllTopLevelTemplateNamesWithAjax :+= x ) end
      end
    ; rules(
        TopLevelTemplateClassName : x -> classname
        // TemplateFormalArguments used in dispatch-servlet.str
        TemplateFormalArguments : x -> farg*
      )
    ; if "errorTemplateInputListString"  := x then rules ( ErrorTemplateInput := def ) end
    ; if "errorTemplateFormListString"   := x then rules ( ErrorTemplateForm := def ) end
    ; if "errorTemplateActionListString" := x then rules ( ErrorTemplateAction := def ) end
    ; if "templateSuccessListString"     := x then rules ( TemplateSuccess := def ) end

rules     // utils

  any-template-name-to-classname: (mod*, x) -> class
    with  name := <try(<fetch(Email)> mod*; <concat-strings> [x, "_Email"])> x 
        ; class := <template-name-to-classname> name
  
  template-name-to-classname: x -> class
    with  class := $[[x]_Template]
