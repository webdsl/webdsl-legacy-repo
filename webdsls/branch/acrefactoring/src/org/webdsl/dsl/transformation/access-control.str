/**

 Security rules for WebDSL

*/

module org/webdsl/dsl/transformation/access-control

imports
  libstrategolib
  //Java-15
  libjava-front

imports
  libwebdsl-front

rules
  process-access-control=
    //declare-access-control

    //; typecheck-access-control(typecheck-access-control-pointcuts|)
   // create-ac-pointcuts
    //; desugar-access-control

    //; typecheck-access-control(typecheck-access-control-declarations|)
    //; generate-access-control-declarations
    if AccessControlEnabled then
      topdown(try(new-generate-access-control-rules-checks))
      //topdown(try(generate-access-control-rules-checks))
      ; topdown(try(remove-all(?AccessControlDefinition(_,_))))
      ; topdown(try(chain-WeaveAccessControl))
      ; try(alltd(chain-WeaveAccessControlOM))
     
      //; new-access-control-weaving
    //  ; access-control-weaving
  //  ; where(<WeaveAccessControl> Define([Page()],"test",[],[]))

      ; add-access-denied-page
      
      //remove overall policy declaration
      ; topdown(try(remove-all(?ACPolicy(_))))// can be removed during transformation
      
      //; where(warn-for-unused-rules)
    end
    
  new-generate-access-control-rules-checks:
    AccessControlDefinition(Some(groupname),defs) -> AccessControlDefinition(Some(groupname),defs)
    where <map(   create-page-rule(|groupname) 
               <+ create-template-rule(|groupname)
               <+ create-action-rule(|groupname)
               <+ {x:?x; !["rule unknown: ",x];debug}
                  )> defs
                  
  get-formarg-from-matcharg:
    MatchArgs(formarg,wc)->formarg
  get-varname-from-formarg:
    Arg(ident,srt)->Var(ident)
  match-arguments=
    ?(fargrule,farg*)
    ; newfargs := <?MatchArgs(args,wc);!args> fargrule
    ; getWC := <?MatchArgs(args,wc);!wc> fargrule
    ; if getWC := None() 
      then newfarg* := farg*
      else newfarg* := <take(<length> newfargs)> farg* end
    ; <zip(extract-sorts;eq)> (newfargs,newfarg*)
  extract-sorts:
    (Arg(ident1,thesort1),Arg(ident2,thesort2)) -> (thesort1,thesort2)
    
    
  create-page-rule(|x_rulegroup):
    acrule@AccessControlRule("page",x_pagename,farg1*,e,acrules) -> acrule
    where x_predname := <newname> "genpagepredicate"
        ; farg2* := <get-formarg-from-matcharg> farg1*
        //; <Desugar;emit-webdsl-code> def|[ predicate x_predname(farg2*) { e } ]| //doesn't parse
        ; <Desugar;emit-webdsl-code> Predicate(x_predname,farg2*,e) 
        ; rules( WeaveAccessControl :+
                   def|[ define page x_pagename(farg*) { elem* } ]| -> 
                   def|[ define page x_pagename(farg*) { acpagecheck (x_rulegroup,x_predname(e*))
                                                         elem1* } ]|
                   where <match-arguments> (farg1*,farg*)
                       ; <debug> ["page rule applied",x_pagename]
                       ; e* := <map(get-varname-from-formarg)> farg*
                       //nested actions
                       ; {| WeaveAccessControl:
                            <map(create-action-rule(|x_rulegroup))> acrules
                            ; elem1* := <topdown(try(chain-WeaveAccessControl))> elem*
                          |}  
               )
        ; rules( WeaveAccessControlOM :+ 
                   tc@TemplateCall("navigate",[ThisCall(x_pagename,args)],_) -> newtc
                   where e* := <map(get-varname-from-formarg)> args
                       ; newtc := IfTempl( |[ x_predname(e*) ]| ,[tc])
               )
        ; <debug> ["page rule created",x_pagename]
          
  create-action-rule(|x_rulegroup):
    acrule@AccessControlRule("action",x_actionname,farg1*,e,acrules) -> acrule
    where x_predname := <newname> "genactionpredicate"
        ; farg2* := <get-formarg-from-matcharg> farg1*
        ; <Desugar;emit-webdsl-code> Predicate(x_predname,farg2*,e) 
        ; rules(   
            WeaveAccessControl :+
              elem|[ action x_actionname(farg*) { stat* } ]| -> 
              elem|[ action x_actionname(farg*) { acactioncheck(x_rulegroup,x_predname(e*));
                                                  stat* } ]|
              where <match-arguments> (farg1*,farg*)
                  ; <debug> ["action rule applied",x_actionname]
                  ; e* := <map(get-varname-from-formarg)> farg*
          )
          ; <debug> ["action rule created",x_actionname]
           

  create-template-rule(|x_rulegroup):
    acrule@AccessControlRule("template",x_templname,fargs,e,acrules) -> acrule
    where rules(   
            WeaveAccessControl :+
              def|[ define x_templname(farg*) { elem* } ]| -> 
              def|[ define x_templname(farg*) { actemplcheck (x_rulegroup, e)
                                                elem* } ]|
              where <debug> ["template rule applied",x_templname]
          )
          ; <debug> ["template rule created",x_templname]
          
  add-access-denied-page:
    Application(qid, sections) -> Application(qid, <concat>[sections, deniedpage])
    where deniedpage :=
      [ |[
          section access denied page.
          define page accessDenied()
          {
            title("Access Denied")
            text("Access Denied")
          }
        ]|
      ]

  
//---------------------------------------------------------------------------  


  warn-for-unused-rules=
    !<All-AC-Rules<+![]>
    ; map(try(check-usage-of-rule))
  check-usage-of-rule=
    ?acr@AccessControlRule(checktype,matchstring,fargs,check,acrules)
    ; !(acr,<Used-AC-Rules<+![]>)
    ; not(elem)
    ; !AccessControlRule(checktype,matchstring,fargs,check,[])//don't show nested rules, that gives too much information
    ; pp-webdsl-to-string
    ; warn(|["warning: in access control rules: rule not used: "])
  
  generate-access-control-rules-checks:
    AccessControlDefinition(groupname,defs) -> AccessControlDefinition(groupname,defs)
    where <filter(create-rule-classes(|groupname))> defs

  create-rule-classes(|groupname):
    st@AccessControlRule(_,_,_,_,_) -> st
    where def0* := <create-rule-classes-helper(|groupname)> st

  create-rule-classes-helper(|groupname):
    st@AccessControlRule(checktype,matchstring,fargs,check,acrules) -> st
    where Some(gname) := groupname
        ; newlistfromtype := <concat> [<Security-Rules-List-From-Type <+ ![]> (gname,checktype) , [st] ]
        ; rules(
            Security-Rules-List-From-Type : (gname,checktype) -> newlistfromtype
            All-AC-Rules := <concat> [<All-AC-Rules <+ ![]>,[st]]
          )

  remove-wildcards=
    explode-string;map(try(?'*';!'1'));implode-string

  //strategy to process policy combination
  generate-access-control-checks(|checktype,name,vars,previousname,previousrules)=
    rules(
      Previous-Selected-Rules := []
      Previous-Decision-Name := [])
  ; where(final-check := <AC-Policy-Expression>
        ; groupnames := <collect(?Name(_))> final-check
        ; groupchecks := <map(map-groupname-to-checks(|checktype,name,vars,previousname,previousrules))> groupnames)
  ; if <map(?[])> groupchecks
    then ![] //weaver expects [] when no rules apply
    else
      where(
            {| groupresult:
                 <zip(\(Name(thename),thecheck) -> None() 
                        where rules(groupresult : Name(thename) -> thecheck)\)> (groupnames,groupchecks)
               ; subst-final-check := <topdown(try(groupresult))> final-check
               ; substituted-final-check := <bottomup(try(  \And([],[])-> []\
                                                         <+ \Or([],[])-> []\
                                                         
                                                         <+ \And([],x)-> x\
                                                         <+ \And(x,[])-> x\
                                                         <+ \Or([],x)-> x\
                                                         <+ \Or(x,[])-> x\
                                                         
                                                         <+ \And(True(),True())-> True()\
                                                         <+ \And(False(),False())-> False()\
                                                         //<+ \And(False(),_)-> False()\
                                                         //<+ \And(_,False())-> False()\
                                                         <+ \Or(False(),False())-> False()\
                                                         <+ \Or(True(),True())-> True()\
                                                         //<+ \Or(True(),_)-> True()\
                                                         //<+ \Or(_,True())-> True()\
                                                          ))> subst-final-check
             |})
    ; !substituted-final-check
    end
  
  map-groupname-to-checks(|checktype,name,vars,previousname,previousrules):
  Name(thename) -> <generate-access-control-checks(|checktype,name,vars,previousname,prev-group-rules-conc,thename)>
    where prev-group-rules := <collect(?(thename,_))> previousrules
        ; if [] := prev-group-rules //collect/filter failed
          then prev-group-rules-map := prev-group-rules
          else prev-group-rules-map := <map(\ (x,y) -> y \)> prev-group-rules end
        ; if [] := prev-group-rules-map //previous find rules failed
          then prev-group-rules-conc := prev-group-rules-map
          else prev-group-rules-conc := <concat> prev-group-rules-map end
  
//  get-second-element:
 //   (x,y) -> y

  generate-access-control-checks(|checktype,name,vars,previousname,previousrules,groupname)=
    if previousname := []
    then
      possibleTargets := <Security-Rules-List-From-Type <+![]> (groupname,checktype)
    else
      possibleTargets := <concat> [<Security-Rules-List-From-Type<+![]> (groupname,checktype), <filter(?AccessControlRule(checktype,_,_,_,_))> previousrules]
    end
    ; pt := <filter(find-most-applicable-target-filter(|name,vars))> possibleTargets

    ; if previousname := []
      then
       ( $decisionclassname := <concat-strings> ["ACDecision",checktype,name]
         ; $acrulename := <concat-strings> ["ACRule",checktype,name] )
      else
       ( $decisionclassname := <concat-strings> ["ACDecision",previousname,checktype,name]
         ; $acrulename := <concat-strings> ["ACRule",previousname,checktype,name] )
      end
    ; selectedchecks := <map(\AccessControlRule(_,_,_,check,_) -> check\)> pt
    ; selectedrules := <map(\AccessControlRule(_,_,_,_,acrules) -> acrules\);concat> pt
    ; if [] := selectedchecks
      then 
        rulecheckactions := [] 
      else
        rulecheckactions := <map(add-not-null-checks);generate-conjunction-exp> selectedchecks
      end
    ;rules
    (
      
      Previous-Selected-Rules := <concat> [[(groupname,selectedrules)],<Previous-Selected-Rules<+![]>]
      Previous-Decision-Name := <concat-strings> [checktype,name]
    )
    ; !rulecheckactions

  //generate-definition-from-check(|$rulename):
  //  (index,check) -> def|[
  //                     
   //                       var $varname :AccessControlCheck := AccessControlCheck{
   //                       rule := $rulename
   //                       description := str0 };

                        
   //                  ]|
  // where $varname := <concat-strings> ["check",$rulename,<int-to-string> index]
  // ; str0 := <pp-webdsl-to-string; double-quote; explode-string; filter(not(?'\n')); implode-string> check

  /*vars-to-props:
    Arg($ident,$argsort) -> |[ $ident -> $classname]|
    where <defined-java-type> $argsort
        ; SimpleSort($classname) := $argsort

  vars-to-props:
    Arg($ident,$argsort) -> |[ $ident :: $typename]|
    where <builtin-java-type> $argsort
        ; SimpleSort($typename) := $argsort

  vars-to-props:
    Arg($ident,$argsort) -> |[ $ident -> $gentype<$thesort>]|
    where GenericSort($gentype,$thesort) := $argsort
        ; <defined-java-type> $thesort*/

  // only supports tail wildcards (*) so far
  find-most-applicable-target-filter(|name,vars):
    acr@AccessControlRule(checktype,matchstring,fargs,check,acrules) -> AccessControlRule(checktype,matchstring,fargs,newcheck,acrules)
    where
    if not(matchstring := "*")
    then
        (
        leftmatcher := <explode-string;reverse;drop-until(?'*');drop-while(?'*');reverse> matchstring
        ; if leftmatcher := []
            then
                (matchresulttemp := <left-match;implode-string> (<explode-string> name,<explode-string> matchstring)
                //still need to check whether it is precisely the name or something longer:
                ; if equal(|<explode-string;length> name, <explode-string;length> matchstring)
                  then matchresult := matchresulttemp
                  else matchresult := matchstring
                  end
                )
            else
                matchresult := <left-match;implode-string> (<explode-string> name,leftmatcher)
            end
        ; not(matchresult := matchstring) //if equal, left-match failed
        )
    end
    //check arguments
    ; newfargs := <?MatchArgs(args,wc);!args> fargs
    ; getWC := <?MatchArgs(args,wc);!wc> fargs
    ; if getWC := None() then
      newvars := vars
    else
      newvars := <take(<length> newfargs)> vars
    end
    //needs to "leak" dynamic rules of available vars for child rules
    ; <zip(try(dynamic-rule-check-vars ; extract-sort-from-arg) ; eq)> (newfargs,newvars)  //try because when failing will be treated as matching on expressions
    ; newcheck := <try(fix-var-names-in-check)> check
    ; rules (Used-AC-Rules:=<concat>[<Used-AC-Rules<+![]>,[acr]])

  dynamic-rule-check-vars:
    (Arg(ident1,thesort1),Arg(ident2,thesort2)) -> (Arg(ident1,thesort1),Arg(ident2,thesort2))
    where if <is-string> ident2 //string implies it was page/action/template argument
          then
            rules (FixVarsInCheck : Var(ident1) -> Var(ident2)) //in case of normal page/action/template arguments
          else
            rules (FixVarsInCheck : Var(ident1) -> ident2) //in case of an expr    
          end       

  fix-var-names-in-check:
    expr -> newexpr
    where newexpr:= <alltd(FixVarsInCheck)> expr

  extract-sort-from-arg:
    (Arg(ident1,thesort1),Arg(ident2,thesort2)) -> (thesort1,thesort2)

  generate-security-checks-from-target(|$acdclassname,vars,$acrulename):
    xs ->
          |[
              stat1*

              if ( e0= false )
              {
                goto(accessDenied());
              }
          ]|
      where numberedchecks := <add-indices> xs
          ; stat1* := <map(generate-security-checks-from-target-element(|$acrulename));concat> numberedchecks
          ; stat2* := <map(generate-security-checks-from-target-var)> vars
          ; e0 := <map(fix-var-name-in-check);generate-final-exp> numberedchecks

  generate-final-exp :
    [x|xs] ->  |[  $varname && e0  ]|
    where ($varname,_) := x
        ; e0 := <generate-final-exp> xs

  generate-final-exp :
    [x] -> Var($varname)
    where ($varname,_) := x

  fix-var-name-in-check:
    (index,anything) -> (newindex,anything)
    where newindex := <concat-strings> ["check",<int-to-string> index]

  generate-security-checks-from-target-element(|rulename):
    (index,expr) -> [ |[ var $varname : Bool := e0; ]| ]
    where $varname := <concat-strings> ["check",<int-to-string> index]
        ; $varnamecheck := <concat-strings> ["check",rulename,<int-to-string> index]
        ; $anyname := <newname> "accessControlCheckResult"
        ; e0 := <add-not-null-checks> expr

  add-not-null-checks:
    expr -> e0
    where e0 := <bottomup(try(match-any-bool-expr-and-add-null-checks))> expr
        //; <debug> "    apply-test(!\"generate-extended-check-test\"\n      ,generate-extended-check\n      ,!"
        //; <debug> expr
        //; <debug> "      ,!"
        //; <debug> e0
        //; <debug> "    )"

  match-any-bool-expr-and-add-null-checks:
    anyexp{Type(SimpleSort("Bool"))} -> newexp{Type(SimpleSort("Bool"))}
    where //must not contain other bool expressions otherwise not-null checks have already been made
          [] := <collect(\ anyexp{Type(SimpleSort("Bool"))} -> <id> \)> anyexp{}
        ; newe := <collect(ignore-certain-exp <+ field-access-to-not-null-checks-first);concat> anyexp
        // add not null check to left side of equality check, because of equals call
        //no longer needed with new equals code generation using a webdsl library function
        //; checkleftsideofequals := <collect(\ consname#([lhs,rhs]) -> NotEq(lhs,Null()) {Type(SimpleSort("Bool"))}
                                                           //where <?"Eq" <+ ?"NotEq"> consname
                                                               //; <?_{Type(lht)}> lhs
                                                               //  \)> anyexp
        ; if InColl(element,thecol) := anyexp
          then
            coll-not-null := <field-access-to-not-null-checks> thecol
          else
            coll-not-null := []
          end
        ; newexp := <concat;uniq;generate-conjunction-exp>[newe,coll-not-null,[anyexp]]//<concat;generate-conjunction-exp>[coll-not-null]//

  ignore-certain-exp :
    ForExp(_, _, _, _, _) -> []

  ignore-certain-exp :
    Call(_,_,_) -> []

  ignore-certain-exp :
    ThisCall(_,_) -> []

  field-access-to-not-null-checks-first:
    fa@FieldAccess(ent,prop)-> extrachecks
    where check := NotEq(fa,Null())
        ; if Var(varname) := ent // case of just one property access
        then
          checks := <not(IsGlobal);![ NotEq(Var(varname),Null()) {Type(SimpleSort("Bool"))},check] <+ ![check]> varname
        else
          checks := []
        end
        ; if newchecks := <field-access-to-not-null-checks> ent
        then
          return := <concat> [newchecks, checks]
        else
          return := checks
        end
        // add a loggedIn check when principal is used
        ; if fa:=FieldAccess(Var("securityContext"){Type(SimpleSort("SecurityContext"))},"principal"){Type(SimpleSort("User"))}
        then
        extrachecks := <concat>[ return, [|[ securityContext.loggedIn ]|] ]
        else
        extrachecks := return
        end

  field-access-to-not-null-checks:
    fa@FieldAccess(ent,prop)-> return
    where check := NotEq(fa,Null())
        ; if Var(varname) := ent
        then
          checks := <not(IsGlobal);![ NotEq(Var(varname),Null()) {Type(SimpleSort("Bool"))},check] <+ ![check]> varname
        else
          checks := [check]
        end
        ; if newchecks := <field-access-to-not-null-checks> ent
        then
          return := <concat> [newchecks, checks]
        else
          return := checks
        end

  generate-conjunction-exp :
    [x|xs] ->  And( e0 , e1 ) {Type(SimpleSort("Bool"))}
    where not([] := xs)
        ; e0 := x
        ; e1 := <generate-conjunction-exp> xs

  generate-conjunction-exp :
    [e0] -> |[ e0 ]|
    
  generate-disjunction-exp :
    [x|xs] ->  Or( e0 , e1 ) {Type(SimpleSort("Bool"))}
    where not([] := xs)
        ; e0 := x
        ; e1 := <generate-disjunction-exp> xs

  generate-disjunction-exp :
    [e0] -> |[ e0 ]|

  generate-security-checks-from-target-var:
    Arg($ident,_) -> |[ acdecision.$ident := $ident; ]|
