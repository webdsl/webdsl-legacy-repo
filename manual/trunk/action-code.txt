Action code
===========

Variable declaration
----------

Syntax:
<verbatim>var <identifier> : <Sort> [:= <expression>];</verbatim>

Defines a variable within the current scope with name *identifier* of
type *Sort*, with (optionally) initial value *expression*.


Statements
----------
**assignments**  
The syntax of an assignment:
<verbatim><variable> := <value expression>;</verbatim>

Example:

<verbatim>p.lastName := "Doe";</verbatim>


**if**  
The if-statement has the following syntax:

<verbatim>if(<expression>) {
   <block executed if true>
} [else {
   <block executed if false>
}]</verbatim>

If the expression is true the first block of code is executed, if it's
false, the second block is executed. The else block is
optional. Example:

<verbatim>if(user.lastName = "Doe") {
   msg := "You are unkown";
}</verbatim>

**for**  
The for-statement has the following syntax:


<verbatim>for(<identifier> : <Sort> in <expression> [where <condition>] [order by <expression>]) {
    <code to be executed repetitively>
}</verbatim>

pp*Note:* the implementation of *order by* is not stable yet.

Example:

<verbatim>
for(p : Person in persons where p.lastName = "Doe") {
   does.add(p)
}</verbatim>

**return**  
Syntax:

<verbatim>return <expression>;</verbatim>

Example:

<verbatim>return p.lastName;</verbatim>

In the context of a entity function this returns the expression as the
result of that function. In the context of an action definition, it
tells the action to redirect the user to the page specified in the
expression.

**goto**  
The goto statement (only allowed in the defintion of an action, not in function code) redirects the user to the specified page. Syntax:

<verbatim>goto <page>([params]);</verbatim>

Example:

<verbatim>goto editPage(p);</verbatim>

Expressions
-----------

**literals**  
A number of literals are supported:

* Strings: <tt>"This is a string"</tt>
* Ints: <tt>22</tt>
* Float: <tt>8.3</tt>
* Boolean: <tt>true</tt>/<tt>false</tt>
* List: <tt>[&lt;expression&gt;, &lt;expression&gt;, ...]</tt>
* Empty list: <tt>List&lt;Int&gt;()</tt>
* Set: <tt>{&lt;expression&gt;, &lt;expression&gt;, ...}</tt>
* Empty set: <tt>Set&lt;Int&gt;()</tt>
* Null: <tt>null</tt>

**operators**  
The following operators are supported:

* Addition (numeric types) and string concatenation: <tt>+</tt>
* Subtraction (numeric types): <tt>-</tt>
* Multiplication (numeric types): <tt>*</tt>
* Division (numeric types): <tt>/</tt>
* Modulus (integer type): <tt>%</tt>

**binary operators**  

* Equality: <tt>=</tt>
* Inequality: <tt>!=</tt>
* Bigger than: <tt>></tt>
* Bigger than or equal to: <tt>>=</tt>
* Smaller than: <tt><</tt>
* Smaller than or equal to: <tt><=</tt>
* Instance of: <tt>is a</tt> (checks if a certain expression is of a certain type)
* Contained in collection: <tt>in</tt> (checks if a certain expression is contained in a collection)
* and: <tt>&&</tt>
* or: <tt>||</tt>
* not: <tt>!</tt>

Example:
<verbatim>if(!(b > 3) && (b in [8, 5] || b + 3 = 7)) {
   // ...
}</verbatim>

**variables**  
Variables can be accessed by use of their identifiers and their properties using the . notation. Example: <tt>person.lastName</tt>

**list comprehensions**  
List comprehensions are a combination of mapping, filtering and sorting. Example:

<verbatim>[e.title
 for(e : BlogEntry in b.entries 
     where e.created > date 
     order by e.created desc)]</verbatim>

This expression returns all titles (<tt>e.title</tt>) from
<tt>b.entries</tt> where the time created (<tt>e.created</tt>) is
greater than a certain <tt>date</tt>, ordered by <tt>e.created</tt> in
descending order. Both the <tt>where</tt> and <tt>order by</tt>
clauses are optional. An ordering is either ascending (<tt>asc</tt>)
or descending (<tt>desc</tt>).