// Generated from interpreter/WebDSL.parser

package webdsl;

import beaver.Parser;
import beaver.ParsingTables;
import beaver.Scanner;
import beaver.Symbol;

/**
 * This class is a LALR parser generated by <a
 * href="http://beaver.sourceforge.net">Beaver</a> v0.9.4 from the grammar
 * specification "WebDSLParser.beaver".
 */
public class WebDSLParser extends Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short FOR = 1;
		static public final short LPAREN = 2;
		static public final short ID = 3;
		static public final short COLON = 4;
		static public final short IN = 5;
		static public final short RPAREN = 6;
		static public final short ACTION = 7;
		static public final short LBRACE = 8;
		static public final short RBRACE = 9;
		static public final short LT = 10;
		static public final short GT = 11;
		static public final short LT_SLASH = 12;
		static public final short IF = 13;
		static public final short THEN = 14;
		static public final short ELSE = 15;
		static public final short ENTITY = 16;
		static public final short DOT = 17;
		static public final short DEFINE = 18;
		static public final short VAR = 19;
		static public final short ASSIGN = 20;
		static public final short INVERSE = 21;
		static public final short SET = 22;
		static public final short ADDRESS = 23;
		static public final short LINK_PAGE = 24;
		static public final short REDIRECT = 25;
		static public final short OUTPUT = 26;
		static public final short DO = 27;
		static public final short BINDING_SCOPE = 28;
		static public final short MODULE = 29;
		static public final short EQUAL = 30;
		static public final short SEMICOLON = 31;
		static public final short COMMA = 32;
		static public final short STRING = 33;
		static public final short AS_EXP = 34;
		static public final short PAGE = 35;
		static public final short ELEMENTS = 36;
		static public final short ACCEPT_BIND = 37;

		static public final String[] NAMES = { "EOF", "FOR", "LPAREN", "ID",
				"COLON", "IN", "RPAREN", "ACTION", "LBRACE", "RBRACE", "LT",
				"GT", "LT_SLASH", "IF", "THEN", "ELSE", "ENTITY", "DOT",
				"DEFINE", "VAR", "ASSIGN", "INVERSE", "SET", "ADDRESS",
				"LINK_PAGE", "REDIRECT", "OUTPUT", "DO", "BINDING_SCOPE",
				"MODULE", "EQUAL", "SEMICOLON", "COMMA", "STRING", "AS_EXP",
				"PAGE", "ELEMENTS", "ACCEPT_BIND" };
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
			"U9pjMGUOLSKLFlFUsxVxzegmjDXPH8ei82XAisDbHH1BnB2YHet6669BD4OtjaHZeecA1PI"
					+ "si603bewK1GkYeCP25Inq42onOvdySyxCspVp7h2V7qc#B#uztvbp$ZF$$7VkVRDtxdiRBT"
					+ "VFmDxKpr03$Jtd6KOn3tzF8#5v#dNRUm0rizbShJbxcth3avIlt$QD2k2ju2CPlquDzLSKK"
					+ "KlR$vL#nFBY#ZlE9j7FuItqjteIOdlJMljEdFPaz2qbu7jGgVJod2HBwMyuMqn3uQVexNfn"
					+ "ODzO$vpHTYe4vtFeSYyhINQzVekpHLGFNa7rzQB0tXAd8eEer8obHwYnzBAIPFlIevozJ0V"
					+ "2JwNP#cNVg0dQnn7tOtGJJQ6Pm1$P$gzndS8hrbzpzXAobsXlsbk$5DX7g3T7$D8WQaxxq3"
					+ "x8FxEzdr9hc$rBVy9n8PGMwe$f8BI#VGR$0lwfGT3yWiUy9xtKHdziiuEfXBCNyNczgFz9p"
					+ "w3rZCw0byAlODIEYcaGNKCTR6yf3KzdfPmje9FXpUdFUe5lD0rU2Z#HKH$zDBJ6wLTj$oiq"
					+ "qMQl6HRi1Je9NehPln3OgwXFGto5qHFwIVsQVefEixq6SqO3wLhEdgTBu9VIvVfvt#XA#5N"
					+ "mtpBw7Tr0Vw2RgTpstaAtskmEkekpv#Xk#D$e7lsSR$Ht#FtmVp0QIIDe55NIuxPtF4srsN"
					+ "Jz1cVF4XathMzI5nU67AutAvkFE9$HVD#aBYuCgpJVuI2RXpYFqJpVf2uk3Aiqp#4WgqQiP"
					+ "bJjczJ5XM6LgXqEihc8SndDzKtguiAmIdCT3h8vY7COpV5DwkB2i4fp70wosOYp6StsJUhY"
					+ "mh1AinqEibc8inZDyatguiAmIhCS3hBfYDCPJVTDwkB2i4hJ7GwobOWh6QtqJUhYmh1AAnq"
					+ "EiYs8MnXjyKtguiAmIbiS3hBDY9iPRVPDwkB2i4gR7GwoJOYR66toJUhYmh1AcnmEies86n"
					+ "bjz4tguiAmIXiT3h8DY1iORV1DwkB2i4eR70wozOZh6QttJUhYmh1AwnqEidM8wnYjyqtgu"
					+ "iAmIkiS3hArY6iPhVLDwkB2i4fh7GwoDOXh6AtnJUhYmh1AQnmEijM8gncjzatguiAmIgiT"
					+ "3h9LYAiOhK8ytxHYKXSNXbLQvN2GhK1SmMY5Rr8N5uPLMk5ma2r1NC9eYMzI5nU6LLhYS91"
					+ "L8LOnga9iRrengOiBmofLEHna4n0dC9hWczJ5XM6L9ZWSPCiHbpDQxflKnOLXbPOx76JB49"
					+ "SnMkQRrCM5OPMMEHnaIn6NCbhgczJ5XM6LbZeSP1CH9pAQw9lKnOLXbIOw76HJ4ASmckARh"
					+ "PTAJuRI58U3R3pYU4RZVPEwk32iqdY7WsmSuZX6utoJkhWmhD8uXuDiBE9OHcDzaxguCApI"
					+ "M8U3h1Anab6bRr8N5uPLgdGuo2OZJcOqsJUfYml3AarsECZ688vXDCOtb9wKFekSakiDiz6"
					+ "8encDzatguiAmIgCT3h8An0f65Rv9NLmOLgd2uI0RXJYAqIZVRBrKUZAKHZaSPDCGfp6Qvf"
					+ "lKnOLXbQOv76HJgGUSgAEUwXlwqsvOB7EX81uHP0YTw50wZ3hJuNG4TQ6kr8swqv5q51rDn"
					+ "z2nT1mT3yx3jM3reC5KHXsfgNwVptecdKLdqpdqKpgN#jDvz3CmVa9xqL$GTndzYdv3$Z60"
					+ "Bg07wQ5QpQWsi$a5b9wWjcWRqVvexwM#T7h6#NhGC1fDJ$6SJ9PxphjpDbNUzVQbYxtPc6E"
					+ "Mn$ZFpQONbEGRmeVwGzUQAEuVjf8r6zHtUIuz0#DdM9qPOZPxXzSLrVJpKUeuT9$jUu0Uin"
					+ "NYCJdkYfufpfoPOf9RLQohT7u2$2BB#IkrfqFeHkuRuqRXk4w$wyR3RwSxwMdkBONtvEmsc"
					+ "kJEvtGn9bENMFUFlcxc74JNSQcdcKEDxe#Oso#B#qjoXt29Vise9xU6cxqgQbEvciBZzrcL"
					+ "FmNuXvrfI9RksApAX03$i3DDpjATaLK9Zrhewcrw6rOxjoPolbLlfJBJccS#MbFvG7#0tBH"
					+ "b74rbctuiyvdFZAqaptot6mYRxvD#rFJex7j6Zgs7i8razWXcZ#JAY5n3q6Ti1DjmhWpZod"
					+ "2k3Cinf0nzneQn3RKwfZBKL1ohPkuyPgWnUrNktARYM1AbTImJosoRgUaVqfyvth4onsUoi"
					+ "iVJ3iVxhQ8ux61aISgd0afH8KMq1zN3FbgV6b0HDSIUsXXP75bxiFQXVMa$x2mzgHaLKtDg"
					+ "WR47KKienS0nkq6er01A3Q4KPwKaymx1suCefJ0FKOfxIhdcv2ire7P0AU1mJZLApMgfLC1"
					+ "AyIobWzDA7LafiKEb3gnKn6CRvxXF2KHHAeHI7XYXKZ6KukavcVsr1tgSakbnLvUoId5hkP"
					+ "IQffMQKXDOAgsKf5PMoSoXHYd9PyizfsAhb49Md36dOgiKIoiLi5Bkgok29LcfZMLriKf5Q"
					+ "IN34QK4E4rpACMjKiokfyXgkQjBfg#kAEFgYbXhPrSNv#k9qgiWWebI2lCLfIHws$3L#aen"
					+ "ACNITpp1Qb7wwk9ffHX6YLAApvUjb8IIMTC5Tav7G2r6Urgb6DQ4A1s0FbRIck8QHwY4Idr"
					+ "u4HnAEds84cUin5cTKfrIdLATKfrIdLATKfrIdLATKftI3r8otssGb#nSYThmY98TAw7jJQ"
					+ "TJ7#fBPr2$7B$R3A0oSDhkceKP7OLl2oLqA2LP$GGwaKwYa#aKEfLwKIcT1eRv3TVCnln6l"
					+ "hVs3dpRE93Efu6rcL6jPjEMxqzhj9teKBIjpI$B6UThmxyob$2SaEMUy#wTZNUzmMpS9vLH"
					+ "#o$CnlmAWZRFVcOfUAI3GrPaZi#pk1RdIgzvHBjIaV5tKBEkkDueurn5RgLILxigpE$$l5A"
					+ "1YdTmLtAU1NazMyEwScSHhlscw$vscXkkEml$xIHpSeiCbsUVmNMwk1yPN5HsmlLrXHlEuS"
					+ "VAnTCcuCewOUHMXwoScYTYzkgiJIMjczRVPUN$uKnPZDhevdXIy6#ezdT6KyEE4zNmE4gj6"
					+ "37ZcM#UAFotZ6U#smsONMptnnJl1gcSSnLsUWol86RlpZ7epnfZzwYKpDfZnJsKxa#FiInF"
					+ "qxAuNsRZgGJp4LRcUClA79$9oXuVt8UCyPajLPTh$Ga#$pngWK#$3rr9bzDDT0UUwTVIpJI"
					+ "ObbCtUfFUfR6qZTwZnVG9VKxRQH8jf6#KAdYbS4tXLggYrVHTuHUgWTPgVzM26gbYTI3Tb#"
					+ "gKEfceu7iQH0$GJ7f7nLKRrLjThHvIizNxiMIi9DOtTbriIAmwjYwUKcNgAbMgOZGZEbUrL"
					+ "dTIo$nFrO1u1zKqkYALZ9yPlpx#MFpP#CR47ebEYNCIDoP695vGToUsfExAgq#z2hUf#$Cw"
					+ "v$LFdQs6H8DKvxoRLKLqjUgMLw76HBUgxdaByxQfIZLEzL2FHFSc6wedrRbgTAeiTOsgKay"
					+ "akoG7gEdHVUgqv2rgKcgucfgiL7DKDNLMpwi5XTlLSyb5KL7KE2g9Ej33qM3g5vqOdH8DLA"
					+ "tKg#e2zPgwK5siBbTlHAFKGFLYQchouzIY$2PgMJH1NP9wFxzxD2b$e2fNjwjvqLHQeEv8V"
					+ "Pb$Us6z$CVLAjpzjUKQxmOVb6jdj2TTAfb#cwulrmKDJ9w$e8RX6xMqSQbf2$Ogrwe9l33$"
					+ "jXsDsA5IBumV8Nb1GucfZtOs8lz1dEdAWlvehx7yhoGMAXiFoj2$3BWzPuCnueRynJLzXKT"
					+ "OnTMkKh0$j#kuEYFDwrypHZtAMeDipqNCRmJdSnPUWUmyn7l07CwLXvXXwYDvPDtnlpmkfG"
					+ "lm$6g7h1tsaVPufp9#D9v57Ib17L3lmF$NK$0OlcaezcFXnw7U2R4J$mTDiHyFxubnRH5tv"
					+ "PsXtHdnCFOuddyAEw327XZ7BfZ4ap2EVJ21dJ21lJ21NJ56n#2TfHN6jGAlDM9hnCFPpNzK"
					+ "p7SXjLlS$1#h2$Ixu9ozWK$77jG7vpuBy#gFjzA#g9s1EVL3$vcuLsUZrWtyRgXtPpV$qOd"
					+ "ZtLpXxJo1z$C4ti#JU4Clm3jw7jxIOtZ7LkpdesyWS5UCxmfy97kCBlmt4tqj00==");

	// Generated from interpreter/WebDSL.parser

	// to enable debugging, run a search in Parser.java for
	// pattern: "// ([a-z]+) = (.*)"
	// replacement: "match = debug(match, offset, "\1 = \2");"
	// and add the line "boolean match = true;" as needed
	private boolean debug(boolean match, int offset, String msg) {
		if (match) {
			System.out.println(msg);
			int count = -1;
			for (int i = 0; i < msg.length() - 1; i++)
				if (msg.charAt(i) == ' ')
					count++;
			for (int i = 0; i < count; i++) {
				Symbol sym = _symbols[offset + i + 1];
				System.out.println(sym.value.toString());
			}
			System.out.println("");
		}
		return false;
	}

	class Events extends Parser.Events {
		public void syntaxError(Symbol token) {
			StringBuffer s = new StringBuffer();
			s.append(token.getLine(token.getStart()) + ", "
					+ token.getColumn(token.getStart()) + "\n");
			s.append("  *** Syntactic error: unexpected token "
					+ Terminals.NAMES[token.getId()]);
			throw new Error(s.toString());
		}

		public void scannerError(Scanner.Exception e) {
			StringBuffer s = new StringBuffer();
			s.append(e.line + ", " + e.column + "\n");
			s.append("  *** Lexical error: " + e.getMessage());
			throw new Error(s.toString());
		}
	}

	{
		report = new Events();
	} // Use error handler in parser

	public WebDSLParser() {
		super(PARSING_TABLES);
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		switch (rule_num) {
		case 0: // Module = MODULE.MODULE ID.ID defList.defList
		{
			final Symbol MODULE = _symbols[offset + 1];
			final Symbol ID = _symbols[offset + 2];
			final Symbol _symbol_defList = _symbols[offset + 3];
			final List defList = (List) _symbol_defList.value;
			return new Module(((String) ID.value), defList);
		}
		case 1: // defList =
		{
			return new List();
		}
		case 2: // defList = defList.defList def.def
		{
			final Symbol _symbol_defList = _symbols[offset + 1];
			final List defList = (List) _symbol_defList.value;
			final Symbol _symbol_def = _symbols[offset + 2];
			final Definition def = (Definition) _symbol_def.value;
			return defList.add(def);
		}
		case 5: // Entity = ENTITY.ENTITY ID.ID LBRACE.LBRACE
			// PropertyList.PropertyList RBRACE.RBRACE
		{
			final Symbol ENTITY = _symbols[offset + 1];
			final Symbol ID = _symbols[offset + 2];
			final Symbol LBRACE = _symbols[offset + 3];
			final Symbol _symbol_PropertyList = _symbols[offset + 4];
			final List PropertyList = (List) _symbol_PropertyList.value;
			final Symbol RBRACE = _symbols[offset + 5];
			return new Entity(((String) ID.value), PropertyList);
		}
		case 6: // Property = ID.ID COLON.COLON Type.Type OptAnnot.OptAnnot
		{
			final Symbol ID = _symbols[offset + 1];
			final Symbol COLON = _symbols[offset + 2];
			final Symbol _symbol_Type = _symbols[offset + 3];
			final Type Type = (Type) _symbol_Type.value;
			final Symbol _symbol_OptAnnot = _symbols[offset + 4];
			final List OptAnnot = (List) _symbol_OptAnnot.value;
			return new Property(((String) ID.value), Type, OptAnnot);
		}
		case 7: // OptAnnot =
		{
			return new List();
		}
		case 8: // OptAnnot = LPAREN.LPAREN AnnotationList.AnnotationList
			// RPAREN.RPAREN
		{
			final Symbol LPAREN = _symbols[offset + 1];
			final Symbol _symbol_AnnotationList = _symbols[offset + 2];
			final List AnnotationList = (List) _symbol_AnnotationList.value;
			final Symbol RPAREN = _symbols[offset + 3];
			return AnnotationList;
		}
		case 9: // PropertyList = Property.Property
		{
			final Symbol _symbol_Property = _symbols[offset + 1];
			final Property Property = (Property) _symbol_Property.value;
			return new List().add(Property);
		}
		case 10: // PropertyList = PropertyList.PropertyList Property.Property
		{
			final Symbol _symbol_PropertyList = _symbols[offset + 1];
			final List PropertyList = (List) _symbol_PropertyList.value;
			final Symbol _symbol_Property = _symbols[offset + 2];
			final Property Property = (Property) _symbol_Property.value;
			return PropertyList.add(Property);
		}
		case 13: // Id = ID.ID
		{
			final Symbol ID = _symbols[offset + 1];
			return new Id(((String) ID.value));
		}
		case 14: // Inverse = INVERSE.INVERSE COLON.COLON ID.ID
		{
			final Symbol INVERSE = _symbols[offset + 1];
			final Symbol COLON = _symbols[offset + 2];
			final Symbol ID = _symbols[offset + 3];
			return new Inverse(((String) ID.value));
		}
		case 15: // AnnotationList = Annotation.Annotation
		{
			final Symbol _symbol_Annotation = _symbols[offset + 1];
			final Annotation Annotation = (Annotation) _symbol_Annotation.value;
			return new List().add(Annotation);
		}
		case 16: // AnnotationList = AnnotationList.AnnotationList COMMA.COMMA
			// Annotation.Annotation
		{
			final Symbol _symbol_AnnotationList = _symbols[offset + 1];
			final List AnnotationList = (List) _symbol_AnnotationList.value;
			final Symbol COMMA = _symbols[offset + 2];
			final Symbol _symbol_Annotation = _symbols[offset + 3];
			final Annotation Annotation = (Annotation) _symbol_Annotation.value;
			return AnnotationList.add(Annotation);
		}
		case 19: // SimpleType = ID.ID
		{
			final Symbol ID = _symbols[offset + 1];
			return new SimpleType(((String) ID.value));
		}
		case 20: // SetType = SET.SET LT.LT Type.Type GT.GT
		{
			final Symbol SET = _symbols[offset + 1];
			final Symbol LT = _symbols[offset + 2];
			final Symbol _symbol_Type = _symbols[offset + 3];
			final Type Type = (Type) _symbol_Type.value;
			final Symbol GT = _symbols[offset + 4];
			return new SetType(Type);
		}
		case 30: // OptExpList =
		{
			return new List();
		}
		case 31: // OptExpList = ExpList.ExpList
		{
			final Symbol _symbol_ExpList = _symbols[offset + 1];
			final List ExpList = (List) _symbol_ExpList.value;
			return ExpList;
		}
		case 32: // ExpList = Exp.Exp
		{
			final Symbol _symbol_Exp = _symbols[offset + 1];
			final Exp Exp = (Exp) _symbol_Exp.value;
			return new List().add(Exp);
		}
		case 33: // ExpList = ExpList.ExpList COMMA.COMMA Exp.Exp
		{
			final Symbol _symbol_ExpList = _symbols[offset + 1];
			final List ExpList = (List) _symbol_ExpList.value;
			final Symbol COMMA = _symbols[offset + 2];
			final Symbol _symbol_Exp = _symbols[offset + 3];
			final Exp Exp = (Exp) _symbol_Exp.value;
			return ExpList.add(Exp);
		}
		case 34: // StringLit = STRING.STRING
		{
			final Symbol STRING = _symbols[offset + 1];
			return new StringLit(((String) STRING.value).substring(1,
					((String) STRING.value).length() - 1));
		}
		case 35: // Var = ID.ID
		{
			final Symbol ID = _symbols[offset + 1];
			return new Var(((String) ID.value));
		}
		case 36: // PropertyAccess = Exp.Exp DOT.DOT ID.ID
		{
			final Symbol _symbol_Exp = _symbols[offset + 1];
			final Exp Exp = (Exp) _symbol_Exp.value;
			final Symbol DOT = _symbols[offset + 2];
			final Symbol ID = _symbols[offset + 3];
			return new PropertyAccess(Exp, ((String) ID.value));
		}
		case 37: // MethodCall = Exp.Exp DOT.DOT ID.ID LPAREN.LPAREN
			// OptExpList.OptExpList RPAREN.RPAREN
		{
			final Symbol _symbol_Exp = _symbols[offset + 1];
			final Exp Exp = (Exp) _symbol_Exp.value;
			final Symbol DOT = _symbols[offset + 2];
			final Symbol ID = _symbols[offset + 3];
			final Symbol LPAREN = _symbols[offset + 4];
			final Symbol _symbol_OptExpList = _symbols[offset + 5];
			final List OptExpList = (List) _symbol_OptExpList.value;
			final Symbol RPAREN = _symbols[offset + 6];
			return new MethodCall(Exp, ((String) ID.value), OptExpList);
		}
		case 38: // Constructor = ID.ID LBRACE.LBRACE RBRACE.RBRACE
		{
			final Symbol ID = _symbols[offset + 1];
			final Symbol LBRACE = _symbols[offset + 2];
			final Symbol RBRACE = _symbols[offset + 3];
			return new Constructor(((String) ID.value));
		}
		case 39: // Address = ADDRESS.ADDRESS LPAREN.LPAREN Exp.Exp
			// RPAREN.RPAREN
		{
			final Symbol ADDRESS = _symbols[offset + 1];
			final Symbol LPAREN = _symbols[offset + 2];
			final Symbol _symbol_Exp = _symbols[offset + 3];
			final Exp Exp = (Exp) _symbol_Exp.value;
			final Symbol RPAREN = _symbols[offset + 4];
			return new Address(Exp);
		}
		case 40: // LinkPage = LINK_PAGE.LINK_PAGE LPAREN.LPAREN Exp.Exp
			// RPAREN.RPAREN
		{
			final Symbol LINK_PAGE = _symbols[offset + 1];
			final Symbol LPAREN = _symbols[offset + 2];
			final Symbol _symbol_Exp = _symbols[offset + 3];
			final Exp Exp = (Exp) _symbol_Exp.value;
			final Symbol RPAREN = _symbols[offset + 4];
			return new LinkPage(Exp);
		}
		case 41: // Redirect = REDIRECT.REDIRECT LPAREN.LPAREN Exp.Exp
			// RPAREN.RPAREN
		{
			final Symbol REDIRECT = _symbols[offset + 1];
			final Symbol LPAREN = _symbols[offset + 2];
			final Symbol _symbol_Exp = _symbols[offset + 3];
			final Exp Exp = (Exp) _symbol_Exp.value;
			final Symbol RPAREN = _symbols[offset + 4];
			return new Redirect(Exp);
		}
		case 42: // AsExp = AS_EXP.AS_EXP Element.Element
		{
			final Symbol AS_EXP = _symbols[offset + 1];
			final Symbol _symbol_Element = _symbols[offset + 2];
			final Element Element = (Element) _symbol_Element.value;
			return new AsExp(Element);
		}
		case 43: // TemplateDef = DEFINE.DEFINE Mod.Mod ID.ID LPAREN.LPAREN
			// OptParamList.OptParamList RPAREN.RPAREN
			// ElementBlock.ElementBlock
		{
			final Symbol DEFINE = _symbols[offset + 1];
			final Symbol _symbol_Mod = _symbols[offset + 2];
			final List Mod = (List) _symbol_Mod.value;
			final Symbol ID = _symbols[offset + 3];
			final Symbol LPAREN = _symbols[offset + 4];
			final Symbol _symbol_OptParamList = _symbols[offset + 5];
			final List OptParamList = (List) _symbol_OptParamList.value;
			final Symbol RPAREN = _symbols[offset + 6];
			final Symbol _symbol_ElementBlock = _symbols[offset + 7];
			final Sequence ElementBlock = (Sequence) _symbol_ElementBlock.value;
			return new TemplateDef(((String) ID.value), Mod, OptParamList,
					ElementBlock);
		}
		case 44: // Mod =
		{
			return new List();
		}
		case 45: // Mod = PAGE.PAGE
		{
			final Symbol PAGE = _symbols[offset + 1];
			return new List().add(new Page());
		}
		case 46: // OptParamList =
		{
			return new List();
		}
		case 47: // OptParamList = ParamList.ParamList
		{
			final Symbol _symbol_ParamList = _symbols[offset + 1];
			final List ParamList = (List) _symbol_ParamList.value;
			return ParamList;
		}
		case 48: // ParamList = Param.Param
		{
			final Symbol _symbol_Param = _symbols[offset + 1];
			final Param Param = (Param) _symbol_Param.value;
			return new List().add(Param);
		}
		case 49: // ParamList = ParamList.ParamList COMMA.COMMA Param.Param
		{
			final Symbol _symbol_ParamList = _symbols[offset + 1];
			final List ParamList = (List) _symbol_ParamList.value;
			final Symbol COMMA = _symbols[offset + 2];
			final Symbol _symbol_Param = _symbols[offset + 3];
			final Param Param = (Param) _symbol_Param.value;
			return ParamList.add(Param);
		}
		case 50: // Param = ID.ID COLON.COLON Type.Type
		{
			final Symbol ID = _symbols[offset + 1];
			final Symbol COLON = _symbols[offset + 2];
			final Symbol _symbol_Type = _symbols[offset + 3];
			final Type Type = (Type) _symbol_Type.value;
			return new Param(((String) ID.value), Type);
		}
		case 69: // ElementBlock = LBRACE.LBRACE ElementList.ElementList
			// RBRACE.RBRACE
		{
			final Symbol LBRACE = _symbols[offset + 1];
			final Symbol _symbol_ElementList = _symbols[offset + 2];
			final Sequence ElementList = (Sequence) _symbol_ElementList.value;
			final Symbol RBRACE = _symbols[offset + 3];
			return ElementList;
		}
		case 70: // ElementList =
		{
			return new Sequence();
		}
		case 71: // ElementList = ElementList.ElementList Element.Element
		{
			final Symbol _symbol_ElementList = _symbols[offset + 1];
			final Sequence ElementList = (Sequence) _symbol_ElementList.value;
			final Symbol _symbol_Element = _symbols[offset + 2];
			final Element Element = (Element) _symbol_Element.value;
			ElementList.addElement(Element);
			return ElementList;
		}
		case 72: // String = STRING.STRING
		{
			final Symbol STRING = _symbols[offset + 1];
			return new StringElem(((String) STRING.value).substring(1,
					((String) STRING.value).length() - 1));
		}
		case 73: // ForElem = FOR.FOR LPAREN.LPAREN ID.ID COLON.COLON Type.Type
			// IN.IN Exp.Exp RPAREN.RPAREN Element.Element
		{
			final Symbol FOR = _symbols[offset + 1];
			final Symbol LPAREN = _symbols[offset + 2];
			final Symbol ID = _symbols[offset + 3];
			final Symbol COLON = _symbols[offset + 4];
			final Symbol _symbol_Type = _symbols[offset + 5];
			final Type Type = (Type) _symbol_Type.value;
			final Symbol IN = _symbols[offset + 6];
			final Symbol _symbol_Exp = _symbols[offset + 7];
			final Exp Exp = (Exp) _symbol_Exp.value;
			final Symbol RPAREN = _symbols[offset + 8];
			final Symbol _symbol_Element = _symbols[offset + 9];
			final Element Element = (Element) _symbol_Element.value;
			return new ForElem(((String) ID.value), Type, Exp, Element);
		}
		case 74: // ForAllElem = FOR.FOR LPAREN.LPAREN ID.ID COLON.COLON
			// Type.Type RPAREN.RPAREN Element.Element
		{
			final Symbol FOR = _symbols[offset + 1];
			final Symbol LPAREN = _symbols[offset + 2];
			final Symbol ID = _symbols[offset + 3];
			final Symbol COLON = _symbols[offset + 4];
			final Symbol _symbol_Type = _symbols[offset + 5];
			final Type Type = (Type) _symbol_Type.value;
			final Symbol RPAREN = _symbols[offset + 6];
			final Symbol _symbol_Element = _symbols[offset + 7];
			final Element Element = (Element) _symbol_Element.value;
			return new ForElem(((String) ID.value), Type, new ClassItem(Type),
					Element);
		}
		case 75: // VarDeclElem = VAR.VAR ID.ID COLON.COLON Type.Type
			// ASSIGN.ASSIGN Exp.Exp
		{
			final Symbol VAR = _symbols[offset + 1];
			final Symbol ID = _symbols[offset + 2];
			final Symbol COLON = _symbols[offset + 3];
			final Symbol _symbol_Type = _symbols[offset + 4];
			final Type Type = (Type) _symbol_Type.value;
			final Symbol ASSIGN = _symbols[offset + 5];
			final Symbol _symbol_Exp = _symbols[offset + 6];
			final Exp Exp = (Exp) _symbol_Exp.value;
			return new VarDeclElem(((String) ID.value), Type, Exp);
		}
		case 76: // Action = ACTION.ACTION ID.ID LPAREN.LPAREN
			// OptParamList.OptParamList RPAREN.RPAREN LBRACE.LBRACE
			// OptStatementList.OptStatementList RBRACE.RBRACE
		{
			final Symbol ACTION = _symbols[offset + 1];
			final Symbol ID = _symbols[offset + 2];
			final Symbol LPAREN = _symbols[offset + 3];
			final Symbol _symbol_OptParamList = _symbols[offset + 4];
			final List OptParamList = (List) _symbol_OptParamList.value;
			final Symbol RPAREN = _symbols[offset + 5];
			final Symbol LBRACE = _symbols[offset + 6];
			final Symbol _symbol_OptStatementList = _symbols[offset + 7];
			final List OptStatementList = (List) _symbol_OptStatementList.value;
			final Symbol RBRACE = _symbols[offset + 8];
			return new Action(((String) ID.value), OptParamList,
					OptStatementList);
		}
		case 77: // Call = ID.ID
		{
			final Symbol ID = _symbols[offset + 1];
			return new Call(((String) ID.value), new List(), new Sequence());
		}
		case 78: // CallArgs = ID.ID LPAREN.LPAREN OptExpList.OptExpList
			// RPAREN.RPAREN
		{
			final Symbol ID = _symbols[offset + 1];
			final Symbol LPAREN = _symbols[offset + 2];
			final Symbol _symbol_OptExpList = _symbols[offset + 3];
			final List OptExpList = (List) _symbol_OptExpList.value;
			final Symbol RPAREN = _symbols[offset + 4];
			return new Call(((String) ID.value), OptExpList, new Sequence());
		}
		case 79: // CallElems = ID.ID ElementBlock.ElementBlock
		{
			final Symbol ID = _symbols[offset + 1];
			final Symbol _symbol_ElementBlock = _symbols[offset + 2];
			final Sequence ElementBlock = (Sequence) _symbol_ElementBlock.value;
			return new Call(((String) ID.value), new List(), ElementBlock);
		}
		case 80: // CallFull = ID.ID LPAREN.LPAREN OptExpList.OptExpList
			// RPAREN.RPAREN ElementBlock.ElementBlock
		{
			final Symbol ID = _symbols[offset + 1];
			final Symbol LPAREN = _symbols[offset + 2];
			final Symbol _symbol_OptExpList = _symbols[offset + 3];
			final List OptExpList = (List) _symbol_OptExpList.value;
			final Symbol RPAREN = _symbols[offset + 4];
			final Symbol _symbol_ElementBlock = _symbols[offset + 5];
			final Sequence ElementBlock = (Sequence) _symbol_ElementBlock.value;
			return new Call(((String) ID.value), OptExpList, ElementBlock);
		}
		case 81: // XmlElem = LT.LT ID.ID OptXmlAttrList.OptXmlAttrList GT.GT
			// ElementList.ElementList LT_SLASH.LT_SLASH ID.ID_ GT.GT_
		{
			final Symbol LT = _symbols[offset + 1];
			final Symbol ID = _symbols[offset + 2];
			final Symbol _symbol_OptXmlAttrList = _symbols[offset + 3];
			final List OptXmlAttrList = (List) _symbol_OptXmlAttrList.value;
			final Symbol GT = _symbols[offset + 4];
			final Symbol _symbol_ElementList = _symbols[offset + 5];
			final Sequence ElementList = (Sequence) _symbol_ElementList.value;
			final Symbol LT_SLASH = _symbols[offset + 6];
			final Symbol ID_ = _symbols[offset + 7];
			final Symbol GT_ = _symbols[offset + 8];
			return new XmlElem(((String) ID.value), OptXmlAttrList, ElementList);
		}
		case 82: // OptXmlAttrList =
		{
			return new List();
		}
		case 83: // OptXmlAttrList = XmlAttrList.XmlAttrList
		{
			final Symbol _symbol_XmlAttrList = _symbols[offset + 1];
			final List XmlAttrList = (List) _symbol_XmlAttrList.value;
			return XmlAttrList;
		}
		case 84: // XmlAttrList = XmlAttr.XmlAttr
		{
			final Symbol _symbol_XmlAttr = _symbols[offset + 1];
			final XmlAttr XmlAttr = (XmlAttr) _symbol_XmlAttr.value;
			return new List().add(XmlAttr);
		}
		case 85: // XmlAttrList = XmlAttrList.XmlAttrList XmlAttr.XmlAttr
		{
			final Symbol _symbol_XmlAttrList = _symbols[offset + 1];
			final List XmlAttrList = (List) _symbol_XmlAttrList.value;
			final Symbol _symbol_XmlAttr = _symbols[offset + 2];
			final XmlAttr XmlAttr = (XmlAttr) _symbol_XmlAttr.value;
			return XmlAttrList.add(XmlAttr);
		}
		case 86: // XmlAttr = ID.ID EQUAL.EQUAL Exp.Exp
		{
			final Symbol ID = _symbols[offset + 1];
			final Symbol EQUAL = _symbols[offset + 2];
			final Symbol _symbol_Exp = _symbols[offset + 3];
			final Exp Exp = (Exp) _symbol_Exp.value;
			return new XmlAttr(((String) ID.value), Exp);
		}
		case 87: // Elements = ELEMENTS.ELEMENTS
		{
			final Symbol ELEMENTS = _symbols[offset + 1];
			return new Elements();
		}
		case 88: // OutputElem = OUTPUT.OUTPUT LPAREN.LPAREN Exp.Exp
			// RPAREN.RPAREN
		{
			final Symbol OUTPUT = _symbols[offset + 1];
			final Symbol LPAREN = _symbols[offset + 2];
			final Symbol _symbol_Exp = _symbols[offset + 3];
			final Exp Exp = (Exp) _symbol_Exp.value;
			final Symbol RPAREN = _symbols[offset + 4];
			return new OutputElem(Exp);
		}
		case 89: // Do = DO.DO LBRACE.LBRACE Element.Element RBRACE.RBRACE
		{
			final Symbol DO = _symbols[offset + 1];
			final Symbol LBRACE = _symbols[offset + 2];
			final Symbol _symbol_Element = _symbols[offset + 3];
			final Element Element = (Element) _symbol_Element.value;
			final Symbol RBRACE = _symbols[offset + 4];
			return new Do(Element);
		}
		case 90: // IfThen = IF.IF LPAREN.LPAREN Exp.Exp RPAREN.RPAREN THEN.THEN
			// Element.ThenPart
		{
			final Symbol IF = _symbols[offset + 1];
			final Symbol LPAREN = _symbols[offset + 2];
			final Symbol _symbol_Exp = _symbols[offset + 3];
			final Exp Exp = (Exp) _symbol_Exp.value;
			final Symbol RPAREN = _symbols[offset + 4];
			final Symbol THEN = _symbols[offset + 5];
			final Symbol _symbol_ThenPart = _symbols[offset + 6];
			final Element ThenPart = (Element) _symbol_ThenPart.value;
			return new IfThen(Exp, ThenPart);
		}
		case 91: // IfThenElse = IF.IF LPAREN.LPAREN Exp.Exp RPAREN.RPAREN
			// THEN.THEN Element.ThenPart ELSE.ELSE Element.ElsePart
		{
			final Symbol IF = _symbols[offset + 1];
			final Symbol LPAREN = _symbols[offset + 2];
			final Symbol _symbol_Exp = _symbols[offset + 3];
			final Exp Exp = (Exp) _symbol_Exp.value;
			final Symbol RPAREN = _symbols[offset + 4];
			final Symbol THEN = _symbols[offset + 5];
			final Symbol _symbol_ThenPart = _symbols[offset + 6];
			final Element ThenPart = (Element) _symbol_ThenPart.value;
			final Symbol ELSE = _symbols[offset + 7];
			final Symbol _symbol_ElsePart = _symbols[offset + 8];
			final Element ElsePart = (Element) _symbol_ElsePart.value;
			return new IfThenElse(Exp, ThenPart, ElsePart);
		}
		case 92: // BindingScope = BINDING_SCOPE.BINDING_SCOPE LPAREN.LPAREN
			// Exp.Exp RPAREN.RPAREN Element.Element
		{
			final Symbol BINDING_SCOPE = _symbols[offset + 1];
			final Symbol LPAREN = _symbols[offset + 2];
			final Symbol _symbol_Exp = _symbols[offset + 3];
			final Exp Exp = (Exp) _symbol_Exp.value;
			final Symbol RPAREN = _symbols[offset + 4];
			final Symbol _symbol_Element = _symbols[offset + 5];
			final Element Element = (Element) _symbol_Element.value;
			return new BindingScope(Exp, Element);
		}
		case 93: // AcceptBind = ACCEPT_BIND.ACCEPT_BIND Exp.Exp
		{
			final Symbol ACCEPT_BIND = _symbols[offset + 1];
			final Symbol _symbol_Exp = _symbols[offset + 2];
			final Exp Exp = (Exp) _symbol_Exp.value;
			return new AcceptBind(Exp);
		}
		case 96: // Assign = Exp.Target ASSIGN.ASSIGN Exp.Source
			// SEMICOLON.SEMICOLON
		{
			final Symbol _symbol_Target = _symbols[offset + 1];
			final Exp Target = (Exp) _symbol_Target.value;
			final Symbol ASSIGN = _symbols[offset + 2];
			final Symbol _symbol_Source = _symbols[offset + 3];
			final Exp Source = (Exp) _symbol_Source.value;
			final Symbol SEMICOLON = _symbols[offset + 4];
			return new Assign(Target, Source);
		}
		case 97: // ExpStat = Exp.Exp SEMICOLON.SEMICOLON
		{
			final Symbol _symbol_Exp = _symbols[offset + 1];
			final Exp Exp = (Exp) _symbol_Exp.value;
			final Symbol SEMICOLON = _symbols[offset + 2];
			return new ExpStat(Exp);
		}
		case 98: // OptStatementList =
		{
			return new List();
		}
		case 99: // OptStatementList = StatementList.StatementList
		{
			final Symbol _symbol_StatementList = _symbols[offset + 1];
			final List StatementList = (List) _symbol_StatementList.value;
			return StatementList;
		}
		case 100: // StatementList = Statement.Statement
		{
			final Symbol _symbol_Statement = _symbols[offset + 1];
			final Statement Statement = (Statement) _symbol_Statement.value;
			return new List().add(Statement);
		}
		case 101: // StatementList = StatementList.StatementList
			// Statement.Statement
		{
			final Symbol _symbol_StatementList = _symbols[offset + 1];
			final List StatementList = (List) _symbol_StatementList.value;
			final Symbol _symbol_Statement = _symbols[offset + 2];
			final Statement Statement = (Statement) _symbol_Statement.value;
			return StatementList.add(Statement);
		}
		case 3: // def = Entity.Entity
		case 4: // def = TemplateDef.TemplateDef
		case 11: // Annotation = Id.Id
		case 12: // Annotation = Inverse.Inverse
		case 17: // Type = SimpleType.SimpleType
		case 18: // Type = SetType.SetType
		case 21: // Exp = StringLit.StringLit
		case 22: // Exp = Var.Var
		case 23: // Exp = PropertyAccess.PropertyAccess
		case 24: // Exp = MethodCall.MethodCall
		case 25: // Exp = Constructor.Constructor
		case 26: // Exp = AsExp.AsExp
		case 27: // Exp = Address.Address
		case 28: // Exp = LinkPage.LinkPage
		case 29: // Exp = Redirect.Redirect
		case 51: // Element = String.String
		case 52: // Element = ForElem.ForElem
		case 53: // Element = ForAllElem.ForAllElem
		case 54: // Element = Call.Call
		case 55: // Element = CallArgs.CallArgs
		case 56: // Element = CallElems.CallElems
		case 57: // Element = CallFull.CallFull
		case 58: // Element = VarDeclElem.VarDeclElem
		case 59: // Element = XmlElem.XmlElem
		case 60: // Element = Elements.Elements
		case 61: // Element = ElementBlock.ElementBlock
		case 62: // Element = OutputElem.OutputElem
		case 63: // Element = Do.Do
		case 64: // Element = Action.Action
		case 65: // Element = IfThen.IfThen
		case 66: // Element = IfThenElse.IfThenElse
		case 67: // Element = BindingScope.BindingScope
		case 68: // Element = AcceptBind.AcceptBind
		case 94: // Statement = Assign.Assign
		case 95: // Statement = ExpStat.ExpStat
		{
			return _symbols[offset + 1];
		}
		default:
			throw new IllegalArgumentException("unknown production #"
					+ rule_num);
		}
	}
}
