module DomainMigration
imports
	DomainTransformationSyntax
	DomainTransformation
	IntermediateTypes
	liblib
	libjava-front
	Desugar
	org/webdsl/dsl/generation/java-code
	org/webdsl/dsl/transformation/types
	org/webdsl/dsl/syntax/parse-webdsl
	org/webdsl/dsl/transformation/desugar
	org/webdsl/dsl/builtins/builtins-desugar
	org/webdsl/dsl/generation/generator

strategies
	main-DomainMigration = 
		io-wrap(constructMigration(|"webdslorg0", "webdslorg1"))
	
	
	
	constructMigration(|persistenceUnit0, persistenceUnit1) =
		prepare;
		?Transformer(originalTypeSet, transformations);
		
		// Construct domain 0
		info(|"constructing source domain");
		rules (	DomainPackage :=  PackageName([Id("domain_0")]));
		!originalTypeSet;
		(alltd(declare-entity)										<+ error(|"Unable to declare source domain entities"));		
		(alltd(entity-to-java-Entity)								<+ error(|"Unable to translate entity to java entity"));
		(alltd(java-file-to-file)									<+ error(|"Cannot write java to file (while constructing source domain)"));
		
		// Construct domain 1
		info(|"constructing target domain");
		rules (	DomainPackage :=  PackageName([Id("domain_1")]));
		!(originalTypeSet, transformations);
		(transform	 								 				<+ error(|"Unable to apply transformations to domain"));
		(alltd(declare-entity) 										<+ error(|"Unable to declare target domain entities"));
		(map(entity-to-java-Entity)									<+ error(|"Unable to translate entity to java entity"));
		(map(java-file-to-file)			 							<+ error(|"Cannot write java to file (while constructing target domain)"));
		
		// Construct migration (intermediate  types and migration itself)
		rules (	DomainPackage :=  PackageName([Id("migration")]));
		info(|"deriving and constructing intermediate types");
			// Ugly hack - view all target types as intermediate types, because the entity to java cannot process package names (only used for entity definitions that refer to target type in generic types)
			<alltd(entity-to-java-Entity; risky(java-file-to-file | "Cannot write java to file (while constructing domain 1 to be used as intermediate types)"))> originalTypeSet;
		<handleIntermediateTypes(|originalTypeSet)> transformations;
		info(|"constructing migrator");
		constructCustomMigrator(|persistenceUnit0, persistenceUnit1);
		info(|"migration generated");
		!""
	
	prepare = 
		info(|"importing modules");
		importModulesInTransformer;
		info(|"desugaring domain");
		desugarDomain;
		info(|"desugaring transformations");
		desugarTransformations
	
	importModulesInTransformer : 
		Transformer(originalTypeSet, transformations) -> Transformer(<import-modules> originalTypeSet, transformations)
	
	constructCustomMigrator(|persistenceUnit0, persistenceUnit1) = 
		map(constructTransformers(|"emf1", "domain_0", "domain_1")); 
		surroundWithDefaultFunctionality(|persistenceUnit0, persistenceUnit1);
		risky(java-file-to-file | "Cannot write java to file")
	
	surroundWithDefaultFunctionality(|persistenceUnit0, persistenceUnit1) :
		migrators -> JavaFile(["src"],
		compilation-unit|[
			package pkgname;
			
			import transformation.*;
			import transformation.hibernate.*;
			import javax.persistence.*;
			
			public class CustomMigrator {
				
				public static void main(String[] args)
				{
					System.out.println("Starting migration");
					EntityManagerFactory emf0 = Persistence.createEntityManagerFactory("~persistenceUnit0");
					EntityManagerFactory emf1 = Persistence.createEntityManagerFactory("~persistenceUnit1");
					
					try {
						HibernateTransFormerClassPair[] migrators = ~migratorsArrayInit;
						CombinedHibernateMigrator hmig = new CombinedHibernateMigrator(emf0, emf1, migrators);
						
						hmig.migrate();
					} catch (TransformationException ex) {
						ex.printStackTrace();
					}
					
					emf0.close();
					emf1.close();
					System.out.println("Migration completed");
				}
			}
		]| )
		where 
			!ArrayInit(migrators) => migratorsArrayInit;
			pkgname := <DomainPackage>
	
	constructTransformers(|targetSessionFactory, oldDomainPackage, newDomainPackage) = 
		// TODO Remove any transformations that do not have injections in advance (transformation of these is only relevant at data-model level)
		innermost(
			emptyEntityToMigration + 
			injectionToMigration(|oldDomainPackage) + 
			propertyAdditionToMigration +
			propertyRemovalToMigration +
			elevateAttributeOverReferenceToMigration +
			propertyNameChangeToMigration + 
			propertySimpleTypeChangeToMigration +
			propertyReferenceTypeChangeToMigration(|targetSessionFactory, oldDomainPackage, newDomainPackage) +
			ejectionToMigration(|newDomainPackage) +
			mergeToMigration + 
			relatedMergeToMigration
		)
	
	emptyEntityToMigration : 
		EmptyEntity() -> 
			|[ new EmptyObject() ]|
			
	injectionToMigration(|oldDomainPackage) : 
		Injection(entityId) -> 
			|[ new Injection(~x:oldDomainPackage.~x:entityId.class) ]|
	
	propertyAdditionToMigration : 
		PropertyAddition(itrafo, propertyName, _, defaultValue) -> 
			|[ new AddAttribute("~propertyName", ~defaultValueExpression, ~itrafo) ]|
		where <expression-to-java> defaultValue => defaultValueExpression
	
	propertyRemovalToMigration :
		PropertyRemoval(itrafo, propertyName) ->
			|[ new DropAttribute("~propertyName", ~itrafo) ]|
			
	elevateAttributeOverReferenceToMigration : 
		ElevateAttributeOverReference(itrafo, refName, attName) -> 
			|[ new ElevateAttributeOverReference("~attName", "~refName", ~itrafo) ]|
	
	propertyNameChangeToMigration :
		PropertyNameChange(itrafo, oldName, newName) -> 
			|[ new AttributeNameChange("~oldName", "~newName", ~itrafo) ]|
			
	propertySimpleTypeChangeToMigration :
		PropertySimpleTypeChange(itrafo, name, newType) -> 
			|[ new AttributeConversion("~name", ~typeConversion, ~itrafo) ]|
		where <getTypeConversion> newType => typeConversion
	
	// Normal reference
	propertyReferenceTypeChangeToMigration(|targetSessionFactory, oldDomainPackage, newDomainPackage) :
		PropertyReferenceTypeChange(itrafo, name, SimpleSort(newType), trafo) -> // TODO targetSession
			|[ new AttributeTransformation(
					"~name",
					new HibernateTransformer(~trafoInJava, ~x:newDomainPackage.~x:newType.class, ~x:targetSessionFactory),
					~itrafo
				)
			]|
		where
			<constructTransformers(|targetSessionFactory, oldDomainPackage, newDomainPackage)> trafo => trafoInJava	// trafo is a Transformation, so no ejection

	// Generic type reference (requires distinction because of Hibernate)
	propertyReferenceTypeChangeToMigration(|targetSessionFactory, oldDomainPackage, newDomainPackage) :
		PropertyReferenceTypeChange(itrafo, name, GenericSort(List, [SimpleSort(newGenericArgType)]), trafo) ->
			|[ new AttributeTransformation(
					"~name",
					new HibernateTransformationMapping(
						java.util.List.class,
						new HibernateTransformer(~trafoInJava, ~x:newDomainPackage.~x:newGenericArgType.class, ~x:targetSessionFactory)
					),
					~itrafo
				)
			]|
		where
			<constructTransformers(|targetSessionFactory, oldDomainPackage, newDomainPackage)> trafo => trafoInJava	// trafo is a Transformation, so no ejection
			
	ejectionToMigration(|newDomainPackage) : 
		Ejection(itrafo, newName) -> 
			|[ new HibernateTransFormerClassPair(~itrafo, ~x:newDomainPackage.~x:newName.class) ]|
	
	mergeToMigration :
		Merge(itrafo, slavetrafo) ->
			|[ new Merge(~slavetrafo, ~itrafo) ]|
	
	relatedMergeToMigration : 
		RelatedMerge(
			itrafo, 
			Function(_, [Arg(arg1, SimpleSort(argType1)), Arg(arg2, SimpleSort(argType2))], SimpleSort("Bool"), relationDef), 
			slavetrafo
		) 
		->
		|[ 
			new RelatedMerge (
				new BinaryRelation <~x:argType1, ~x:argType2>(){public boolean relate(~x:argType1 ~x:arg1, ~x:argType2 ~x:arg2){ ~javaRelation }},
				new BeanTransformer(~slavetrafo, ~x:argType2.class),
				new BeanTransformer(~itrafo, ~x:argType1.class)
			)
		]|
		where
			{|
				InFunction : 
				rules(InFunction : _ -> <id>);	// to make sure the translation below is seen as function translation
				javaRelation := <statement-to-java> relationDef
			|}
	
	/* ---- Auxiliary strategies ---- */
	error(|msg) = 
		log(|Error(), msg, <id>)
	
	getTypeConversion : 
		String -> |[ PrimitiveTypeConversions.selectByName("toString") ]|