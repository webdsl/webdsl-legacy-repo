module DomainTransformation
imports
	DomainTransformationSyntax 
	liblib
	Desugar

strategies
// WebDSL and transformation syntax integration
/*	transform : 
		// Select the transformations first (we no longer need the type information, or any of that kind)
		sections -> <collect-all-transformations; applyTransformation> injectionLessSections
		where
		{|	SubstituteInjection :
			alltd(injectionConstruction);
			injectionLessSections := outermost(SubstituteInjection)
		|}
		
	collect-all-transformations = 
		collect-all(?Ejection(_, _))
*/
	transform : 
		Transformer(sections, transformations) -> <transform>(sections, transformations)
	
	transform : 
		(sections, transformations) -> <map(innermost(SubstituteInjection); applyTransformation)> transformations
			where 
				<is-list> transformations;
				// TODO use collect withou the collecting part (result of collect not required
				<collect-all(injectionConstruction)> sections	// collect is required, because the list of entities is actually a list of Sections
	
	transform : 
		(sections, transformation) -> <innermost(SubstituteInjection); applyTransformation> transformation
			where
				<not(is-list)> transformation;
				// TODO Same as above
				<collect-all(injectionConstruction)> sections 	// collect is required, because the list of entities is actually a list of Sections
	
	injectionConstruction : 
		EntityNoSuper(entityName, properties, functions) -> EntityNoSuper(entityName, properties, functions)
			where rules(SubstituteInjection : Injection(entityName) ->  EntityNoSuper(entityName, properties, functions))

	applyTransformation = 
		innermost(
			emptyEntityRewrite + 
			ejectionRewrite +
			propertyRemoval +
			propertyAdditionDefaultValue +
			propertyAddition +
			elevateAttributeOverReference +
			propertyNameChange +
			propertySimpleTypeChange +
			propertyReferenceTypeChange +
			restrict +
			merge +
			relatedMerge
		)
		
	/****************************** Level 0 ******************************/
	emptyEntityRewrite : 
		EmptyEntity() ->
			EntityNoSuper(<getType>, [], [])	// Name should be overwritten anyway

	/****************************** Level 1 ******************************/
	/** Entity modifications **/
	ejectionRewrite : 
		Ejection(EntityNoSuper(entityName, properties, functions), newEntityName) ->
			EntityNoSuper(newEntityName, properties, functions)
	
	propertyAdditionDefaultValue :
		PropertyAdditionDefaultValue(EntityNoSuper(entityName, properties, functions), propertyName, sort, defValue) ->	
			PropertyAddition(EntityNoSuper(entityName, properties, functions), propertyName, sort, defValue)
	
	propertyAddition :
		PropertyAddition(EntityNoSuper(entityName, properties, functions), propertyName, sort,_) -> // Calculation will be ignored for now (cannot be used as part of the domain model)
			EntityNoSuper(entityName, <conc>(properties, [Property(propertyName, Simple(), sort, [])]) , functions)
	
	propertyRemoval :
		PropertyRemoval(EntityNoSuper(entityName, properties, functions), propertyName) ->
			EntityNoSuper(entityName, <remove-all(?Property(propertyName, _, _, _))> properties, functions)
			
	elevateAttributeOverReference : 
		ElevateAttributeOverReference(EntityNoSuper(entityName, properties, functions), refName, attName) -> 
			EntityNoSuper(entityName, <conc> (properties, propertyToElevate), functions)
		where <fetch(?Property(propertyName, _, _, _))> properties => propertyToElevate
	
	/** Property modifications **/
	propertyNameChange :
		PropertyNameChange(EntityNoSuper(entityName, properties, functions), oldName, newName) ->
			EntityNoSuper(entityName, newProperties, functions)
			where 
			{|	ChangePropertyName : 
				rules(
					ChangePropertyName : Property(oldName, kind, sort, annos) ->  Property(newName, kind, sort, annos) );
				newProperties := <map(try(ChangePropertyName))> properties
			|}
				
	propertySimpleTypeChange :
		PropertySimpleTypeChange(EntityNoSuper(entityName, properties, functions), name, newSort) ->
			EntityNoSuper(entityName, newProperties, functions)
			where 
			{|	ChangeSimplePropertyType : 
				rules(
					ChangeSimplePropertyType : Property(name, kind, _, annos) ->  Property(name, kind, newSort, annos) );
				newProperties := <map(try(ChangeSimplePropertyType))> properties
			|}
	
	propertyReferenceTypeChange :
		PropertyReferenceTypeChange(EntityNoSuper(entityName, properties, functions), name, newSort, _) ->
			EntityNoSuper(entityName, newProperties, functions)
			where
			{|	ChangeReferencePropertyType : 
				rules(
					ChangeReferencePropertyType : Property(name, kind, _, annos) ->  Property(name, kind, newSort, annos) );
				newProperties := <map(try(ChangeReferencePropertyType))> properties
			|}
			
	restrict :
		Restrict(e, _) -> e
	
	/****************************** Level 2 ******************************/	
	merge :
		Merge(EntityNoSuper(entityName, masterProperties, functions), EntityNoSuper(_, [slaveProperty|slavePropertiesTail], _)) ->
			Merge(EntityNoSuper(entityName, newProperties, functions), EntityNoSuper(entityName,  slavePropertiesTail, []))
		where
			<mergeElementAndList(|slaveProperty)> masterProperties => newProperties
	merge :
		Merge(EntityNoSuper(entityName, masterProperties, functions), EntityNoSuper(_, [], _)) ->
			EntityNoSuper(entityName, masterProperties, functions)
			
	relatedMerge :
		RelatedMerge(e1, _, e2) -> Merge(e1, e2)

	/****************************** Auxiliary ******************************/	
	mergeElementAndList(|element) : list -> list
		where <elem> (element, list)
	mergeElementAndList(|element) : list -> [element|list]
		where not(<elem> (element, list))
	
			
			