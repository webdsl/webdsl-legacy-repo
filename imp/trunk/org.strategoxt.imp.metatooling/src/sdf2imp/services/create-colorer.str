/**
 * sdf2imp concrete token colorer generator.
 *
 *
 * @author Lennart Kats <lennart add lclnet.nl>
 */
module sdf2imp/services/create-colorer

imports
  libstratego-lib
  
  sdf2imp/util/-
  sdf2imp/services/common

strategies

  read-colorer =
    <input-descriptor-file> <main-descriptor-name>;
    
    collect-all(?Colorer(_, <id>));
    
    concat
  
  // "all" rules override any existing coloring style
  descriptor-rule-to-java-1:
    RuleAll(condition, color, bgcolor, font) ->
    |[ if (e_Condition) return noWhitespaceBackground(mergeStyles(x_Style, result), (IToken) token); ]|
    where
      e_Condition := <condition-to-java> condition;
      x_Style     := <create-style(|color, bgcolor, font)>
  
  // constructor/sort rules override token rules
  descriptor-rule-to-java-2:
    Rule(condition @ <not(?Token(_))>, color, bgcolor, font) ->
    |[ if (!otherThanTokenSet && e_Condition) {
         otherThanTokenSet = true;
         result = noWhitespaceBackground(mergeStyles(x_Style, result), (IToken) token);
         break out;
       }
     ]|
    where
      e_Condition := <condition-to-java> condition;
      x_Style := <create-style(|color, bgcolor, font)>
  
  // TODO2 - Optimize - token rules could use a switch
  
  // token rules don't get to override anything
  descriptor-rule-to-java-3:
    Rule(condition @ Token(_), color, bgcolor, font) ->
    |[ if (e_Condition) { result = x_Style; break out; } ]|
    where
      e_Condition := <condition-to-java> condition;
      x_Style := <create-style(|color, bgcolor, font)>

  create-style(|color, bgcolor, font) =
    e_Color     := <color-to-java> color;
    e_BGColor   := <color-to-java> bgcolor;
    e_Font      := <font-to-java> font;
    x_Style     := <newname> "style";
    
    rules(
      TokenStyles :+= |[
        private final TextAttribute x_Style =
          new TextAttribute(e_Color, e_BGColor, e_Font);
      ]|
    )
  
  color-to-java:
    ColorName(x) -> |[ display.getSystemColor(SWT.x_Name) ]|
    where
      x_Name := <conc-strings> ("COLOR_", <write-to-string> x)
  
  color-to-java:
    ColorDefault() -> |[ null ]|
    
  color-to-java:
    ColorRGB(r,g,b) -> |[ new Color(display, ~i:r, ~i:g, ~i:b) ]|
  
  font-to-java:
    x -> |[ SWT.x_Name ]|
    where x_Name := <write-to-string> x

  create-colorer =
    x_Name  := <conc-strings> (<get-main-class-name>, "TokenColorer");
    pkgname := <get-package-name(|["tokenColorer"])>;
    
    {| TokenStyles:
      colorer := <read-colorer>;
      ifs1    := <filter(descriptor-rule-to-java-1)> colorer;
      ifs2    := <filter(descriptor-rule-to-java-2)> colorer;
      ifs3    := <filter(descriptor-rule-to-java-3)> colorer;
      decls   := <bagof-TokenStyles>
    |};
    
    <output-java-file> |[
      package pkgname;
      
      import org.eclipse.imp.parser.IParseController;
      import org.eclipse.imp.services.ITokenColorer;
      import org.eclipse.imp.services.base.TokenColorerBase;
      import org.eclipse.jface.text.IRegion;
      import org.eclipse.jface.text.TextAttribute;
      import org.eclipse.swt.SWT;
      import org.eclipse.swt.widgets.Display;
      import org.eclipse.swt.graphics.Color;
      
      import org.strategoxt.imp.runtime.parser.ast.AstNode;
      import org.strategoxt.imp.runtime.parser.tokens.SGLRToken;
      import static org.strategoxt.imp.runtime.parser.tokens.SGLRParsersym.*;
      
      import lpg.runtime.IToken;
      
      @SuppressWarnings("unused")
      public class x_Name extends TokenColorerBase {
        private Display display = Display.getDefault();
        
        ~*decls
      
        public TextAttribute getColoring(IParseController controller, Object token) {
          TextAttribute result = null;
          boolean otherThanTokenSet = false;

          AstNode node = ((SGLRToken) token).getAstNode();
          final int tokenKind = ((SGLRToken) token).getKind();
          String sort = node == null ? null : node.getSort();
          String constructor = node == null ? null : node.getConstructor();
          
          out: { ~*ifs3 }
          out: { ~*ifs2 }
          
          // TODO2: Optimize - color selection loop
          do {
            ~*ifs1
            
            otherThanTokenSet = result != null; // don't override the color from outer sorts
            
            if (node == null) break;
            
            sort = node.getSort();
            constructor = node.getConstructor();
            
          } while ((node = node.getParent()) != null);
          
          if (result != null) return result;

          return super.getColoring(controller, ((IToken)token));
        }
        
        // TODO2: Optimize - don't create new TextAttributes at runtime
        
        // TODO: Allow overriding of colors and text attributes?
        private TextAttribute mergeStyles(TextAttribute master, TextAttribute slave) {
          if (slave == null)
            return master;
          
          Color fg = master.getForeground();
          Color bg = master.getBackground();
          
          if (fg == null || bg == null) {
            return new TextAttribute(
              fg == null ? slave.getForeground() : fg,
              bg == null ? slave.getBackground() : bg,
              master.getStyle()
            );
          } else {
            return master;
          }
        }
        
        private TextAttribute noWhitespaceBackground(TextAttribute attribute, IToken token) {
          if (attribute.getBackground() == null) {
            return attribute;
          } else if (token.toString().contains("\n")) { // TODO: Don't use toString() on tokens
            return new TextAttribute(
              attribute.getForeground(),
              null,
              attribute.getStyle()
            );
          } else {
            return attribute;
          }
        }
        
        @Override
        public IRegion calculateDamageExtent(IRegion seed) {
	      return seed;
        }
      }
  ]|
