module sdf2imp/util/io

imports
  libstratego-gpp
  libstratego-sglr
  
  sdf2imp/lib/-

  sdf2imp/util/pp

/** File input. */
strategies
  
  /**
   * Given its filename (no extension), parse a service descriptor, including its imports.
   */
  input-descriptor-file = // TODO: file input caching
  {| IsImported:
    <add-imports> Module("<main>", Imports([Import(<id>)]), [])
  |}
  
  /** @internal */
  input-descriptor-import =
    ?Import(name);
    !FILE(<add-extension; file-exists> (name, "esv"));
    parse-xtc-file-report-errors(|<parse-table-descriptor>, "Module");
    
    risky(?Module(name, _, _) <+ IgnoreBadName |"Module name does not match file name")
  <+
    ?ImportRenamed(name, tail);
    <input-descriptor-import> Import(name);
    add-imports;
    alltd(rename-sort(|tail))
    
  // TODO: Sort renaming could be inferred from the .def file
  
  rename-sort(|tail):
    Sort(name) -> Sort(<conc-strings> (name, "_", tail))
  
  rename-sort(|tail):
    ListSort(name) -> ListSort(<conc-strings> (name, "_", tail))
  
  /** @internal */
  add-imports:
    Module(name, Imports(imports), definitions) ->
    Module(name, Imports(imports'), definitions')
    where
      rules(IsImported: name);
      
      !imports;
      map(
        risky(
          IsImported
        <+
          input-descriptor-import;
          add-imports
        <+
          OnImportFailure
        | "Unable to import module"
        )
      ) => imported;
      
      imported-defs    := <mapconcat(?Module(_, _, <id>))>;
      definitions'     := <conc> (definitions, <id>);
      imported-imports := <filter(?Module(_, Import(<id>), _))> imported;
      imports'         := <concat> [imports | <id>]

  add-imports:
    Module(_, NoImports(), _) -> <id>

/** File output. */
strategies
  
  output-java-file =
    where(
      ?class;
      path := <create-dirs> ["src" | <package-name>];
      fullpath := <conc-strings> (path, "/", <class-name> class, ".java")
    );
    
    output-java-file(|fullpath)
  
  // TODO2: Add @Generated attribute to files
  // import javax.annotation.Generated;
  // @Generated("sdf2imp")

  output-java-file(|filename) =
    print-filename(|["src" | <package-name>], <base-filename> filename);
    
    risky(
      text := <pp-java-string>
    | "Illegal Java output"
    );
    
    output-text-file(|filename)

  output-xml-file(|pathparts, filename) =
    risky(
      xml-doc2abox; box2text-string(|80)
    | "Illegal XML output"
    );
    
    output-text-file(|pathparts, filename)

  output-default-descriptor-file(name, new-contents) =
    where(
      filename := <add-extension> (<name>, "esv");
      path     := "src";
      fullpath := <conc-strings> (path, "/", filename)
    );
    
    if is-descriptor-necessary(|<name>, fullpath) then
      new-contents;
      risky(
        ?Module(name, _ ,_);
        pp-descriptor-to-string
      | "Illegal editor service descriptor output"
      );
      output-text-file(|[path], filename)
    else
      verbose-msg(!"Skipping", !fullpath)
    end
  
  is-descriptor-necessary(|name, fullpath) =
    ResetFiles
  <+
    if MainDescriptor then 
      // Only generate default descriptors if they are imported by the main descriptor
      MainDescriptor;
      oncetd(?Import(name) + ?ImportRenamed(name, _))
    else
      not(<file-exists> fullpath) // main descriptor file must exist
    end
  
  output-text-file(|pathparts, filename) =
    print-filename(|pathparts, filename);
    
    where(path := <create-dirs> pathparts);
    
    output-text-file(|<conc-strings> (path, "/", filename))
  
  output-text-file(|filename) =
    where(file := <fopen> (filename, "w"));
    
    <fputs> (<id>, file);
    <fclose> file
  
  parse-table-descriptor =
    CachedParseTableDescriptor
  <+
    table := <open-parse-table> <import-term(EditorService.tbl)>;
    rules(CachedParseTableDescriptor := table)
  
  print-filename(|pathparts, filename) =
    if [] := pathparts then
      verbose-msg(!"Generating", !filename)
    else
      verbose-msg(!"Generating", <conc-strings> (
                                   <separate-by(|"/"); concat-strings> pathparts
                                 , "/", filename
                                 ))
    end
  
  create-dirs = 
    where(root := <getcwd>);
    map((file-exists <+ mkdir(|"w")); chdir);
    getcwd; // return path to innermost created dir.
    where (<chdir> root)     
  
  package-name:
    CompilationUnit(Some(PackageDec(_, PackageName(ids))), _, _) -> xs
    where xs := <map(?Id(<id>))> ids
    
  package-name:
    CompilationUnit(None(), _, _) -> []
    
  class-name =
    ?CompilationUnit(_, _, [ClassDec(ClassDecHead(_,Id(<id>),_,_,_),_)|_])
  <+
    ?CompilationUnit(_, _, [InterfaceDec(InterfaceDecHead(_,Id(<id>),_,_),_)|_])
