module sdf2imp/util/io

imports
  libstratego-gpp
  libstratego-sglr
  
  sdf2imp/lib/xml-doc2abox

  sdf2imp/util/pp

/** File input. */
strategies
  
  /**
   * Given its filename (no extension), parse a service descriptor, including its imports.
   */
  input-descriptor-file =
  {| IsImported:    
    <add-imports> Module("", Imports([<id>]), []) // placeholder module importing the real module
  |}
  
  /**
   * Given its filename (no extension), parse a service descriptor, excluding its imports.
   */
  input-descriptor-file-no-imports =
    ?name;
    !FILE(<add-extension> (<id>, "esv"));
    
    parse-xtc-file-report-errors(|<parse-table-descriptor>, "Module");
    
    risky(?Module(name, _, _) |"Module name does not match file name")
  
  /** @internal */
  add-imports:
    Module(name, Imports(imports), definitions) -> Module(name, NoImports(), definitions')
    where rules(IsImported: name);
          
          !imports;
          map(
            risky(
              IsImported
            <+
              input-descriptor-file-no-imports;
              add-imports => Module(_, _, <id>)
            | "Unable to import module"
            )
          );
          
          definitions' := <conc> (definitions, <concat>)

  add-imports:
    Module(_, NoImports(), _) -> <id>

/** File output. */
strategies
  
  output-java-file =
    where(
      ?class;
      path := <create-dirs> ["src" | <package-name>];
      fullpath := <conc-strings> (path, "/", <class-name> class, ".java")
    );
    
    output-java-file(|fullpath)
  
  // TODO2: Add @Generated attribute to files
  // import javax.annotation.Generated;
  // @Generated("sdf2imp")

  output-java-file(|filename) =
    print-filename(|["src" | <package-name>], <base-filename> filename);
    
    risky(
      text := <pp-java-string>
    | "Illegal Java output"
    );
    
    output-text-file(|filename)

  output-xml-file(|pathparts, filename) =
    risky(
      xml-doc2abox; box2text-string(|80)
    | "Illegal XML output"
    );
    
    output-text-file(|pathparts, filename)

  output-default-descriptor-file =
    risky(
      ?Module(name, _ ,_);
      pp-descriptor-to-string
    | "Illegal editor service descriptor output"
    );
    
    where(
      filename := <add-extension> (name, "esv");
      path     := <create-dirs> ["services"];
      fullpath := <conc-strings> (path, "/", filename)
    );
    
    if ResetFiles + not(<file-exists> fullpath) then
      output-text-file(|[], filename)
    else
      verbose-msg(!"Skipping", !fullpath)
    end
  
  output-text-file(|pathparts, filename) =
    print-filename(|pathparts, filename);
    
    where(path := <create-dirs> pathparts);
    
    output-text-file(|<conc-strings> (path, "/", filename))
  
  output-text-file(|filename) =
    where(file := <fopen> (filename, "w"));
    
    <fputs> (<id>, file);
    <fclose> file
  
  parse-table-descriptor =
    CachedParseTableDescriptor
  <+
    table := <open-parse-table> <import-term(EditorService.tbl)>;
    rules(CachedParseTableDescriptor := table)
  
  print-filename(|pathparts, filename) =
    if [] := pathparts then
      verbose-msg(!"Outputting", !filename)
    else
      verbose-msg(!"Outputting", <conc-strings> (
                                   <separate-by(|"/"); concat-strings> pathparts
                                 , "/", filename
                                 ))
    end
  
  create-dirs = 
    where(root := <getcwd>);
    map((file-exists <+ mkdir(|"w")); chdir);
    getcwd; // return path to innermost created dir.
    where (<chdir> root)     
  
  package-name:
    CompilationUnit(Some(PackageDec(_, PackageName(ids))), _, _) -> xs
    where xs := <map(?Id(<id>))> ids
    
  package-name:
    CompilationUnit(None(), _, _) -> []
    
  class-name =
    ?CompilationUnit(_, _, [ClassDec(ClassDecHead(_,Id(<id>),_,_,_),_)|_])
  <+
    ?CompilationUnit(_, _, [InterfaceDec(InterfaceDecHead(_,Id(<id>),_,_),_)|_])
