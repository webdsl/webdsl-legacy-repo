module sdf2imp/util/io

imports
  libstratego-gpp
  libstratego-sglr
  
  sdf2imp/lib/-

  sdf2imp/util/pp

/** File input. */
strategies

  /**
   * Given a location and filename (no extension),
   * parse an editor descriptor, including all imports.
   */
  input-descriptor-file =
    {| IsImported:
      ?import;
      name := <conc-strings> (<main-descriptor-name>, ".packed");
      <add-imports> Module(name, Imports([Import(import)]), [])
    |}
  
  set-input-dir-prefix =
    with(string-ends-with(|"/"));
    rules(InputDirPrefix := <id>)
  
  add-input-dir-prefix =
    <set-input-dir-prefix> <conc-strings> (<InputDirPrefix <+ !"">, <id>)

/** @internal */
strategies
  
  include-input-dir-prefix =
    try(<conc-strings> (<InputDirPrefix>, <id>))
    
  // TODO: Optimize - file input/parsing caching
  
  input-descriptor-import =
    ?Import(name);
    !FILE(<add-extension; include-input-dir-prefix> (name, "esv"));
    parse-xtc-file-report-errors(|<parse-table-descriptor>, "Module");
    
    risky(?Module(name, _, _) |"Module name does not match file name")
  <+
    ?ImportRenamed(name, tail);
    <input-descriptor-import> Import(name);
    add-imports;
    alltd(rename-sort(|tail))
    
  // TODO: Sort renaming could be inferred from the .def file
  
  rename-sort(|tail):
    Sort(name) -> Sort(<conc-strings> (name, "_", tail))
  
  rename-sort(|tail):
    ListSort(name) -> ListSort(<conc-strings> (name, "_", tail))
  
  add-imports:
    Module(name, Imports(imports), definitions) ->
    Module(name, Imports(imports'), definitions')
    where
      rules(IsImported: name);
      
      !imports;
      map(
        risky(
          IsImported
        <+
          input-descriptor-import;
          add-imports
        <+
          OnImportFailure
        | "Unable to import module"
        )
      ) => imported;
      
      imported-defs    := <mapconcat(?Module(_, _, <id>))>;
      definitions'     := <conc> (definitions, <id>);
      imported-imports := <filter(?Module(_, Imports(<id>), _))> imported;
      imports'         := <concat> [imports | <id>]

  add-imports:
    Module(_, NoImports(), _) -> <id>

/**
 * Descriptor output.
 */
strategies
  
  /**
   * Output the main descriptor file (e.g., EditorService.main.esv).
   * This file is never overwritten.
   */
  output-main-descriptor-file(name, new-contents) =
    output-descriptor-file(
      name
    , new-contents
    , not(file-exists)
    )
  
  /**
   * Output an initial descriptor file (e.g., EditorService-Outliner.esv).
   * These files are never overwritten and only generated if imported.
   */
  output-initial-descriptor-file(name, new-contents) =
    output-descriptor-file(
      name
    , new-contents
    , not(file-exists); is-descriptor-imported(|<name>)
    )

  /**
   * Output an derived descriptor file (e.g., EditorService-Outliner.generated.esv).
   * These files are always overwritten, but only if imported.
   */
  output-derived-descriptor-file(name, new-contents) =
    output-descriptor-file(
      name
    , new-contents
    , is-descriptor-imported(|<name>)
    )
  
  /**
   * Output a descriptor file if <condition> succeeds for
   * the full file path of the generated file.
   *
   * @internal
   */
  output-descriptor-file(name, new-contents, condition) =
    with(
      filename := <add-extension> (<name>, "esv");
      path     := "src";
      fullpath := <conc-strings> (path, "/", filename)
    );
    
    if ResetFiles <+ <condition> fullpath then
      new-contents;
      risky(
        ?Module(name, _ ,_);
        pp-descriptor-to-string
      | "Illegal editor service descriptor output"
      );
      output-text-file(|[path], filename)
    else
      verbose-msg(!"Skipping", !fullpath)
    end

  /**
   * Output a packed descriptor file (e.g., EditorService.packed.esv).
   */
  output-packed-descriptor-file(|filename) =
    with(
      path     := "include";
      fullpath := <conc-strings> (path, "/", filename)
    );
    
    pp-descriptor-to-string;
    output-text-file(|[path], filename)
  
  is-descriptor-imported(|name) =
    MainDescriptor;
    oncetd(?Import(name) + ?ImportRenamed(name, _))

/**
 * Pretty-printing support.
 */
strategies
  
  output-java-file =
    where(
      ?class;
      path := <create-dirs> ["src" | <package-name>];
      fullpath := <conc-strings> (path, "/", <class-name> class, ".java")
    );
    
    output-java-file(|fullpath)

  output-java-file(|filename) =
    print-filename(|["src" | <package-name>], <base-filename> filename);
    
    risky(
      text := <pp-java-string>
    | "Illegal Java output"
    );
    
    output-text-file(|filename)

  output-xml-file(|pathparts, filename) =
    risky(
      xml-doc2abox; box2text-string(|80)
    | "Illegal XML output"
    );
    
    output-text-file(|pathparts, filename)
  
  output-text-file(|pathparts, filename) =
    print-filename(|pathparts, filename);
    
    where(path := <create-dirs> pathparts);
    
    output-text-file(|<conc-strings> (path, "/", filename))
  
  output-text-file(|filename) =
    where(file := <fopen> (filename, "w"));
    
    <fputs> (<id>, file);
    <fclose> file

strategies
  
  parse-table-descriptor =
    CachedParseTableDescriptor
  <+
    table := <open-parse-table> <import-term(EditorService.tbl)>;
    rules(CachedParseTableDescriptor := table)
  
  print-filename(|pathparts, filename) =
    if [] := pathparts then
      verbose-msg(!"Generating", !filename)
    else
      verbose-msg(!"Generating", <conc-strings> (
                                   <separate-by(|"/"); concat-strings> pathparts
                                 , "/", filename
                                 ))
    end
  
  create-dirs = 
    where(root := <getcwd>);
    map((file-exists <+ mkdir(|"w")); chdir);
    getcwd; // return path to innermost created dir.
    where (<chdir> root)     
  
  package-name:
    CompilationUnit(Some(PackageDec(_, PackageName(ids))), _, _) -> xs
    where xs := <map(?Id(<id>))> ids
    
  package-name:
    CompilationUnit(None(), _, _) -> []
    
  class-name =
    ?CompilationUnit(_, _, [ClassDec(ClassDecHead(_,Id(<id>),_,_,_),_)|_])
  <+
    ?CompilationUnit(_, _, [InterfaceDec(InterfaceDecHead(_,Id(<id>),_,_),_)|_])
