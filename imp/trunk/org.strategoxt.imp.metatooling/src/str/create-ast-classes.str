module create-ast-classes

imports
  libstratego-lib
  sdf-options
  rtg
  
  io
  debug
  create-ast-visitor
  create-ast-factory

strategies

  rtg-to-ast-classes =
    ?RTG(_, ProdRules(<id>));
    
    where(register-builtin-classes);
    
    list-loop(
      if(sort-to-class, output-file)
    );
    
    list-loop(risky(
      (terminal-to-class <+ non-terminal-to-class <+ non-terminal-list-to-class);
      (None <+ output-file)
    | "Could not convert production to AST class") 
    );
    
    create-ast-base-class;
    create-ast-list-class;
    create-ast-string-class;
    
    consistency-check
  
  register-builtin-classes =
    // Reserve default class names
    <reserve-class-name> "Visitor";
    <reserve-class-name> "AbstractVisitor";
    <reserve-class-name> "List";
    <reserve-class-name> "String";
    <reserve-class-name> <get-ast-base-name>;
    <reserve-class-name> <get-ast-factory-name>;
    
    rules(
      SortClassName: "List"
      SortClassName: "String"
    );
    
    // Reserve default accessor method names
    rules(
      IsReservedAccessorName: "Sort"
      IsReservedAccessorName: "Constructor"
      IsReservedAccessorName: "Class"
      IsReservedAccessorName: "Children"
      IsReservedAccessorName: "AllChildren"
      IsReservedAccessorName: "FollowingAdjuncts"
      IsReservedAccessorName: "PrecedingAdjuncts"
      IsReservedAccessorName: "LeftIToken"
      IsReservedAccessorName: "RightIToken"
      IsReservedAccessorName: "Parent"
      IsReservedAccessorName: "NextAst"
    );
    
    visitor-register-class(|"List");
    visitor-register-class(|"String")
  
  consistency-check =
    bagof-AccessedSorts;
    make-set;
    
    list-loop(
      SortClassName
    <+
      // TODO2: Recover from undefined sort by creating an abstract placeholder class
      err(|"Undefined sort referenced");
      try(?error)
    );
    
    not(!error)

/** Create default node classes. */ 
strategies

  get-ast-base-name =
    <conc-strings> (<get-sdf-main-module>, "AstNode")
  
  create-ast-base-class =
    x_Name := <get-ast-base-name>;
    
    <output-file> compilation-unit |[
      package parser.ast;
    
      public abstract class x_Name extends tname_ASTNODE<x_Name> {
        protected x_Name(tname_ITOKEN leftToken, tname_ITOKEN rightToken,
            java.util.ArrayList<x_Name> children) {
          super(leftToken, rightToken, children);
	    }
	    
        protected x_Name(tname_ITOKEN leftToken, tname_ITOKEN rightToken) {
          super(leftToken, rightToken);
	    }
	    
        public abstract void accept(AbstractVisitor visitor);
        
        // also abstract: getSort(); getCosntructor()
      }
    ]|
  
  create-ast-string-class =
    x_Super := <get-ast-base-name>;
    
    <output-file> compilation-unit |[
      package parser.ast;
    
      public class String extends x_Super {
        public String(tname_ITOKEN leftToken, tname_ITOKEN rightToken) {
          super(leftToken, rightToken);
	    }
	    
	    @Override
	    public java.lang.String getSort() {
	      return STRING_SORT;
	    }
	    
	    @Override
	    public java.lang.String getConstructor() {
	      return null;
	    }
	    
        @Override
	    public void accept(AbstractVisitor visitor) {
          visitor.visit(this);
          visitor.endVisit(this);
        }
        
        public java.lang.String getValue() {
          return getConstructor();
        }
      }
    ]|
  
  create-ast-list-class =
    x_Super := <get-ast-base-name>;
    
    <output-file> compilation-unit |[
      package parser.ast;
    
      public class List extends x_Super {
        private final java.lang.String sort;
        
        public List(java.lang.String sort, tname_ITOKEN leftToken, tname_ITOKEN rightToken,
            java.util.ArrayList<x_Super> children) {
          
          super(leftToken, rightToken, children);
          this.sort = sort;
	    }
	    
	    @Override
	    public java.lang.String getSort() {
	      return sort;
	    }
	    
	    @Override
	    public java.lang.String getConstructor() {
	      return LIST_CONSTRUCTOR;
	    }
	    
	    @Override
	    public void accept(AbstractVisitor visitor) {
	      if (!visitor.preVisit(this)) return;
	      enter(visitor);
	      visitor.postVisit(this);
	    }
	    
	    protected void enter(AbstractVisitor visitor) {
	      if (visitor.visit(this)) {
	        for (x_Super node : this) {
	          node.accept(visitor);
	        }
	      }  
	      visitor.endVisit(this);
	    }
      }
    ]|

/** Converting productions to classes. */
rules

  sort-to-class:
    ProdRule(
      Nonterm(Plain(sort))
    , [rhs]
    ) ->
    compilation-unit |[
      package parser.ast;
      
      public abstract class x_Name extends x_Super {
        protected x_Name(tname_ITOKEN leftToken, tname_ITOKEN rightToken,
            java.util.ArrayList<x_Super> children) {
          
          super(leftToken, rightToken, children);
	    }
	    
	    @Override
	    public java.lang.String getSort() {
	      return "~sort";
	    }
      }
    ]|  
    where not(<SortClassName> sort); // create only once
          x_Super := <get-ast-base-name>;

          // Try not to create sort class if constructor has same name
          // TODO: Consider always creating a sort class
          if Appl(constructor, _) := rhs then
            not(<eq> (sort, constructor))
          end;
          
          not(<Ref(String + Int)> rhs); // no sort class for terminals
          
          x_Name := <reserve-class-name> sort;
          rules(SortClassName: sort -> x_Name)
  
   /**
    * Create a class for a non-terminal with a constructor.
    */
  non-terminal-to-class:
    ProdRule(
      Nonterm(Plain(sort))
    , [rhs]
    ) ->
    compilation-unit |[
      package parser.ast;
      
      public class x_Name extends x_Parent {
        protected x_Name(tname_ITOKEN leftToken, tname_ITOKEN rightToken,
            java.util.ArrayList<x_Super> children) {
          super(leftToken, rightToken, children);
	    }
	    
	    @Override
	    public java.lang.String getConstructor() {
	      return e_Constructor;
	    }
	    
	    @Override
	    public void accept(AbstractVisitor visitor) {
	      if (!visitor.preVisit(this)) return;
	      enter(visitor);
	      visitor.postVisit(this);
	    }
	    
	    protected void enter(AbstractVisitor visitor) {
	      if (visitor.visit(this)) {
	        for (x_Super node : this) {
	          node.accept(visitor);
	        }
	      }  
	      visitor.endVisit(this);
	    }
      
        ~*children
      }
    ]|
    where (name, args, e_Constructor) := <get-non-terminal-properties>;
          
          args' := <map(try(generic-name-for-arg))> args;
          
          x_Name   := <reserve-class-name> name;
          x_Super  := <get-ast-base-name>;
          x_Parent := <get-parent-name> sort;
          
          {| IsReservedAccessorName:            
            children := <number(create-child-accessor)> args'
          |};
          
          factory-register-non-terminal(|sort, e_Constructor, x_Name, args');
          visitor-register-class(|x_Name)
  
  /** Get the name, arguments and Java constructor expression for the right-hand side of a rule. */
  get-non-terminal-properties:
    ProdRule(
      Nonterm(Plain(sort))
    , [Appl(Term(Plain(name)), args)]
    ) ->
    (name, args, |[ "~name" ]|)
  
  /** Get the name, arguments and Java constructor expression for the right-hand side of a rule. */
  get-non-terminal-properties:
    ProdRule(
      Nonterm(Plain(sort))
    , [Ref(Nonterm(Plain(rhs)))]
    ) ->
    (sort, [Ref(Nonterm(Plain(rhs)))], |[ null ]|)
  
  /**
   * Create a class for a terminal.
   */
  terminal-to-class:
    ProdRule(
      Nonterm(Plain(sort))
    , [Ref(String)]
    ) ->
    compilation-unit |[
      package parser.ast;
      
      public class x_Name extends x_Parent {
        private final java.lang.String value;
        
        public x_Name(java.lang.String value, tname_ITOKEN leftToken, tname_ITOKEN rightToken) {
          super(leftToken, rightToken);
          this.value = value;
	    }
        
        public java.lang.String getValue() {
          return value;
        }
	    
	    @Override
	    public java.lang.String getConstructor() {
	      return null;
	    }
	    
	    @Override
	    public java.lang.String getSort() {
	      return "~sort";
	    }
	    
	    @Override
	    public void accept(AbstractVisitor visitor) {
	      if (!visitor.preVisit(this)) return;
	      enter(visitor);
	      visitor.postVisit(this);
	    }
	    
	    protected void enter(AbstractVisitor visitor) {
	      visitor.visit(this);
	      visitor.endVisit(this);
	    }
      }
    ]|
    where x_Name      := <reserve-class-name> sort;
          x_Parent    := <get-parent-name> sort;
          
          factory-register-terminal(|sort, x_Name);
          visitor-register-class(|x_Name)
  
  // HACK: use a single generic class for lists
  non-terminal-list-to-class: // don't generate anything for <conc>, <cons>, etc.
    ProdRule(
      Nonterm(Plain(lhs))
    , [Appl(rhs, _)]
    ) ->
    None()
    where <is-list-term> rhs;
          rules(IsListTerm: lhs)
  
  // HACK: treat <some> and <none> as lists
  non-terminal-list-to-class:
    ProdRule(
      Nonterm(Plain(lhs))
    , [Appl(rhs, _)]
    ) ->
    None()
    where <is-maybe-term> rhs;
          rules(IsListTerm: lhs)
  
  is-list-term =
    ConcTerm + ConsTerm + NilTerm + TupleTerm(id)
  
  is-maybe-term =
    SomeTerm + NoneTerm
  
  generic-name-for-arg:
    Ref(Nonterm(Plain(x))) -> Ref(Nonterm(Plain("List")))
    where <IsListTerm> x
  
  /** Returns a node's parent class name. */
  get-parent-name =
    SortClassName
  <+
    // There is no separate sort class for this type
    ?sort;
    x_Parent := <get-ast-base-name>;
    rules(SortClassName: sort -> x_Parent)
  
  create-child-accessor:
    (Ref(String()), index) ->
    class-body-dec |[
      java.lang.String x_Name() {
        return ((String) getChildren().get(i)).getValue();      
      }
    ]|
    where x_Name := <create-accessor-name(|index)> "String";
          i      := <write-to-string> index

  create-child-accessor:
    (Ref(Nonterm(Plain(child))), index) ->
    class-body-dec |[
      x_Type x_Name() {
        return (x_Type) getChildren().get(i);      
      }
    ]|
    where x_Name := <create-accessor-name(|index)> child;
          x_Type := child;
          i      := <write-to-string> index;
          rules(AccessedSorts :+= child)

/** Utility strategies. */
strategies
  
  create-accessor-name(|index) =
    not(IsReservedAccessorName) => name;
    rules(IsReservedAccessorName: name);
    
    <conc-strings> ("get", <id>)
  <+
    <conc-strings> ("get", <id>, <write-to-string> index)

  reserve-class-name =
    is-string => name;
    
    for(
      !(0, name)
    , not((id, IsReservedClassName))
    , {n: // Create a new name0 ... nameN until non-reserved name found
          ?(n, _);
          (inc, <conc-strings> (name, <write-to-string> n))
      }
    );
    
    reserved := <Snd>;
    
    rules(IsReservedClassName: reserved)
    
