module create-ast-classes

imports
  libstratego-lib
  sdf-options
  rtg
  
  io
  debug
  create-ast-visitor
  create-ast-factory

strategies

  rtg-to-ast-classes =
    ?RTG(_, ProdRules(<id>));
    
    where(register-builtin-classes);
    
    list-loop(
      // HACK: use a single generic class for lists
      list-sort-no-class
    <+
      if(sort-to-class, output-file)
    );
    
    list-loop(risky(
      (non-terminal-list-no-class <+ terminal-to-class <+ non-terminal-to-class);
      (None <+ output-file)
    | "Could not convert production to AST class") 
    );
    
    create-ast-base-class;
    create-ast-list-class;
    create-ast-string-class;
    
    not(HadErrors)
  
  register-builtin-classes =
    // Reserve default class names
    <reserve-class-name> "Visitor";
    <reserve-class-name> "AbstractVisitor";
    <reserve-class-name> "List";
    <reserve-class-name> "String";
    <reserve-class-name> "ASTNode";
    <reserve-class-name> <get-ast-factory-name>;
    
    rules(
      SortClassName: "List"
      SortClassName: "String"
    );
    
    // Reserve default accessor method names
    rules(
      IsReservedAccessorName: "Sort"
      IsReservedAccessorName: "Constructor"
      IsReservedAccessorName: "Class"
      IsReservedAccessorName: "Children"
      IsReservedAccessorName: "AllChildren"
      IsReservedAccessorName: "FollowingAdjuncts"
      IsReservedAccessorName: "PrecedingAdjuncts"
      IsReservedAccessorName: "LeftIToken"
      IsReservedAccessorName: "RightIToken"
      IsReservedAccessorName: "Parent"
      IsReservedAccessorName: "NextAst"
    );
    
    visitor-register-class(|"List");
    visitor-register-class(|"String");
    
    not(HadErrors)

/** Create default node classes. */ 
strategies
  
  create-ast-base-class =
    <output-file> compilation-unit |[
      package parser.ast;
    
      public abstract class ASTNode extends tname_ASTNODE<ASTNode> {
        protected ASTNode(tname_ITOKEN leftToken, tname_ITOKEN rightToken,
            java.util.ArrayList<ASTNode> children) {
          
          super(leftToken, rightToken, children);
	    }
	    
        protected ASTNode(tname_ITOKEN leftToken, tname_ITOKEN rightToken) {
          super(leftToken, rightToken);
	    }
	    
        protected void setRightIToken(tname_ITOKEN value) {
          super.setRightIToken(value);
	    }
	    
        public abstract void accept(AbstractVisitor visitor);
        
        // also abstract: getSort(); getConstructor()
      }
    ]|
  
  create-ast-string-class =
    <output-file> compilation-unit |[
      package parser.ast;
    
      public class String extends ASTNode {
        public String(tname_ITOKEN leftToken, tname_ITOKEN rightToken) {
          super(leftToken, rightToken);
	    }
	    
	    @Override
	    public java.lang.String getSort() {
	      return STRING_SORT;
	    }
	    
	    @Override
	    public java.lang.String getConstructor() {
	      return null;
	    }
	    
        @Override
	    public void accept(AbstractVisitor visitor) {
          visitor.visit(this);
          visitor.endVisit(this);
        }
        
        public java.lang.String getValue() {
          return getConstructor();
        }
      }
    ]|
  
  create-ast-list-class =
    <output-file> compilation-unit |[
      package parser.ast;
    
      public class List extends ASTNode {
        private final java.lang.String elementSort;
        
        public List(java.lang.String elementSort, tname_ITOKEN leftToken, tname_ITOKEN rightToken,
            java.util.ArrayList<ASTNode> children) {
          
          super(leftToken, rightToken, children);
          this.elementSort = elementSort;
	    }
	    
	    public java.lang.String getElementSort() {
	      return elementSort;
	    }
	    
	    @Override
	    public java.lang.String getSort() {
	      return getElementSort() + "*";
	    }
	    
	    @Override
	    public java.lang.String getConstructor() {
	      return LIST_CONSTRUCTOR;
	    }
	    
	    @Override
	    public void accept(AbstractVisitor visitor) {
	      if (!visitor.preVisit(this)) return;
	      enter(visitor);
	      visitor.postVisit(this);
	    }
	    
	    protected void enter(AbstractVisitor visitor) {
	      if (visitor.visit(this)) {
	        for (ASTNode node : this) {
	          node.accept(visitor);
	        }
	      }  
	      visitor.endVisit(this);
	    }
      }
    ]|

/** Converting productions to classes. */
rules

  sort-to-class:
    ProdRule(
      Nonterm(Plain(sort))
    , [rhs]
    ) ->
    compilation-unit |[
      package parser.ast;
      
      public abstract class x_Name extends ASTNode {
        protected x_Name(tname_ITOKEN leftToken, tname_ITOKEN rightToken,
            java.util.ArrayList<ASTNode> children) {
          
          super(leftToken, rightToken, children);
	    }
	    
        protected x_Name(tname_ITOKEN leftToken, tname_ITOKEN rightToken) {
          super(leftToken, rightToken);
	    }
	    
	    @Override
	    public java.lang.String getSort() {
	      return "~sort";
	    }
      }
    ]|  
    where not(<SortClassName> sort); // create only once
          
          x_Name := <reserve-class-name> <conc-strings> (sort, "Sort");
          rules(SortClassName: sort -> x_Name)
  
  list-sort-no-class:
    ProdRule(
      Nonterm(Plain(lhs))
    , [Appl(rhs, _)]
    ) ->
    None()
    where <is-list-term <+ is-maybe-term> rhs; // HACK: treat <some> and <none> as lists
          rules(SortClassName: lhs -> "List")

  is-list-term =
    ConcTerm + ConsTerm + NilTerm + TupleTerm(id)
  
  is-maybe-term =
    SomeTerm + NoneTerm
  
  non-terminal-list-no-class:
    ProdRule(
      Nonterm(Plain(lhs))
    , _
    ) ->
    None()
    where "List" := <SortClassName> lhs
  
   /**
    * Create a class for a non-terminal with a constructor.
    */
  non-terminal-to-class:
    ProdRule(
      Nonterm(Plain(sort))
    , [rhs]
    ) ->
    compilation-unit |[
      package parser.ast;
      
      public class x_Name extends x_Parent {
        protected x_Name(tname_ITOKEN leftToken, tname_ITOKEN rightToken,
            java.util.ArrayList<ASTNode> children) {
          super(leftToken, rightToken, children);
	    }
	    
	    @Override
	    public java.lang.String getConstructor() {
	      return e_Constructor;
	    }
	    
	    @Override
	    public void accept(AbstractVisitor visitor) {
	      if (!visitor.preVisit(this)) return;
	      enter(visitor);
	      visitor.postVisit(this);
	    }
	    
	    protected void enter(AbstractVisitor visitor) {
	      if (visitor.visit(this)) {
	        for (ASTNode node : this) {
	          node.accept(visitor);
	        }
	      }  
	      visitor.endVisit(this);
	    }
      
        ~*children
      }
    ]|
    where (name, args, e_Constructor) := <get-non-terminal-properties>;
          
          argtypes := <map(sort-to-typename)> args;          
          x_Name   := <reserve-class-name> name;
          x_Parent := <SortClassName> sort;
          
          {| IsReservedAccessorName:            
            children := <number(create-child-accessor)> argtypes
          |};
          
          factory-register-non-terminal(|sort, e_Constructor, x_Name, argtypes);
          visitor-register-class(|x_Name)
  
  sort-to-typename:
    Ref(String()) -> tname |[ String ]|
  
  sort-to-typename:
    Ref(Int()) -> <err(|"Not implemented"); fail>
  
  sort-to-typename:
    Ref(Nonterm(Plain(x))) -> tname |[ y ]|
    where y := <SortClassName> x
          <+ y := <conc-strings> (x, "Sort");

             err(|"Undefined sort referenced");
             
             rules(
               SortClassName: x // single error only
               HadErrors: _
             )
  
  /** Get the name, arguments and Java constructor expression for the right-hand side of a rule. */
  get-non-terminal-properties:
    ProdRule(
      Nonterm(Plain(sort))
    , [Appl(Term(Plain(name)), args)]
    ) ->
    (name, args, |[ "~name" ]|)
  
  /** Get the name, arguments and Java constructor expression for the right-hand side of a rule. */
  get-non-terminal-properties:
    ProdRule(
      Nonterm(Plain(sort))
    , [Ref(Nonterm(Plain(rhs)))]
    ) ->
    (sort, [Ref(Nonterm(Plain(rhs)))], |[ null ]|)
  
  /**
   * Create a class for a terminal.
   */
  terminal-to-class:
    ProdRule(
      Nonterm(Plain(sort))
    , [Ref(String)]
    ) ->
    compilation-unit |[
      package parser.ast;
      
      public class x_Name extends x_Parent {
        private final java.lang.String value;
        
        public x_Name(java.lang.String value, tname_ITOKEN leftToken, tname_ITOKEN rightToken) {
          super(leftToken, rightToken);
          this.value = value;
	    }
        
        public java.lang.String getValue() {
          return value;
        }
	    
	    @Override
	    public java.lang.String getConstructor() {
	      return null;
	    }
	    
	    @Override
	    public void accept(AbstractVisitor visitor) {
	      if (!visitor.preVisit(this)) return;
	      enter(visitor);
	      visitor.postVisit(this);
	    }
	    
	    protected void enter(AbstractVisitor visitor) {
	      visitor.visit(this);
	      visitor.endVisit(this);
	    }
      }
    ]|
    where x_Name   := <reserve-class-name> sort;
          x_Parent := <SortClassName> sort;
          
          factory-register-terminal(|sort, x_Name);
          visitor-register-class(|x_Name)

  create-child-accessor:
    (|[ java.lang.String ]|, index) ->
    class-body-dec |[
      public java.lang.String x_Name() {
        return (java.lang.String) getChildren().get(i);      
      }
    ]|
    where x_Name := <create-accessor-name(|index)> "String";
          i := <write-to-string> index
  
  create-child-accessor:
    (tname, index) ->
    class-body-dec |[
      public tname x_Name() {
        return (tname) getChildren().get(i);      
      }
    ]|
    where tname |[ x ]| := tname;
          x_Name := <create-accessor-name(|index)> x;
          i      := <write-to-string> index
    
  create-accessor-name(|index) =
    not(IsReservedAccessorName) => name;
    rules(IsReservedAccessorName: name);
    
    <conc-strings> ("get", <id>)
  <+
    <conc-strings> ("get", <id>, <write-to-string> index)

  reserve-class-name =
    is-string => name;
    
    for(
      !(0, name)
    , not((id, IsReservedClassName))
    , {n: // Create a new name0 ... nameN until non-reserved name found
          ?(n, _);
          (inc, <conc-strings> (name, <write-to-string> n))
      }
    );
    
    reserved := <Snd>;
    
    rules(IsReservedClassName: reserved)
    
