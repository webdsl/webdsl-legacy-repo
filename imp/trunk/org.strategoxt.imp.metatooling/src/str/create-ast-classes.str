module create-ast-classes

// TODO2: Reorganize; file is too large

imports
  libstratego-lib
  sdf-options
  rtg
  
  io
  debug
  class-naming
  create-ast-visitor
  create-ast-factory

strategies

  rtg-to-ast-classes =
    ?RTG(_, ProdRules(<id>));
    
    where(register-builtin-classes);
    
    list-loop(
      // HACK: use a single generic class for lists
      list-sort-no-class <+ maybe-sort-no-class
    <+
      if(sort-to-class, output-java-file)
    );
    
    list-loop(try(maybe-sort-redirects-to-class));
    
    list-loop(risky(
      (   non-terminal-list-no-class
       <+ non-terminal-some-to-class
       <+ non-terminal-none-no-class
       <+ terminal-to-class
       <+ non-terminal-to-class
       <+ non-terminal-to-class
      );
      (None <+ output-java-file)
    | "Could not convert production to AST class") 
    );
    
    create-ast-base-class;
    create-ast-list-class;
    create-ast-string-class;
    
    risky(not(HadErrors) |"Errors encountered; aborting.")
  
  register-builtin-classes =
    // Reserve default class names
    <reserve-class-name> "Visitor";
    <reserve-class-name> "AbstractVisitor";
    <reserve-class-name> "List";
    <reserve-class-name> "ASTString";
    <reserve-class-name> "ASTNode";
    <reserve-class-name> <get-ast-factory-name>;
    
    rules(
      SortClassName: "List"
    );
    
    // Reserve default accessor method names
    rules(
      IsReservedAccessorName: "Sort"
      IsReservedAccessorName: "Constructor"
      IsReservedAccessorName: "Class"
      IsReservedAccessorName: "Children"
      IsReservedAccessorName: "AllChildren"
      IsReservedAccessorName: "FollowingAdjuncts"
      IsReservedAccessorName: "PrecedingAdjuncts"
      IsReservedAccessorName: "LeftIToken"
      IsReservedAccessorName: "RightIToken"
      IsReservedAccessorName: "Parent"
      IsReservedAccessorName: "NextAst"
    );
    
    visitor-register-class(|"List");
    visitor-register-class(|"ASTString")

/** Create default node classes. */ 
strategies
  
  create-ast-base-class =
    <output-java-file> compilation-unit |[
      package parser.ast;
    
      public abstract class ASTNode extends tname_ASTNODE<ASTNode> {
        protected ASTNode(tname_ITOKEN leftToken, tname_ITOKEN rightToken,
            java.util.ArrayList<ASTNode> children) {
          
          super(leftToken, rightToken, children);
        }
        
        protected ASTNode(tname_ITOKEN leftToken, tname_ITOKEN rightToken) {
          super(leftToken, rightToken);
        }
        
        protected void setRightIToken(tname_ITOKEN value) {
          super.setRightIToken(value);
        }
        
        public final void accept(AbstractVisitor visitor) {
          if (!visitor.preVisit(this)) return;
          enter(visitor);
          visitor.postVisit(this);
        }
        
        protected abstract void enter(AbstractVisitor visitor);
        
        // also abstract: getSort(); getConstructor()
      }
    ]|
  
  create-ast-string-class =
    <output-java-file> compilation-unit |[
      package parser.ast;
    
      public class ASTString extends ASTNode {
        private final java.lang.String value;
        
        public ASTString(tname_ITOKEN leftToken, tname_ITOKEN rightToken, java.lang.String value) {
          super(leftToken, rightToken);
          this.value = value;
        }
        
        @Override
        public java.lang.String getSort() {
          return STRING_SORT;
        }
        
        @Override
        public java.lang.String getConstructor() {
          return null;
        }
        
        @Override
        public java.lang.String toString() {
          return value;
        }
        
        @Override
        protected void enter(AbstractVisitor visitor) {
          visitor.visit(this);
          visitor.endVisit(this);
        }
        
        public java.lang.String getValue() {
          return value;
        }
      }
    ]|
  
  create-ast-list-class =
    <output-java-file> compilation-unit |[
      package parser.ast;
    
      public class List extends ASTNode {
        private final java.lang.String elementSort;
        
        public List(java.lang.String elementSort, tname_ITOKEN leftToken, tname_ITOKEN rightToken,
            java.util.ArrayList<ASTNode> children) {
          
          super(leftToken, rightToken, children);
          this.elementSort = elementSort;
        }
        
        public java.lang.String getElementSort() {
          return elementSort;
        }
        
        @Override
        public java.lang.String getSort() {
          return getElementSort() + "*";
        }
        
        @Override
        public java.lang.String getConstructor() {
          return LIST_CONSTRUCTOR;
        }
        
        @Override
        protected void enter(AbstractVisitor visitor) {
          if (visitor.visit(this)) {
            for (ASTNode child : this) {
              child.accept(visitor);
            }
          }  
          visitor.endVisit(this);
        }
      }
    ]|

/** Converting productions to classes. */
rules

  sort-to-class:
    ProdRule(
      Nonterm(Plain(sort))
    , _
    ) ->
    compilation-unit |[
      package parser.ast;
      
      public abstract class x_Name extends ASTNode {
        protected x_Name(tname_ITOKEN leftToken, tname_ITOKEN rightToken,
            java.util.ArrayList<ASTNode> children) {
          
          super(leftToken, rightToken, children);
        }
        
        protected x_Name(tname_ITOKEN leftToken, tname_ITOKEN rightToken) {
          super(leftToken, rightToken);
        }
        
        @Override
        public java.lang.String getSort() {
          return "~sort";
        }
      }
    ]|  
    where not(<SortClassName> sort); // create only once
          
          x_Name := <reserve-class-name> <conc-strings> (sort, "Sort");
          
          visitor-register-class(|x_Name);
          rules(SortClassName: sort -> x_Name)
  
  /**
   * Don't create a separate sort class for list nodes,
   * but redirect them to the generic list class.
   */
  list-sort-no-class:
    ProdRule(
      Nonterm(Plain(sort))
    , [Appl(cons, _)]
    ) ->
    None()
    where <is-list-term> cons; 
          rules(SortClassName: sort -> "List")

  is-list-term =
    ConcTerm + ConsTerm + NilTerm + TupleTerm(id)
  
  /**
   * Don't create a separate sort class for <some>/<none> nodes.
   */
  maybe-sort-no-class:
    ProdRule(
      _
    , [Appl(<NoneTerm + SomeTerm>, _)]
    ) ->
    None()
  
  /**
   * Redirect <some>/<none> nodes to an existing sort class.
   */
  maybe-sort-redirects-to-class:
    ProdRule(
      Nonterm(Plain(lhs)) // not an actual sort but a name given by sdf2rtg
    , [Appl(SomeTerm(), [Ref(Nonterm(Plain(sort)))])]
    ) ->
    None()
    where // Redirect the RTG name to the sort class of the asfix sort
          // (dynamically to ensure late errors)
          rules(SortClassName: lhs -> <try-get-sort-class-name> sort)
  
  non-terminal-list-no-class:
    ProdRule(
      Nonterm(Plain(lhs))
    , _
    ) ->
    None()
    where "List" := <SortClassName> lhs
  
   /**
    * Create a class for a non-terminal with a constructor.
    */
  non-terminal-to-class:
    ProdRule(
      Nonterm(Plain(sort))
    , [rhs]
    ) ->
    compilation-unit |[
      package parser.ast;
      
      public class x_Name extends x_Parent {
        public x_Name(tname_ITOKEN leftToken, tname_ITOKEN rightToken,
            java.util.ArrayList<ASTNode> children) {
          
          super(leftToken, rightToken, children);
        }
        
        @Override
        public java.lang.String getConstructor() {
          return e_Constructor;
        }
        
        @Override
        protected void enter(AbstractVisitor visitor) {
          if (visitor.visit((x_Parent) this)) {
            if (visitor.visit(this)) {
              for (ASTNode child : this) {
                child.accept(visitor);
              }
            }  
            visitor.endVisit(this);
          }
          visitor.endVisit((x_Parent) this);
        }
      
        ~*children
      }
    ]|
    where (name, args, e_Constructor) := <get-non-terminal-properties>;
          
          argtypes := <map(sort-to-typename)> args;          
          x_Name   := <reserve-class-name> name;
          x_Parent := <SortClassName> sort;
          
          {| IsReservedAccessorName:            
            children := <number(create-child-accessor)> argtypes
          |};
          
          factory-register-non-terminal(|sort, e_Constructor, x_Name, argtypes);
          visitor-register-class(|x_Name)
  
  sort-to-typename:
    Ref(String()) -> tname |[ ASTString ]|
  
  sort-to-typename:
    Ref(Int()) -> tname |[ ASTString ]| // HACK: Sort type for integers is string
  
  sort-to-typename:
    Ref(Nonterm(Plain(x))) -> tname |[ y ]|
    where y := <try-get-sort-class-name> x
  
  /**
   * Get the name of a sort class, or report an error if it's undefined.
   */
  try-get-sort-class-name =
    SortClassName
  <+
    recover-from-missing-renamed-sort
  <+
    ?sort; 
    err(|"Undefined sort referenced");
    
    class := <conc-strings> (sort, "Sort");
    
    rules(
      SortClassName: sort -> class // single error only
      HadErrors: _
    )
  
  // HACK: try finding missing renamed sorts 
  //       sdf2rtg doesn't seem to rename renamed sorts without a constructor
  //       e.g., in Stratego-Java-15, ArraySubscript is not renamed to
  //       ArraySubscript_JavaObject.
  // TODO: Report this issue
  recover-from-missing-renamed-sort =
    // "ArraySubscript_JavaObject" -> "ArraySubscript"
    ?sort;
    explode-string;
    reverse;
    split-at('_') => (_, <id>);
    reverse;
    implode-string;
    SortClassName;
    warn-msg(|<conc-strings> ("Could not find sort ", sort, "; using ", <simple-sort-name>, " instead."))
  
  /** Get the name, arguments and Java constructor expression for the right-hand side of a rule. */
  get-non-terminal-properties:
    ProdRule(
      Nonterm(Plain(sort))
    , [Appl(Term(Plain(name)), args)]
    ) ->
    (name, args, |[ "~name" ]|)
  
  /** Get the name, arguments and Java constructor expression for the right-hand side of a rule. */
  get-non-terminal-properties:
    ProdRule(
      Nonterm(Plain(sort))
    , rhs @ [Ref(Nonterm(Plain(_)))]
    ) ->
    (sort, rhs, |[ null ]|)
  
  /**
   * Create a class for a terminal.
   */
  terminal-to-class:
    ProdRule(
      Nonterm(Plain(sort))
    , [Ref(<String + Int>)] // HACK: Treat Int terminal as String
    ) ->
    compilation-unit |[
      package parser.ast;
      
      public class x_Name extends x_Parent {
        private final java.lang.String value;
        
        public x_Name(tname_ITOKEN leftToken, tname_ITOKEN rightToken, java.lang.String value) {
          super(leftToken, rightToken);
          this.value = value;
        }
        
        @Override
        public java.lang.String getConstructor() {
          return null;
        }
        
        @Override
        public java.lang.String toString() { // more efficient than parent impl.
          return value;
        }
        
        @Override
        protected void enter(AbstractVisitor visitor) {
          if (visitor.visit((x_Parent) this)) {
            visitor.visit(this);
            visitor.endVisit(this);
          }
          visitor.endVisit((x_Parent) this);
        }
        
        public java.lang.String getValue() {
          return value;
        }
      }
    ]|
    where x_Name   := <reserve-class-name> sort;
          x_Parent := <SortClassName> sort;
          
          factory-register-terminal(|sort, x_Name);
          visitor-register-class(|x_Name)
  
  // TODO2: Only create a maximally 1 some/none pair per sort
  
  /**
   * Create a class for an optional AST node (<some>/<none>).
   */
  non-terminal-some-to-class:
    ProdRule(
      Nonterm(Plain(name))
    , [Appl(SomeTerm(), [rhs @ Ref(Nonterm(Plain(sort)))])] // rhs is sort in asfix
    ) ->
    compilation-unit |[
      package parser.ast;
      
      public class x_Name extends x_Parent {
        private final x_Parent value;
        
        public x_Name(tname_ITOKEN leftToken, tname_ITOKEN rightToken,
            java.util.ArrayList<ASTNode> children) {
          
          super(leftToken, rightToken, children);
          value = getChildren().size() > 0 ? (x_Parent) getChildren().get(0)
                                           : null;
        }
        
        @Override
        public java.lang.String getConstructor() {
          return value == null ? "None" : "Some";
        }
        
        @Override
        protected void enter(AbstractVisitor visitor) {
          if (visitor.visit((x_Parent) this)) {
            if (visitor.visit(this) && value != null)
              value.accept(visitor);
            
            visitor.endVisit(this);
          }
          visitor.endVisit((x_Parent) this);
        }
        
        public x_Parent getValue() {
          return value;
        }
      }
    ]|
    where argtype  := <sort-to-typename> rhs;
          x_Parent := <try-get-sort-class-name> sort; // e.g., "OptTypeArgs0"
          x_Name   := <reserve-class-name> name;
          
          // Register some, none, and the visitor
          factory-register-non-terminal(|sort, |[ null ]|, x_Name, [argtype]);
          factory-register-non-terminal(|sort, |[ null ]|, x_Name, []);
          visitor-register-class(|x_Name)
  
  /**
   * Don't create a separate class for a <none> constructor.
   */
  non-terminal-none-no-class: // nah-uh, no class for you
    ProdRule(
      Nonterm(Plain(sort))
    , [Appl(NoneTerm(), [])]
    ) ->
    None()

  create-child-accessor:
    (tname |[ ASTString ]|, index) ->
    class-body-dec |[
      public java.lang.String x_Name() {
        return getChildren().get(i).toString();      
      }
    ]|
    where x_Name := <create-accessor-name(|index)> "Value";
          i := <write-to-string> index
  
  create-child-accessor:
    (tname, index) ->
    class-body-dec |[
      public tname x_Name() {
        return (tname) getChildren().get(i);      
      }
    ]|
    where tname |[ x ]| := tname;
          x_Name := <create-accessor-name(|index)> <try(simple-sort-name)> x;
          i      := <write-to-string> index
  
  // TODO2: Use name "SortModule" instead of "ModuleSort"?
  simple-sort-name = // "ModuleSort" -> "Module"
    explode-string;
    
    rec rec(
      \[x | ['S', 'o', 'r', 't']] -> [x]\
    <+
      \[x | xs] -> [x | <rec> xs]\
    );
    
    implode-string
  
  create-accessor-name(|index) =
    not(IsReservedAccessorName) => name;
    rules(IsReservedAccessorName: name);
    
    <conc-strings> ("get", <id>)
  <+
    <conc-strings> ("get", <id>, <write-to-string> index)
