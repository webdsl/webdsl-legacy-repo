module ast-form-heuristic

imports
  libstratego-lib
  
  io
  debug

strategies

  
/**
 * Heuristic traversal strategies.
 *
 * @internal
 */
strategies

  init-ast-form-heuristic =
    list-loop(heuristic-register-production);
    
    verified-start-symbol

  verified-start-symbol =
    StartSymbol;
    where(
      bagof-Productions;
      not([])
    )
  <+
    fatal-err-msg(|"No legal start symbol specified.")

  // TODO: More specific outline/folding heuristic?
  
  heuristic-outline-and-folding-sorts =
    StartSymbol;
    
    heuristic-collect-all-rtg(
      heuristic-is-outline-or-folding-production
    );
    
    map(heuristic-asfix-sort-name; try-get-sort-class-name);
    make-set
  
  heuristic-is-outline-or-folding-production =
    where(
      not(is-list-production);
      
      // TODO: Don't just match with identifier at head (requires adapted visitor)
      heuristic-child-sorts;
      ?[heuristic-sort-is-identifier | <id>];
      
      one(heuristic-sort-is-unvisited-list)
    )
  
  heuristic-register-production =
    try(
      ?prod;
      heuristic-rtg-sort-name => sort;
      
      rules(
        Productions :+ sort -> prod
      )
    )

  heuristic-child-sorts =
    ?ProdRule(
      Nonterm(Plain(sort))
    , [Appl(_, <id>)]
    );
    
    map(?Ref(Nonterm(Plain(<id>))));
    
    filter(not(?sort)) // avoid circular references
  <+
    // Injection
    ?ProdRule(
      Nonterm(Plain(sort))
    , [Ref(Nonterm(Plain(<id>)))]
    );
    
    ![<not(?sort)>] // avoid circular references
  <+
    verify(ProdRule(id, id), !"Bad input for heuristic-child-sorts");
    ![]
  
  heuristic-collect-all-rtg(condition) =
  {| CollectAllVisited:
    rec rec(
      CollectAllVisited;
      ![]
    <+
      { ?sort;
        rules(CollectAllVisited: sort);
        
        heuristic-collect-all-visit-sort(condition, rec)
      }
    );
    
    flatten-list;
    make-set
  |}
  
  heuristic-collect-all-visit-sort(condition, rec) =
    bagof-Productions;
    
    map(heuristic-collect-all-visit-production(condition, rec))
  
  heuristic-collect-all-visit-production(condition, rec) =
    ?prod;
    heuristic-child-sorts;
    filter(rec);
    
    try(![<condition> prod | <id>])
  
  /**
   * Succeeds if by following recursively the current productions single child,
   * at some point <condition> applies.
   */
  heuristic-follow-single-child-productions(condition) =
  {| FollowVisited:
    rec rec({
      if not(FollowVisited) then // avoid infinite looping
        ?sort;
        rules(FollowVisited: sort);
        
        bagof-Productions;
        where(
          one(condition)
        <+
          one(
            not(is-list-production);
            heuristic-child-sorts;
            [rec]
          )
        )
      end
    })
  |}

/**
 * Heuristic conditions.
 *
 * @internal
 */
strategies

  heuristic-rtg-sort-name =
    non-terminal-sort-name
  <+
    // Injection: use lhs name
    ?ProdRule(
      Nonterm(Plain(<id>))
    , [Ref(_)]
    )

  heuristic-asfix-sort-name =
    non-terminal-sort-name
  <+
    // Injection: use rhs name
    ?ProdRule(
      _
    , [Ref(Nonterm(Plain(<id>)))]
    )
  
  non-terminal-sort-name =
    ?ProdRule(
      Nonterm(Plain(<id>))
    , [Appl(_, _)]
    )
  
  heuristic-sort-is-identifier =
    heuristic-follow-single-child-productions(is-string-production)
  
  heuristic-sort-is-unvisited-list =
    heuristic-follow-single-child-productions(is-unvisited-list-production)
  
  is-string-production =
    ?ProdRule(
      _
    , [Ref(String())]
    )
  
  is-list-production =
    ProdRule(
      id
    , [Appl(is-list-term, id)]
    )
  
  is-unvisited-list-production =
    ProdRule(
      id
    , [Appl(is-list-term, [not(FollowVisited)])]
    )
    