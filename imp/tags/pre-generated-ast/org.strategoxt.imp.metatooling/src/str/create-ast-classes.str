module create-ast-classes

imports
  libstratego-lib
  libstratego-xtc
  sdf-options
  rtg

strategies

  sdf2rtg =
    // TODO2: XTC detox?
    xtc-transform(!"sdf2rtg", !["-n", "--ignore-missing-cons", "-m", <get-sdf-main-module> | <pass-verbose>])

  ast-package =
    <conc> (<BasePackage>, ["ast"]);
    !PackageDec(None, PackageName(<id>))

  rtg-to-ast-classes =
    sdf2rtg;
    read-from => RTG(_, prods);
    
    list-loop(try(
      sort-to-class;
      write-file
    ));
    
    list-loop(risky(
      constructor-to-class
      write-file
    | "Could not convert production to AST class") 
    )
  
  sort-to-class:
    ProdRule(
      Nonterm(Plain(lhs))
    , [rhs]
    ) ->
    compilation-unit |[
      package ast;
      
      abstract class ~x:lhs extends SGLRAstNode {
      
      }
    ]|
    where not(<ReservedName> lhs); // create only once

          if Appl(constructor, _) := rhs then
            not(<eq> (lhs, constructor)); // try not to create sort class if constructor has same name
          end;
          
          <reserve-name> lhs
  
  constructor-to-class:
    ProdRule(
      Nonterm(Plain(lhs))
    , [Appl(rhs, args)]
    ) ->
    compilation-unit |[
      package ast;
      
      class x_Name implements x_Parent {
 
      }     
    ]|
    where x_Name := <reserve-name> rhs;
          if <eq> (x_Name, 
  
  get-constructor =
    

  reserve-name ==
    ?name;
    
    for(
      !(0, <id>)
    , (id, ReservedName)
    , {n: // Create a new name0 ... nameN until non-reserved name found
          ?(n, _)
          (inc, <conc-strings> (name, <write-to-string> n);
      }
    );
    
    rules(ReservedName := <id>)
